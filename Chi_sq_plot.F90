!
!*****************************************************************************
!
      SUBROUTINE PrepareChiSqPlotData(ntotmov, iteration, cpb)
!
!
!  ep added subroutine.  Called from SimulatedAnnealing subroutine (sa_subs.for).
!    This subroutine stores and manipulates data for a Profile Chi-sqd
!  vs. number of moves plot.  Actual plotting is done by Subroutine Plotting_chi_sqd.
!
!
!
!  Graph plotting code generated by GraphEd at 09:32 on 01 Aug 2001.
!
!
!  USE module containing routine definitions and symbolic names.
!
      USE DRUID_HEADER
      USE WINTERACTER
!
!      IMPLICIT NONE
!
!  Definitions and array declarations.
!
      INCLUDE 'PARAMS.INC'

      INTEGER           :: ntotmov
      INTEGER           :: iteration
      REAL              :: cpb
      REAL           :: x_min
      REAL           :: y_max
      INTEGER                    ChiSqdChildWindows,                 ChiHandle
      COMMON /ChiSqdWindowsUsed/ ChiSqdChildWindows(MaxNumChildWin), ChiHandle
      DATA  ChiSqdChildWindows / 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /
      DATA  ChiHandle / 1 /
! Variables used to specify Child Window position
      INTEGER Ix, Iy
      COMMON /WindowPosition/ Ix, Iy
      DATA Ix /10/, Iy /450/

      LOGICAL         RESTART
      INTEGER                  SA_Run_Number
      INTEGER                                 MaxRuns, MaxMoves
      REAL                                                       ChiMult
      COMMON /MULRUN/ RESTART, SA_Run_Number, MaxRuns, MaxMoves, ChiMult

! Max number or SA runs is 30
      REAL, DIMENSION(MaxIter,MaxRun) :: chi_sqd
      INTEGER           :: it_count
      INTEGER           :: Run_Number
      COMMON /CHISQDPLOTDATA/chi_sqd, x_min, it_count, y_max, Run_Number

      EXTERNAL DealWithChiSqdPlot

      Run_Number = SA_Run_Number + 1
!
! Clear Chi-sqd array between starting sets of SA Runs
      IF ((Iteration.EQ.1).and.(Run_Number.EQ.1)) Chi_sqd = 0.0
      it_count = iteration
!
! Record chi-sqd value in array.  Chi-sqd values following it_count entry
! set to last Chi-sqd value entered.
      chi_sqd(it_count, Run_Number) = cpb
      DO J = it_count+1, MaxIter
        Chi_sqd(J, Run_number) = cpb
      ENDDO
! Record y_max for graph
      y_max = chi_sqd(1, Run_Number)*1.25
!
! If first iteration then record number of moves for minimum value of x axis on graph
      IF (It_count.EQ.1) x_min = ntotmov
 
! If this is the first SA run and 2 points for the line graph have been determined, open Child Window
      IF ((Run_Number.EQ.1) .AND. (it_count.EQ.2)) THEN
        CALL WindowOpenChild(ChiHandle, x=Ix, y=Iy, width=400, height=300, title='SA Run Progress')
        ChiSqdChildWindows(ChiHandle) = 1
        CALL RegisterChildWindow(Chihandle,DealWithChiSqdPlot)
      ENDIF

      IF ((ChiSqdChildWindows(ChiHandle).EQ.1).and.(It_count.GE.2)) CALL plotting_chi_sqd(ChiHandle)

      END SUBROUTINE PrepareChiSqPlotData
!
!*****************************************************************************
!
      SUBROUTINE plotting_Chi_sqd(ChiHandle)

      USE DRUID_HEADER
      USE WINTERACTER

      IMPLICIT NONE

      INCLUDE 'PARAMS.INC'
      INCLUDE 'poly_colours.inc'

      INTEGER        :: Run_Number
      INTEGER        :: it_count
      INTEGER        :: ixaxis
      REAL           :: x_max
      REAL           :: x_min
      REAL           :: y_max
      REAL, DIMENSION(MaxIter, MaxRun) :: chi_sqd
      REAL, DIMENSION(MaxIter+1) :: Xarray
      REAL           ::DynamicMaxX
      REAL           ::TempMaxX
      INTEGER        ::NumDynamicX
      DATA  DynamicMaxX / 0.0 /
      INTEGER ChiHandle
      COMMON /CHISQDPLOTDATA/chi_sqd, x_min, it_count, y_max, Run_Number

      LOGICAL         RESTART
      INTEGER                  SA_Run_Number
      INTEGER                                 MaxRuns, MaxMoves
      REAL                                                       ChiMult
      COMMON /MULRUN/ RESTART, SA_Run_Number, MaxRuns, MaxMoves, ChiMult

      INTEGER J, ISET

      CALL WindowSelect(ChiHandle)
      CALL WindowClear()

! First Run so set DynamicMaxX to zero.  IF "stop" pressed in SA run Window want to reset
! DynamicMAxX
      IF((Run_number.EQ.1).AND.(It_count.EQ.2)) THEN
        DynamicMaxX = 0.0
      ENDIF

! calculate array of x values for graph
      ixaxis = NINT(MaxMoves/(x_min))
        DO j = 1, (ixaxis+1)
           Xarray(j) = j*(x_min)
        ENDDO
!
! Set x_max for graph.  When have dynamic x-axis (first SA Run) the maximum value possible for 
! the xaxis is the maximum number of moves
      IF (Run_number.EQ.1) THEN
        IF(it_count.GE.(NINT(MaxMoves/x_min))) THEN
          x_max = MaxMoves
        ELSE
          x_max = Xarray(it_count)
        ENDIF
      ENDIF
! Xaxis max is largest value of x recorded so far
      IF (Run_Number.gt.1) THEN
        x_max = DynamicMaxX
      ENDIF

!  Start new presentation graphics plot
!
!  Set Clipping Rectangle
!
      CALL IPgClipRectangle('P')
!
!  Set style for each data set
!
      CALL IPgStyle(  1,  0,  0,  0,      KolNumobs)
!
!  Set marker number for data sets not using default marker
!
!
!  Set units for plot
!
      CALL IPgUnits(  x_min,      0.0000000, &
                      x_max,    y_max)
!
!  Set presentation graphics area
!
      CALL IPgArea(0.150,0.200,0.900,0.800)
!
!  Draw main title
!
      CALL IGrCharSet('H')
      CALL IGrCharFont(3)
      CALL IGrCharSpacing('P')
      CALL IGrCharSize( 2.0, 1.5)
      CALL IGrColourN( KolNumMain)
      CALL IPgTitle('Profile Chi-squared vs. Number of Moves','C')
!
!  Label bottom X axis
!
      CALL IPgXLabelPos(  0.70)
      CALL IPgXLabel('Number of Moves','C')
!
!  Label left Y axis
!
      CALL IPgYLabelPos(  0.80)
      CALL IPgYLabelLeft('Profile Chi-squared','C9')
!
!  Draw axes
!
      CALL IGrColourN(KolNumMain)
      CALL IPgAxes()
!
!  Adjust tick position for X Axes
!
      CALL IPgXTickPos(     1.0000    ,    -1.0000    )
!
!  Scale for bottom X Axis
!
      CALL IPgXTickLength(  1.00)
      CALL IPgDecimalPlaces(      -1)
      CALL IPgXUserScale((/0.0/),0)
      CALL IPgXScaleAngle(  0.00,  0.00)
      CALL IPgXScalePos(  0.38)
      CALL IPgXScale('NT')
!
!  Adjust tick position for Y Axes
!
      CALL IPgYTickPos(     1.0000    ,    -1.0000    )
!
!  Scale for left Y Axis
!
      CALL IPgYTickLength(  1.00)
      CALL IPgDecimalPlaces(      -1)
      CALL IPgYUserScale((/0.0/),0)
      CALL IPgYScaleAngle(  0.00,  0.00)
      CALL IPgYScalePos(  1.50)
      CALL IPgYScaleLeft('NT')
!
!  Draw graph.
!
      IF (Run_Number.GT.1) THEN
! Plot Chi-sqd values to maximum number of moves for completed SA runs
!!        iMaxMoves = NINT(x_Max/(x_min)) 
!!        CALL IPgNewPlot(PgPolyLine,(Run_Number-1),iMaxMoves,0,1)
        CALL IPgNewPlot(PgPolyLine,(Run_Number-1),NumDynamicX,0,1)
          DO j = 1,(Run_Number-1)
            CALL IPgStyle(  j,  0,  0,  0,      KolNumobs)
          END DO
          DO ISET = 1, (Run_Number-1)
            CALL IPgXYPairs(Xarray, Chi_sqd(1,ISET))
          ENDDO
      ENDIF
! Plot Chi-sqd values iteration by iteration
        CALL IPgNewPlot(PgPolyLine,1,it_count,0,1)
        CALL IPgStyle(  1,  0,  0,  0,      KolNumCal)
        CALL IPgXYPairs(Xarray, chi_sqd(1,Run_number))
! Record the largest value of x so far.  This is used as the maxmimum value for x when drawing
! x_axis.  
        IF ((it_count*x_min).LE.(MaxMoves)) THEN
          TempMaxX = it_count*x_min
            IF(TempMaxX.GT.DynamicMaxX) THEN
              DynamicMaxX = TempMaxX
              NumDynamicX = DynamicMaxX/x_min
            ENDIF
        ENDIF

      END SUBROUTINE plotting_chi_sqd
!
!*****************************************************************************
!
      SUBROUTINE DealWithChiSqdPlot
      USE WINTERACTER
      USE DRUID_HEADER
      USE VARIABLES
      INCLUDE 'PARAMS.INC'

      INTEGER                    ChiSqdChildWindows,                 ChiHandle
      COMMON /ChiSqdWindowsUsed/ ChiSqdChildWindows(MaxNumChildWin), ChiHandle

      SELECT CASE (EventType)
! will close the profile plot window
        CASE (CloseRequest)
          CALL WindowCloseChild(EventInfo%win)
          ChiSqdChildWindows(EventInfo%win) = 0
          CALL UnRegisterChildWindow(EventInfo%win)
! exposing or resizing of profile plot windows 
        CASE (expose, resize)
          CALL PLotting_chi_sqd(EventInfo%win)
        END SELECT

      END SUBROUTINE DealWithChiSqdPlot
!
!*****************************************************************************
!
      SUBROUTINE Close_Chisq_Plot

      USE WINTERACTER
      USE DRUID_HEADER

      INCLUDE 'PARAMS.INC'

      INTEGER ChiSqdChildWindows
      INTEGER ChiHandle
      COMMON /ChiSqdWindowsUsed/ ChiSqdChildWindows(MaxNumChildWin), ChiHandle
      INTEGER Ix, Iy
      COMMON /WindowPosition/ Ix, Iy

      DO I = 1, MaxNumChildWin
        IF (ChiSqdChildWindows(I) .EQ. 1) THEN
! save position of window before close.  If more than one chisqd window open (not
! the case in this implementation) will save the position of the last window closed.
          CALL WindowSelect(I)
          Ix = WinfoWindow(WindowXpos)
          Iy = WinfoWindow(WindowYpos)
          CALL WindowCloseChild(I)
          CALL UnRegisterChildWindow(I)
          ChiSqdChildWindows(I) = 0
        ENDIF
      ENDDO

      END SUBROUTINE Close_Chisq_Plot
!
!*****************************************************************************
!
