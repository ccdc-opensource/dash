      SUBROUTINE Chi_sq_plot(ntotmov, iteration, cpb)
!
!
!  ep added subroutine.  Called from SimulatedAnnealing subroutine (sa_subs.for).
!    This subroutine stores and manipulates data for a Profile Chi-sqd
!  vs. number of moves plot.  Actual plotting is done by Subroutine Plotting_chi_sqd.
!
!
!
!  Graph plotting code generated by GraphEd at 09:32 on 01 Aug 2001.
!
!
!  USE module containing routine definitions and symbolic names.
!
      USE DRUID_HEADER
      USE WINTERACTER
!
!      IMPLICIT NONE
!
!  Definitions and array declarations.
!
      INCLUDE 'PARAMS.INC'
      INTEGER,PARAMETER :: NSETS   =     1
      INTEGER           :: ntotmov
      INTEGER           :: iteration
      REAL              :: cpb
      INTEGER           :: it_count
      REAL           :: x_max
      REAL           :: x_min
      REAL           :: y_max
      REAL, DIMENSION(MaxIter) :: num_moves
      REAL, DIMENSION(MaxIter) :: chi_sqd
      INTEGER                    ChiSqdChildWindows,                 ChiHandle
      COMMON /ChiSqdWindowsUsed/ ChiSqdChildWindows(MaxNumChildWin), ChiHandle
      DATA  ChiSqdChildWindows / 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 /
      DATA  ChiHandle / 1 /
! Variables used to specify Child Window position
      INTEGER Ix, Iy
      COMMON /WindowPosition/ Ix, Iy
      DATA Ix /10/, Iy /450/

      it_count = iteration
      num_moves(it_count) = ntotmov
      chi_sqd(it_count) = cpb
      x_min = num_moves(1)
      x_max = num_moves(it_count)
      y_max = chi_sqd(1)*1.25
! First two interations performed both have iteration number=1.  The graph requires
! two points to plot a straight line and so the plot of chi-sqd vs.moves only
! starts when it_count =2, ie iteration number 2
      IF (it_count.EQ.2) THEN
        CALL WindowOpenChild(ChiHandle, x=Ix, y=Iy, width=400, height=300, title='Chi-sqd vs. Moves')
        ChiSqdChildWindows(ChiHandle) = 1 
   !     CALL plotting_chi_sqd(num_moves, chi_sqd, x_min, x_max, it_count, y_max)
      ENDIF    
! If ChildWindow is open then call plotting routine.
   !   IF (it_count.GT.2) THEN
      IF (ChiSqdChildWindows(ChiHandle).EQ.1) THEN
        CALL WindowSelect(ChiHandle)
        CALL WindowClear()
        CALL plotting_chi_sqd(num_moves, chi_sqd, x_min, x_max, it_count, y_max)
      ENDIF

      END SUBROUTINE Chi_sq_plot

!***********************************************************************************************
      SUBROUTINE plotting_Chi_sqd(num_moves, chi_sqd, x_min, x_max, it_count, y_max)
      
      USE DRUID_HEADER
      USE WINTERACTER
      
      INCLUDE 'PARAMS.INC'        
      INCLUDE 'poly_colours.inc'  
        
      INTEGER,PARAMETER :: NSETS  =  1
      INTEGER, INTENT(IN)        :: it_count
      REAL, INTENT(IN)           :: x_max
      REAL, INTENT(IN)           :: x_min
      REAL, INTENT(IN)           :: y_max
      REAL, DIMENSION(MaxIter), INTENT(IN   ) :: num_moves
      REAL, DIMENSION(MaxIter), INTENT(IN   ) :: chi_sqd

!
!  Start new presentation graphics plot
!
      CALL IPgNewPlot(PgPolyLine,NSETS,it_count,0,1)
!
!  Set Clipping Rectangle
!
      CALL IPgClipRectangle('G')
!
!  Set style for each data set
!
      CALL IPgStyle(  1,  0,  0,  0,      KolNumObs)
!
!  Set marker number for data sets not using default marker
!
!
!  Set units for plot
!

      CALL IPgUnits(  x_min,      0.0000000, &
                      x_max,    y_max)
!
!  Set presentation graphics area
!
      CALL IPgArea(0.150,0.200,0.900,0.800)
!
!  Draw main title
!
      CALL IGrCharSet('H')
      CALL IGrCharFont(3)
      CALL IGrCharSpacing('P')
      CALL IGrCharSize( 2.0, 1.5)
      CALL IGrColourN( KolNumMain)
      CALL IPgTitle('Profile Chi-squared vs. Number of Moves','C')
!
!  Label bottom X axis
!
      CALL IPgXLabelPos(  0.70)
      CALL IPgXLabel('Number of Moves','C')
!
!  Label left Y axis
!
      CALL IPgYLabelPos(  0.80)
      CALL IPgYLabelLeft('Profile Chi-squared','C9')
!
!  Draw axes
!
      CALL IGrColourN(KolNumMain)
      CALL IPgAxes()
!
!  Adjust tick position for X Axes
!
      CALL IPgXTickPos(     1.0000    ,    -1.0000    )
!
!  Scale for bottom X Axis
!
      CALL IPgXTickLength(  1.00)
      CALL IPgDecimalPlaces(      -1)
      CALL IPgXUserScale((/0.0/),0)
      CALL IPgXScaleAngle(  0.00,  0.00)
      CALL IPgXScalePos(  0.38)
      CALL IPgXScale('NT')
!
!  Adjust tick position for Y Axes
!
      CALL IPgYTickPos(     1.0000    ,    -1.0000    )
!
!  Scale for left Y Axis
!
      CALL IPgYTickLength(  1.00)
      CALL IPgDecimalPlaces(      -1)
      CALL IPgYUserScale((/0.0/),0)
      CALL IPgYScaleAngle(  0.00,  0.00)
      CALL IPgYScalePos(  1.50)
      CALL IPgYScaleLeft('NT')
!
!  Draw graph.
!
!      DO ISET = 1,NSETS
!          CALL IPgXYPairs(XVALUES(1,ISET),YVALUES(1,ISET))
           call IPgXYPairs(num_moves, chi_sqd)
!      END DO

      END SUBROUTINE plotting_chi_sqd
!******************************************************************************************
      
      SUBROUTINE Close_Chisq_Plot

      USE WINTERACTER

      INCLUDE 'PARAMS.INC'

      INTEGER ChiSqdChildWindows
      INTEGER ChiHandle
      COMMON /ChiSqdWindowsUsed/ ChiSqdChildWindows(MaxNumChildWin), ChiHandle
      INTEGER Ix, Iy
      COMMON /WindowPosition/ Ix, Iy

      DO I = 1, MaxNumChildWin
        IF (ChiSqdChildWindows(I) .EQ. 1) THEN
! save position of window before close.  If more than one chisqd window open (not 
! the case in this implementation) will save the position of the last window closed.
          CALL WindowSelect(I)
          Ix = WinfoWindow(WindowXpos)
          Iy = WinfoWindow(WindowYpos)
          CALL WindowCloseChild(I)
          ChiSqdChildWindows(I) = 0
        ENDIF
      ENDDO

      END SUBROUTINE Close_Chisq_Plot                         