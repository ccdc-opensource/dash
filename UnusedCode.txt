!
!*****************************************************************************
!
! Originally in PolyLoadFiles.f90
!
!U      INTEGER FUNCTION Load_CCL_File(FLEN,TheFileName)
!U!
!U      CHARACTER(LEN=256),           INTENT (IN) :: TheFileName
!U      INTEGER,                      INTENT (IN) :: FLEN
!U      CHARACTER(LEN=80) CCL_LINE
!U      INCLUDE 'GLBVAR.INC' ! Contains ALambda
!U      COMMON /CELLREF/ CELLPAR(6),ZEROPOINT
!U      INTEGER I
!U      REAL  WaveLengthOf ! Function
!U!
!U!>> JCC Initialise return value
!U!
!U      Load_CCL_File = 1
!U      ZEROPOINT = 0.0
!U      ALambda = WaveLengthOf('Cu')
!U!
!U!>> JCC Add in Error trap
!U!                          
!U      OPEN(11,FILE=TheFileName(:FLEN),STATUS='OLD', ERR = 999)
!U!>> JCC Set SA Output files
!U      CALL sa_SetOutputFiles(TheFileName)
!U   10 READ(11,5000,ERR=100,END=100) NLCCL,CCL_LINE
!U 5000 FORMAT(Q,A)
!U      IF (CCL_LINE(1:1) .EQ. 'C') THEN
!U        READ(CCL_LINE(2:NLCCL),*) (CELLPAR(I),I=1,6)
!U      ELSE IF (CCL_LINE(1:1) .EQ. 'L') THEN
!U        IF (CCL_LINE(3:6) .EQ. 'WVLN') THEN
!U          READ(CCL_LINE(7:NLCCL),*) ALambda
!U        ELSE IF (CCL_LINE(3:6) .EQ. 'ZERO') THEN
!U          READ(CCL_LINE(7:NLCCL),*) zeropoint
!U        END IF
!U      END IF
!U      GOTO 10
!U  100 CLOSE(11)
!U!
!U      CALL UpLoad_Crystal_Data()
!U!
!U!>> JCC Added in next few lines
!U      RETURN
!U 999  Load_CCL_File = 0
!U      RETURN
!U      END FUNCTION Load_CCL_File
!
!*****************************************************************************
!
! Originally in Fou.for
!
C
C
C
C
C LEVEL 6      SUBROUTINE ARROW(X,Y,L)
      SUBROUTINE ARROW(X,Y,L)
C
C *** ARROW by PJB Sep 87 ***
C
CX
CC 14C
CH Draws an arrow centred at X,Y in the current space.
CP General CCSL plotting must have been set up.
CA On entry L=0 requests outline arrow
CA          L=1 requests solid arrow
C
      DIMENSION SPTS(2,7),PTS(2,7)
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
      DATA SPTS/-8.,-1.,-8.,1.,4.,1.,4.,4.,8.,0.,4.,-4.,4.,-1./
      DATA NPTS/7/

C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C  ADD DISPLACEMENT
      DO 2 I=1,NPTS
      PTS(1,I)=SPTS(1,I)+X
    2 PTS(2,I)=SPTS(2,I)+Y
C
C  DRAW OUTLINE
      CALL KANGA1(PTS(1,NPTS),PTS(2,NPTS),3)
      DO 1 N=1,NPTS
      CALL KANGA1(PTS(1,N),PTS(2,N),2)
    1 CONTINUE
C
C  RETURN IF L=0
      IF (L.EQ.0) GO TO 100
C
C  GET EFFECTIVE GRID FOR SHADING
      CALL PLCONV(0.,0.,1,A1,B1,NSPCE)
	IF (IBMBER .NE. 0) RETURN
      CALL PLCONV(.02,0.,1,A,B,NSPCE)
	IF (IBMBER .NE. 0) RETURN
      A=A-A1
      B=B-B1
      STEP=SQRT(A**2+B**2)
C
C  NOW SHADE THE ARROW
C  FIRST THE TAIL
      CALL KANGA1(PTS(1,1),PTS(2,1),3)
      DO 3 XX=PTS(1,1)+STEP,PTS(1,7),STEP
      CALL KANGA1(XX,PTS(2,2),2)
    3 CALL KANGA1(XX,PTS(2,1),2)
C  THEN THE HEAD
      SY1=STEP*((PTS(2,5)-PTS(2,4))/(PTS(1,5)-PTS(1,4)))
      SY2=STEP*((PTS(2,5)-PTS(2,6))/(PTS(1,5)-PTS(1,6)))
      CALL KANGA1(PTS(1,6),PTS(2,6),3)
      Y1=PTS(2,4)
      Y2=PTS(2,6)
C
C NOTE FROM JCM - THIS OUGHT TO BE TIDIED:
      DO 4 XX=PTS(1,7)+STEP,PTS(1,5),STEP
      Y1=Y1+SY1
      Y2=Y2+SY2
      CALL KANGA1(XX,Y1,2)
      CALL KANGA1(XX,Y2,2)
    4 CONTINUE
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE ATMPLO(IFND,NFND,JP)
      SUBROUTINE ATMPLO(IFND,NFND,JP)
C
C *** ATMPLO by PJB Aug 86 ***
C
CX
CC 5B
CH Plots atom positions on a map.
CA On exit NFND=number of positions plotted
CA         IFND, an integer array, contains pointers to the atoms plotted
CA         JP, an integer array, points to the symbols used for each atom
C
      DIMENSION JP(4),IFND(4),Z(2)
      LOGICAL FOUND1
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON/SCRAT/AA(3,3),TRXX(3,48),TLAT(3,4),BOUNDS(2,6),XX(3,3),
     & TMPV1(3),TMPV2(3),TMPV3(3),TTXX(3,50),NT
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C SET MAP SPACE:
      CALL SPCSET(4)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      JP(1)=1
      JP(2)=2
      JP(3)=4
      JP(4)=9
C
      NT=NDIM
      NFND=0
C
C  GET INVERSE OF U
      CALL GMEQ(U,AA,3,3)
      CALL TRINV3(AA,D)
C  TRANSORM LATTICE VECTORS IF NECESSARY
      DO 6 L=1,NLAT
      IF (MODET.EQ.1) THEN
        CALL GMPRD(ALAT(1,L),AA,TLAT(1,L),1,3,3)
      ELSE
        CALL GMEQ(ALAT(1,L),TLAT(1,L),1,3)
      ENDIF
    6 CONTINUE
C  FIX BOUNDARIES
      CALL GMEQ(OUTLIM,BOUNDS,2,1)
      CALL GMEQ(OUTLIM(1,2),BOUNDS(1,2),2,1)
C  LIMIT IN Z
      AL=VCTMOD(1.,U(1,3),1)
      ALZ=.1/AL
      BOUNDS(1,3)=OUTLIM(1,3) -ALZ
      BOUNDS(2,3)=OUTLIM(1,3) +ALZ
C  COPY VECTOR
      CALL GMEQ(BOUNDS(1,1),BOUNDS(1,4),2,3)
      IF (MODET.EQ.0) GO TO 5
      II=1
      DO 20 I=1,2
      TMPV1(3)=BOUNDS(I,3)
      DO 20 J=1,2
      TMPV1(2)=BOUNDS(J,2)
      DO 20 L=1,2
      TMPV1(1)=BOUNDS(L,1)
      CALL GMPRD(U,TMPV1,TRXX(1,II),3,3,1)
   20 II=II+1
C  FIND MAXIMUM AND MINIMUM ON EACH CRYSTALLOGRAPHIC AXIS
      DO 21 I=1,3
      BOUNDS(1,I)=AMIN1(TRXX(I,1),TRXX(I,2),TRXX(I,3),TRXX(I,4),
     & TRXX(I,5),TRXX(I,6),TRXX(I,7),TRXX(I,8))
      BOUNDS(2,I)=AMAX1(TRXX(I,1),TRXX(I,2),TRXX(I,3),TRXX(I,4),
     & TRXX(I,5),TRXX(I,6),TRXX(I,7),TRXX(I,8))
   21 CONTINUE
C GENERATE ATOMIC POSITIONS
    5 DO 1 IAT=1,NATOM
C FOR SKEW BUT RATIONAL PLANE, POSITIONS MUST BE TRANSFORMED TO MATCH THE
C SYMMETRY OPERATORS
      IF (MODET.EQ.1) THEN
        CALL GMPRD(X(1,IAT),AA,TRXX(1,1),1,3,3)
      ELSE
        CALL GMEQ(X(1,IAT),TRXX(1,1),1,3)
      ENDIF
      CALL ATOGEN(MOLD)
      FOUND1=.FALSE.
      DO 3 M=1,MOLD
      IF (MODET.NE.1) THEN
        CALL GMEQ(TRXX(1,M),TMPV1,1,3)
      ELSE
        CALL GMPRD(TRXX(1,M),U,TMPV1,1,3,3)
      ENDIF
      CALL TBOUND(IFOUND)
      IF (IFOUND .EQ.0) GO TO 3
      FOUND1=.TRUE.
      DO 31 IFN=1,IFOUND
      DO 30 I=1,2
      Z(I)=(TTXX(I,IFN)-OUTLIM(1,I))/OUTLIM(3,I)
   30 CONTINUE
      CALL KANGA3(Z(1),Z(2),1.5*CHUNIT*CHSCAL(2,3),JP(NFND+1))
   31 CONTINUE
    3 CONTINUE
      IF (FOUND1) CALL ERRCHK(2,NFND,4,0,'atoms in ATMPLO')
      IFND(NFND)=IAT
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ATOGEN(MOLD)
      SUBROUTINE ATOGEN(MOLD)
C
C *** ATOGEN by PJB Aug 86 ***
C
CX
CC 5B
CH Generates a set of equivalent positions.
CA MOLD on exit is the number generated
CP In /SCRAT/ on entry (usually from ATMPLO) TRXX(1:3,1) holds the original
CP atomic position.
CD Generates all the related (different) positions in TRXX within 1 unit cell.
C
CN A PJB special for use with ATMPLO.
C
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON/SCRAT/AA(3,3),TRXX(3,48),TLAT(3,4),BOUNDS(2,6),XX(3,3),
     & TMPV1(3),TMPV2(3),TMPV3(3),TTXX(3,50),NT
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
      MOLD=0
      CALL GMEQ(TRXX(1,1),XX,1,3)
      DO 1 L=1,NLAT
      DO 1 N=1,NOPC
      CALL GMADD(TRANS(1,N),TLAT(1,L),TMPV1,1,3)
      CALL ROTSYM(XX,XX(1,2),N,1)
C  CYCLE OVER CENTRE OF SYMMETRY
      DO 2 IR=1,NCENT
      CALL GMADD(TMPV1,XX(1,2),TMPV2,1,3)
      IF (MOLD.EQ.0) THEN
        MOLD=1
      ELSE
        CALL EQPOS(TRXX,TMPV2,MOLD,M,48)
        IF (M.GT.MOLD) MOLD=M
      ENDIF
C
    2 CALL GMREV(XX(1,2),XX(1,2),1,3)
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CHOOSF(F,SF,ALPHA1,ALPHA,MODEF)
      SUBROUTINE CHOOSF(F,SF,ALPHA1,ALPHA,MODEF)
C
C *** CHOOSF by PJB ***
C
CX
CC 5C
CH Chooses modulus and phase for a particular Fourier.
C
CA On entry ALPHA1 is an original phase
CA          F is a 1x2 array of read coefficients
CA          MODEF is the type of Fourier:
CA            MODEF=1   FCAL
CA            MODEF=2   FOBS (Centrosymmetric)
CA            MODEF=3   mod(FOBS)*phase(FCAL)
CA            MODEF=4   FOBS-FCAL
CA            MODEF=5   (mod(FOBS)-mod(FCAL))*phase(FCAL)
CA            MODEF=6   FOBS*FOBS (Patterson)
CA On exit SF holds the modulus and ALPHA the required phase.
C
      DIMENSION F(2)
C
      ALPHA=ALPHA1
      GO TO (21,22,23,24,25,26),MODEF
C
  21  SF = ABS(F(1))
      GO TO 10
C
   22  SF = F(2)
      ALPHA = 0.
      GO TO 10
C
  23  SF = ABS(F(2))
      GO TO 10
C
  24  SF = F(2) -F(1)
      ALPHA = 0.
      GO TO 10
C
  25  SF = ABS(F(2)) - ABS(F(1))
      GO TO 10
C
  26  SF = F(2)*F(2)
      ALPHA = 0.
C
C SF AND ALPHA NOW SET UP:
C
   10 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE DOSIDE(A,B,ISIDE,NR,NC,X,Y)
      SUBROUTINE DOSIDE(A,B,ISIDE,NR,NC,X,Y)
C
C *** DOSIDE 24 Nov 83 by JCM ***
C
CX
CC 5C
CH A specialist routine for contour plotting, to help to decide where a
CH contour crosses the side of a square.
C
      IF (ISIDE .NE. 1) THEN
        DO 3 I=2,ISIDE
        C=B
        B=A
   3    A=1.0-C
      ENDIF
      Y = FLOAT(NC-1) + A
      X = B + FLOAT(NR-1)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE DPLOT(XXIN,YYIN,LINE)
      SUBROUTINE DPLOT(XXIN,YYIN,LINE)
C
C *** DPLOT by PJB Apr 85 ***
C
CX
CC 14C
CH Does plotting in current coordinate system.
CA On entry:
CA     XXIN,YYIN give the target position.
CA     LINE controls the kind of line being drawn:
CA          If LINE = 0 pen is "up"
CA          If LINE = 1 a continuous line is drawn
CA          If LINE = 2 a dashed line is drawn
CA          If LINE>10 but <21 the symbol LINE-10 is drawn at intervals of
CA                     DASH in /ADASH/
CP COMMON /ADASH/ is used to remember what is happening for dashed lines
CP        X1,Y1=where pen went to.
CD The pen is moved from its current position to XXIN,YYIN.
C
      COMMON /ADASH/DASH,X1,Y1,REM,IPEN,IDSH,DTRAN(2,2)
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP

C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C
      IF (LINE .LE. 1) GO TO 12
      ILINE=1
      IF (LINE.GT.10) ILINE=2
C  CHECK THAT THE SPACE HAS NOT CHANGED
      IF (IDSH.EQ.NSPCE) GO TO 10
C  MAKE A DUMMY CALL TO PLCONV
      CALL PLCONV(0.,0.,0,X,Y,3)
	IF (IBMBER .NE. 0) RETURN

C  AND SET DTRAN FROM THE NEW PTRAN
      CALL GMEQ(PTRAN(1,1,2),DTRAN,2,2)
      IDSH=NSPCE
      GO TO 10
C
C NOT DASHING - RESET DASH COUNT - JOIN HERE IF DASHING AT CONTOUR START:
   12 II=3-LINE
  11  REM = 0.
      IPEN = 2
      CALL KANGA1 (XXIN,YYIN,II)
C FOR NOW - AS IPN IS NOT SET THIS CANNOT BE RIGHT, BUT OFFHAND I DON'T KNOW
C WHAT IT SHOULD BE:
C      IF (IPN .GT. 0) GO TO 100
      GO TO 101
C AVOID STORAGE OF X1,Y1 IF NOT DASHING, AND EXIT
C
C HERE FOR DASHED LINE:
C IF "DASHING" BUT ACTUALLY PEN UP, DO NOT COMPUTE DASHES, BUT DO ARRANGE TO
C STORE CURRENT POSITION IN X1,Y1:
C LENGTH OF LINE TO BE PLOTTED
   10 U = XXIN-X1
      V = YYIN-Y1
      ALEN = SQRT((U*DTRAN(1,1)+V*DTRAN(1,2))**2+(U*DTRAN(2,1)+V*DTRAN(2
     & ,2))**2)
C
C  DEAL WITH ANY PART LEFT FROM LAST ENTRY:
      BLEN = ALEN-REM
      IF (BLEN .LE.0.) GO TO 1
C  IN CASE THAT VECTOR IS LESS THAN REMAINING DASH LENGTH
C
C  REMAINDER OF PREVIOUS DASH:
      FRAC = REM/ALEN
      X = X1 + FRAC*U
      Y = Y1 + FRAC*V
      GO TO (4,5),ILINE
    4 CALL KANGA1(X,Y,IPEN)
      IPEN=5-IPEN
      GO TO 6
   5  CONTINUE
      CALL KANGA3(X,Y,DASH/5,LINE-10)
C
C  CALCULATE NUMBER OF DASHES:
    6 NUM = IFIX(BLEN/DASH)
      REM = FLOAT(NUM+1)*DASH-BLEN
      IF (NUM .EQ.0) GO TO 2
      FRAC = DASH/ALEN
C
C  DO DASHES:
      DO 3 I=1,NUM
      X = X+FRAC*U
      Y = Y+FRAC*V
      GO TO (7,8),ILINE
    7 CALL KANGA1(X,Y,IPEN)
C  CHANGE MODE:
      IPEN = 5-IPEN
      GO TO 3
   8  CONTINUE
      CALL KANGA3(X,Y,DASH/5,LINE-10)
    3 CONTINUE
      GO TO 2
C
    1 REM = -BLEN
C  FINISH OFF
    2 IF (ILINE.EQ.2) GO TO 101
      CALL KANGA1(XXIN,YYIN,IPEN)
 101  X1=XXIN
      Y1=YYIN
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE ERRMAP
      SUBROUTINE ERRMAP
C
C *** ERRMAP updated by JCM 14 Apr 89 ***
C
CX
CC 5B
CH Calculates the standard deviation of the density in a Fourier map.
CP The results are meaningless if DELTA, the resolution length, is zero.
CP Should be set up in the same way as FOUR1Z
C
CD Uses the same kind of data as FOUR1Z, the normal Fourier routine, but the
CD calculation is much slower.  One should therefore use a coarser sampling
CD grid. Experience shows that the results vary very little throughout the
CD unit cell.
CD
CD Assumes errors in non-equivalent reflections are independent and those in
CD related reflections the same.
CI Reads data from unit LUNI in FORMAT given by MODED in /MAPDA/
CN Old.
C
      DIMENSION FIN(4)
C%
C      DIMENSION H(3,%SY*2%),EH(3),HI(3),K(3),SINCOX(100),SINCOY(100)
      DIMENSION H(3,48),EH(3),HI(3),K(3),SINCOX(100),SINCOY(100)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /SCRAT/SUM(10201)
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
      NOBSIN=-1
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
C     GET OUT THE SINES AND COSINES REQUIRED IN THE RECURSIONS.
      CALL TRIG(SINCOX,TWOPI*OUTLIM(3,1),(NH-1)/2+1)
      CALL TRIG(SINCOY,TWOPI*OUTLIM(3,2),NK)
C     CLEAR STORE FOR SUMS
      DO 1 I=1,NXY
      SUM(I) = 0.
    1 DENS(I) = 0.
C
C     READ REFLECTIONS FROM STREAM LUNI
C     MODED=1 H,K,L, FCAL,FOBS,DELF
C     MODED=2 H,K,L, ARG(FCAL),PHASE ANGLE,FOBS,DELF
C     MODED=3 H,K,L, A,B,FOBS,DELF
C     MODED=4 H,K,L, FOBS,DELF
   2  NOBSIN=NOBSIN+1
      CALL RDDATA(LUNI,K,HI,FIN,4,IOU)
      IF (IOU .EQ. -9999) GO TO 7
C     SWITCH ACCORDING TO FORMAT OF REFLECTION CARDS (MODED)
      GO TO (3,4,4,5), MODED
   3  F=FIN(2)
      SF=FIN(3)
      GO TO 6
C
   4  F=FIN(3)
      SF=FIN(4)
      GO TO 6
C
   5  F=FIN(1)
      SF=FIN(2)
C     ABSOLUTE PHASE DOESN'T MATTER AS TERMS ARE TO BE SQUARED
C     TEST FOR 0 0 0 REFLECTION
    6 IF ((K(1).EQ.0) .AND. (K(2).EQ.0) .AND. (K(3) .EQ.0)) GO TO 8
      IF (VCTMOD(0.5,HI,2) .GT. SMAX) GO TO 2
C     MULTIPLY BY 2 BECAUSE WE ASSUME -H,-K,-L, IS NOT GIVEN AND WILL
C     NOT BE GENERATED IF NCENT=2
      NUSED=NUSED+1
      SF = 2.*SF*RESOL(HI,DELTA)*SCALEF
      DO 26 N = 1,NOPC
      CALL ROTSYM(HI,EH,N,2)
      IF (N .NE. 1) GO TO 44
      DO 45 I = 1,3
   45 H(I,1) = EH(I)
      MI = 1
      GO TO 46
  44  CALL EQVEC(H,EH,MI,M,NOP)
      IF (M .LE. MI) GO TO 26
      MI = M
   46 IF (NDIM .NE. 2) GO TO 27
C     SYMMETRY MATRICES ALREADY ROTATED TO AXES OF MAP
      IF (EH(3) .NE. 0) GO TO 26
   27 TRA = 0.
      DO 23 I = 1,3
      K(I) = NINT(EH(I))
   23 TRA = TRA + EH(I)*(TRANS(I,N) - OUTLIM(1,I))
C     PHASE AT ORIGIN OF MAP
      TRA = TWOPI*TRA
C
C     NOW CALCULATE THE CONTRIBUTION FROM THIS REFLECTION AT ALL POINTS
      J = 2*IABS(K(1))+1
      SDX = SINCOX(J+1)
      CDX = SINCOX(J)
      IF (K(1) .GT. 0) SDX = -SDX
      J = 2*IABS(K(2))+1
      SDY = SINCOY(J+1)
      CDY = SINCOY(J)
      IF (K(2) .GT. 0) SDY = -SDY
      COX = COS(TRA)*SF
      SOX = SIN(TRA)*SF
      DO 30 IX = 1,NX
      I = IX
      SUM(I) = SUM(I) + COX
      COY = COX*CDY - SOX*SDY
      SOY = SOX*CDY + COX*SDY
      DO 31 IY = 2,NY
      I = I+NX
      SUM(I) = SUM(I) + COY
      SNEW = SOY*CDY + COY*SDY
      COY = COY*CDY - SOY*SDY
   31 SOY = SNEW
      SNEW = SOX*CDX + COX*SDX
      COX = COX*CDX - SOX*SDX
   30 SOX = SNEW
C
C     ACCUMULATE SUM OVER ALL EQUIVALENTS
   26 CONTINUE
C     NOW SQUARE SUM, ADD TO RESULT AND CLEAR FOR NEXT
      DO 32 I = 1,NXY
      DENS(I) = DENS(I) + SUM(I)**2
   32 SUM(I) = 0.
      GO TO 2
C     ADD CONTRIBUTION FROM 0,0,0 REFLECTION
    8 SF = (SF*SCALEF)**2
      DO 9 I = 1,NXY
    9 DENS(I) = DENS(I) + SF
      GO TO 2
C     HAVE RUN OUT OF REFLECTIONS ON STREAM LUNI
C     TAKE SQRT TO GET STANDARD DEVIATION
    7 DO 50 I = 1,NXY
   50 DENS(I) = SQRT(DENS(I))
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE FORIER(IIN,IOP,START)
      SUBROUTINE FORIER(IIN,IOP,START)
C
C *** FORIER updated by PJB 29 Apr 88 ***
C
CX
CC 5B
CH Controls Fourier calculations.
C
CA On entry START, a logical, indicates whether this is the first call of FORIER
CA On exit  IIN indicates how the next map is to be obtained:
CA          IIN = 1 means get back previously saved map
CA                2 means read back pre-calculated map in binary form
CA                3 means calculate map using FOUR1Z
CA                4 means calculate map using FOURGP (general plane)
CA                5 means calculate map using ERRMAP (error map)
CA          IOP indicates how the next map is to be sent out:
CA          IOP contains 1 bit = print
CA                       2 bit = plot
CA                       4 bit = save
C
CP Must be set up by a call of SETFOU, reading the relevant M cards
C
CD If 2D (NDIM=2), only one possible map, a projection, is involved.  If 3D
CD (NDIM=3), several layers may be involved.  Their values of Z are stored
CD in arrays:
CD    ZRDVAL for reading down pre-calculated maps
CD    ZGTVAL for getting back previously saved maps
CD    ZSVVAL for saving maps just calculated
CD    ZPRVAL for printing
CD    ZPLVAL for plotting
CD NDIM=4 is a request for a bounded section
C
      LOGICAL START
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
      COMMON /MAPPR/ZPRVAL(20),ZCPR,IPR,IZPR
      COMMON /MAPRD/ZRDVAL(20),ZCRD,IRD,IZRD,IDUMPR
      COMMON /MAPSV/ZSVVAL(20),ZCSV,ISV,IZSV,NDUMPS,NSAV
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C
C DOES NOT OPEN FILE FROM WHICH TO READ REFLECTIONS - ASSUMES USER WANTS
C TO DO IT HIMSELF IN MAIN
C SET ZERO FOR A START
      IOP=0
      IIN=0
C  THEN SWITCH IF NOT STARTING
      IF (START) THEN
      START=.FALSE.
C
C SET FLAG TO SAY NO MAPS SAVED YET (TO BE CONSULTED IN SAVMAP):
      NSAV=0
C
C IF SAVING , OPEN FILE (IF GETTING, FILE IS OPENED IN MAJUST):
      MESSAG='Saved maps'
      NAMFIL='.SAV'
      IF (IZSV .GT. 0) CALL OPNFIL(NDUMPS,1112)
C
C IF READING BINARY PRE-CALCULATED MAP, OPEN FILE:
      MESSAG='Pre-calculated maps'
      IF (IZRD .GT. 0) CALL OPNFIL(IDUMPR,1011)
C
      IF (NDIM .EQ. 2) GO TO 1
C
C 3D - FIND ALL VALUES OF Z IN ALL 5 LISTS:
      IPR=1
      IF (IZPR .EQ. 0) THEN
      ZCPR=99999.
      ELSE
      ZCPR=ZPRVAL(1)
      ENDIF
      IPL=1
      IF (IZPL .EQ. 0) THEN
      ZCPL=99999.
      ELSE
      ZCPL=ZPLVAL(1)
      ENDIF
      ISV=1
      IF (IZSV .EQ. 0) THEN
      ZCSV=99999.
      ELSE
      ZCSV=ZSVVAL(1)
      ENDIF
      IGT=1
      IF (IZGT .EQ. 0) THEN
      ZCGT=99999.
      ELSE
      ZCGT=ZGTVAL(1)
      ENDIF
      IRD=1
      IF (IZRD .EQ. 0) THEN
      ZCRD=99999.
      ELSE
      ZCRD=ZRDVAL(1)
      ENDIF
C
      ENDIF
C  START HERE AFTER FIRST ENTRY
C
      IF (NDIM.EQ.2) GO TO 1
C
C NEXT VALUE OF Z:
      Z=AMIN1(ZCPL,ZCSV,ZCPR,ZCGT,ZCRD)
      IF (Z.GT.99998.) GO TO 100
      OUTLIM(1,3)=Z
C
C DO WE NEED TO GET SAVED FILE FOR THIS VALUE OF Z?
      IF (ABS(ZCGT-Z) .GT. 10.E-5) GO TO 37
      IIN=1
      IGT=IGT+1
      ZCGT=ZGTVAL(IGT)
      IF (IGT.GT.IZGT) ZCGT=99999.
      GO TO 10
C
C DO WE NEED TO READ BINARY FILE FOR THIS VALUE OF Z?
  37  IF (ABS(ZCRD-Z) .GT. 10.E-5) GO TO 97
      IIN=2
      IRD=IRD+1
      ZCRD=ZRDVAL(IRD)
      IF (IRD.GT.IZRD) ZCRD=99999.
      GO TO 10
C
C WE WANT TO CALCULATE A NEW MAP:
  97  IF (MODET .EQ. 2) THEN
      IIN=4
      ELSE
      IF (MODEF .LT. 7) IIN=3
      IF (MODEF .EQ. 7) IIN=5
      ENDIF
C
C DO WE WANT TO PRINT AT THIS VALUE OF Z?
  10  IF (ABS(ZCPR-Z) .GT. 10.E-5) GO TO 17
      IOP=IOP+1
      IPR=IPR+1
      ZCPR=ZPRVAL(IPR)
      IF (IPR.GT.IZPR) ZCPR=99999.
C
C DO WE WANT TO PLOT AT THIS VALUE OF Z?
  17  IF (ABS(ZCPL-Z) .GT. 10.E-5) GO TO 7
      IOP=IOP+2
      IPL=IPL+1
      ZCPL=ZPLVAL(IPL)
      IF (IPL.GT.IZPL) ZCPL=99999.
C
C DO WE WANT TO SAVE THIS VALUE OF Z?
   7  IF (ABS(ZCSV-Z) .GT. 10.E-5) GO TO 8
      IOP=IOP+4
      ISV=ISV+1
      ZCSV=ZSVVAL(ISV)
      IF (ISV.GT.IZSV) ZCSV=99999.
   8  IF (NDIM.NE.4 .OR.IOP.EQ.0) GO TO 100
C
C  SPECIAL FOR BOUNDED SECTIONS
      SECEND=Z
      IF (ZCPL.LT.99999.) SECEND=ZCPL
      IF (ZCPR.LT.99999.) SECEND=AMAX1(SECEND,ZCPR)
      IF (ZCSV.LT. 99999.) SECEND=AMAX1(SECEND,ZCSV)
      IF (ZCPR .LT.99999.) THEN
        IF (ABS(SECEND-ZCPR).GT.10.E-4) THEN
          IPR=IPR-1
          ZCPR=ZPRVAL(IPR)
        ELSE
          IPR=IPR+1
          ZCPR=ZPRVAL(IPR)
          IF (IPR.GT.IZPR) ZCPR=99999.
        ENDIF
      ENDIF
      IF (ZCPL.LT. 99999.) THEN
        IF (ABS(SECEND-ZCPL).GT.10.E-4) THEN
          IPL=IPL-1
          ZCPL=ZPLVAL(IPL)
        ELSE
          IPL=IPL+1
          ZCPL=ZPLVAL(IPL)
          IF (IPL.GT.IZPL) ZCPL=99999.
        ENDIF
      ENDIF
      IF (ZCSV.LT.99999.) THEN
        IF (ABS(SECEND-ZCSV).GT.10.E-4) THEN
          ISV=ISV-1
          ZCSV=ZSVVAL(ISV)
        ELSE
          ISV=ISV+1
          ZCSV=ZSVVAL(ISV)
          IF (ISV.GT.IZSV) ZCSV=99999.
        ENDIF
      ENDIF
      GO TO 100
C
C 2D IS EASIER BECAUSE THERE IS NO Z COUNT:
    1 IF (IZGT .EQ. 0) GO TO 2
      IIN=1
      GO TO 3
   2  IF (IZRD .EQ. 0) GO TO 90
      IIN=2
      GO TO 3
  90  OUTLIM(1,3)=0.
      IIN=3
      IF (MODEF .EQ. 7) IIN=5
   3  IF (IZPR .NE. 0) IOP=IOP+1
      IF (IZPL .NE. 0) IOP=IOP+2
      IF (IZSV .NE. 0) IOP=IOP+4
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      SUBROUTINE FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
C
C *** FOUINP updated by JCM 14 Apr 89 ***
C
CX
CC 5C
CH Reads one data item for a given type of Fourier, in a given format.
CA On entry MODED indicates the data format type, from M DTYP card
CA     MODED=0: user-supplied routine QFOUIN should set K, F, ALPHA, ENDIP
CA     MODED=1: read H,K,L FCAL,FOBS,(D)
CA     MODED=2: read H,K,L, mod(FCAL), phase angle, FOBS
CA     MODED=3: read H,K,L, A, B, FOBS
CA     MODED=4: read H,K,L, FOBS (or FCAL)
CA On entry MODEF indicates the Fourier type required, from M FTYP card
CA     MODEF=1:   FCAL
CA     MODEF=2:   FOBS (Centrosymmetric)
CA     MODEF=3:   mod(FOBS)*phase(FCAL)
CA     MODEF=4:   FOBS-FCAL
CA     MODEF=5:   (mod(FOBS)-mod(FCAL))*phase(FCAL)
CA     MODEF=6:   FOBS*FOBS (Patterson)
CA On exit  K is a 1x3 integer vector holding h,k,l
CA          F is a 1x2 vector holding whichever of FOBS, etc were requested
CA          ALPHA, if relevant, holds the phase
CA          ENDIP is a logical set TRUE if the end of the input has occurred.
CO Checks that MODED and MODEF are compatible and complains and stops if not.
C
      LOGICAL ENDIP
      DIMENSION K(3),F(3),H(3)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C
      ENDIP=.FALSE.
      IF (MODED .GT. 0) GO TO 9
      CALL QFOUIN(K,F,ALPHA,ENDIP)
      GO TO 100
C
   9  CALL RDDATA(LUNI,K,H,F,3,IOU)
      IF (IOU .EQ. -9999) GO TO 101
      GO TO (11,12,13,14) , MODED
  11  ALPHA = PIBY2 - SIGN(PIBY2,F(1))
      GO TO 100
C
  12  ALPHA=F(2)
      F(2)=F(3)
      GO TO (100,99,100,99,100,100),MODEF
C
  13  FA=F(1)
      FB=F(2)
      F(2)=F(3)
      F(1) = SQRT(FA*FA+FB*FB)
      IF (F(1) .EQ. 0.) GO TO 9
      ALPHA = ATAN2(FB,FA)
      GO TO (100,99,100,99,100,100),MODEF
C
  14  F(2)=F(1)
      GO TO (99,100,99,99,99,100),MODEF
C
C ERROR:
  99  CALL ERRMES(1,0,'MODEF & MODED values incompatible')
C
C  MARK END OF DATA
  101 ENDIP=.TRUE.
  100 RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE FOUR1D
      SUBROUTINE FOUR1D
C
C *** FOUR1D by PJB Dec 85 ***
C
CX
CC 5B
CH Calculates a Fourier along a general line.
CP SETFOU should have been obeyed to read M, N and I  cards and set up
CP the calculation.
CD Uses FOUINP to allow all different data input and Fourier types.
CD Puts calculated 1-D Fourier in array DENS in /MAPDA
C
CN Expects that the h,k,l values cover a suitable asymmetric unit, from which it
CN uses the given symmetry to generate an entire reciprocal space full.  If the
CN data stray outside one asymmetric unit, some h,k,l values will occur more
CN than once.
C
      COMPLEX RHO(1500),CE(100,3),FAC(2),Y,YM
      LOGICAL USED,ENDIP
C%
C      DIMENSION H(3,%SY*2%),HI(3),K(3),F(2)
      DIMENSION H(3,48),HI(3),K(3),F(2)
      DIMENSION KLIM(3),SF(2),ALPH(2)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      EQUIVALENCE (DENS,RHO),(CE,DENS(3001)),(KLIM(1),NH)
C
C NOBSIN COUNTS DATA READ, NUSED COUNTS THOSE USED
      NOBSIN=-1
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
      NY=4*NX
C     CLEAR STORE FOR SUM OVER L
      DO 1 M = 1,NY
    1 DENS(M) = 0.
C
C  GET RQUIRED TRIG FUNCTIONS
      DO 2 I=1,3
      KK=KLIM(I)+1
      AMP=-TWOPI*OUTLIM(3,I)
      CALL TRIG(CE(1,I),AMP,KK)
    2 CONTINUE
C
C  NOW READ REFLECTIONS
    7 USED=.FALSE.
      CALL FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      IF (ENDIP) GO TO 20
C
      NOBSIN=NOBSIN+1
      CALL INDFLO(HI,K)
C DO NOT USE IF SIN THETA/LAMBDA TOO LARGE:
      VL =VCTMOD(0.5,HI,2)
      IF (VL .GT. SMAX) GO TO 7
C
C APPLY RESOLUTION FUNCTION AND USER'S SCALE:
      AMP = RESOL(HI,DELTA)*SCALEF
      DO 3 MODE=1,2
      CALL CHOOSF(F,SF(MODE),ALPHA,ALPH(MODE),MODE)
C SF AND ALPHA NOW SET UP:
C
C DOUBLE ALL BUT 000 REFLN. AS WE ARE ONLY USING HALF RECIPROCAL SPACE:
      IF  ((K(1).NE.0).OR.(K(2).NE.0).OR.(K(3).NE.0))
     & SF(MODE)=2.*SF(MODE)
C
      SF(MODE)=SF(MODE)*AMP
    3 CONTINUE
C
C DEAL WITH SYMMETRY EQUIVALENTS:
      MI=0
C TO MAKE EQVEC ACCEPT FIRST SET OF INDICES
      DO 8 N = 1,NOPC
      CALL SYMEQU(HI,H,K,N,MI,UU,BETA)
      IF (UU.EQ.0.) GO TO 8
      USED=.TRUE.
      FAC(1)=SF(1)*CEXP(CMPLX(0.,UU*ALPH(1)+BETA))
      FAC(2)=SF(2)*CEXP(CMPLX(0.,UU*ALPH(2)+BETA))
      DO 9 I=1,NX
      RHO(I)=RHO(I)+FAC(1)
      RHO(NX+I)=RHO(NX+I)+FAC(2)
      YM=CMPLX(1.,0.)
      DO 10 J=1,3
      Y=CE(IABS(K(J))+1,J)
      IF (K(J).LT.0) Y=CONJG(Y)
   10 YM=YM*Y
      FAC(1)=FAC(1)*YM
      FAC(2)=FAC(2)*YM
    9 CONTINUE
C
    8 CONTINUE
      IF (USED) NUSED=NUSED+1
      GO TO 7
C
C  HERE ON END OF DATA
   20 NY=2*NX
      II=2*NY
      DO 11 I=1,NY,2
      DENS(II+I)=DENS(NY+I)-DENS(I)
   11 CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE FOUR1Z
      SUBROUTINE FOUR1Z
C
C *** FOUR1Z corrected by PJB 17-Jun-1994 ***
C
CX
CC 5B
CH Calculates 1 layer of Fourier sum : a section if 3D, a projection if 2D,
CH or a bounded section if "4D".
C
CP Must be set up by call to SETFOU to read M, N, I cards
C
CD Uses FOUINP to allow all different data input and Fourier types.
CD Puts calculated  Fourier map in array DENS in /MAPDA
C
CN Expects that the h,k,l values cover a suitable asymmetric unit, from which it
CN uses the given symmetry to generate an entire reciprocal space full.  If the
CN data stray outside one asymmetric unit, some h,k,l values will occur more
CN than once.
CN
CN Ignores FRIEDL - if non-centrosymmetric, and Friedel's law not to be assumed,
CN the user must do something to combine F(H,K,L) and F(-H,-K,-L) outside
CN FOUR1Z.
C
      LOGICAL USED,ENDIP
C%
C      DIMENSION H(3,%SY*2%),HI(3),K(3),F(3),SINCO(200)
      DIMENSION H(3,48),HI(3),K(3),F(3),SINCO(200)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /SCRAT/SUM(10201)
C
C NOBSIN COUNTS DATA READ, NUSED COUNTS THOSE USED
      NOBSIN=0
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
C SET ORIGIN OF SECTION:
      DO 2 I=1,3
   2  SECZER(I)=OUTLIM(1,I)
C
C     CLEAR STORE FOR SUM OVER L
      DO 1 M = 1,NHK
    1 DENS(M) = 0.
C
C JJ=H MAX + 1
      JJ = ((NH-1)/2)+1
C  NOW READ REFLECTIONS
    7 USED=.FALSE.
      CALL FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      IF (ENDIP) GO TO 20
C
      NOBSIN=NOBSIN+1
      CALL INDFLO(HI,K)
C DO NOT USE IF SIN THETA/LAMBDA TOO LARGE:
      IF (VCTMOD(0.5,HI,2) .GT. SMAX) GO TO 7
C
C APPLY RESOLUTION FUNCTION AND USER'S SCALE:
      AMP = RESOL(HI,DELTA)*SCALEF
      CALL CHOOSF(F,SF,ALPHA,ALPH,MODEF)
C SF AND ALPHA NOW SET UP:
C
C DOUBLE ALL BUT 000 REFLN. AS WE ARE ONLY USING HALF RECIPROCAL SPACE:
      IF  ((K(1).NE.0).OR.(K(2).NE.0).OR.(K(3).NE.0))
     & SF=2.*SF
C
      SF=SF*AMP
    3 CONTINUE
C
C DEAL WITH SYMMETRY EQUIVALENTS:
C TO MAKE EQVEC ACCEPT FIRST SET OF INDICES
      MI=0
C TRANSFORM HI (GIVEN H) TO OCCUPY FIRST PLACE IN TABLE FOR EQVEC:
      CALL GMEQ(HI,H(1,1),1,3)
      CALL GMPRD(H(1,1),U,HI,1,3,3)
      DO 8 N = 1,NOPC
      CALL SYMEQU(HI,H,K,N,MI,UU,BETA)
      IF (UU.EQ.0.) GO TO 8
      USED=.TRUE.
C49 - SECTION updated by PJB
      ALPHA1=ALPH*SIGN(1.,UU)+BETA
      SFUU=SF*ABS(UU)
      KF=1
      KH = 2*(NK*(K(1)+JJ-1)+K(2)+KF)
      DENS(KH-1) = DENS(KH-1)+SFUU*COS(ALPHA1)
      DENS(KH) = DENS(KH) + SFUU*SIN(ALPHA1)
C49 - END OF UPDATED SECTION
C
    8 CONTINUE
      IF (USED) NUSED=NUSED+1
      GO TO 7
C
C     SUM OVER L COMPLETED - ALL REFLECTIONS HAVE BEEN READ
C CLEAR STORE FOR SUM OVER H:
  20  DO 30 N = 1,NKX
   30 SUM(N) = 0.
C
C SET UP COS AND SIN TABLES:
      CALL TRIG (SINCO,TWOPI*OUTLIM(3,1),JJ)
      KH = 1
      DO 34 IH=1,NH
      KXI = 1
      J = 2*IABS(IH-JJ)+1
      SD = -SINCO(J+1)
      CD = SINCO(J)
      IF (IH .LT. JJ) SD = -SD
      DO 34 IK=1,NK
      KX = KXI
      IF ((DENS(KH) .EQ. 0.) .AND. (DENS(KH+1) .EQ.0.)) GO TO 39
      C = DENS(KH)
      S = DENS(KH+1)
      DO 38 N=1,NX
      SUM(KX) = SUM(KX) + C
      SUM(KX+1) = SUM(KX+1) + S
      CNEW = C*CD - S*SD
      S = C*SD + S*CD
      C = CNEW
   38 KX = KX+2
   39 KH = KH+2
   34 KXI = KXI + 2*NX
C
C     SUM OVER H COMPLETE
C FINAL SUM OVER K:
      KF=NK
      CALL TRIG(SINCO,TWOPI*OUTLIM(3,2),KF)
C CLEAR DENS FOR ANSWERS:
      DO 40 N = 1,NXY
   40 DENS(N) = 0.
      KX = 1
      DO 41 IK=1,NK
      KK = 2*IK
      CD = SINCO(KK-1)
      SD = -SINCO(KK)
      DO 42 N = 1,NX
      M = N
      IF ((SUM(KX) .EQ. 0.) .AND. (SUM(KX+1) .EQ. 0.)) GO TO 42
      C = SUM(KX)
      S = SUM(KX+1)
      DO 43 IY = 1,NY
      DENS(M) = DENS(M) + C
      CNEW = C*CD - S*SD
      S = C*SD + S*CD
      C = CNEW
   43 M = M+NX
   42 KX = KX+2
   41 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE FOURGP
      SUBROUTINE FOURGP
C
C *** FOURGP by PJB Dec 85 ***
C
CX
CC 5B
CH Calculates a Fourier on a general plane.
C
CP Must be set up by call to SETFOU to read M, N, I cards
C
CD Uses FOUINP to allow all different data input and Fourier types.
CD Puts calculated  Fourier map in array DENS in /MAPDA
C
CN Expects that the h,k,l values cover a suitable asymmetric unit, from which it
CN uses the given symmetry to generate an entire reciprocal space full.  If the
CN data stray outside one asymmetric unit, some h,k,l values will occur more
CN than once.
CN
CN Ignores FRIEDL - if non-centrosymmetric, and Friedel's law not to be assumed,
CN the user must do something to combine F(H,K,L) and F(-H,-K,-L) outside
CN FOURGP
C
      COMPLEX RHO,CE,Y,YM(2),VAL
      LOGICAL USED,ENDIP
C%
C      DIMENSION H(3,%SY*2%),HI(3),K(3),F(2)
      DIMENSION H(3,48),HI(3),K(3),F(2)
      DIMENSION KLIM(3)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /SCRAT/RHO(100),CE(100,6)
      EQUIVALENCE (KLIM(1),NH)
C
C NOBSIN COUNTS DATA READ, NUSED COUNTS THOSE USED
      NOBSIN=0
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
C     CLEAR STORE FOR SUM
      DO 1 M = 1,NXY
    1 DENS(M) = 0.
C
C
C  GET REQUIRED TRIG FUNCTIONS, AND TRANSFORMED STARTING POS
      L=1
      DO 2 J=1,3
      SECZER(J)=0.
      DO 2 I=1,3
      IF (J.EQ.3) GO TO 4
      KK=KLIM(I)+1
      AMP=-TWOPI*OUTLIM(3,J)*U(I,J)
      CALL TRIG(CE(1,L),AMP,KK)
      L=L+1
    4 SECZER(J)=SECZER(J)+OUTLIM(1,I)*U(J,I)
    2 CONTINUE
C
C  NOW READ REFLECTIONS
    7 USED=.FALSE.
      CALL FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      IF (ENDIP) GO TO 100
C
      NOBSIN=NOBSIN+1
      CALL INDFLO(HI,K)
C DO NOT USE IF SIN THETA/LAMBDA TOO LARGE:
      IF (VCTMOD(0.5,HI,2) .GT. SMAX) GO TO 7
C
C APPLY RESOLUTION FUNCTION AND USER'S SCALE:
      AMP = RESOL(HI,DELTA)*SCALEF
      CALL CHOOSF(F,SF,ALPHA,ALPH,MODEF)
C SF AND ALPHA NOW SET UP:
C
C DOUBLE ALL BUT 000 REFLN. AS WE ARE ONLY USING HALF RECIPROCAL SPACE:
      IF  ((K(1).NE.0).OR.(K(2).NE.0).OR.(K(3).NE.0))
     & SF=2.*SF
C
      SF=SF*AMP
    3 CONTINUE
C
C DEAL WITH SYMMETRY EQUIVALENTS:
      MI=0
C TO MAKE EQVEC ACCEPT FIRST SET OF INDICES
      DO 8 N = 1,NOPC
      CALL SYMEQU(HI,H,K,N,MI,UU,BETA)
      IF (UU.EQ.0.) GO TO 8
      USED=.TRUE.
      VAL=SF*CEXP(CMPLX(0.,UU*ALPH+BETA))
      L=1
      DO 9 I=1,2
      YM(I)=CMPLX(1.,0.)
      DO 9 J=1,3
      Y=CE(IABS(K(J))+1,L)
      L=L+1
      IF (K(J).LT.0) Y=CONJG(Y)
   9  YM(I)=YM(I)*Y
C
      L=1
      RHO(1)=VAL
      DO 10 J=1,NY
      VAL=RHO(J)
      RHO(J+1)=RHO(J)*YM(2)
      DO 10 I=1,NX
      DENS(L)=DENS(L)+REAL(VAL)
      L=L+1
      VAL=VAL*YM(1)
   10 CONTINUE
C
    8 CONTINUE
      IF (USED) NUSED=NUSED+1
      GO TO 7
C
C  HERE ON END OF DATA
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE FRAME(X1,Y1,X2,Y2)
      SUBROUTINE FRAME(X1,Y1,X2,Y2)
C
C *** FRAME by JCM 24 Nov 83 ***
C
CX
CC 14C
CH Draws a rectangle in the plotting context.
CA On entry (X1,Y1) and (X2,Y2) are the coordinates of opposite corners of
CA the required rectangle.  These are in "current coordinates"
CP The plotting must have been set up by, e.g. STPLOT, and a suitable space
CP selected by SPCSET.
C
      CALL KANGA1(X1,Y1,3)
      CALL KANGA1(X1,Y2,2)
      CALL KANGA1(X2,Y2,2)
      CALL KANGA1(X2,Y1,2)
      CALL KANGA1(X1,Y1,2)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE GETMAP
      SUBROUTINE GETMAP
C
C *** GETMAP updated C19 by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Retrieves 1 Fourier map previously filed using SAVMAP.
CP Assumes unit IDUMPG is positioned so that reading from it will
CP produce the "next" map dumped there.
CP
CP The required Z value must be set in OUTLIM(1,3)
C
CD Continues reading down maps until it finds one for the given Z.
CD
CD If no map is dumped for this value of Z, will eventually read the
CD trailer record of file IDUMPG and complain.
C
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
C>> JCC Use error flag instead of STOP

	INTEGER IBMBER
	COMMON / CCSLER / IBMBER 
C
   1  READ(IDUMPG) ZI,NOBSIN,NUSED,NXX,NYY
      IF (NXX .EQ. NX .AND. NYY .EQ. NY) GO TO 3
      WRITE (LPT,3001) NXX,NYY,NX,NY
      WRITE (ITO,3001) NXX,NYY,NX,NY
3001  FORMAT (/' ERROR ** MAP TO BE READ OF SIZE',I3,' BY',I3,
     & ' BUT CURRENT SET SIZE IS',I3,' BY',I3)
      IBMBER = 1
	RETURN
C
C CHECK NOT READING TRAILER:
   3  IF (ZI .GE. 99998.) CALL ERRRE2(OUTLIM(1,3),0,
     & 'no dumped map for z=',' ')
C
C READ RECTANGULAR ARRAY OF PREVIOUSLY CALCULATED MAP:
      I=0
      DO 4 IY=1,NY
      READ (IDUMPG) (DENS(I+J),J=1,NX)
   4  I=I+NX
C
C IF WRONG VALUE OF Z, BACK FOR NEXT:
      IF (ABS(OUTLIM(1,3)-ZI) .GT. 10.E-5) GO TO 1
      WRITE (LPT,2000) OUTLIM(1,3),NX,NY
2000  FORMAT(/' For Z=',F10.4,' map of size',I4,' by',I4,
     & ' read')
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE GETSCL(VMIN,VMAX,L)
      SUBROUTINE GETSCL(VMIN,VMAX,L)
C
C *** GETSCL updated by PJB Sep 87 ***
C
CX
CC 14A
CH Chooses a sensible scale for a graph.
CA On entry VMIN is minimum value to be plotted
CA          VMAX is maximum value to be plotted
CA          L=1 for x axis
CA            2 for y axis
CP X(L,2) must be set up as below:
CD The vector X(I,J) in /PLTS defines how the graph will be drawn.
CD           I=1  for X-axis, I=2 for Y-axis.
CD           J=1  length of axis in user units
CD           J=2  length of axis in cms.
CD           J=3  division of axis in user units
CD           J=4  minimum value in user units
CD           J=5  position of plotted axis in user units
CD Sets X(L,J) for J=1,3,4,5.
CO If VMAX and VMIN are not sensible, complains and bombs an error flag.
C
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /PLTS/X(2,5),S(2),CH,XS,ISIG(2),YS,NDIVS(2,2)

C>> JCC Use bomb out flag instead of stop
C
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
      AMAX=VMAX
      AMIN=VMIN
      XX=AMAX-AMIN
      I=0
C
    1 IF (XX.GT.10.) GO TO 2
    4 IF (XX.GT.1.) GO TO 3
      I=I-1
      IF (I.LT.-8) THEN
        WRITE (ITO,3000) AMAX,AMIN
3000  FORMAT (' Range from ',E12.4,' to ',E12.4,' too small for GETSCL')
C>> Was STOP
       CALL BMBOUT
	 RETURN
      ENDIF
      XX=XX*10.
      GO TO 4
C
    2 I=I+1
      IF (I.GT.8) THEN
        WRITE(ITO,3001) AMAX,AMIN
3001  FORMAT (' Range from ',E12.4,' to ',E12.4,' too big for GETSCL')
C>>        STOP
        CALL BMBOUT
	  RETURN
      ENDIF
      XX=XX/10.
      GO TO 1
C
    3 AMUL=10.**I
      STEP=2.
      IF (XX.LE.5.) STEP=1.
      IF (XX.LE.2.5) STEP=.5
      IF (XX.LE.1.4) STEP=.2
      BIGSTP=AMUL*STEP
      STEPX=BIGSTP/5.
      BIT=STEPX*0.49
C  SET POSITION OF AXIS TO BE PLOTTED
C BIGSTP USED INSTEAD OF ZERO FOR COSMETIC REASONS:
      IF (AMIN.LE.BIGSTP  .AND. AMAX.GE.-BIGSTP) THEN
        X(L,5)=0.
        IF (AMIN .GT. 0.) AMIN=0.
        IF (AMAX .LT. 0.) AMAX=0.
      ELSE
C  ORIGIN OUTSIDE GRAPH
        IF (AMIN .LE. 0.) THEN
          X(L,5)=FLOAT(IFIX(AMIN/BIGSTP))*BIGSTP
        ELSE
          X(L,5)=FLOAT(IFIX((AMIN-BIT)/BIGSTP)+1)*BIGSTP
        ENDIF
      ENDIF
      NDIVS(L,1)=NINT((ABS(AMIN-X(L,5))+BIT)/STEPX)
      NDIVS(L,2)=NINT((ABS(AMAX-X(L,5))+BIT)/STEPX)
      X(L,1)=FLOAT(NDIVS(L,1)+NDIVS(L,2))*STEPX
      X(L,3)=BIGSTP
      X(L,4)=X(L,5)-FLOAT(NDIVS(L,1))*STEPX
      ISIG(L)=I
      IF (STEP.LT.1) ISIG(L)=I-1
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE INPUTM
      SUBROUTINE INPUTM
C
C *** INPUTM updated by PJB 29 Apr 88 ***
C
CX
CC 5A
CH Reads and interprets all "M" cards.
CD Takes the information from "M" cards into the map or contouring COMMON,
CD usually as a prelude to a Fourier calculation
CD "M" cards have a significant word in columns 3,4,5,6.  Possible words are:
CD    M NDIM     Number of dimensions for Fourier, 2 (projection), 3 (3D)
CD               or 4 (bounded section).
CD    M FTYP     Fourier type (see below).
CD    M MESH     Output mesh - 6 numbers, being:
CD               X(START) X(END) X(STEP), and the same in Y
CD    M AXES     Matrix of 9 integers turning the Fourier to a different
CD               orientation, or 9 reals asking for a plane section.
CD    M PRIN     By itself means "print calculated map".  Followed by a
CD               list of Z values, means "print only at these selected
CD               Z values".  If absent, the default is not to print anything,
CD               so if there are no "M PRIN", "M PLOT" or "M SAVE" cards the
CD               run will not tell the user much.
CD    M PLOT     Present if plotting required - also gives values of Z at which
CD               plotting is required if NDIM=3, on several cards if necessary.
CD    M CM/A     If plotting, number of centimetres of plotter paper per
CD               Angstrom.
CD    M CONT     If plotting, list of required contour values (may be several
CD               cards, all starting M CONT)
CD    M SAVE     Save the calculated map(s) on a named file in such a way that
CD               a subsequent run with an "M GET" card will retrieve it/them
CD               with a view to drawing another contour map.  Details in the
CD               specification of SUBROUTINE FORIER.
CD    M GET      Do not calculate a map at all - read an already calculated map
CD               from unit IDUMPG, and interpret only those cards which make
CD               sense - e.g. the user may alter contours, scale of map in
CD               cms/Angstrom, etc, but he may not alter cell dimensions, space
CD               group, theta maximum etc.
CD    M DTYP     data input type
CD    M DELT     delta for resolution function
CD    M SCAL     scale to multiply Fourier coefficients
CD    M SMAX     sin theta/lambda maximun for this particular run
CD    M READ     do not calculate map - take the crystal data cards on trust,
CD               and read from a binary file some pre-calculated map.
C
CI Reads all "M" cards
CO Writes its findings on unit LPT.
C
      CHARACTER *4 MWD,MTABLE(15)
      DIMENSION IU(3,3)
C
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
      COMMON /MAPPR/ZPRVAL(20),ZCPR,IPR,IZPR
      COMMON /MAPRD/ZRDVAL(20),ZCRD,IRD,IZRD,IDUMPR
      COMMON /MAPSV/ZSVVAL(20),ZCSV,ISV,IZSV,NDUMPS,NSAV
      COMMON /MREAD/IMREAD(15)
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      DATA MTABLE/'NDIM','FTYP','MESH','AXES','PRIN','PLOT',
     & 'CM/A','CONT','SAVE','READ','DTYP','DELT','SCAL','GET',
     & 'SMAX'/
C
C SET "NO M CARDS READ":
C%
C      CALL JGMZER(IMREAD,1,%MCRD%)
      CALL JGMZER(IMREAD,1,15)
C
C INITIALISE COUNTS OF ITEMS WHICH MAY COME ON MORE THAN 1 CARD:
      IZPR=0
      IZPL=0
      IZSV=0
      IZGT=0
      IZRD=0
      NCONT=0
C
C READ ALL "M" CARDS:
      INREAD(13)=-IABS(INREAD(13))
      ID=IABS(INREAD(13))
      NCARD=ICDNO(13)
      IF (NCARD .LE. 0) THEN
        CALL MESS(LPT,1,'No "M" cards given')
        GO TO 100
      ENDIF
C
      DO 3 ICD=1,NCARD
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(MWD,LEN,3,IPT,80,0,IER)
C%
C  62  L=NCFIND(MWD,MTABLE,%MCRD%)
  62  L=NCFIND(MWD,MTABLE,15)
      IF (L .LE. 0) THEN
        CALL ERRCH2(MWD,2,'cannot recognise word','on "M" card')
        GO TO 3
      ENDIF
C
C SET "HAVE READ PARTICULAR WORD" (COUNTING NUMBER OF CARDS), THEN BRANCH:
   4  IMREAD(L)=IMREAD(L)+1
      GO TO (31,32,33,34,35,36,37,38,39,40,41,42,43,44,45) , L
C
C M NDIM:
C READ 1 INTEGER BEING NUMBER OF DIMENSIONS FOR FOURIER, 2 OR 3:
C NDIM=4 MEANS CALCULATE BOUNDED SECTIONS
  31  CALL RDINTG(NDIM,IPT,IPT,80,IER)
      IF (NDIM .EQ. 2) THEN
        CALL MESS(LPT,1,'Fourier projection required')
      ELSE IF (NDIM .EQ. 3) THEN
        CALL MESS(LPT,1,'3D Fourier required')
      ELSE IF (NDIM .EQ. 4) THEN
        CALL MESS(LPT,1,'Bounded sections of Fourier required')
      ELSE
        CALL ERRIN2(NDIM,2,'Number of dimensions on M NDIM card =',
     &  ' - only 2, 3 or 4 allowed')
      ENDIF
      GO TO 63
C
C M FTYP:
C READ 1 INTEGER GIVING TYPE OF FOURIER CALCULATION REQUIRED:
  32  CALL RDINTG(MODEF,IPT,IPT,80,IER)
      IF (MODEF .GE.1 .OR. MODEF .LT.8) GO TO 7
      CALL ERRIN2(MODEF,2,'Fourier type on M FTYP card =',
     & ' - only 1-7 allowed')
      GO TO 63
   7  WRITE (LPT,2003) MODEF
2003  FORMAT (/' Fourier type ',I3,' -')
      GO TO (21,22,23,24,25,26,27) , MODEF
C
  21  CALL MESS(LPT,0,'coeffs are F(cal)')
      GO TO 63
C
  22  CALL MESS(LPT,0,'coeffs are F(obs)')
      GO TO 63
C
  23  CALL MESS(LPT,0,'coeffs are mod(F(obs)*phase F(cal)')
      GO TO 63
C
  24  CALL MESS(LPT,0,'coeffs are F(obs)-F(cal)')
      GO TO 63
C
  25  CALL MESS(LPT,0,'coeffs are (mod(F(obs)-mod(F(cal))'//
     & ' * phase(F(cal))')
      GO TO 63
C
  26  CALL MESS(LPT,0,'coeffs are F(obs) sqrd '//
     & '(for Patterson function)')
      GO TO 63
C
  27  CALL MESS(LPT,0,'standard deviation of electron density')
      GO TO 63
C
C M MESH:
C READ 6 NUMBERS GIVING OUTPUT MESH IN X AND Y:
  33  DO 8 I=1,2
      DO 8 J=1,3
      CALL RDREAL(OUTLIM(J,I),IPT,IPT,80,IER)
      IF (IER .NE. 0 .AND. IER .NE. 100) IERR=IERR+1
   8  CONTINUE
   9  WRITE (LPT,2004) ((OUTLIM(I,J),I=1,3),J=1,2)
2004  FORMAT (/' Mesh for output of map is:  Initial     Final   Step'/
     & 2(26X,3F10.5/))
      GO TO 3
C
C M AXES:
C READ 9 INTEGERS  (OR 9 REALS) GIVING MATRIX TO TURN FOURIER MAP:
  34  IPKEEP=IPT
      DO 10 I=1,3
      DO 10 J=1,3
      CALL RDINTG(IU(J,I),IPT,IPT,80,IER)
C DETECT DECIMAL POINT:
      IF (IER .EQ. -1) GO TO 60
      IF (IER .NE. 0 .AND. IER .NE. 100) IERR=IERR+1
      U(J,I)=FLOAT(IU(J,I))
  10  CONTINUE
C
      WRITE (LPT,2005) IU
2005  FORMAT (/' Orientation matrix:'/3(4X,3I5/))
      MODET=1
      GO TO 3
C
C  HERE FOR GENERAL ORIENTATION
   60 IPT=IPKEEP
      DO 61 I=1,3
      DO 61 J=1,3
      CALL RDREAL(U(J,I),IPT,IPT,80,IER)
      IF (IER.NE.0 .AND. IER .NE.100) IERR=IERR+1
   61 CONTINUE
      WRITE (LPT,2020) U
 2020 FORMAT (/' General Fourier section with x parallel to',3F8.4/
     & 31X,'y         to',3F8.4/31X,'z         to',3F8.4)
      MODET=2
      GO TO 3
C
C M PRIN:
C READ PRINTING INSTRUCTIONS - A NUMBER OF Z VALUES (OR NOTHING) - MAY BE MORE
C THAN 1 CARD:
  35  IZKEEP=IZPR+1
C%
C      CALL RDNUMS(ZPRVAL(IZKEEP),IPT,%PRIN%,NUM,IER)
      CALL RDNUMS(ZPRVAL(IZKEEP),IPT,20,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZPR=IZPR+NUM
      IF (NUM .NE. 0) GO TO 3
      CALL MESS(LPT,1,'Print map')
      IZPR=1
      GO TO 3
C
C M PLOT:
C  READ NUMBER OF VALUES OF Z AT WHICH TO PLOT - MAY BE MORE THAN
C  ONE CARD:
  36  IZKEEP=IZPL+1
C%
C      CALL RDNUMS(ZPLVAL(IZKEEP),IPT,%PLOT%,NUM,IER)
      CALL RDNUMS(ZPLVAL(IZKEEP),IPT,20,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZPL=IZPL+NUM
      IF (NUM .NE. 0) GO TO 3
      CALL MESS(LPT,1,'Plot map')
      IZPL=1
      GO TO 3
C
C M CM/A - READ 1 REAL BEING THE SCALE OF PLOTTED MAPS IN CMS/ANGSTROM.
  37  CALL RDREAL(SCALMP,IPT,IPT,80,IER)
      IF (IER .NE. 0) IERR=IERR+1
      WRITE (LPT,2010) SCALMP
2010  FORMAT (/' Plot in',F10.4,' cms/Angstrom')
      GO TO 63
C
C M CONT - READ SOME CONTOURS TO PLOT - MAY BE MORE THAN 1 CARD:
  38  IZKEEP=NCONT+1
C%
C      CALL RDNUMS(CONT(IZKEEP),IPT,%CONT%,NUM,IER)
      CALL RDNUMS(CONT(IZKEEP),IPT,50,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      NCONT=NCONT+NUM
      IF (NUM .EQ. 0) GO TO 16
      CALL MESS(LPT,1,'Contour values')
      CALL PRILIS(CONT,IZKEEP,NCONT)
      GO TO 3
  16  CALL MESS(LPT,1,'No contours on card')
      GO TO 3
C
C M SAVE - READ Z VALUES IF GIVEN, AND KEEP INSTRUCTION TO DUMP
  39  IZKEEP=IZSV+1
C%
C      CALL RDNUMS(ZSVVAL(IZKEEP),IPT,%SAVE%,NUM,IER)
      CALL RDNUMS(ZSVVAL(IZKEEP),IPT,20,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZSV=IZSV+NUM
      IF (NUM .NE. 0) GO TO 3
      CALL MESS(LPT,1,'Save calculated map')
      IZSV=1
      GO TO 3
C
C M GET:
C READ NUMBER OF Z VALUES FOR WHICH MAPS REQUIRED TO BE GOT FROM SAVED FILE:
  44  IZKEEP=IZGT+1
C%
C      CALL RDNUMS(ZGTVAL(IZKEEP),IPT,%GETM%,NUM,IER)
      CALL RDNUMS(ZGTVAL(IZKEEP),IPT,20,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZGT=IZGT+NUM
      IF (NUM .GT. 0) THEN
        CALL MESS(LPT,1,
     &  'Undump previously calculated map for z values ')
        CALL PRILIS(ZGTVAL,IZKEEP,IZGT)
        GO TO 3
      ENDIF
      CALL MESS(LPT,1,'Undump previously calculated map')
      IZGT=1
      GO TO 3
C
C M READ:
C READ NUMBER OF Z VALUES FOR WHICH MAPS REQUIRED TO BE READ FROM BINARY:
  40  IZKEEP=IZRD+1
C%
C      CALL RDNUMS(ZRDVAL(IZKEEP),IPT,%READ%,NUM,IER)
      CALL RDNUMS(ZRDVAL(IZKEEP),IPT,20,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZRD=IZRD+NUM
      IF (NUM .GT. 0) THEN
        CALL MESS(LPT,1,'Read previously calculated map for z values ')
        CALL PRILIS(ZRDVAL,IZKEEP,IZRD)
        GO TO 3
      ENDIF
      CALL MESS(LPT,1,'Read previously calculated map')
      IZRD=1
      GO TO 3
C
C M DTYP:
C READ 1 INTEGER INTO MODED
  41  CALL RDINTG(MODED,IPT,IPT,80,IER)
      IF (IER .NE. 0 .AND. IER .NE. 100) IERR=IERR+1
      WRITE (LPT,2030) MODED
2030  FORMAT (/' Data input format type',I3)
      IF ((MODED .LT. 0) .OR. (MODED .GE. 5)) THEN
        CALL ERRMES(1,1,'Type is unacceptable')
        GO TO 63
      ENDIF
C
C MODED CHECKED OK - PRINT:
      GO TO (50,51,52,53,54) , MODED+1
C MODE 0 MEANS USER WILL SUPPLY INPUT ROUTINE TO READ OWN FORMAT:
  50  CALL MESS(LPT,0,'User to supply SUBROUTINE QFOUIN(K,F,ALPHA)'//
     & ' to read own format of data')
      GO TO 63
C
C MODES 1-4 AS IN MK2:
  51  CALL MESS (LPT,0,'h,k,l, F(cal), F(obs), possible Diff')
      GO TO 13
C
  52  CALL MESS(LPT,0,'h,k,l, mod F(cal), phase, F(obs)')
      GO TO 13
C
  53  CALL MESS(LPT,0,'h,k,l, A(cal), B(cal), F(obs)')
      GO TO 13
C
  54  CALL MESS(LPT,0,'h,k,l, F')
      GO TO 13
C
  13  CALL MESS(LPT,0,'In format 3I5,several F')
      GO TO 63
C
C M DELT:
C READ 1 REAL TO DELTA
  42  CALL RDREAL(DELTA,IPT,IPT,80,IER)
      D2=DELTA*2.
      WRITE (LPT,2011) D2
2011  FORMAT (/' Data to be averaged over a cube of edge ',F10.4)
      GO TO 63
C
C M SCAL:
C READ 1 REAL AS SCALE FACTOR TO APPLY TO INCOMING FOURIER COEFFICIENTS:
  43  CALL RDREAL(SCALF1,IPT,IPT,80,IER)
      IF (IER .NE. 0) IERR=IERR+1
      WRITE (LPT,2019) SCALF1
2019  FORMAT (/' Multiply Fourier coefficients by ',F10.4)
      GO TO 63
C
C M SMAX:
C READ SIN THETA/ LAMBDA MAXIMUM
  45  CALL RDREAL(SMAX,IPT,IPT,80,IER)
      IF (IER .NE. 0) IERR=IERR+1
      WRITE (LPT,2018) SMAX
2018  FORMAT (/' Maximum sin theta/lambda for this map =',F10.4)
      GO TO 63
C
C HERE AFTER ONE <WORD> <NUMBER> PAIR:
  63  CALL RDWORD(MWD,LEN,IPT,IPT,80,0,IER)
      IF (IER .NE. 100) GO TO 62
   3  CONTINUE
      IF (IZSV.NE.0) THEN
        IF (NDIM.EQ.4) THEN
          CALL MESS(LPT,1,'Save sections bounded by z values ')
          WRITE (LPT,2115) (ZSVVAL(I),I=1,IZSV)
2115      FORMAT ('+',33X,F8.4,' to',F8.4,/(34X,F8.4,' to',F8.4))
        ELSE
          CALL MESS(LPT,1,'Save calculated map at z values ')
          CALL PRILIS(ZSVVAL,IZKEEP,IZSV)
        ENDIF
      ENDIF
      IF (IZPL.NE.0) THEN
        IF (NDIM.EQ.4) THEN
          CALL MESS(LPT,1,'Plot sections bounded by z values ')
          WRITE (LPT,2115) (ZPLVAL(I),I=1,IZPL)
        ELSE
          CALL MESS(LPT,1,'Plot at z values ')
          CALL PRILIS(ZPLVAL,IZKEEP,IZPL)
        ENDIF
      ENDIF
      IF (IZPR.NE.0) THEN
        IF (NDIM.EQ.4) THEN
          CALL MESS(LPT,1,'Print sections bounded by z values ')
          WRITE (LPT,2115) (ZPRVAL(I),I=1,IZPR)
        ELSE
          CALL MESS(LPT,1,'Print at z values ')
          CALL PRILIS(ZPRVAL,IZKEEP,IZPR)
        ENDIF
      ENDIF
C
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE KANGA1(X,Y,MODE)
      SUBROUTINE KANGA1(X,Y,MODE)
C
C *** KANGA1 by JCM 24 Nov 83 ***
C
CX
CC 14C
CH Moves plotter pen (or equivalent) to X,Y in current coordinates.
CA On entry X,Y give the required destination of the pen.
CA          MODE indicates whether the pen is to be up or down while moving
CA          MODE=1 leaves pen in state it was last time
CA          MODE=2 lowers pen
CA          MODE=3 raises pen
CP Plotting must have been set up by, e.g., STPLOT.  In particular the
CP transformation PTRAN must be held in /PLTRAN to take current coordinates
CP into the basic hardware coordinates.
C
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
C
      M=MODE
C LEAVE M AS ONLY 2 OR 3, NOT 1, BECAUSE SPECIFIC PLOTTER SOFTWARE LIBRARIES
C MAY WELL NOT CATER FOR M=1:
      IF (M .EQ. 1) M=MPEN
      MPEN=M
C
C CONVERT CURRENT COORDINATES X,Y INTO PLOTTER'S COORDINATES X1,Y1:
      X1=X*PTRAN(1,1,1) + Y*PTRAN(1,2,1) + PTRAN(1,3,1)
      Y1=X*PTRAN(2,1,1) + Y*PTRAN(2,2,1) + PTRAN(2,3,1)
      CALL PIGLET(X1,Y1,M)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE KANGA2(X0,Y0,XF,ICHARS,NCHAR)
      SUBROUTINE KANGA2(X0,Y0,XF,ICHARS,NCHAR)
C
C *** KANGA2 updated by JCM 12 Nov 89 **
C
CX
CC 14C
CH Writes on a plot a string of characters, or simulates this in order
CH to measure the length of the string.
CA On entry ICHARS is a character string
CA          NCHAR is the number of characters in ICHARS;  if NCHAR is given
CA                negatively, KANGA2 goes through the motions of writing but
CA                does not actually plot anything.  This facility is for
CA                measuring strings.
CA          X0, Y0 give where, in the current (character) space, to start
CA                 writing (i.e. the bottom left hand side of the first letter)
CA On exit XF has been updated to be the X position for the "next" character,
CA                 it is adjusted (by the subtraction of X0) so that it is the
CA                 length of the string in character units.
C
CP Plotting must have already been set up by, e.g., STPLOT, and we must
CP already be in "character" space, though this may be of one of various
CP types of character previously set up.
C
CD Instructions to plot the characters are held in the array LINES.
CD A character is described on a 30 by 30 grid.  The X direction is numbered
CD 0 to 30 (including both ends), but the Y direction is -8 to 22.  The line
CD on which the character looks to be written is thus the X axis.  Lower case
CD letters with descenders use the 0 to -8 range.
CD
CD The array LINES holds for each character in turn:
CD     First element = width of character as an integer (in character coords)
CD     Subsequent elements are instructions, packed one per element.  If MPACK
CD     is an instruction, then its sign says whether pen should be up or down
CD     (+ve=up, -ve=down) and the modulus of MPACK is X*32 + Y+8 (where this
CD     is an instruction to move to (X,Y).)
C
CN The character # (hash) is a special character, signalling that the
CN one character which follows it is in a special alphabet (so far, Greek,
CN and so far only theta and lambda allowed, requested by #T and #L)
CN
CN Unidentifiable characters are converted to spaces.
C
      CHARACTER *80 ICHARS
      CHARACTER *1 IALCHR
      LOGICAL GREEK
      DIMENSION IALCHR(84),ITBLCH(96),LINES(1030),LINE1(130),LINE2(130)
      DIMENSION LINE3(130),LINE4(130),LINE5(130),LINE6(130),LINE7(130)
      DIMENSION LINE8(82)
      COMMON /CHARS/LETUP(26),LETLOW(26),ISPCE,IDIGIT(10),ISMBOL(21)
      CHARACTER *1 LETUP,LETLOW,ISPCE,IDIGIT,ISMBOL
      EQUIVALENCE (IALCHR(1),LETUP(1)),(LINE1(1),LINES(1))
      EQUIVALENCE (LINE2(1),LINES(131)),(LINE3(1),LINES(261))
      EQUIVALENCE (LINE4(1),LINES(391)),(LINE5(1),LINES(521))
      EQUIVALENCE (LINE6(1),LINES(651)),(LINE7(1),LINES(781))
      EQUIVALENCE (LINE8(1),LINES(911))
      DATA ITBLCH/1,8,30,49,64,73,80,102,109,112,123,130,135,
     & 144,151,173,186,210,225,246,251,262,267,276,281,287,
     & 294,311,328,343,360,378,386,408,418,426,437,444,447,
     & 464,474,492,509,526,534,552,560,570,575,584,589,598,
     & 605,606,611,626,642,648,666,690,695,725,749,767,773,
     & 782,793,807,815,835,838,843,868,871,882,893,896,899,
     & 904,909,916,925,960,964,968,968,968,968,968,968,968,968,
     & 988,988,988,993/
      DATA LINE1/18,317,-40,317,-552,143,-463,21,157,-136,157,-445,-540,
     & -571,-601,-599,-565,-532,-435,147,-435,-530,-561,-591,-588,-554,
     & -521,-424,-136,21,600,-570,-508,-445,-317,-252,-186,-152,-117,
     & -112,-141,-171,-233,-296,-424,-489,-555,-589,21,157,-136,157,
     & -381,-476,-538,-568,-597,-592,-557,-523,-457,-360,-136,19,157,
     & -136,157,-573,147,-403,136,-552,18,157,-136,157,-573,147,
     & -403,21,600,-570,-508,-445,-317,-252,-186,-152,-117,-112,-141,
     & -171,-233,-296,-424,-489,-555,-589,-592,432,-592,22,157,-136,
     & 605,-584,147,-595,8,157,-136,16,413,-397,-362,-329,-264,
     & -200,-137,-106,-77,-79,21,157,-136,605,-143,308,-584,17/
      DATA LINE2/157,-136,136,-520,24,157,-136,157,-392,669,-392,669,
     & -648,22,157,-136,157,-584,605,-584,22,317,-252,-186,-152,-117,
     & -112,-141,-171,-233,-296,-424,-489,-555,-589,-624,-629,-600,-570,
     & -508,-445,-317,21,157,-136,157,-445,-540,-571,-601,-598,-564,
     & -531,-434,-146,22,317,-252,-186,-152,-117,-112,-141,-171,-233,
     & -296,-424,-489,-555,-589,-624,-629,-600,-570,-508,-445,-317,396,
     & -582,21,157,-136,157,-445,-540,-571,-601,-599,-565,-532,-435,
     & -147,371,-584,20,570,-508,-413,-285,-188,-122,-120,-150,-181,
     & -244,-434,-497,-528,-558,-555,-489,-392,-264,-169,-107,16,285,
     & -264,61,-509,22,157,-142,-171,-233,-328,-392,-489,-555,-590/
      DATA LINE3/-605,18,61,-296,573,-296,24,93,-232,413,-232,413,
     & -552,733,-552,20,125,-552,573,-104,18,61,-307,-296,573,-307,
     & 20,573,-104,125,-573,104,-552,19,502,-488,499,-437,-374,
     & -278,-213,-147,-112,-110,-139,-201,-264,-360,-425,-491,19,157,
     & -136,147,-213,-278,-374,-437,-499,-528,-526,-491,-425,-360,-264,
     & -201,-139,18,499,-437,-374,-278,-213,-147,-112,-110,-139,-201,
     & -264,-360,-425,-491,19,509,-488,499,-437,-374,-278,-213,-147,
     & -112,-110,-139,-201,-264,-360,-425,-491,18,112,-496,-498,-468,
     & -437,-374,-278,-213,-147,-112,-110,-139,-201,-264,-360,-425,-491,
     & 12,349,-285,-220,-185,-168,86,-310,19,502,-486,-451,-418/
      DATA LINE4/-353,-257,-194,499,-437,-374,-278,-213,-147,-112,-110,
     & -139,-201,-264,-360,-425,-491,19,157,-136,146,-245,-310,-406,
     & -469,-498,-488,8,125,-156,-189,-158,-125,150,-136,10,189,-220,
     & -253,-222,-189,214,-197,-162,-97,-33,17,157,-136,470,-140,272,
     & -488,8,157,-136,30,150,-136,146,-245,-310,-406,-469,-498,
     & -488,498,-597,-662,-758,-821,-850,-840,19,150,-136,146,-245,
     & -310,-406,-469,-498,-488,19,278,-213,-147,-112,-110,-139,-201,
     & -264,-360,-425,-491,-526,-528,-499,-437,-374,-278,19,150,-129,
     & 147,-213,-278,-374,-437,-499,-528,-526,-491,-425,-360,-264,-201,
     & -139,19,502,-481,499,-437,-374,-278,-213,-147,-112,-110,-139/
      DATA LINE5/-201,-264,-360,-425,-491,13,150,-136,144,-179,-245,
     & -310,-406,17,467,-437,-342,-246,-149,-115,-145,-208,-367,-430,
     & -460,-459,-425,-328,-232,-137,-107,12,189,-172,-201,-264,-328,86,
     & -310,19,150,-140,-169,-232,-328,-393,-492,502,-488,16,86,-264,
     & 470,-264,22,118,-232,374,-232,374,-488,630,-488,17,118,
     & -456,470,-104,16,86,-264,470,-264,-196,-130,-65,-33,17,
     & 470,-104,118,-470,104,-456,16,20,217,-282,-381,-360,20,
     & 152,-153,-187,-220,-285,-413,-476,-507,-537,-535,-501,-434,-104,
     & -552,20,189,-541,-341,-437,-500,-531,-560,-558,-523,-457,-360,
     & -264,-169,-138,-108,20,445,-111,-591,445,-424,20,509,-189/
      DATA LINE6/-148,-181,-278,-374,-469,-531,-560,-558,-523,-457,
     & -360,-264,-169,-138,-108,20,538,-508,-413,-349,-252,-185,-148,
     & -143,-171,-233,-328,-360,-457,-523,-558,-559,-530,-468,-373,
     & -341,-244,-178,-143,20,573,-232,125,-573,20,285,-188,-154,-152,
     & -182,-245,-372,-467,-529,-559,-556,-522,-489,-392,-264,-169,
     & -138,-108,-111,-145,-211,-308,-437,-502,-536,-538,-508,-413,-285,
     & 20,534,-499,-433,-336,-304,-209,-147,-118,-119,-154,-220,-317,
     & -349,-444,-506,-534,-529,-492,-425,-328,-264,-169,-139,20,317,
     & -220,-153,-116,-113,-140,-201,-296,-360,-457,-524,-561,-564,-537,
     & -476,-381,-317,10,170,-137,-168,-201,-170,10,201,-168,-137,-170,
     & -201,-199,-165/
      DATA LINE7/-132,10,182,-149,-180,-213,-182,170,-137,-168,-201,
     &-170,10,182,-149,-180,-213,-182,201,-168,-137,-170,-201,-199,-165,
     & -132,10,189,-175,170,-137,-168,-201,-170,18,120,-121,-155,-188,
     & -253,-381,-444,-475,-505,-503,-469,-436,-306,-303,298,-265,-296,
     & -329,-298,8,157,-150,16,157,-150,413,-406,20,286,-262,
     & 414,-390,570,-508,-413,-285,-188,-122,-120,-150,-181,-244,-434,
     & -497,-528,-558,-555,-489,-392,-264,-169,-107,22,670,-68,14,
     & 318,-285,-252,-184,-147,-143,-170,-230,-261,-292,14,190,-221,
     & -252,-312,-339,-335,-298,-230,-197,-164,8,158,-131,26,145,
     & -721,26,442,-424,145,-721,26,148,-724,142,-718,16,279/
      DATA LINE8/-267,116,-430,436,-110,21,382,-131,574,-323,148,-596,
     &110,-558,26,756,-757,-726,-694,-661,-627,-558,-491,-425,-360,-232,
     & -169,-138,-108,-110,-144,-177,-405,-438,-472,-474,-444,-381,-316,
     & -282,-280,-309,-370,-523,-585,-648,-712,-745,-746,26,734,-19,
     & -30,26,30,-723,-8,20,317,-220,-153,-116,-113,-140,-201,-296,
     & -360,-457,-524,-561,-564,-537,-476,-381,-317,115,-563,22,
     & 286,-648,404,-136/
C
C SET NOT IN FUNNY CHARACTER SET:
      GREEK=.FALSE.
C
C XF FOLLOWS CHARACTERS ALONG LINE:
      XF=X0
C
      IF (NCHAR .EQ. 0) GO TO 100
      MODNC=IABS(NCHAR)
      DO 1 I=1,MODNC
C
C IDENTIFY CHARACTER  - IF UNKNOWN TO TABLES, SET SPACE (NUMBER 53)
      DO 2 J=1,84
      IF (IALCHR(J) .EQ. ICHARS(I:I)) GO TO 3
   2  CONTINUE
      J=53
C
C IF HASH, SET THAT NEXT CHARACTER WILL BE IN FUNNY SET:
   3  IF (J .NE. 81) GO TO 6
      GREEK=.TRUE.
      GO TO 1
C
C ARE WE ALREADY IN FUNNY CHARACTER SET?
   6  IF (.NOT. GREEK) GO TO 7
      GREEK=.FALSE.
      IF (J .EQ. 46) J=92
      IF (J .EQ. 38) J=95
C J=WHICH CHARACTER - SET K=START OF ITS INSTRUCTIONS IN ARRAY LINES
   7  K=ITBLCH(J)
      L=ITBLCH(J+1)
C IF ONLY MEASURING, NO NEED TO UNPACK INSTRUCTIONS:
      IF (NCHAR .LT. 0) GO TO 4
C
C WITH M SCAN EACH PACKED INSTRUCTION FOR THIS CHARACTER
      M=K+1
   5  IF (M .GE. L) GO TO 4
      MPACK=LINES(M)
      IPEN=2
      IF (MPACK .GT. 0) IPEN=3
      MP=IABS(MPACK)
      M1=MP/32
      M2=MP-M1*32-8
      X=FLOAT(M1)+XF
      Y=FLOAT(M2)+Y0
      CALL KANGA1(X,Y,IPEN)
      M=M+1
      GO TO 5
C
C CHARACTER WRITTEN - ADJUST XF
   4  XWIDE=FLOAT(LINES(K))
      XF=XF+XWIDE
   1  CONTINUE
      XF=XF-X0
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE KANGA3(X,Y,SIZE,MSYM)
      SUBROUTINE KANGA3(X,Y,SIZE,MSYM)
C
C *** KANGA3 updated by PJB 23 May 90 ***
C
CX
CC 14C
CH Plots a special symbol.
CA On entry X,Y give the position in current coordinates of the CENTRE of the
CA              symbol.  The current space will usually be graph or map space.
CA          MSYM is negative if the symbol should be "filled in";
CA               its absolute value indicates which symbol is required:
CA          MSYM=1   square
CA          MSYM=2   triangle, apex up
CA          MSYM=3   triangle, apex down
CA          MSYM=4   hexagon (which if drawn small will make a circle)
CA          MSYM=5   cross like X
CA          MSYM=6   cross like +
CA          MSYM=7   cross like X with top and bottom (egg-timer)
CA          MSYM=8   cross like X with sides (butterfly)
CA          MSYM=9   diamond
CA                   The symbols are "the right way up" for CCSL space.
CA On entry SIZE is set so that the symbol is drawn within a notional square
CA               of side SIZE cms. (Cms are CCSL units).
CP Plotting must be set up by, e.g., STPLOT, and a suitable space set by SPCSET
C
CN This is distinct from KANGA2, which can also draw symbols if they can
CN be represented as A1 characters, but expects them to be part of a
CN sentence, and draws them on a 30 x 30 character space grid with origin
CN at a point part way up the left hand side.  KANGA3 centres the symbol.
C
      LOGICAL SOLID,FOUND
      DIMENSION SMPTS(2,12),MLINE(43),MPOINT(10),S(8),C(8)
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
      DATA SMPTS/-2.,2.,2.,2.,2.,-2.,-2.,-2.,-2.,0.,0.,2.,2.,0.,0.,
     & -2.,-2.,-1.,-2.,1.,2.,1.,2.,-1./
      DATA MPOINT/1,6,10,14,21,25,29,34,39,44/
      DATA MLINE/1,-2,-3,-4,-1,9,-6,-12,-9,8,-10,-11,-8,6,-11,
     & -12,-8,-9,-10,-6,1,-3,2,-4,6,-8,5,-7,1,-2,-4,-3,-1,1,-4,-2,
     & -3,-1,6,-7,-8,-5,-6/

C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C
      S4=SIZE/4.
C
      MSYMB=IABS(MSYM)
      SOLID=(MSYM.LT.0 .AND. (MSYMB.GT.-5 .OR. MSYMB.EQ.-9))
      IF (SOLID) THEN
        YSTEP=1./(100.*S4)
        XMIN=0.
        XMAX=0.
        YMIN=0.
        YMAX=0.
      ENDIF
C
      GO TO (2,3,3,3,2,4,2,2,4) ,MSYMB
C
C TIMES 1 OVER ROOT 2:
   2  S4=S4*0.7071
      GO TO 4
C
C TIMES ROOT 3 OVER 2:
   3  S4=S4*0.8660
C CONVERT POINT AT SYMBOL CENTRE TO BE IN PLOTTER SPACE:
   4  CALL PLCONV(X,Y,0,X0,Y0,1)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C MAKE UNIT VECTORS IN BOTH DIRECTIONS IN PLOTTER SPACE:
      CALL PLCONV(0.,0.,2,XX0,YY0,1)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
      CALL PLCONV(S4,0.,2,XX1,YY1,1)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
      CALL PLCONV(0.,S4,2,XX2,YY2,1)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      XX1=XX1-XX0
      YY1=YY1-YY0
      XX2=XX2-XX0
      YY2=YY2-YY0
      K=MPOINT(MSYMB)
      L=MPOINT(MSYMB+1)-1
      DO 1 I=K,L
      M=MLINE(I)
      MPEN=2
      IF (M .GT. 0) MPEN=3
      M=IABS(M)
      XIN=SMPTS(1,M)*XX1+SMPTS(2,M)*XX2+X0
      YIN=SMPTS(1,M)*YY1+SMPTS(2,M)*YY2+Y0
      CALL PIGLET(XIN,YIN,MPEN)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      IF (SOLID .AND. I.LT.L) THEN
        J=I+1
        IF (SMPTS(1,M).GT.XMAX) XMAX=SMPTS(1,M)
        IF (SMPTS(1,M).LT.XMIN) XMIN=SMPTS(1,M)
        IF (SMPTS(2,M).GT.YMAX) YMAX=SMPTS(2,M)
        IF (SMPTS(2,M).LT.YMIN) YMIN=SMPTS(2,M)
C GET SLOPES AND INTERCEPTS OF LINES JOINING POINTS
        MM=IABS(MLINE(J))
        DEN=(SMPTS(2,MM)-SMPTS(2,M))
        IF (ABS(DEN).LT.10E-6) THEN
          S(I-K+1)=1.1*10E6
        ELSE
          S(I-K+1)=(SMPTS(1,MM)-SMPTS(1,M))/DEN
          C(I-K+1)=(SMPTS(2,MM)*SMPTS(1,M)-SMPTS(2,M)*SMPTS(1,MM))
     &     /DEN
        ENDIF
      ENDIF
    1 CONTINUE
      IF (SOLID) THEN
        NY=IFIX((YMAX-YMIN)/YSTEP)
        MPEN=3
        YPT=YMIN
C FIND THE SMALLEST POSITIVE X ON AN EDGE
        DO 5 IY=1,NY
        YPT=YPT+YSTEP
        FOUND=.FALSE.
        XP=XMAX
        DO 6 I=1,L-K
        IF (S(I).GT.10.E6) GO TO 6
        XPT=YPT*S(I)+C(I)
        IF (XPT.GT. 0. .AND. XPT.LT.XP) XP=XPT
   6    CONTINUE
C USE THE SYMMETRY ABOUT X=0
          XIN=-XP*XX1+YPT*XX2+X0
          YIN=-XP*YY1+YPT*YY2+Y0
          CALL PIGLET(XIN,YIN,MPEN)
          MPEN=2
          XIN=XP*XX1+YPT*XX2+X0
          YIN=XP*YY1+YPT*YY2+Y0
          CALL PIGLET(XIN,YIN,MPEN)
	    IF (IBMBER .NE. 0) RETURN
   5    CONTINUE
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE LOCBIT(I,J,NR,NC,ISIDE,M,N)
      SUBROUTINE LOCBIT(I,J,NR,NC,ISIDE,M,N)
C
C *** LOCBIT by JCM 24 Nov 83 ***
C
CX
CC 15C
CH A specialist routine for contour plotting, which finds the "next" bit in
CH the bit-map, removes it, and indicates where on the picture it was.
CA On entry I=which bit within a word in the bit-map,
CA          J=which word in the bit-map
CA          M,N give the size of the bit-map
CA On exit ISIDE=1,2,3 or 4 to indicate side of picture,
CA         NR,NC are set to indicate the top left of the relevant square.
CD Finds whether the indicated bit is 0 or 1, and in any case removes it.
CP The bit-map must be set up in IBIT in /BITMAP/
CP NBITS must be set up as at most the number of bits in an integer.
C
      COMMON /BITMAP/IBIT(108,4),NWORDS
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /LENINT/NBITS

C
      IF (J .GT. NWORDS) THEN
        WRITE (LPT,3000) J,NWORDS
        WRITE (ITO,3000) J,NWORDS
3000    FORMAT (' ERROR ** IN LOCBIT - INTEGER',I4,' CALLED FOR, ',
     &  ' BUT ONLY',I4,' AVAILABLE')
C>> Was STOP
        CALL BMBOUT
	  RETURN
      ENDIF
C
      ISIDE = I
      IF (I .GT. 4) ISIDE = 1
      MM=1
      IB=1
   5  IF (LOGAND(IBIT(I,J),MM) .NE. 0) GO TO 6
      MM=MM*2
C NB IF THIS GIVES INTEGER OVERFLOW, REDUCE THE VALUE OF NBITS IN COMMON
C CONTUR SO THAT THE SIGN BIT OF AN INTEGER IS NOT USED
      IB=IB+1
      GO TO 5
   6  IBIT(I,J)=IBIT(I,J)-MM
      GO TO(1,2,3,4),ISIDE
    1 NR = I
      IF (I .GT. 4) NR = I-3
      NC = (J-1)*NBITS +IB
      GO TO 100
    2 NC = N-1
      NR = (J-1)*NBITS + IB
      GO TO 100
    3 NR = M-1
      NC = N - (J-1)*NBITS - IB
      GO TO 100
    4 NC = 1
      NR = M - (J-1)*NBITS - IB
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE MAJUST
      SUBROUTINE MAJUST
C
C *** MAJUST updated by JCM May 88 ***
C
CC 5A
CH A specialist routine used in the input of the Crystal Data File needing
CH previously stored Fourier maps.
CD MAJUST is called from PREFIN, on discovering that the user has given an
CD "M GET" card.  It adjusts file IO10 so that it contains mainly cards from the
CD previously dumped run (to be found on named file), updated to include
CD any new "M" cards presented for this run.  The rule for "M" cards belonging
CD to the "old" and "new" sets is:
CD   take only new cards for PRIN, PLOT, SAVE and GET;
CD   take only old cards for NDIM, FTYP, MESH, DTYP, DELT, SCAL, SMAX and AXES.
CD   For CM/A and CONT:
CD     if the card type occurs in "old" but not "new", accept it
CD     if card type occurs in "new" but not "old", accept it
CD     if card type occurs in both, accept the "new" only.
CD Also takes a new "N" card, unless there is only an old one.
C
CN All the cards capable of being telescoped happen to occur in the "take only
CN old" category, so should not pose a problem by hiding something other than
CN in columns 3-6, but - care will be needed with any newly defined cards.
C
C
      LOGICAL NONEWN
      CHARACTER *4 MWORD,MTBL1(8),MTBL2(4),MNEW(20)
      CHARACTER *80 MCARD(20),NEWNCD
      CHARACTER *10 FILNOM
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      DATA MTBL1/'NDIM','FTYP','MESH','AXES','DELT','SCAL',
     & 'SMAX','DTYP'/
      DATA MTBL2/'PRIN','PLOT','SAVE','GET'/
C
C
C IF THERE IS A NEW 'N' CARD, SAVE IT:
      NONEWN=.TRUE.
      IF (ICDNO(14) .EQ. 0) GO TO 16
      CALL CARDIN(IABS(INREAD(14)))
      NEWNCD=ICARD
      NONEWN=.FALSE.
C
C SAVE NEW M CARDS FOR CONT, CM/A,  PRIN, PLOT, READ OR SAVE:
   16 NEWMC=ICDNO(13)
      MSTART=INREAD(13)
      J=0
      ID=IABS(MSTART)
      DO 1 I=1,NEWMC
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(MWORD,ITEMP1,3,ITEMP2,80,0,IER)
C IGNORE IF ONE OF NDIM, AXES, MESH, FTYP, DTYP, DELT, SCAL, SMAX:
      DO 10 K=1,8
      IF (MWORD .EQ. MTBL1(K)) GO TO 1
  10  CONTINUE
      J=J+1
      MCARD(J)=ICARD
      MNEW(J)=MWORD
   1  CONTINUE
C RESET NUMBER OF NEW M CARDS:
      NEWMC=J
C
C COPY CARDS FROM UNIT IDUMPG, UNFORMATTED, ADDING NEW M CARDS:
      MESSAG='File containing saved Fourier '
      NAMFIL='.SAV'
      CALL OPNFIL(IDUMPG,1111)
      INEW=1
C RESTORE OLD VALUES FOR ARRAYS OF COUNTS AND START POINTERS FOR CARDS:
      READ (IDUMPG) INREAD,ICDNO,NCDS
C ENSURE ALL POINTERS INITIALISED POSITIVE:
      DO 2 I=1,26
   2  INREAD(I)=IABS(INREAD(I))
C
C COPY CARDS ACROSS FROM IDUMPG TO IO10 NOTING WHEN M BLOCK REACHED:
      I=0
      LET=-1
   3  I=I+1
      IF (I .GT. NCDS) GO TO 101
      READ(IDUMPG) ICARD
  14  LETNEW=LETTER(ICARD(1:1))
      IF (LETNEW .EQ. LET) GO TO 5
C
C NEW BATCH - ADJUST STARTING POINTER:
      INREAD(LETNEW)=INEW
      LET=LETNEW
C NOTE WHEN ABOUT TO DEAL WITH M CARDS, AND JUMP:
      IF (I .EQ. INREAD(13)) GO TO 4
C
C WRITE OUT CARD OTHER THAN ONE STARTING "M":
   5  INEW=INEW+1
C IF ABOUT TO WRITE AN 'N' CARD, SEE IF THERE IS A NEW ONE:
      IF (ICARD(1:1) .NE. 'N') GO TO 15
      IF (NONEWN) GO TO 15
      ICARD=NEWNCD
  15  WRITE (IO10,2000) ICARD
2000  FORMAT (A80)
C COUNT AS THOUGH A "DO" LOOP OVER I (BUT ALLOWING FOR MOVING I FURTHER DOWN)
      GO TO 3
C
C HERE ON FIRST OLD "M" CARD - SCAN ALL OLD CARDS:
   4  MEND=ICDNO(13)
      DO 6 K=1,MEND
      CALL RDWORD(MWORD,ITEMP1,3,ITEMP2,80,0,IER)
C REFUSE TO COPY PRIN, PLOT, SAVE, GET:
      DO 12 II=1,4
      IF (MWORD .EQ. MTBL2(II)) GO TO 9
  12  CONTINUE
C
C INSIST ON COPYING NDIM, AXES, FTYP, MESH:
      DO 13 II=1,4
      IF (MWORD .EQ. MTBL1(II)) GO TO 8
  13  CONTINUE
C
C THIS LEAVES CONT AND CM/A;  ONLY COPY IF THEY ARE OLD BUT NOT NEW:
      DO 7 J=1,NEWMC
      IF (MWORD .EQ. MNEW(J)) GO TO 9
   7  CONTINUE
C
C OLD CARD STILL WANTED:
   8  INEW=INEW+1
      WRITE (IO10,2000) ICARD
C
C OLD CARD OCCURS AGAIN IN NEW SET - DISCARD OLD:
C COUNT INPUT OLD CARDS
   9  I=I+1
      IF (I .GT. NCDS) GO TO 101
      READ(IDUMPG) ICARD
   6  CONTINUE
C
C END OF SCANNING OLD M CARDS - NOW ADD ALL NEW ONES:
      DO 11 K=1,NEWMC
      INEW=INEW+1
  11  WRITE (IO10,2000) MCARD(K)
      ICDNO(13)=INEW-INREAD(13)
      GO TO 14
C
 101  IF (ICDNO(14) .NE. 0 .OR. NONEWN) GO TO 100
      INREAD(14) = INEW
      INEW=INEW+1
      WRITE (IO10,2000) NEWNCD
      ICDNO(14)=1
 100  WRITE (LPT,2001) FILNOM(IDUMPG)
2001  FORMAT (/' "M GET" card given;  crystal data read from ',
     & A10,' and given relevant new M cards')
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE MAKEBM(I,A,C,M,N)
      SUBROUTINE MAKEBM(I,A,C,M,N)
C
C *** MAKEBM by JCM 24 Nov 82 ***
C
CX
CC 15C
CH A specialist contour plotting routine which makes a bit map to show where
CH the contours are.
C
      LOGICAL ABOVE,ABVE,TEST
      DIMENSION A(M,N)
      IC=1
      IR=0
      NB=N-1
      NR=I-3
      NC=1
      IF (NR .GT. 1) GO TO 6
      GO TO (1,2,3,4), I
   1  NR=1
      GO TO 6
   2  NR=1
      NC=N
      IR=1
      GO TO 5
   3  NR=M
      NC=N
      IC=-1
      GO TO 6
   4  NR=M
      NC=1
      IR=-1
   5  IC=0
      NB=M-1
   6  ABOVE = A(NR,NC) .GE. C
      DO 10 IB=1,NB
      NR = NR + IR
      NC = NC + IC
      ABVE = A(NR,NC) .GE. C
      IF (ABOVE .AND. ABVE .OR. .NOT.(ABOVE .OR. ABVE)) GO TO 10
      ABOVE = ABVE
      CALL BITSET (I,IB,TEST,.TRUE.)
  10  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MAPCON(CFOUND,IC,IBMAX,IFMAX)
      SUBROUTINE MAPCON(CFOUND,IC,IBMAX,IFMAX)
C
C *** MAPCON by JCM 22 Aug 86 ***
C
CX
CC 5B
CH After a Fourier map has been plotted, sends to the plotter the list of
CH contours which were plotted, with a frame.
C
CA On entry CFOUND is a real array containing the contour values to write,
CA          IC is the number of elements in CFOUND,
CA          IBMAX and IFMAX are handed over to indicate general size of numbers.
C
CP STPLOT shuld set this up, and MPPLOT should call it, having made the list
C
      DIMENSION CFOUND(IC),PTEMP(2,3)
      CHARACTER *8 NUMBUF
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C WRITE CONTOUR LIST IF ANY FOUND:
C IF VALUES SO WIDELY DIFFERENT THAT COULD NOT ALL BE WRITTEN, EXIT:
      IF (IBMAX .GT. 8) GO TO 100
C BLACK PEN AGAIN:
      CALL PIGLET(0.,0.,-1)
C>> JCC Added
	IF (IBMBER .NE.0) RETURN
C NOW CHARACTER TYPE 3 - CONTOUR LIST PANEL - WE KNOW THIS TO BE 10 CHARS WIDE:
C WE NOW KNOW SIZE OF LIST - IC NUMBERS PLUS A TITLE:
      A=FLOAT(IC+1)*2.*CHUNIT
      CHSCAL(2,3)=(HGTMAP+5.*YWHITE+HGTTXT)/A
C DO NOT ALLOW TYPE 3 TO BECOME LARGER THAN TYPE 1:
      IF (CHSCAL(2,3) .GT. CHSCAL(2,1)) CHSCAL(2,3)=CHSCAL(2,1)
      CHSCAL(1,3)=CHSCAL(2,3)/ASPECT
C A DIGIT IS 20 PLOTTER UNITS WIDE:
      WIDCON=220.*CHSCAL(1,3)
      HGTCON=A*CHSCAL(2,3)
C
C PUT IN PLACE THE TRANSFORMATION FOR CHARACTER TYPE 3:
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,3)
      PTEMP(2,2)=CHSCAL(2,3)
      PTEMP(1,3)=WIDPIC-XMARG-WIDCON
      PTEMP(2,3)=(PMTRIX(2,3,3)+YMARG-HGTCON)/2.
      CALL PLTRIN(PTEMP,7,3)
C>> JCC Added
	IF (IBMBER .NE.0) RETURN
C
C SET CHARACTER TYPE 3 SPACE:
      CALL SPCSET(7)
C>> JCC Added
	IF (IBMBER .NE.0) RETURN
      CALL FRAME(0.,0.,220.,A)
      B=A-2.*CHUNIT
      CALL KANGA1(0.,B,3)
      CALL KANGA1(220.,B,2)
C WRITE 'CONTOURS'
      CALL KANGA2(CHUNIT,B+CHUNIT/2.,TEMP,'CONTOURS',8)
C
C SELECT FIELD WIDTH:
      IBMAX=IBMAX+IFMAX
      IF (IFMAX .EQ. 0) IBMAX=IBMAX-1
      IW=IBMAX/2 + 4
      IF (IW .GT. 8) IFMAX=IFMAX-IW+8
C
C LIST VALUES PLOTTED:
      B=B+CHUNIT/2.
      DO 5 I=1,IC
      B=B-2.*CHUNIT
      CALL NUMA1(CFOUND(I),IW,IFMAX,8,NUMBUF)
   5  CALL KANGA2(CHUNIT,B,TEMP,NUMBUF,8)
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE MAPDRW(CFOUND,IC,IBMAX,IFMAX)
      SUBROUTINE MAPDRW(CFOUND,IC,IBMAX,IFMAX)
C
C *** MAPDRW by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Draws an unframed contour map, in predetermined place.
C
CA On exit CFOUND is a real array which holds all the found contour values.
CA         IC is the number of found contours.
CA         IBMAX and IFMAX are sensible sizes for later contour list printing.
C
CP STPLOT must have set up the map contouring
C
      LOGICAL MORE,FOUND
C%
C      DIMENSION CFOUND(%CONT%)
      DIMENSION CFOUND(50)
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
C>> JCC Implement error handling
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C SET MAP SPACE:
      CALL SPCSET(4)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
C INITIALISE IC=COUNT OF FOUND CONTOURS, IBMAX AND IFMAX WHICH CONTROL THE
C DETAILS OF PRINTING THE CONTOUR LIST, AND ICON WHICH COUNTS CONTOURS SOUGHT:
      IC=0
      IBMAX=0
      IFMAX=0
      ICON=0
      MORE=.TRUE.
C
C NEXT CONTOUR:
   1  CALL NEXCON(C,ICON,MORE)
      IF (.NOT. MORE) GO TO 100
      CALL PLOTCT(C,DENS,FOUND,NX,NY)
C>> JCC Added
	IF (IBMBER .NE.0) RETURN
      IF (.NOT. FOUND) GO TO 3
C
C CONTOUR FOUND - KEEP:
      IC=IC+1
      CFOUND(IC)=C
C ADJUST IFMAX AND IBMAX SO THAT THE RESULTING LIST LOOKS NICE:
      CALL FETTLE(C,IF1,IF2)
      IB=IF1-IF2
      IF (IF2 .EQ. 0) IB=IB+1
      IF (IB .GT. IBMAX) IBMAX=IB
      IF (IF2 .GT. IFMAX) IFMAX=IF2
      WRITE (LPT,2000) C
2000  FORMAT (' Contour at',F12.4,' drawn')
      IF (NCONT .EQ. 0) WRITE(ITO,2000) C
C%
C      IF (IC .GE. %CONT%) GO TO 100
      IF (IC .GE. 50) GO TO 100
C
C JOIN IF REQUESTED CONTOUR NOT FOUND:
   3  MORE=FOUND
C BACK FOR NEXT CONTOUR VALUE:
      GO TO 1
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MAPFRA
      SUBROUTINE MAPFRA
C
C *** MAPFRA by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Draws a black frame round a potential contoured map, adding the labels
CH X Y and a 1A scale.
C
CP Needs to be set up within a whole picture by STPLOT
C
CO Causes (possibly skew) frame to be drawn via PIGLET, with labels X and
CO Y (and therefore implicit origin), and a one-angstrom scale underneath.
C
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP

C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C MOVE INTO MAP SPACE:

      CALL SPCSET(4)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
C BLACK PEN:
      CALL PIGLET(0.,0.,-1)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
C DRAW FRAME ROUND MAP:
      FX=FLOAT(NX-1)
      FY=FLOAT(NY-1)
      CALL FRAME(0.,0.,FX,FY)
C
C POSITIONS FOR 'X' AND 'Y' LABELS:
      CALL PLCONV(FX/2.,0.,4,X1,X2,5)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
      CALL PLCONV(0.,FY/2.,4,Y1,Y2,5)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
C POSITION FOR 1 ANGSTROM LINE, IN BOTH CHARACTER 1 AND PICTURE COORDS:
      CALL PLCONV(FX,FY/2.,4,C1,C2,5)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
      CALL PLCONV(FX,FY/2.,4,P1,P2,3)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
C
C BRIEF SOJURN IN PICTURE SPACE TO DRAW 1 ANGSTROM LINE:
      CALL SPCSET(3)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
      CALL KANGA1(P1-SCALMP/2.,P2-YWHITE*1.5,3)
      CALL KANGA1(P1-SCALMP/2.,P2-YWHITE*2.,2)
      CALL KANGA1(P1+SCALMP/2.,P2-YWHITE*2.,2)
      CALL KANGA1(P1+SCALMP/2.,P2-YWHITE*1.5,2)
C MOVE INTO CHARACTER TYPE 1 SPACE, WITH X1,X2 AND Y1,Y2 SET AS POSITIONS TO
C WRITE 'X' AND 'Y' AND C1,C2 MIDDLE POINT FOR '1A':
      CALL SPCSET(5)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
      CALL KANGA2(C1-CHUNIT,C2-1.8*CHUNIT,TEMP,'1A',2)
      CALL KANGA2(X1-1.5*CHUNIT,X2,TEMP,'X',1)
      CALL KANGA2(Y1-CHUNIT/2.,Y2+CHUNIT/2.,TEMP,'Y',1)
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MAPKEY(IFND,NFND,JP)
      SUBROUTINE MAPKEY(IFND,NFND,JP)
C
C *** MAPKEY updated by JCM Sep 91 ***
C
CX
CC 5B
CH Plots a key to the atoms found by ATMPLO.
C
      DIMENSION IFND(4),JP(4),PTEMP(2,3)
      COMMON /ATNAM/ATNAME(150),ATNA(150,9)
      CHARACTER *4 ATNA,ATNAME
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP

C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C
C FIT THE KEY TO NAMES OF ATOMS IN THE SPACE NORMALLY USED FOR CONTOUR VALUES
      IF (NFND.LE.0) GO TO 100
C  SET BLACK PEN
      CALL PIGLET(0.,0.,-1)
	IF (IBMBER .NE. 0) RETURN
C
C  LIST TO CONTAIN NFND ENTRIES PLUS HEADING
C A=HEIGHT OF LIST IN CHARACTER UNITS:
      A=FLOAT(NFND+1)*2.*CHUNIT
C CONVERT MIDPOINT OF RHS OF MAP FRAME INTO PICTURE COORDS:
      FX=FLOAT(NX-1)/2.
      FY=FLOAT(NY-1)
      CALL PLCONV(FX,FY,4,X,Y,3)
	IF (IBMBER .NE. 0) RETURN

C NOW CHARACTER TYPE 3 - ATOM LIST PANEL - WE SET THIS TO BE 10 CHARS WIDE:
       CHSCAL(2,3)=(HGTMAP+5.*YWHITE+HGTTXT)/A
C DO NOT ALLOW TYPE 3 TO BECOME LARGER THAN TYPE 1:
      IF (CHSCAL(2,3) .GT. CHSCAL(2,1)) CHSCAL(2,3)=CHSCAL(2,1)
      CHSCAL(1,3)=CHSCAL(2,3)/ASPECT
C A DIGIT IS 20 PLOTTER UNITS WIDE:
      WIDCON=240.*CHSCAL(1,3)
      HGTCON=A*CHSCAL(2,3)
C
C PUT IN PLACE THE TRANSFORMATION FOR CHARACTER TYPE 3:
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,3)
      PTEMP(2,2)=CHSCAL(2,3)
      PTEMP(1,3)=WIDPIC-XMARG-WIDCON
      PTEMP(2,3)=Y-HGTCON*0.5
      CALL PLTRIN(PTEMP,7,3)
C>> JCC Added
	IF (IBMBER .NE.0) RETURN
C
C  CHARACTER 3 SPACE COMPLETED - SET IT
      CALL SPCSET(7)
	IF (IBMBER .NE. 0) RETURN

      CALL FRAME(0.,0.,240.,A)
      B=A-2.*CHUNIT
      CALL KANGA1(0.,B,3)
      CALL KANGA1(240.,B,2)
C  WRITE 'KEY'
      CALL KANGA2(88.,B+CHUNIT/2.,TEMP,'KEY',3)
C  NOW LIST OF ATOMS FOUND
      B=B+CHUNIT/2.
      DO 5 I=1,NFND
      B=B-2.*CHUNIT
C  PLOT APPROPRIATE CHARACTER
      CALL KANGA3(55.,B+.5*CHUNIT,1.5*CHUNIT*CHSCAL(2,3),JP(I))
C  THEN NAME OF CORRESPONDING ATOM
      CALL KANGA2(5.*CHUNIT,B,TEMP,ATNAME(IFND(I)),4)
    5 CONTINUE
C
  100 RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MAPTIT
      SUBROUTINE MAPTIT
C
C *** MAPTIT by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Writes a title over a plotted map, with a frame.
C
CP The picture must be initialised by a call of STPLOT, setting up in particular
CP space 6 to be "character type 2" space, measured for suitability for title.
CP The title must have been read by INPUTN.
C
      COMMON /NTITL/NTITLE,KOM14
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /TITLE/ITITLE
      CHARACTER *80 ITITLE
C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C
C MOVE TO CHARACTER TYPE 2 SPACE (TITLE CHARACTERS):
      CALL SPCSET(6)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

C WRITE TITLE, ONE CHARACTER IN AND HALF CHARACTER UP:
      CALL KANGA2(CHUNIT,CHUNIT/2.,TEMP,ITITLE,NTITLE)
C AND PUT FRAME ROUND IT:
      CALL FRAME(0.,0.,TEMP+2.*CHUNIT,2.*CHUNIT)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE NEXCON(C,ICON,MORE)
      SUBROUTINE NEXCON(C,ICON,MORE)
C
C *** NEXCON updated by JCM 22 Aug 86 ***
C
CX
CC 5A
CH Sets up the "next" contour value to plot for Fouriers.
CA On entry LOGICAL MORE is .TRUE. if there is no reason why more contours
CA                           should not be requested,
CA                       or .FALSE. if the interactive user
CA                           has requested a contour which was not found.
CA If non-interactive, on entry ICON = which contour in the list in CONT
CA we have just tried to draw.
CA On exit C = the next contour to draw, if possible.
CA         ICON has been incremented.
CA         MORE = .TRUE. if C has been found, or .FALSE. if no more contours
CA                       are to be drawn.
C
CD If NCONT (in COMMON /CONTUR/) is zero, expects to read contour values
CD interactively.  If NCONT is non-zero, expects ICON to be a count within
CD a previously read list of contours, NCONT in total in the array CONT.
C
      LOGICAL MORE,SAYS
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C
C IF NCONT IS ZERO, INTERACTIVE WORKING:
      IF (NCONT .EQ. 0) GO TO 1
C
C NEXT C FROM LIST, UNLESS FINISHED:
C MAY BE SIMPLE LIST ITEM (ICONT=0) OR STEP (ICONT=-1):
      MORE = .FALSE.
      ICON=ICON+1
      IF (ICON .GT. NCONT) GO TO 100
      C=CONT(ICON)
      GO TO 101
C
C INTERACTIVE WORKING - IF MORE CAME IN FALSE, LAST ONE REQUESTED NOT FOUND:
   1  IF (MORE) GO TO 2
      WRITE (ITO,1001)
 1001 FORMAT (' Contour at',F12.2,' not found ')
      CALL ASK('type C to continue or X to exit')
      IF (.NOT. SAYS('X')) GO TO 2
      MORE = .FALSE.
      GO TO 100
C
   2  CALL ASK('Type contour value required')
      CALL RDREAL(C,1,IPT,80,IER)
 101  MORE = .TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PICMOV
      SUBROUTINE PICMOV
C
C *** PICMOV by JCM 22 Aug 86 ***
C
CX
CC 14B
CH If plotting to Tektronix, do nothing;  if to plotter, move to next picture.
CP FROMCM in /PLODAT/ is 0 if plotting is actually to a VDU, for which
CP the scale "from cm" is irrelevant.
CP NYPIC in /PLOMAP/ is the number of pictures expected, and IYPIC is the
CP number already plotted.
CD If a large plotter is in use for several pictures plotted in sequence,
CD the matrix PMTRIX(,,2) holds the part of the transformation which
CD moves from one picture to another.  This routine deals with the moving
CD from one picture to another, advancing IYPIC and adjusting PMTRIX(,,2)
C
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
C
C USE FROMCM ALSO TO TELL WHETHER ACTUAL PLOTTER  (CALCOMP, BENSON, ZETA,
C ETC -FROMCM > 0) OR VDU (FROMCM =< 0)
      IF (FROMCM .LE. 0.) GO TO 100
C
C DEAL WITH PUTTING PICTUES NEATLY ON A LARGE PLOTTER:
      IF (IYPIC .EQ. 0) GO TO 11
      IF (IYPIC .LT. NYPIC) GO TO 12
      PMTRIX(1,3,2)=PMTRIX(1,3,2)+WIDPIC+BORDER
      PMTRIX(2,3,2)=-(HGTPIC+BORDER)
      IYPIC=0
  12  PMTRIX(2,3,2)=PMTRIX(2,3,2)+HGTPIC+BORDER
  11  IYPIC=IYPIC+1
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE PIGLET(X,Y,N)
       SUBROUTINE PIGLET(X,Y,N)
C
C *** PIGLET updated by JCM 27 Jun 86 ***
C
CX
CC 14C
CH A complete set of device-specific plotting commands.
CA On entry X and Y are plotter coordinates
CA          N indicates the function required:
CA
CA N=0  Called at very start of a plotting job, to set up physical things like
CA       plotter width in cms, plotter units (as FROMCM which converts from cms
CA       to plotter units).  Also sets up some transformation matrices and
CA       initialises quantities for transformations.
CD
CA N=2   Move the pen to the point X,Y (in the plotter's own coordinates)
CA or          N=2 moves with pen down (i.e. draws)
CA N=3         N=3 moves with pen up.
CA             There was originally an N=1 meaning move with the pen in the
CA             state it was last time.  Not every library implements this,
CA             so although CCSL uses it, it is now done by the routines which
CA             call PIGLET.
CD
CA N=-1 or -2 or -3 Changes the colour of the ink in the pen
CA             N=-1 Asks for black
CA             N=-2 Asks for red
CA             N=-3 Asks for green
CA             (These may be altered, or others added, as the user wishes)
CD
CA The remaining values of N carry out whatever special actions the local
CA plotter software needs to make when starting or finishing various stages.
CD
CD The complete plotter output produced by the whole job is called here a
CD "plot".  The plot may be made up of various "pictures" such as layers of
CD a Fourier map; or it may be just one graph. Within a "picture" there are
CD various boxes of explanatory text and the main graphic object such as a
CD "map" for fouriers or a "graph" from PLOTO
CD
CD Most plotter software libraries require that a certain routine be called to
CD start a plot, and some also require another routine to be called to finish
CD a plot (say, to move the pen clear of the plot ready for the next job).
CD There is no obvious need for any special action on an actual plotter at the
CD start and finish of one "picture", but if a Tektronix or other vdu is used,
CD there will be only one "picture" on the screen at once (remember several
CD "pictures"=1 "plot"), so special actions will be needed to start (say, clear
CD screen) and finish (say, ask user if he wants a hard copy) a picture.
CD
CD To accomplish these actions large values of n are assigned as follows:
CD N=999 Start "plot" (which will be X cms wide and Y cms high)
CD N=-999 Finish "plot" (which was X cms wide and Y cms high)
CD N=888 Start "picture" (which will be X cms wide and Y cms high)
CD N=-888 Finish "picture" (which was X cms wide and Y cms high)
C
CD Sets PMTRIX number 1: the CCSL to hardware transformation
C
CO When requested, sends output to graphical device.
CN Contains all plotting commands which are specific to whatever machine (and
CN which output device) is being used.  These are believed to be a bare
CN minimum.  Whenever a new plotter (specifically a new plotter software
CN library) is implemented on the system a specific version of this routine
CN must be made.
CN
CN There are other versions of PIGLET in CCSL for specific output devices.
C
      DIMENSION PTEMP(2,3)
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C>> JCC Implement error handling
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
      IF (N .NE. 0) GO TO 3
C INITIAL ENTRY - SET UP PLOTTER WITHOUT YET KNOWING WHAT WE WISH TO PLOT:
C
C PLOTTER CONVENTIONS - FIRST SET UP DEFAULTS COMMON TO ALL:
      CALL PINITL
	IF (IBMBER .NE. 0) RETURN
C CONVERSION MATRIX WHICH TAKES (X,Y) IN CCSL UNITS INTO (X',Y') IN YOUR
C ACTUAL PLOTTER UNITS.  SEE THE ANNOTATION FOR SUBROUTINE PLCONV FOR
C DEFINITIONS.  THE DEFAULT HERE IS THE UNIT TRANSFORMATION.
      CALL GMZER(PTEMP,2,3)
      CALL GMUNI(PTEMP,2)
C
C FROMCM POSITIVE USED TO INDICATE PLOTTER NOT VDU:
CRAL
C RUTHERFORD VAX PLOTTER WORKS IN SAME ORIENTATION AS CCSL EXPECTS,
CRAL
C  BUT IN INCHES.
CRAL
      FROMCM=1./2.54
CRAL
      PAPERW=28.
C
C3084C THE 3084 PLOTTER HAS ITS ORIGIN THE OTHER SIDE, WITH X AND Y REVERSED,
C3084C  AND IT WORKS IN MILLIMETRES.
C3084      FROMCM=10.
C3084      PAPERW=30.
C3084      PTEMP(1,1)=0.
C3084      PTEMP(2,1)=1.
C3084      PTEMP(1,2)=-1.
C3084      PTEMP(2,2)=0.
C3084      PTEMP(1,3)=PAPERW
C3084      PTEMP(2,3)=0.
C
C SET UP CCSL TO PLOTTER TRANSFORMATION:
      CALL GMSCA(PTEMP,PTEMP,ABS(FROMCM),2,3)
      CALL PLTRIN(PTEMP,2,1)
	IF (IBMBER .NE. 0) RETURN
C
      GO TO 100
C
   3  IF (IABS(N) .GT. 500) GO TO 1
      IF (N .LT. 0) GO TO 2
C
C BASIC PEN MOVING: 2=DOWN, 3=UP
CVMS
      IF ((N .EQ.2) .OR. (N .EQ. 3)) GO TO 4
C3084      IF (N .EQ. 2) GO TO 4
C3084      IF (N .EQ. 3) GO TO 5
      CALL ERRMES(-1,0,'call of PIGLET with small N not 2 or 3')
C
C3084C INSTALLATION DEPENDENT LIBRARY CALLS FOR CURVE PLOTTING ON 3084
C3084C 'DRAW TO'
C3084   4  CALL GLDT2S(X,Y)
C3084      GO TO 100
C3084C 'MOVE TO'
C3084   5  CALL GLMT2S(X,Y)
C
CVMS
C   4  CALL PLOT(X,Y,N)
4     CONTINUE
      GO TO 100
C
C PEN COLOUR CHANGE:
C3084   2  CALL GLDV2S(-N)
CVMS
C   2  CALL NEWPEN(-N)
2     CONTINUE
      GO TO 100
C
C START/FINISH ROUTINES:
C INPUT X AND Y WERE IN CCSL UNITS - PUT INTO PLOTTER:
   1  CALL PLCONV(X,Y,2,XX,YY,1)
C>> JCC added
      IF (IBMBER .NE. 0) RETURN
      IF (IABS(N) .NE. 999) GO TO 100
C ONLY "START/STOP PLOT" IS RELEVANT HERE AT PRESENT:
C3084      IF (N .EQ. -999) GO TO 9
C3084C INITIALISE PACKAGE:
C3084      CALL GLPC2S
C3084C TIE UP PLOTTING WITH JCL ITEM LABELLED 'PLOT';  ASK FOR PAPER WHICH IS
C3084C 300 MMS WIDE (MAXIMUM 30 CMS AS SET IN PAPERW IN ROUTINE FRIG AND ALREADY
C3084C CHECKED) AND MAX 6 METRES LONG (NO CHECK AT PRESENT)
C3084C
C3084C THE LAST PARAMETER IS THE RATIO OF THE LENGTH TO THE WIDTH
C3084      CALL GLPS2S('PLOT    ',300.0,20.001)
C3084C THESE NEXT 4 PROVIDED BY CS - THIS SAYS IT DEFINES DEVICE WINDOW IN
C3084C NORMALISED DEVICE SPACE WITH PREFERRED WIDTH:
C3084      CALL GLWV4S(0.0, 0.05, 0.0, 1.0, 300.0)
C3084C THIS SAYS IT DEFINES USER VIEWPORT IN NORMALISED DEVICE SPACE:
C3084      CALL GLWV3S(0.0, 0.05, 0.0, 0.05)
C3084C AND THIS SAYS IT DEFINES USER WINDOW IN WORLD COORDINATE SPACE:
C3084      CALL GLWV2S(0.0, 300.0, 0.0, 300.0)
C3084C SELECT TRANSPARENT MODE FOR SOME REASON:
C3084      CALL GLMD3S(3)
C3084      GO TO 100
C3084C
C3084C FINISH PLOT:
C3084C CLOSE OUTPUT STREAM:
C3084   9  CALL GLPS7S
C3084C CLOSE PACKAGE:
C3084      CALL GLPC4S
C
CILL      IF (N .EQ. 999) CALL PLOTS(0,XX,YY)
CILL      IF (N .EQ. -999) CALL PLOT(0.,0.,999)
C
CRAL
C      IF (N .EQ. 999) CALL PLOTS(53,0,8)
CRAL
C      IF (N .EQ. -999) CALL PLOT(XX,-0.5,999)
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE PINITL
      SUBROUTINE PINITL
C
C *** PINITL by JCM 27 Jun 86 ***
C
CX
CC 14A
CH Initialises the system in order to make graphical output.
C
CD Sets up various quantities, some of them probably machine specific, to
CD enable SUBROUTINE PIGLET to be called.  PIGLET may well alter some
CD of them.  Suitable for either the plotter version or the Tektronix
C
CD  Sets    PAPERW = width of paper in cms (or no. of pixels)
CD          PAPERH = "height" of paper in cms - this is the maximum
CD                   amount allowed in direction perpendicular to the
CD                   axis of the plotter (or no. of pixels)
CD          FROMCM = the conversion factor from centimetres to hardware
CD                   units - set to 1 for now, and adjusted in PIGLET
CD                   where necessary (<0 for VDU output)
CD          CHUNIT = number of character units of a character grid which
CD                   make the height of a character (and also the maximum
CD                   width of a character, which may not use it all)
CD          ASPECT = ratio of the height of a plotted character to its width
CD          BORDER = width of border between pictures, in cms
CD          DASH = length of the dash of a dashed line, in cms
CD  Initialises the general structure of transformations in /PLODAT;
CD  does not initialise the basic 'CCSL to hardware' transformation,
CD which must be done in individual PIGLETs.
      DIMENSION PTEMP(2,3)
      COMMON /ADASH/DASH,X1,Y1,REM,IPEN,IDSH,DTRAN(2,2)
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
C>> JCC Implement error handling
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C RATIO OF HEIGHT OF CHARACTER TO ITS WIDTH:
      ASPECT=1.0
C   PAPERW AND PAPERH = MAXIMUM VALUES FOR WIDTH (CCSL Y DIRECTION) AND
C   HEIGHT (CCSL X DIRECTION, WHICH WOULD BE "INFINITE" IF A DRUM PLOTTER
C   IS BEING USED) EXPRESSED IN CCSL UNITS WHICH ARE ** CENTIMETRES **
C INITIALISATION IS FOR GRENOBLE BENSON:
      PAPERW = 72.
      PAPERH = 500.
C FROMCM = CONVERSION FACTOR FROM CMS TO HARDWARE UNITS:
      FROMCM=1.
C BORDER = SPACE BETWEEN ONE PICTURE AND THE NEXT IN A PLOT (SEE PIGLET
C FOR EXPLANATION)
      BORDER = 0.5
C CHUNIT IS THE NUMBER OF UNITS OF CHARACTER GRID WHICH MAKE THE HEIGHT OF A
C CHARACTER, AND THE MAXIMUM WIDTH (CHARACTERS MAY TAKE FEWER UNITS ACROSS).
      CHUNIT=30.
C LENGTH OF A DASH IN NEGATIVE CONTOURS IN CMS:
      DASH=0.2
C
C SET UP PICTURE TO CCSL TRANSFORMATION (DEFAULT 1 PICTURE):
      CALL GMZER(PTEMP,2,3)
      CALL GMUNI(PTEMP,2)
      CALL PLTRIN(PTEMP,3,2)
	IF (IBMBER .NE. 0) RETURN
C INITIALISE TRANSFORMATIONS:
      NSPCE=0
      NCON1=0
      NCON2=0
      MAXSP=2
      IDSH=0
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE PLCONV(X1,Y1,NN1,X2,Y2,NN2)
      SUBROUTINE PLCONV(X1,Y1,NN1,X2,Y2,NN2)
C
C *** PLCONV updated by PJB 4 Apr 85 ***
C
CX
CC 14B
CH Performs the transformation of coordinates between different plotter spaces.
CA On entry X1, Y1 are coordinates in coordinate system number NN1
CA On exit  X2, Y2 are the same coordinates transformed into the
CA                 coordinate system number NN2
C
CP PIGLET with N=0, PLTRIN to set up the required transformation matrices.
C
CD Coordinate systems:
CD 0=Current - The current space is held in NSPCE in COMMON /PLTRAN/
CD 1=Plotter (actual coords on a particular plotter)
CD 2=CCSL (the coords in which the programs are written)
CD Coordinate sytems 3 to 7 are for user applications, for example in plotting
CD Fourier maps they are used as follows:
CD 3=Picture (one "picture" which contains one section of the map)
CD 4=Map (The crystallographically related axes of the Fourier calculation)
CD 5=Character type 1 (a mesh of 30 by 30 on which characters are defined)
CD 6=Character type 2 (a mesh of 30 by 30 on which characters are defined)
CD 7=Character type 3 (a mesh of 30 by 30 on which characters are defined)
CD
CD Conversion involves both a translation (or origin shift) and a rotation.
CD These are combined by holding the conversion matrix as 3 by 2 with
CD the translation vector as the 3rd column.
C
      DIMENSION A(2,3),B(2,3),C(2,3)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
C
      N1=NN1
      N2=NN2
      IF (N1 .EQ. 0) N1=NSPCE
      IF (N2 .EQ. 0) N2=NSPCE
C  DO WE NEED A NEW MATRIX?
      IF (N1.EQ.NCON1 .AND. N2.EQ.NCON2) GO TO 101
C MAKE IT:
      N=N1-1
      M=N2-1
      CALL GMZER(A,2,3)
      A(1,1)=1.
      A(2,2)=1.
      CALL GMEQ(A,B,2,3)
    1 IF (N-M) 4,3,2
C
C  SOURCE SPACE HIGHER
    2 IF (N .LE. 0) GO TO 6
      CALL PMTMUL(PMTRIX(1,1,N),A,C)
      CALL GMEQ(C,A,2,3)
      N=NTRAN(N)-1
      GO TO 1
C
C  DESTINATION HIGHER
    4 IF (M .LE. 0) GO TO 6
C CHECK WHICH WAY ROUND THIS SHOULD BE:
      CALL PMTMUL(PMTRIX(1,1,M),B,C)
      CALL GMEQ(C,B,2,3)
      M=NTRAN(M)-1
      GO TO 1
C
C  SOURCE AND DESTINATION NOW THE SAME, FORM MATRIX
    3 CALL PMTINV(B,C)
      CALL PMTMUL(C,A,PTRAN(1,1,2))
C  AND SET NEW VALUES IN NCON
      NCON1=N1
      NCON2=N2
C  GO AND DO TRANSFORMATION
      GO TO 101
C
    6 WRITE (LPT,3000) N1,N2
      WRITE (ITO,3000) N1,N2
3000  FORMAT (' ERROR ** PLCONV REQUIRED TO CONVERT FROM COORDS',
     & I3,' TO COORDS',I3)
C>> JCC Was STOP
      CALL BMBOUT
	RETURN
C
 101  X2=PTRAN(1,1,2)*X1+PTRAN(1,2,2)*Y1+PTRAN(1,3,2)
      Y2=PTRAN(2,1,2)*X1+PTRAN(2,2,2)*Y1+PTRAN(2,3,2)
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PLOTCT(C,A,FOUND,M,N)
      SUBROUTINE PLOTCT(C,A,FOUND,M,N)
C
C *** PLOTCT by JCM 24 Nov 83 ***
C
CX
CC 14B
CH Plots a single contour throughout a given array.
CA On entry C is the contour value required
CA          A is a M by N array of values in which the contour C is to be
CA            interpolated
CA On exit  FOUND is true if a contour was found and plotted, false otherwise.
CP PIGLET with N=0 and N=999, to set up the plotter.
CP The desired mesh on the plotter should be set up with PLTRIN and SPCSET
CO Output is to a plotter whose characteristics are defined in the version of
CO PIGLET linked.
C
      LOGICAL FOUND,MID,TEST
      DIMENSION A(M,N),T(6)
      COMMON /BITMAP/IBIT(108,4),NWORDS
C>> JCC Implemented error handling
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
      FOUND = .FALSE.
      IPEN=3
      ICC=1
      IF (C) 6,7,8
   6  ICC=2
      IPEN=2
      GO TO 8
   7  IPEN=1
      ICC=14
C
C SELECT COLOUR OF PEN:
   8  CALL PIGLET(0.,0.,-IPEN)
      M2=M+2
      DO 1 I=1,M2
      DO 5 J = 1,4
    5 IBIT(I,J) = 0
      CALL MAKEBM(I,A,C,M,N)
   1  CONTINUE
      DO 2 I=1,M2
      DO 2 J=1,4
  22  IF (IBIT(I,J) .EQ. 0) GO TO 2
      FOUND = .TRUE.
      CALL LOCBIT(I,J,NR,NC,ISIDE,M,N)
	IF (IBMBER .NE. 0) RETURN ! Bomb out on error
C        SETS NR,NC TO TOP LEFT OF SQUARE - ISIDE = 1,2,3 OR 4
      CALL GETSQ(A,T,C,NR,NC,M,N)
      XPNT = 0.
      POINT = T(ISIDE)/(T(ISIDE) - T(ISIDE+1))
      LINE=0
      CALL DOSIDE (POINT,XPNT,ISIDE,NR,NC,X,Y)
      CALL DPLOT(X,Y,LINE)
      LINE = ICC
   4  MID = T(6) .GE. 0.
      IC = 0
      IF (MID .AND. T(ISIDE) .GE. 0. .OR. .NOT. MID .AND. T(ISIDE)
     & .LT. 0.) IC = 1
      ID = ISIDE + IC
   3  POINT = 0.5 * T(ID)/(T(ID) - T(6))
      XPNT = POINT
      IF (IC .NE. 0)  XPNT = 1.-POINT
      CALL DOSIDE (XPNT,POINT,ISIDE,NR,NC,X,Y)
      CALL DPLOT(X,Y,LINE)
      LINE = ICC
      ISIDE = ISIDE - 1 + IC + IC
      IF (ISIDE .EQ. 5)  ISIDE = 1
      IF (ISIDE .EQ. 0)  ISIDE = 4
      ID = ISIDE + IC
      IF (MID .AND. T(ID) .LT. 0. .OR. .NOT. MID .AND. T(ID)
     & .GE. 0.) GO TO 3
      XPNT = 0.
      POINT = T(ISIDE)/(T(ISIDE) - T(ISIDE+1))
      CALL DOSIDE (POINT,XPNT,ISIDE,NR,NC,X,Y)
      CALL DPLOT(X,Y,LINE)
      GO TO (11,12,13,14), ISIDE
  11  ISIDE = 3
      IF (NR .GT. 1) GO TO 21
      CALL BITSET(1,NC,TEST,.FALSE.)
  17  IF (TEST)  GO TO 22
      CALL ERRMES(-1,0,'in PLOTCT')
C
  21  NR = NR-1
      CALL BITSET(NR+4,NC,TEST,.FALSE.)
      IF (.NOT. TEST) GO TO 22
      GO TO 16
  12  NC = NC+1
      ISIDE = 4
      IF (NC .LT. N) GO TO 16
      CALL BITSET (2,NR,TEST,.FALSE.)
      GO TO 17
  13  NR = NR+1
      ISIDE = 1
      IF (NR .LT. M) GO TO 15
      CALL BITSET (3,N-NC,TEST,.FALSE.)
      GO TO 17
  14  NC = NC-1
      ISIDE = 2
      IF (NC .GT. 0) GO TO 16
      CALL BITSET(4,M-NR,TEST,.FALSE.)
      GO TO 17
  15  CALL BITSET(NR+3,NC,TEST,.FALSE.)
      IF (.NOT. TEST) GO TO 22
  16  CALL GETSQ(A,T,C,NR,NC,M,N)
      GO TO 4
   2  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE PLOTIT(X,NP,SIZE)
      SUBROUTINE PLOTIT(X,NP,SIZE)
C
C *** PLOTIT by PJB Sep 87 ***
C
CX
CC 14B
CH Plots the graph of given vector y against x, with esds.
CA On entry X(3,NP) holds values to be plotted
CA    X(1,1:NP)= x values
CA    X(2,1:NP) = y values
CA    X(3,1:NP) = standard deviations of y values
CA On entry NP = number of points in graph
CA          SIZE a vector of dimension 2 holds the lengths of the x and
CA                 y axes in cms.
CD This subroutine sets up the plotter as well as drawing the graph.*
CO Output to a plotter whose characteristics are defined in the version of
CO PIGLET linked.
C
      DIMENSION X(3,NP),SIZE(2)
      DIMENSION XMAX(2),XMIN(2)
C>> JCC Trap for error in GETSCL to prevent STOP
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C  FIND MAXIMUM AND MINIMUM VALUES
      DO 3 J=1,2
      XMAX(J)=X(J,1)
      XMIN(J)=X(J,1)
      DO 2 I=2,NP
      IF (XMAX(J).LT.X(J,I)) XMAX(J)=X(J,I)
      IF (XMIN(J).GT.X(J,I)) XMIN(J)=X(J,I)
    2 CONTINUE
C  SET SCALE
    3 CALL GETSCL(XMIN(J),XMAX(J),J)
	IF (IBMBER .GT. 0) RETURN
C
C  DRAW AXES ETC
      CALL PLOTO(SIZE(1),SIZE(2),.8,0)
	IF (IBMBER .GT. 0) RETURN

C
      DO 1 I=1,NP
      CALL PLOTO(X(1,I),X(2,I),X(3,I),2)
	IF (IBMBER .GT. 0) RETURN
    1 CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PLOTO(XX,YY,ER,MODE)
      SUBROUTINE PLOTO(XX,YY,ER,MODE)
C
C *** PLOTO updated by PJB/JCM 10 Jun 88 ***
C
CX
CC 14B
CH A multi-purpose graph-drawing routine.
CA On entry XX and YY are x and y coordinates whose meaning is defined by MODE:
CA MODE=0 Set up to draw a graph in which the lengths of the axes are x, y.
CA     >0 Line drawing: move the "pen" from its current position to x, y.
CA        If MODE = -1 the "pen" is down
CA                = -2 a dashed line is drawn. The dash interval is ER.
CA                = -3 the "pen" is up
CA        If -MODE > 10 and < 21 the symbol ABS(MODE+10) is drawn at
CA                   intervals of ER.
CA MODE>0 Plot the point x,y with an error bar of length ER. The value of
CA           MODE defines the symbol to be plotted.
CA           MODE = 1 square
CA           MODE = 2 triangle, apex up
CA           MODE = 3 triangle, apex down
CA           MODE = 4 hexagon, which if small will look like a circle
CA           MODE = 5 cross like x
CA           MODE = 6 cross like +
CA           MODE = 7 cross like x with top and bottom (egg-timer)
CA           MODE = 8 cross like x with sides (butterfly)
CA           MODE = 9 diamond
CP The vector X(I,J) held in COMMON /PLTS/ defines how the graph will be drawn
CP     I=1 for x-axis, I=2 for y-axis.
CP         J=1  length of axis in user units
CP         J=2  length of axis in cms.
CP         J=3  division of axis in user units
CP         J=4  minimum value in user units
CP         J=5  position of axis to be plotted
CP GETSCL should be called for both x and y axes, to define the ranges of
CP values to plot.
C
      DIMENSION YC(2),Y(2),XO(2),IPNT(2),ICH(2),AM(2,3)
      COMMON /ADASH/DASH,X1,Y1,REM,IPEN,IDSH,DTRAN(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
      COMMON /PLTS/X(2,5),S(2),CH,XS,ISIG(2),YS,NDIVS(2,2)
      COMMON /PLOTCH/ITEXT,NTEX(2)
      CHARACTER *80 ITEXT,NTEX*15
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      EQUIVALENCE (Y(1),A),(Y(2),B)
C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
      IF (MODE) 1,2,3
C
C  MODE=0 SET UP AND DRAW AXES
C
C  GET HOLD OF PLOTTER
    2 CALL PIGLET(0.,0.,0)
C  SET DASH LENGTH
      DASH=0.5
C  IF ABLE, ACCEPT TITLE (IF NOT, IT MUST BE SET UP BEFORE ENTRY):
      CALL ASK('Give title (up to 80 characters)')
      ITEXT=ICARD
C
C  SET LENGTHS OF AXES IN CMS
      X(1,2)=XX
      X(2,2)=YY
C  DETERMINE NUMBER OF FIGURES BEFORE AND AFTER DECIMAL POINT FOR
C  LABELLING AXES
      DO 21 I=1,2
      IPNT(I)=1-ISIG(I)
      ICH(I)=2+IABS(ISIG(I))
      IF (ISIG(I).EQ.0) ICH(I)=ICH(I)+1
      IF (ISIG(I).GT.1) ICH(I)=ICH(I)-1
C  SET SCALE OF GRAPH
      S(I)=X(I,2)/X(I,1)
   21 CONTINUE
C  LIMITING CHARACTER SIZE
      CLIM=1.5
      IF (ER.NE.0) CLIM=ER
C  NORMALLY CHARACTERS LABELLING AXES SHOULD TAKE HALF THE SPACE BETWEEN
C  LABELLED DIVISIONS IN THE X DIRECTION
      CH2=S(1)*X(1,3)/(2.*FLOAT(ICH(1)))
      IF (CH2.GT.CLIM) CH2=CLIM
C  ALEN IS THE LENGTH IN USER UNITS OF THE FIGURES ON THE Y-AXIS
      ALEN=(ICH(2)+3)*CH2/S(1)
C  SET XO TO BE MINIMUM VALUE IN USER UNITS INCLUDUNG SPACE FOR NUMBERS
      DO 31 I=1,2
      XO(I)=AMIN1(X(I,5)-ALEN,X(I,4))
   31 ALEN=4.*CH2/S(2)
C
C  SPACE FOR TITLE AND CHARACTER SIZE FOR TITLE
      ITITLE=LENGT(ITEXT)
      CALL KANGA2(0.,0.,TLEN,ITEXT,-ITITLE)
      TLEN=TLEN+2.*CHUNIT
      CH1=X(1,2)*CHUNIT/TLEN
      CLIM=1.5*CH2
      IF (CH1.GT.CLIM)CH1=CLIM
C  CENTRE TITLE
      ALEN=CH1*TLEN/CHUNIT
C      ALEN=((X(1,1)-XO(1))*S(1)-ALEN)/2.
       ALEN=BORDER+(X(1,4)-XO(1))*S(1)+(X(1,2)-ALEN)/2
C  ALEN IS DISTANCE IN CMS OF START OF TITLE FROM LH EDGE
C  SET SIZES OF OTHER MARKS
C  XS FOR DASHES ON AXES
      XS=0.4*CH2
C  YS FOR TOP AND BOTTOM OF ERROR BARS
      YS=0.6*CH2/S(1)
      CH=0.5*CH2
C
C  CHARACTER 1 SPACE - FOR TITLE
      AM(1,1)=CH1/CHUNIT
      AM(2,2)=AM(1,1)*ASPECT
      AM(1,2)=0.
      AM(2,1)=0.
      AM(1,3)=BORDER+ALEN
      AM(2,3)=BORDER
      CALL PLTRIN(AM,5,3)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
C  CHARACTER 2 ROTATED BY 90 DEGREES - FOR LABEL ON Y AXIS
      A1=CH2/CHUNIT
      A2=A1*ASPECT
      AM(1,2)=-A1
      AM(2,1)=A2
      AM(1,1)=0.
      AM(2,2)=0.
      AM(1,3)=BORDER-XO(1)*S(1)
C  CHANGE HERE WHEN NO TITLE
C      AM(2,3)=BORDER-XO(2)*S(2)+5*CH1
      AM(2,3)=BORDER-XO(2)*S(2)+2.*CH1
      CALL PLTRIN(AM,6,3)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C  CHARACTER 2 SPACE - FOR NUMBERS ON AXES AND X AXIS LABEL
      AM(1,1)=A1
      AM(2,2)=A2
      AM(1,2)=0.
      AM(2,1)=0.
      CALL PLTRIN(AM,7,3)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
C  GRAPH SPACE
      AM(1,1)=S(1)
      AM(2,2)=S(2)
      CALL PLTRIN(AM,4,3)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C  SIZE OF PLOT
      PW=X(1,2)+(X(1,4)-XO(1))*S(1)+(ICH(1)+3)*CH2+3.*BORDER
      PH=X(2,2)+(X(2,4)-XO(2))*S(2)+2.*BORDER+5.*CH1
C
      CALL PIGLET(PW,PH,999)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
      CALL PIGLET(0.,0.,-1)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
C  WRITE TITLE
      CALL SPCSET(5)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      IF (ITITLE.NE.0) THEN
      CALL KANGA2(CHUNIT,0.5*CHUNIT,TLEN,ITEXT,ITITLE)
      CALL FRAME(0.,0.,TLEN+2.*CHUNIT,2*CHUNIT)
      ENDIF
C
C  LABEL AXES
      CALL SPCSET(6)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      X1=X(1,5)
      X2=X(2,1)+X(2,4)-X(2,3)
      CALL PLCONV(X1,X2,4,YC(1),YC(2),6)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
      YC(2)=YC(2)+(ICH(2)+1)*CHUNIT
      N=LENG(NTEX(2),15)
      IF (N .GT. 0) THEN
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(2),-N)
        YC(1)=YC(1)-ALEN
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(2),N)
      ENDIF
      CALL SPCSET(7)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      X1=X(1,1)+X(1,4)-X(1,3)
      X2=X(2,5)
      CALL PLCONV(X1,X2,4,YC(1),YC(2),7)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
      N=LENG(NTEX(1),15)
      IF (N .GT. 0) THEN
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(1),-N)
        YC(1)=YC(1)-ALEN
        YC(2)=YC(2)-3*CHUNIT
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(1),N)
      ENDIF
C NOW LABEL THE DIVISIONS
      L=2
      DO 22 J=1,2
      VAL0=X(J,4)
      II=NDIVS(J,1)/5+NDIVS(J,2)/5 + 1
      NLFT=IFIX((ABS(X(J,4)/X(J,3)))+.001)
      VAL=SIGN(FLOAT(NLFT),X(J,4))*X(J,3)
C CASE WHERE ALL VALUES ARE POSITIVE
      IF (VAL0-VAL .GT. .01*X(J,3)) VAL=VAL+X(J,3)
      Y(J)=VAL+X(J,3)
      Y(L)=X(L,5)
      CALL PLCONV(Y(1),Y(2),4,YC(1),YC(2),7)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
      STEP=YC(J)
      Y(J)=VAL
      CALL PLCONV(Y(1),Y(2),4,YC(1),YC(2),7)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
      YC(L)=YC(L)-1.5*CHUNIT
      STEP=STEP-YC(J)
C
      DO 4 I=1,II
      IF (ABS(X(J,5)-VAL).LT.10E-4) GO TO 6
      IF (ABS(VAL).LT. 10E-5) GO TO 6
      CALL FETTLE(VAL,IW,IP)
      CALL NUMA1(VAL,IW,IP,IW,ITEXT)
      IW2=IW/2
      CALL KANGA2(YC(1)-IW2*CHUNIT,YC(2),ALEN,ITEXT,IW)
    6 YC(J)=YC(J)+STEP
      VAL=VAL+X(J,3)
    4 CONTINUE
      L=1
   22 CONTINUE
C
C  DRAW AXES
      L=2
      CALL SPCSET(4)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      DO 23 J=1,2
      YO=X(L,5)
      Y2=XS/S(L)
      Y1=YO+Y2
      Y2=Y1+Y2
      II=NDIVS(J,1)+NDIVS(J,2) + 1
      STEP=X(J,3)/5.
      Y(L)=YO
      Y(J)=X(J,4)
      CALL KANGA1(A,B,3)
      Y(J)=Y(J)+AMOD(X(J,4),STEP)
C
      DO 5 I=1,II
      CALL KANGA1(A,B,2)
      Y(L)=Y1
      BIT=X(J,3)/50.
      BITTLE=BIT/10.
      TEST=ABS(AMOD(ABS(Y(J))+BITTLE,X(J,3)))
      IF (TEST.LT.BIT) Y(L)=Y2
      CALL KANGA1(A,B,1)
      Y(L)=YO
      CALL KANGA1(A,B,3)
      Y(J)=Y(J)+STEP
    5 CONTINUE
      L=1
   23 CONTINUE
C
C
C USE THIS IF WANT A FRAME:
C      CALL SPCSET(2)
C      CALL FRAME(0.,0.,PW,PH)
      GO TO 100
C
C  ENTRY TO PLOT A POINT WITH AN ERROR BAR
    3 CALL SPCSET(4)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
      A=XX
      B=YY
      X1=A-0.5*YS
      X2=X1+YS
C MAKE THE SYMBOLS BIGGER
      SIZ=1.5*YS*S(1)
      IF (ER.EQ.0) GO TO 20
      CALL KANGA3(A,B,SIZ,MODE)
      IF (2.*ER*S(2) .LT. SIZ) GO TO 100
      B=B+ER
      CALL KANGA1(X1,B,3)
      CALL KANGA1(X2,B,2)
      CALL KANGA1(A,B,3)
      B=B-2*ER
      CALL KANGA1(A,B,2)
      CALL KANGA1(X1,B,3)
      CALL KANGA1(X2,B,2)
      GO TO 100
C
C  ENTRY TO PLOT A VECTOR
    1 CALL SPCSET(4)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      IF (MODE.GE.-3) GO TO 40
C  SET UP FOR DASHED LINES
      DASH=ER
   40 J=IABS(MODE)
      IF (J.EQ.3) J=0
      CALL DPLOT(XX,YY,J)
      GO TO 100
C
C  CALCULATED POINT
   20 CALL KANGA3(A,B,SIZ,MODE)
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE PLTRIN(PMAT,N,M)
      SUBROUTINE PLTRIN(PMAT,N,M)
C
C *** PLTRIN by JCM 4 Apr 85 ***
C
CX
CC 14B
CH Defines a new coordinate transformation for plotting.
CA On entry PMAT is a 2 X 3 real matrix which defines the coordinate system
CA N with respect to M.
CA          PMAT(1:2,1:2) gives the scaling and rotation
CA          PMAT(1:2,3) gives the origin of space N with respect to that of
CA                      space M, in M's cordinates.
CA M must be greater than N
C
CD PMAT and N will be written as items number N-1 in PMTRIX and NTRAN in
CD COMMON /PLTRAN/. MAXSP in /PLTRAN/ holds the largest N yet given.
C
      DIMENSION PMAT(2,3)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
      IF (M .LT. N .AND. M .GT. 0) GO TO 1
      WRITE (LPT,3000) N,M
      WRITE (ITO,3000) N,M
3000  FORMAT (/' ERROR ** TRYING TO TRANSFORM FROM SPACE',I4,
     & ' TO SPACE',I4,' IN PLTRIN')
      IBMBER =  1
	RETURN
C
   1  CALL GMEQ(PMAT,PMTRIX(1,1,N-1),2,3)
      NTRAN(N-1)=M
      IF (N .GT. MAXSP) MAXSP=N
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PLTTXT
      SUBROUTINE PLTTXT
C
C *** PLTTXT updated by JCM 29 Apr 92 ***
C
CX
CC 5B
CH Plots a block of explanatory text under a plotted Fourier map.
C
CD Plots the block of text which lists all the necessary details for
CD identification of the map.  Does this in what is for the Fourier plotting
CD "character 1 space", space number 5.
C
CO Outputs to graphical device as set up by PIGLET
C
      CHARACTER *10 MTYP(5)
      CHARACTER *1 IXCHR(2)
      CHARACTER *52 LINE1
      CHARACTER *58 LINE2
      CHARACTER *63 LINE3
      CHARACTER *50 LINE4
      CHARACTER *45 LINE5
      CHARACTER *22 LINE6
      CHARACTER *75 LINE7
      DIMENSION ITYPE(7)
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      DATA IXCHR/'X','Y'/
      DATA MTYP/'  FCALC','   FOBS','FOBS-FCALC',' FOBS**2',
     & 'SIGMA FOBS'/
      DATA LINE1/'    FOURIER PROJECTION DOWN'/
      DATA LINE2/'  FOURIER SECTION AT           ON'/
      DATA LINE3/'   parallel to                         from         to
     & '/
      DATA LINE4/'Coefficients are            multiplied by'/
      DATA LINE5/'    and averaged over a cube of edge'/
      DATA LINE6/'No resolution function'/
      DATA LINE7/'Bounded section from          to          on'/
      DATA ITYPE/1,2,2,3,3,4,5/

C>> JCC Added error trapping
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C WE SHOULD BE NOW WORKING IN CHAR 1 SPACE:
      CALL SPCSET(5)
	IF (IBMBER .NE. 0) RETURN
C
C BLACK PEN:
      CALL PIGLET(0.,0.,-1)
	IF (IBMBER .NE. 0) RETURN
C
C
C COLLECT LENGTH OF LONGEST LINE FOR FRAME SIZE:
      A=0.
C
C LINES OF TEXT:
      IF (NDIM.EQ.3) GO TO 3
      IF (NDIM.EQ.4) GO TO 12
      DO 4 I=1,3
      CALL FETTLE(U(I,3),IW,IF)
   4  CALL NUMA1(U(I,3),IW,IF,8,LINE1(21+8*I:28+8*I))
      CALL KANGA2(CHUNIT,8.5*CHUNIT,TEMP,LINE1,52)
      IF (TEMP .GT. A) A=TEMP
      GO TO 5
    3 DO 6 I=1,3
      CALL FETTLE(U(I,3),IW,IF)
    6 CALL NUMA1(U(I,3),IW,IF,8,LINE2(27+8*I:34+8*I))
      CALL FETTLE(OUTLIM(1,3),IW,IF)
      CALL NUMA1(OUTLIM(1,3),IW,IF,9,LINE2(22:30))
      CALL KANGA2(CHUNIT,8.5*CHUNIT,TEMP,LINE2,58)
      IF (TEMP .GT. A) A=TEMP
      GO TO 5
C
  12  DO 13 I=1,3
      CALL FETTLE(U(I,3),IW,IF)
      IP=38+8*I
   13 CALL NUMA1(U(I,3),IW,IF,8,LINE7(IP:IP+7))
      CALL FETTLE(OUTLIM(1,3),IW,IF)
      CALL NUMA1(OUTLIM(1,3),IW,IF,9,LINE7(22:30))
      CALL FETTLE(SECEND,IW,IF)
      CALL NUMA1(SECEND,IW,IF,9,LINE7(33:41))
      CALL KANGA2(CHUNIT,8.5*CHUNIT,TEMP,LINE7,64)
      IF (TEMP .GT. A) A=TEMP
C
C LINES DESCRIBING AXES:
   5  Y=6.3*CHUNIT
      DO 1 J=1,2
      DO 8 I=1,3
      CALL FETTLE(U(I,J),IW,IF)
    8 CALL NUMA1(U(I,J),IW,IF,8,LINE3(7+8*I:14+8*I))
      DO 9 I=1,2
      CALL FETTLE(OUTLIM(I,J),IW,IF)
    9 CALL NUMA1(OUTLIM(I,J),IW,IF,7,LINE3(33+11*I:39+11*I))
      LINE3(2:2)=IXCHR(J)
      CALL KANGA2(CHUNIT,Y,TEMP,LINE3,62)
      IF (TEMP .GT. A) A=TEMP
    1 Y=Y-CHUNIT*2.
C
C COEFFICIENT TYPE AND SCALE FACTOR:
      J=ITYPE(MODEF)
      CALL FETTLE(SCALF1,IW,IF)
      CALL NUMA1(SCALF1,IW,IF,9,LINE4(42:50))
      LINE4(18:27)=MTYP(J)
      CALL KANGA2(CHUNIT,2.3*CHUNIT,TEMP,LINE4,50)
      IF (TEMP .GT. A) A=TEMP
C
C DECIDE ON MESSAGE ABOUT RESOLUTI0N FUNCTION
      IF (DELTA .NE. 0.) GO TO 11
      CALL KANGA2(8.*CHUNIT,CHUNIT/2.,TEMP,LINE6,22)
      IF (TEMP .GT. A) A=TEMP
      GO TO 101
  11  TWODEL=2.*DELTA
      CALL FETTLE(TWODEL,IW,IF)
      CALL NUMA1(TWODEL,IW,IF,8,LINE5(38:45))
      CALL KANGA2(CHUNIT,0.3*CHUNIT,TEMP,LINE5,45)
      IF (TEMP .GT. A) A=TEMP
C
C DRAW BOXES TO BE ROUND EXPLANATORY TEXT:
 101  CALL FRAME(0.,0.,A+2.*CHUNIT,10.*CHUNIT)
      CALL KANGA1(0.,4.*CHUNIT,3)
      CALL KANGA1(A+2.*CHUNIT,4.*CHUNIT,2)
      CALL KANGA1(A+2.*CHUNIT,8.*CHUNIT,3)
      CALL KANGA1(0.,8.*CHUNIT,2)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PMTINV(A,B)
      SUBROUTINE PMTINV(A,B)
C
C *** PMTINV by JCM 18 May 84 ***
C
CX
CC 14B
CH Specialist routine to invert a 2x3 matrix, such as those which transform
CH plotting coordinates from one space to another.
C
CA On entry A holds a 2x3 matrix as A(2,3)
CA On exit  B(2,3) holds the matrix representing the inverse transformation.
C
      DIMENSION A(2,3),B(2,3)
      D=1./(A(1,1)*A(2,2)-A(1,2)*A(2,1))
      B(1,1)=A(2,2)*D
      B(1,2)=-A(1,2)*D
      B(1,3)=(A(1,2)*A(2,3) - A(1,3)*A(2,2))*D
      B(2,1)=-A(2,1)*D
      B(2,2)=A(1,1)*D
      B(2,3)=(A(1,3)*A(2,1)-A(1,1)*A(2,3))*D
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PMTMUL(A,B,C)
      SUBROUTINE PMTMUL(A,B,C)
C
C *** PMTMUL by JCM 1 May 84 ***
C
CX
CC 14B
CH Specialist routine to multiply together two 2x3 matrices, such as those
CH which transform plotting coordinates from one space to another.
C
CA On entry A and B are 2x3 real arrays
CA On exit  C represents the result of performing B then A.
C
      DIMENSION A(2,3),B(2,3),C(2,3)
C
      C(1,1)=A(1,1)*B(1,1)+A(1,2)*B(2,1)
      C(2,1)=A(2,1)*B(1,1)+A(2,2)*B(2,1)
      C(1,2)=A(1,1)*B(1,2)+A(1,2)*B(2,2)
      C(2,2)=A(2,1)*B(1,2)+A(2,2)*B(2,2)
      C(1,3)=A(1,1)*B(1,3)+A(1,2)*B(2,3)+A(1,3)
      C(2,3)=A(2,1)*B(1,3)+A(2,2)*B(2,3)+A(2,3)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE PRNTMP(L21)
      SUBROUTINE PRNTMP(L21)
C
C *** PRNTMP updated by PJB 29 Apr 88 ***
C
CX
CC 5B
CH Prints out a Fourier projection or one layer of a 3D Fourier.
C
CA On entry L21 is the number of I5 integers required on a line.
CP The values of points on the map must be in array dens in COMMON /MAPDA/,
CP They are usually put there by one of FOUR1Z, FOURGP, ERRMAP, or GETMAP
CP which of these is used is usually decided by FORIER in respons to requests
CP on the M "cards"
CO The array of values is rounded to I5 integers and printed in rows of L21
CO columns on unit LPT
C
C
      LOGICAL EXACT
      DIMENSION JDENS(100),IU(3,3)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
C
      WRITE (LPT,2000) NOBSIN,NUSED
2000  FORMAT ('1Layer of Fourier calculated reading',I10,' reflections',
     & ' and using',I10)
      IF (MODET .EQ. 1) THEN
      DO 4 I=1,3
   4  CALL INDFIX(U(1,I),IU(1,I))
      IF (NDIM .EQ. 2) WRITE (LPT,2001) (IU(I,3),I=1,3),((IU(I,J),
     & I=1,3),J=1,2)
2001  FORMAT (//' Fourier projection down',3I4,' axis'/' x-axis along',
     & 3I4,'  y-axis along',3I4)
      IF (NDIM .EQ. 3) WRITE (LPT,2002) (IU(I,3),I=1,3),OUTLIM(1,3),
     & ((IU(I,J),I=1,3),J=1,2)
2002  FORMAT (//' Fourier section through',3I4,' axis at height',
     & F8.4/' x-axis parallel to',3I4,'  y-axis parallel to',3I4)
      IF (NDIM .EQ. 4) WRITE (LPT,2007) (IU(I,3),I=1,3),OUTLIM(1,3),
     & SECEND,((IU(I,J),I=1,3),J=1,2)
2007  FORMAT (//' Bounded section on ',3I4,' axis from ',F7.4,' to'
     & ,F8.4/' x-axis parallel to',3I4,'  y-axis parallel to',3I4)
      ELSE
      WRITE (LPT,2009) (U(I,3),I=1,3),OUTLIM(1,3),((U(I,J),I=1,3),
     & J=1,2)
2009  FORMAT (//' Fourier section through',3F8.4,' axis at height',
     & F8.4/' x-axis parallel to',3F8.4,'  y-axis parallel to',3F8.4)
      ENDIF
      WRITE (LPT,2003) ((OUTLIM(I,J),I=1,3),J=1,2)
2003  FORMAT (/' Rows of constant x and columns of constant y'/' x',
     & ' varies down the page from',F6.3,' to',F6.3,' in steps of',F6.3/
     & ' y varies along a row from',F6.3,' to',F6.3,' in steps of',F6.3)
      NL = NY/L21
      NR = MOD(NY,L21)
      EXACT = (NR .EQ. 0)
      IF (.NOT. EXACT) NL=NL+1
      DO 1 IX = 1,NX
      CALL MESS(LPT,1,' ')
      M = IX
      DO 2 N = 1,NL
      NEND=L21
      IF (N .EQ. NL .AND. .NOT. EXACT) NEND=NR
      DO 3 I=1,NEND
      JDENS(I) = NINT(DENS(M))
    3 M = M+NX
    2 WRITE (LPT,2004) (JDENS(I),I=1,NEND)
2004  FORMAT (1X,100(I6))
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE QFOUIN(K,F,ALPHA,ENDD)
      SUBROUTINE QFOUIN(K,F,ALPHA,ENDD)
C
C *** QFOUIN DUMMY by JCM 20 Mar 84 ***
C
CX
CC 5B
CH In the library, simply a dummy routine.  If the user wishes some special
CH new input format for Fourier routines, he provides a new version of
CH QFOUIN.
C
CD Called when type 0 Fourier coefficient input is specified.  The user-
CD supplied routine must set:
CD K(1:3) = h,k,l
CD F(1:2) and PHASE according to the value of DTYP on an "M" card,
CD LOGICAL ENDD to be TRUE if there are no more items of data.
C
      LOGICAL ENDD
      DIMENSION K(3),F(2)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE READMP
      SUBROUTINE READMP
C
C *** READMP updated by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Reads into the array DENS a map previously written to file, unformatted.
C
CP Assumes simply that NX by NY numbers have been written to unit IDUMPR
C
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPRD/ZRDVAL(20),ZCRD,IRD,IZRD,IDUMPR
C
      I=0
      DO 1 IY=1,NY
      READ (IDUMPR) (DENS(I+J),J=1,NX)
   1  I=I+NX
      RETURN
      END
C
C
C
C
C LEVEL 3      FUNCTION RESOL(H,D)
      FUNCTION RESOL(H,D)
C
C *** RESOL by JCM 17 Apr 84 ***
C
CX
CC 5B
CH Calculates a resolution function for use with Fourier inversion.
CA On entry H(1:3) contains the indices h,k,l of a reflection.
CA          D is the resolution length in Angstroms.
CD The function value returned in RESOL multiplies the amplitude of the
CD term corresponding to H in the Fourier sum. The result corresponds
CD to averaging the density over a cube of edge 2D.
C
CP RECIP to set up the metric
C
      DIMENSION H(3),OH(3)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
C
      RESOL=1.
      IF (ABS(D) .LT. 0.00001) GO TO 100
      CALL ORTHO(H,OH,2)
      DO 1 I = 1,3
      A = TWOPI*OH(I)*D
      IF (ABS(A) .LT. .001) GO TO 1
      RESOL = RESOL*SIN(A)/A
    1 CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SAVMAP
      SUBROUTINE SAVMAP
C
C *** SAVMAP updated by JCM 10 May 88 ***
C
CX
CC 5B
CH Writes 1 layer of map to given file, plus information for later retrieval.
C
CP One of FOUR1Z, FOURGP etc must have been obeyed first to produce map.
C
CO Writes on first entry a header block, plus one map;  on subsequent entries,
CO one map, and on the final entry one map and a trailer block.
C
CO The material written is the value of Z, NOBS and NUSED, and the array DENS.
C
CN The map can be later got back by GETMAP.
C
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPSV/ZSVVAL(20),ZCSV,ISV,IZSV,NDUMPS,NSAV
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)

C
C
C NSAV=HOW MANY MAPS ALREADY SENT - IF 0, SEND HEADER:
      IF (NSAV .GT. 0) GO TO 2
C
C * THERE IS A STRONG SUSPICION THAT THE USE OF NTOTAL WILL SIMPLIFY THIS
C COUNT AND CHECK NUMBER OF CARDS IN FILE IO10:
      NCDS=0
      DO 5 I=1,26
   5  NCDS=NCDS+ICDNO(I)
      WRITE (NDUMPS) INREAD,ICDNO,NCDS
      ICD=0
      ID=0
   9  ID=ID+1
      IF (ID .GT. NTOTAL(1)) GO TO 6
      READ (IO10,REC=ID,FMT=1000) ICARD
1000  FORMAT (A80)
      WRITE (NDUMPS) ICARD
      IF (ICARD(1:1) .NE. 'Y' .AND. ICARD(1:1) .NE. 'Z')ICD=ICD+1
      GO TO 9
C
   6  IF (ICD .EQ. NCDS) GO TO 2
      WRITE (LPT,3000) IO10,NCDS
      WRITE (ITO,3000) IO10,NCDS
3000  FORMAT (/' ERROR ** FILE',I3,' AND VECTOR ICDNO ARE',
     & ' OUT OF STEP - ICDNO EXPECTS',I4,' CARDS')
C>> JCC Was      STOP
	CALL BMBOUT
	RETURN
C
C WRITE INFO FOR ONE MAP:
   2  WRITE (NDUMPS) OUTLIM(1,3),NOBSIN,NUSED,NX,NY
      I=0
      DO  4 IY=1,NY
      WRITE (NDUMPS) (DENS(I+J),J=1,NX)
   4  I=I+NX
      NSAV=NSAV+1
C
 101  IF (NSAV .EQ. 1) WRITE (LPT,2003) NCDS
2003  FORMAT (/' Header record with',I4,' cards written')
      IF (NDIM .EQ. 2) WRITE (LPT,2001) NSAV
2001  FORMAT (/' Map no.',I3,' saved')
      IF (NDIM .EQ. 3) WRITE (LPT,2002) NSAV,OUTLIM(1,3)
2002  FORMAT (/' Map no.',I3,' saved for Z=',F10.4)
      IF (ZCSV .LE. 99998.) GO TO 100
C
C WRITE TRAILER:
      WRITE (NDUMPS) 99999.,0,0,0,0
      CALL MESS(LPT,1,'Trailer record written')
 100  RETURN
      END
C
C
C
C
C LEVEL 11      SUBROUTINE SETFOU
      SUBROUTINE SETFOU
C
C *** SETFOU updated by JCM 22 Aug 86  ***
C
CX
CC 5A
CH Sets up data for Fourier map calculations.
CD Reads in:  one "N" card with the title
CD            several "M" cards with map information (including that
CD            for contour plotting if required by user)
CD Sets up:   COMMON ready for calls of FORIER, which will then organise
CD            the actual calculation of (possibly several) maps, and their
CD            plotting, printing and saving as requested.
CD
CD Sets defaults of: 3 dimensions if no M NDIM card is given
CD            no resolution if no M DELT card is given
CD            a scale for Fourier coefficients of 1. if no M SCAL card is given
CD            a map scale of 2.5 cm/Angstrom if no M CM/A card is given.
CD Checks that M cards have been read for DTYP, SMAX, FTYP, MESH.
CI Causes "N" and "M" cards to be read from the copy of the Crystal
CI Data File on unit IO10.
CO Writes its findings to unit LPT.
C
      LOGICAL TESTOV
      DIMENSION KLIM(3),UU(3,3),NPOINT(100)
      COMMON /CELPAR/CELL(3,3,2),V(2),ORTH(3,3,2),CPARS(6,2),KCPARS(6),
     & CELESD(6,6,2),CELLSD(6,6),KOM4
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /FRIED/FRIEDL,KOM8
      LOGICAL FRIEDL
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
      COMMON /MAPPR/ZPRVAL(20),ZCPR,IPR,IZPR
      COMMON /MAPRD/ZRDVAL(20),ZCRD,IRD,IZRD,IDUMPR
      COMMON /MAPSV/ZSVVAL(20),ZCSV,ISV,IZSV,NDUMPS,NSAV
      COMMON /MREAD/IMREAD(15)
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP

C
C RECIP MUST BE OBEYED FIRST (AND THEREFORE SYMOP ALSO)
      IF (INREAD(3) .GT. 0) CALL RECIP
C
C COMMENT THAT FRIED CANNOT BE USED (IF FALSE) HERE:
      IF (.NOT. FRIEDL) CALL MESS(LPT,1,
     & 'Friedel''s law being assumed for Fourier')
C
C READ, STORE AND PRINT TITLE FROM AN "N" CARD:
      CALL INPUTN(LPT)
C
C NOW READ ALL "M" CARDS:
      CALL INPUTM
C
C NOW CHECK ALL INFO GIVEN, AND WRITE OUT FOR THOSE CARDS NOT GIVEN
      IF (IMREAD(11) .EQ. 0) CALL ERRMES(2,1,
     & 'M DTYP card giving data input type')
C
      IF (IMREAD(12) .LE. 0) THEN
        CALL MESS(LPT,1,'No resolution function')
        DELTA=0.
      ENDIF
C
      IF (IMREAD(15) .LE. 0) CALL ERRMES(2,1,
     & 'sin theta/lambda maximum')
C
      IF (IMREAD(13) .EQ. 0) SCALF1=1.0
C
      IF (IMREAD(1) .LE. 0) THEN
        NDIM=3
        CALL MESS(LPT,1,'No M NDIM card - assuming 3D')
      ENDIF
C
      IF (IMREAD(2) .LE. 0) CALL ERRMES(2,1,
     & 'M FTYP card giving type of Fourier required')
C
      IF (IMREAD(3) .LE. 0) CALL ERRMES(2,1,
     & 'M MESH card giving mesh for output')
C
      IF ((IMREAD(6) .NE. 0) .AND. (IMREAD(7) .LE. 0)) THEN
        SCALMP=2.5
       CALL MESS(LPT,1,
     & 'Default scale of 2.5 cm/Angstrom for plotted map')
      ENDIF
C
C SET UP SCALE ACCORDING TO NUMBER OF DIMENSIONS:
      IF (IMREAD(4) .EQ. 0) THEN
        CALL GMUNI(U,3)
        MODET=0
      ENDIF
      IF (MODET.EQ.1) THEN
        M=1
      ELSE
        M=0
      ENDIF
      CALL USYM(M)
C
C WE ARE NOW DOWN TO DECIDING WHERE THE MAP IS TO COME FROM, AND WHAT IS
C TO BE DONE WITH IT ONCE WE HAVE IT.
C
C SAVE, GET, READ, PRIN AND PLOT CARDS HAVE ALL BEEN INTERPRETED IN INPUTM.
C HERE WE NEED ONLY MAKE SURE WE HAVE SOMETHING SENSIBLE TO DO.
C
C FIRST SORT ALL LISTS INTO ASCENDING ORDER:
      IF (NCONT .GT. 0) THEN
        CALL SORTX(CONT,NPOINT,NCONT)
        CALL RESHUF(CONT,NPOINT,NCONT)
      ENDIF
      IF (IZPR .GT. 0) THEN
        CALL SORTX(ZPRVAL,NPOINT,IZPR)
        CALL RESHUF(ZPRVAL,NPOINT,IZPR)
      ENDIF
      IF (IZPL .GT. 0) THEN
        CALL SORTX(ZPLVAL,NPOINT,IZPL)
        CALL RESHUF(ZPLVAL,NPOINT,IZPL)
      ENDIF
      IF (IZSV .GT. 0) THEN
        CALL SORTX(ZSVVAL,NPOINT,IZSV)
        CALL RESHUF(ZSVVAL,NPOINT,IZSV)
      ENDIF
      IF (IZRD .GT. 0) THEN
        CALL SORTX(ZRDVAL,NPOINT,IZRD)
        CALL RESHUF(ZRDVAL,NPOINT,IZRD)
      ENDIF
      IF (IZGT .GT. 0) THEN
        CALL SORTX(ZGTVAL,NPOINT,IZGT)
        CALL RESHUF(ZGTVAL,NPOINT,IZGT)
      ENDIF
C
      IF ((IMREAD(5) .LE. 0).AND.(IMREAD(6) .LE. 0).AND.(IMREAD
     & (9) .LE. 0)) CALL ERRMES(1,1,
     & 'no M PRIN, M PLOT or M SAVE cards')
C
      SCALF2=V(2)
      IF (NDIM .EQ. 2) SCALF2=SCALF2*VCTMOD(1.,U(1,3),1)
C
C CALCULATE AND CHECK MAXIMUM VALUES OF INDICES, LIMITS ETC:
      CALL GMUNI(UU,3)
      IF (MODET .EQ.1) CALL GMEQ(U,UU,3,3)
      DO 1 I=1,2
      KLIM(I)=IFIX(VCTMOD(2.*SMAX,UU(1,I),1))
      IF (TESTOV(1.,OUTLIM(3,I))) THEN
        CALL ERRIN2(I,1,'zero step length for Fourier in direction',' ')
        GO TO 1
      ENDIF
C
      IF (OUTLIM(3,I) .LE. 0.) THEN
        WRITE (LPT,3001) OUTLIM(3,I),I
        WRITE (ITO,3001) OUTLIM(3,I),I
3001    FORMAT (' ERROR ** Negative step for Fourier',F10.4,
     & ' in direction',I2)
        IERR=IERR+1
        GO TO 1
      ENDIF
C
      NN=NINT((OUTLIM(2,I)-OUTLIM(1,I)+10.E-5)/OUTLIM(3,I)) +1
      IF (I .EQ. 1) NX=NN
      IF (I .EQ. 2) NY=NN
      IF (NN .GT. 0) GO TO 1
      WRITE (LPT,3002) NN,I
      WRITE (ITO,3002) NN,I
3002  FORMAT (' ERROR ** Negative number',I3,' of points ',
     & 'required for Fourier in direction',I2)
      IERR=IERR+1
   1  CONTINUE
C
C CHECK STORAGE LIMITS:
      NH=2*KLIM(1)+1
      NK=KLIM(2)+1
      NHK=2*NH*NK
      IF (NHK .GT. 10201) THEN
        WRITE (LPT,3010) KLIM(1),KLIM(2),NHK
        WRITE (ITO,3010) KLIM(1),KLIM(2),NHK
3010    FORMAT (/' ERROR ** Too much data for Fourier store'/
     &  ' h max=',I4,' k max=',I4, 'needing space',I7,' - only 10201',
     &  ' available')
C>> JCC WAS STOP
        CALL BMBOUT
	  RETURN
      ENDIF
C
      NXY=NX*NY
      IF (NXY .GT. 10201) THEN
        WRITE (LPT,3011) NX,NY,NXY
        WRITE (ITO,3011) NX,NY,NXY
3011    FORMAT (/' ERROR ** Too much data for Fourier store'/
     & ' No. of points in x direction =',I5/
     & ' no. of points in y direction =',I5/
     & ' requiring store',i7,' - only 10201 available')
C>> JCC WAS STOP
        CALL BMBOUT
	  RETURN
      ENDIF
C
      IF (MODET.EQ.2) THEN
C  REDEFINE NH,NK,NHK TO BE MAX VALUES OF INDICES FOR GENERAL PLANE FOURIER
        NHK=IFIX(VCTMOD(2.*SMAX,UU(1,3),1))
        NH=KLIM(1)
      ELSE
        NKX=2*NK*NX
        IF (NKX .GT. 10201) THEN
          WRITE (LPT,3012) KLIM(1),NX,NKX
          WRITE (ITO,3012) KLIM(1),NX,NKX
3012      FORMAT (/' Error ** too much data for Fourier store'/
     &    ' k max =',I4,' no. of points in x direction =',I5/
     &    ' requiring store',i7,' - only 10201 available')
          CALL BMBOUT
	    RETURN
        ENDIF
C
        CALL ERRCHK(1,KLIM(1)+1,100,0,'h values in Fourier')
        CALL ERRCHK(1,NK,100,0,'k values in Fourier')
      ENDIF
C
C NOW DISCOVER WHETHER PLOTTING
      IF (IMREAD(6) .NE. 0) CALL STPLOT
      IF (IERR .NE. 0) CALL ERRMES(1,0,'during SETFOU')
C
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE SPCSET(N)
      SUBROUTINE SPCSET(N)
C
C *** SPCSET updated by JCM 14 Nov 89 ***
C
CX
CC 14B
CH Defines the "space" in which coordinates will be given for plotting.
CA On entry N is the number of the space in which subsequent "plot"
CA            coordinates will be given.
C
CD The current space is held in NSPCE in COMMON /PLTRAN/.
CD  Coordinate systems useful in most plotting applications:
CD        1=Plotter (actual coordinates on a particular graphical output device)
CD        2=CCSL (the coordinates in which the programs are written)
CD Coordinate sytems 3 to 7 are for user applications; for example in plotting
CD Fourier maps they are used as follows:
CD        3=Picture (one "picture" which contains one section of the map)
CD        4=Map (The crystallographically related axes of the Fourier
CD               calculation).
CD        5=Character type 1 (in contouring, the text under the map)
CD        6=Character type 2 ( the title over the map)
CD        7=Character type 3 (the contour list panel)
C
CD A new conversion matrix is set up into PTRAN(,,1).
CD It should take a point expressed in current coordinates (space N) into
CD plotter coordinates (space 1).
C
CP PLTRIN  must have been used to set up matrices defining the
CP transformation from space N to "plotter" space.
C
CP For plotting FOURIERS:
CP Matrix 1 takes CCSL into plotter
CP Matrix 2 takes picture into CCSL
CP Matrix 3 takes map into picture
CP Matrix 4 takes char 1 into picture
CP Matrix 5 takes char 2 into picture (if required)
CP Matrix 6 takes char 3 into picture (if required)
CP
CP These must have been set up initially.  They are mostly unchanging,
CP but to move from one picture to the next we alter column 3 of matrix 2.
C
      DIMENSION PTEMP(2,3)
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
C
C CHECK PLAUSIBLE N:
      IF (N .LE. 0 .OR. N .GT. MAXSP) CALL ERRIN2(N,0,
     & 'cannot set space','in SPCSET')
C
   1  IF (N .GT. 1) GO TO 2
      CALL GMZER(PTRAN(1,1,1),2,3)
      CALL GMUNI(PTRAN(1,1,1),2)
      GO TO 101
C
C ANY SPACE OTHER THAN 1:
   2  M=N-1
      CALL GMEQ(PMTRIX(1,1,M),PTRAN(1,1,1),2,3)
C
C HAVE WE REACHED PLOTTER SPACE YET?
   3  M=NTRAN(M)-1
      IF (M .LT. 0) CALL ERRIN2(N,0,'Space',
     & 'in plotting not available - check setting up')
      IF (M .EQ. 0) GO TO 101
      CALL PMTMUL(PMTRIX(1,1,M),PTRAN(1,1,1),PTEMP)
      CALL GMEQ(PTEMP,PTRAN(1,1,1),2,3)
      GO TO 3
C
 101  NSPCE=N
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE STPLOT
      SUBROUTINE STPLOT
C
C *** STPLOT updated by JCM 26 Sep 87 ***
C
CX
CC 14A
CH Sets up the plotting of maps;  fits elements of a picture together.
C
CP Plotting of a Fourier map must be set up by SETFOU.  In particular:
CP NX=number of x values wanted for plotted points
CP NY=number of y values wanted for plotted points
CP PMAP(2,2) in /CONTUR/ holds the matrix which converts map coords
CP       to cms, set by USYM.
CP There is a title in ITITLE, of length NTITLE, read by INPUTN
C
CD Calls the special plotting routine PIGLET to do whatever is necessary
CD locally to start using graphical output.
CD
CD Decides the scales of various sizes of characters which will be
CD written on a picture.  Sets up all conversion matrices needed in
CD subsequent map plotting, by calculating the layout of the various
CD elements of a picture (map, title, expanatory text, etc) within its
CD frame.
CD
CD Finally calls PIGLET to do whatever is required locally to start the
CD whole plot, now we know how big it will be.
C
      DIMENSION PTEMP(2,3)
      COMMON /BITMAP/IBIT(108,4),NWORDS
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /LENINT/NBITS
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NTITL/NTITLE,KOM14
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      COMMON /TITLE/ITITLE
      CHARACTER *80 ITITLE
C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0

C
C INITIALISE ANY SPECIAL HARDWARE QUANTITIES FOR PLOTTER:
      CALL PIGLET(0.,0.,0)
	IF (IBMBER .NE. 0) RETURN
C
C SET UP NWORDS=NUMBER OF CONSECUTIVE INTEGERS OF LENGTH NBITS NEEDED TO
C TAKE 108 BITS (OR WHATEVER IS SET UP):
C%
C      NWORDS=IFIX(%CBIT%./FLOAT(NBITS))+1
      NWORDS=IFIX(108./FLOAT(NBITS))+1
C
C WE MUST CHECK THAT THERE IS ROOM FOR NX ROWS + 2 EDGES IN THE LONG
C DIMENSION OF IBIT, AND THAT BOTH THE NUMBER OF ROWS AND THE NUMBER OF COLUMNS
C WILL FIT IN THE "BITS ALLOWED PER ROW", WHICH IS THE SHORTER DIMENSION
C OF IBIT TIMES THE WORD LENGTH IN NBITS.
C
C NBITS IS ACTUALLY THE WORD LENGTH MINUS ONE, TO AVOID THE SIGN BIT.
C
C%
C      M1DIM=%CBIT%
      M1DIM=108
      M2=NX+2
      MSIZE=NBITS*NWORDS
      M1DIM2=M1DIM-2
      IF (M1DIM2 .LT. NX) THEN
        WRITE (LPT,3000) M1DIM2,NX
        WRITE (ITO,3000) M1DIM2,NX
3000    FORMAT (' ERROR ** Too many x values to plot -',I5,
     &  ' allowed by parameter CM1-2,',I5,' given')
C>> JCC Was STOP
        CALL BMBOUT
	  RETURN
      ENDIF
C
      IF (NX .GT. MSIZE) THEN
        WRITE (LPT,3001) NX,NBITS,NWORDS
        WRITE (ITO,3001) NX,NBITS,NWORDS
3001    FORMAT (' ERROR ** Too many x values to plot -',I5,
     &  ' requested - NBITS,NWORDS in STPLOT=',2I5)
C>> JCC Was STOP
        CALL BMBOUT
	  RETURN
      ENDIF
C
      IF (NY .GT. MSIZE) THEN
        CALL ERRIN2(NY,-1,'too many y values to plot -','requested')
        WRITE (LPT,3003) MSIZE,NWORDS,NBITS
        WRITE (ITO,3003) MSIZE,NWORDS,NBITS
3003    FORMAT (' but only space for',I5,' arising from',I5,' words',
     &  ' using',I5,' bits in each')
C>> JCC Was STOP
        CALL BMBOUT
	  RETURN	  
      ENDIF
C
      FX=FLOAT(NX-1)
      FY=FLOAT(NY-1)
C
C PMAP HAS BEEN SET UP IN USYM FOR MAP TO CMS CONVERSION:
      HGTMAP=-PMAP(2,1)*FX
C WIDTH OF PROJECTING PIECE OF MAP:
      WIDPRO=ABS(PMAP(1,1)*FX)
      WIDMAP=WIDPRO+PMAP(1,2)*FY
C
C DECIDE CHARACTER SCALES - FIRST TYPE 1, THE TEXT BLOCK:
C FIRST TRY TO MAKE THE TEXT BLOCK THE SAME WIDTH AS THE MAP:
      CHSCAL(1,1)=WIDMAP/1050.
C 1050 IS A GUESS, BEING  AN ARBITRARY AMOUNT TO BE THE WIDTH OF A LINE
C OF TEXT, THE WHOLE THING BEING IN CHARACTER COORDINATES.  THE BEST SIZE FOR
C THE FRAME IS CALCULATED IN PLTTXT.
      CHSCAL(2,1)=ASPECT*CHSCAL(1,1)
C IF CHARS TYPE 1 ARE MORE THAN 1 CM OR LESS THAN 0.2 CMS, ADJUST SO THAT THEY
C HIT THE LIMIT:
      CLIM1=1./CHUNIT
      CLIM2=0.2/CHUNIT
      IF (CHSCAL(2,1) .GT. CLIM1) CHSCAL(2,1)=CLIM1
      IF (CHSCAL(2,1) .LT. CLIM2) CHSCAL(2,1)=CLIM2
      CHSCAL(1,1)=CHSCAL(2,1)/ASPECT
C ALL WIDTHS OF ITEMS IN PICTURE ARE WANTED IN CMS:
      WIDTXT=CHSCAL(1,1)*1050.
      HGTTXT=10.*CHSCAL(2,1)*CHUNIT
C THE 10 COVERS 5 LINES OF TEXT AND 5 BLANKS IN BETWEEN
C
C CHAR TYPE 1 IS DEFINITIVE FOR ALL THE WHITE SPACE AND INTERNAL BORDERS:
      XWHITE=CHSCAL(1,1)*CHUNIT
      YWHITE=CHSCAL(2,1)*CHUNIT
      XMARG=4.*XWHITE
      YMARG=4.*YWHITE
C
C NOW CHARACTER TYPE 2, THE TITLE.  WE MAKE THIS MATCH THE TEXT BLOCK BY
C TRYING TO MAKE THEIR WIDTHS THE SAME, BUT IF THIS GIVES CHAR TYPE 2 OF
C MORE THAN 1.5 CMS HIGH, WE ALLOW IT TO BE SMALLER:
C
C FIRST MEASURE LENGTH OF TITLE IN CHARACTER UNITS:
      CALL KANGA2(0.,0.,TLEN,ITITLE,-NTITLE)
      TLEN=TLEN+2.*CHUNIT
      CHSCAL(1,2)=WIDTXT/TLEN
      CLIM1=1.5/CHUNIT
      IF (CHSCAL(1,2) .GT. CLIM1) CHSCAL(1,2)=CLIM1
      CHSCAL(2,2)=CHSCAL(1,2)*ASPECT
      WIDTTL=TLEN*CHSCAL(1,2)
      HGTTTL=2.*CHSCAL(2,2)*CHUNIT
C
C DO NOTHING ABOUT CHARACTER TYPE 3 - CONTOUR LIST PANEL YET:
C A DIGIT IS 20 PLOTTER UNITS WIDE - PRETEND USING TYPE 1 FOR NOW:
      WIDCON=220.*CHSCAL(1,1)
      WIDMAX=WIDMAP
      IF (WIDTXT .GT. WIDMAP) WIDMAX=WIDTXT
      WIDPIC=3.*XMARG+WIDMAX+WIDCON
      HGTPIC=4.*YMARG+HGTMAP+HGTTXT+HGTTTL+2.*YWHITE
C
C NOW SET UP THE VARIOUS MATRICES WHICH MOVE FROM ONE SPACE TO ANOTHER:
C
C A TRANSFORMATION TAKES THE FORM:
C        A B C    OLD X = NEW X
C        D E F    OLD Y   NEW Y
C                  1
C SO A,B,D,E ROTATES OLD X,OLD Y AND C,F GIVES A TRANSLATION.  THUS C AND
C F ARE IN THE SAME UNITS AS NEW X, NEW Y.
C
C PMTRIX 1 MOVES FROM CCSL TO PLOTTER - IT HAS BEEN SET UP IN PINTIL
C
C PMTRIX 2 MOVES FROM PICTURE TO CCSL - WE HAVE NO REASON TO ALTER THE SCALE OR
C ORIENTATION OF A PICTURE IN CCSL SPACE.  (IF, LATER, WE WANT TO DO THIS, HERE
C IS THE PLACE TO DO IT.)
C
C THIS MATRIX IS THE ONLY ONE WHICH CHANGES ONCE SET UP - ITS THIRD COLUMN IS
C THE ONE WHICH MOVES FROM PICTURE TO PICTURE, POSSIBLY PUTTING SEVERAL
C SIDE BY SIDE ON WIDE PAPER.
C
C FIRST CALCULATE HOW SEVERAL PICTURES CAN FIT ON THE PLOTTER:
      IF (HGTPIC .GE. PAPERW) THEN
        WRITE (LPT,3004) HGTPIC,PAPERW
        WRITE (ITO,3004) HGTPIC,PAPERW
3004    FORMAT (' ERROR ** picture of height',F10.2,'cms requested',
     &  ' but plotter paper given as only',F10.2,'cms')
C>> Was STOP
        CALL BMBOUT
	  RETURN        
      ENDIF
C
      NYPIC=IFIX(PAPERW/(HGTPIC+BORDER))
      N1=(IZPL-1)/NYPIC + 1
      N2=NYPIC
      IF (N1 .EQ. 1) N2=IZPL
C
C TOTAL SIZE OF PLOT IN CMS:
      WIDTOT=(WIDPIC+BORDER)*FLOAT(N1)
      HGTTOT=(HGTPIC+BORDER)*FLOAT(N2)
C
C INITIALISE COUNT ACROSS PAGE:
      IYPIC=0
C
C USE PLTRIN TO PUT MATRICES 3 4 5 AND 6 IN PLACE:
C
C PMTRIX 3 TAKES MAP COORDINATES INTO PICTURE COORDINATES.  THE ROTATION
C PART HAS BEEN SET UP BY USYM AND IS IN PMAP IN /CONTUR/
C
      CALL GMEQ(PMAP,PTEMP,2,2)
C MAP ORIGIN IN PICTURE COORDS:
      XO=XMARG
      DIFF=(WIDTXT-WIDMAP)/2.
      IF (DIFF .GT. 0.) XO=XO+DIFF
      IF (WIDPRO .GT. 0.) XO=XO+WIDPRO
      PTEMP(1,3)=XO
C
      PTEMP(2,3)=2.*YMARG+HGTTXT+3.*YWHITE+HGTMAP
      CALL PLTRIN(PTEMP,4,3)
	IF (IBMBER .NE. 0) RETURN
C
C NOW THE CHARACTERS INTO PICTURE MATRICES.  ALL THE ROTATIONS ARE AT
C PRESENT SIMPLE SCALES, NOT ACTUAL ROTATIONS.
C
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,1)
      PTEMP(2,2)=CHSCAL(2,1)
C
C PMTRIX 4 TAKES CHARACTERS OF TYPE 1 INTO PICTURE COORDS.  THE ORIGIN HERE
C IS THE BOTTOM LEFT HAND CORNER OF THE TEXT BLOCK:
      XO=XMARG
      IF (DIFF .LT. 0.) XO=XO-DIFF
      PTEMP(1,3)=XO
      PTEMP(2,3)=YMARG
      CALL PLTRIN(PTEMP,5,3)
	IF (IBMBER .NE. 0) RETURN
C
C PMTRIX 5 IS FOR CHARACTER TYPE 2, THE TITLE CHARACTERS.  THE ORIGIN IS THE
C BOTTOM LEFT HAND CORNER OF THE TITLE BLOCK:
C
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,2)
      PTEMP(2,2)=CHSCAL(2,2)
      DIFF1=(WIDMAP-WIDTTL)/2.
      IF (DIFF .GT. 0.) DIFF1=DIFF1+DIFF
      IF (DIFF1 .LT. 0.) DIFF1=0.
      PTEMP(1,3)=DIFF1+XMARG
      PTEMP(2,3)=HGTPIC-YMARG-HGTTTL
      CALL PLTRIN(PTEMP,6,3)
	IF (IBMBER .NE. 0) RETURN
C
C PMTRIX 6 IS FOR CHARACTER TYPE 3, THE CONTOUR LIST.  THE ORIGIN IS NOT
C YET DETERMINED AS WE DO NOT KNOW HOW MANY CONTOURS WILL BE FOUND
C
C
C WE ARE NOW IN A POSITION TO CALL WHATEVER SPECIAL ROUTINE IS NEEDED TO START
C A PLOT, REQUESTING A PIECE OF PAPER HGTTOT WIDE (ACROSS PLOTTER) AND WIDTOT
C LONG (ALONG LENGTH OF PLOTTER, OFTEN APPROACHING INFINITY IF REALLY A PLOTTER)
C
C WHEN WE START TO APPLY THIS TO VDUS, OUR REQUIRED SCREEN (IN CMS) IS
C WIDTOT WIDE AND HGTTOT HIGH.  BUT WE WOULD IN PRACTICE ASK FOR WIDPIC TIMES
C HGTPIC BECAUSE OF DRAWING ONE AT A TIME.  LEAVE THIS FOR NOW.
C
      IF (FROMCM .GT. 0)   CALL PIGLET(WIDTOT,HGTTOT,999)	
      IF (FROMCM .LE. 0)   CALL PIGLET(WIDPIC,HGTPIC,999)
	IF (IBMBER .NE. 0) RETURN
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE SYMEQU(HI,H,K,N,MI,UU,BETA)
      SUBROUTINE SYMEQU(HI,H,K,N,MI,UU,BETA)
C
C *** SYMEQU updated by PJB 29 Apr 88 ***
C
CX
CC 5B
CH Generates new indices and a phase, in Fourier calculations.
C
CA On entry HI is a 1x3 vector containg h,k,l
CA          N is the number of a symmetry operator
CA          H is an array of indices already found for this HI
CA          MI is the number of entries in H.
CA On exit  EH holds the new h,k,l
CA          UU=0. if these indices have occurred before in the array H
CA             or, if NDIM=2 or 3, =-1 if the (-h,-k,-l) operator was
CA                 necessary to put EH into the correct half of reciprocal
CA                  space with l >=0,
CA                                  +1 if (-h,-k,-l) was not used.
CA            or, if NDIM=2, the transformed l is non-zero;
CA            or, if NDIM=4 for a bounded section, UU= the coefficient
CA                needed for this EH in the sum.
CA          BETA is the phase for this h,k,l.
C
CP Fourier calculations should be set up by SETFOU.
C
      DIMENSION HI(3),EH(3),K(3),H(1)
      COMPLEX BOUND
      LOGICAL TESTOV
C
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
      UU=1.
      CALL ROTSYM(HI,EH,N,2)
      CALL INDFIX(EH,K)
      IF (K(2)) 4,3,2
   3  IF (K(1)) 4,5,2
   5  IF (K(3)) 4,2,2
   4  DO 6 I=1,3
      K(I)=-K(I)
      EH(I)=-EH(I)
   6  CONTINUE
C TO ENSURE FRIEDEL EXACT HALF
      UU=-UU
   2  CALL EQVEC(H,EH,MI,M,NOP)
C DO NOT USE IF EXACTLY THIS HKL HAS ALREADY OCCURRED FROM THIS CYCLE:
      IF (M .LE. MI) GO TO 101
      MI = M
C ONLY TEST L IF 2D:
      IF ((NDIM .EQ. 2) .AND. (K(3) .NE. 0)) GO TO 101
      TRA = 0.
      DO 31 I = 1,3
      Q = -SECZER(I)
      IF (NDIM.NE.3 .AND. I.EQ.3) Q=0
      IF (MODEF .NE. 6) Q=Q+TRANS(I,N)
      TRA = TRA+EH(I)*Q
  31  CONTINUE
      BETA = TWOPI*TRA
      IF (NDIM.NE.4) GO TO 100
      IF (TESTOV(1.,EH(3))) GO TO 100
      ARG=TWOPI*EH(3)
      BOUND=CEXP(CMPLX(0.,-ARG*SECEND))
     & -CEXP(CMPLX(0.,-ARG*SECZER(3)))
      BOUND=BOUND*CMPLX(0.,1./ARG)
      ABOUND=CABS(BOUND)
      UU=UU*ABOUND/(SECEND-SECZER(3))
      IF (ABOUND.GT.10E-5)
     &  BETA=BETA+ATAN2(AIMAG(BOUND),REAL(BOUND))
      GO TO 100
C
 101  UU=0.
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE TBOUND(IFOUND)
      SUBROUTINE TBOUND(IFOUND)
C
C *** TBOUND by PJB Aug 86 ***
C
CX
CC 5B
CH A specialist routine used duing the plotting of atomic positions
CH in main program ATMPLO.
C
      DIMENSION Y(3)
C%
C      COMMON/SCRAT/AA(3,3),TRXX(3,%SY*2%),TLAT(3,4),BOUNDS(2,6),XX(3,3),
      COMMON/SCRAT/AA(3,3),TRXX(3,48),TLAT(3,4),BOUNDS(2,6),XX(3,3),
     & TMPV1(3),TMPV2(3),TMPV3(3),TTXX(3,50),NT
      EQUIVALENCE(Y,TMPV1)
C
C  FIRST GET JUST INSIDE THE LOWER BOUND
      IFOUND=0
      CALL GMEQ(Y,XX(1,NT),1,3)
      DO 3 I=1,NT
    1 DIFF=XX(I,NT)-BOUNDS(1,I)
      IF (DIFF.GT. -.001) GO TO 2
      XX(I,NT)=XX(I,NT)+1.
      GO TO 1
C
C  HERE IF INSIDE LOWER BOUND, SEE IF LOWEST POSSIBLE
    2 IF (DIFF.LT.1.) GO TO 3
      XX(I,NT)=XX(I,NT)-1.
      DIFF=DIFF-1.
      GO TO 2
    3 CONTINUE
C
C  NOW TEST UPPER BOUND
      J=NT
   12 IF (BOUNDS(2,J)-XX(J,J).LT.-.001) GO TO 10
      IF (J.EQ.1) THEN
C  TEST IF STRICLY INSIDE BOX
      CALL GMPRD(XX(1,1),AA,TMPV2,1,3,3)
      DO 21 I=1,3
      IF (TMPV2(I).LT.BOUNDS(1,3+I) .OR. TMPV2(I).GT.BOUNDS(2,3+I))
     &  GO TO 10
   21 CONTINUE
      IFOUND=IFOUND+1
      CALL GMEQ(TMPV2,TTXX(1,IFOUND),1,3)
      XX(1,1)=XX(1,1)+1.
      ELSE
      CALL GMEQ(XX(1,J),XX(1,J-1),1,3)
      J=J-1
      ENDIF
      GO TO 12
C
C  HERE IF TESTED POINT OUTSIDE
   10 IF(J.EQ.NT) GO TO 100
      J=J+1
      XX(J,J)=XX(J,J)+1.
      GO TO 12
C
C  HERE WHEN NO MORE POSSIBILITIES
 100  RETURN
C
      END
C
C
C
C
C LEVEL 3      SUBROUTINE USYM(N)
      SUBROUTINE USYM(N)
C
C *** USYM by JCM 19 Mar 83 ***
C
CX
CC 5A
CH Transforms all the symmetry operators by pre- and post-multiplying
CH them by U, the orientation matrix for a Fourier map.
C
CA On entry N=0 if no matrix U has in fact been read.
C
CP Fourier calculations should be set up by SETFOU;  in particular the
CP number of dimensions, NDIM, is needed.
C
CD Each symmetry matrix R except the first is replaced by:
CD         (U)**-1 * R * U
CD and each translation operator T by (U)**-1 * T
C
CD The routine also fills in the matrix PMAP(2,2), using the matrix
CD U expressed on the standard orthogonal axes.  This matrix is
CD then used in a "map to picture" conversion during plotting.
C
CN If the original symmetry matrices are ever needed we can recover the
CN transformations from the first element.
C
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
C%
C      COMMON /SCRAT/B(3,3,%SYMO%),A(3,3),C(3,3),TT(3)
      COMMON /SCRAT/B(3,3,24),A(3,3),C(3,3),TT(3)
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
C
      CALL GMEQ(U,A,3,3)
C
C IF UNIT MATRIX, SKIP INVERSION:
      IF (N .EQ. 0) GO TO 10
      CALL TRINV3(A,D)
      WRITE (LPT,2000) D
2000  FORMAT (/' Unit cell transformed for Fourier is ',F6.2,' times',
     & ' original cell')
      IF (ABS(D) .GT. 0.0001) GO TO 2
      CALL ERRMES(1,1,'3 axes of transformed map are coplanar')
      GO TO 100
C
C INTO A PUT INVERSE OF U (NOT TRANSPOSED)
   2  CALL TRANSQ(A,3)
      DO 1 N=2,NOPC
      CALL GMPRD(SYM(1,1,N),U,B(1,1,N),3,3,3)
      CALL GMPRD(A,TRANS(1,N),TT,3,3,1)
      CALL GMEQ(TT,TRANS(1,N),1,3)
   1  CONTINUE
C
C COPY MATRICES BACK:
      DO 3 N=2,NOPC
      CALL GMPRD(A,B(1,1,N),SYM(1,1,N),3,3,3)
   3  CONTINUE
C
  10  DO 4 I=1,3
   4  CALL ORTHO(U(1,I),A(1,I),1)
      GO TO (100,5,6), NDIM
C 2-D PROJECTION:
    5 CALL UNIVEC(A(1,3),TT(3))
      DO 7 I=1,2
      CALL VECPRD(A(1,I),A(1,3),C(1,I))
      CALL UNIVEC(C(1,I),TT(I))
   7  CONTINUE
      COSPHI=SCALPR(C(1,1),C(1,2))
      GO TO 8
C
C 3-D:
   6  DO 9 I=1,2
   9  CALL UNIVEC(A(1,I),TT(I))
      COSPHI=SCALPR(A(1,1),A(1,2))
C
   8  CALL SINCOS(COSPHI,SINPHI,'USYM')
      TEMP=TT(1)*OUTLIM(3,1)*SCALMP
      PMAP(1,1)=TEMP*COSPHI
      PMAP(2,1)=-TEMP*SINPHI
      PMAP(1,2)=TT(2)*OUTLIM(3,2)*SCALMP
      PMAP(2,2)=0.0
 100  RETURN
      END
C
C

!
!*****************************************************************************
!
! Originally in PCDruid_Main.f90
!
! This doesnt work for chm files, only hlp files - I think we have to upgrade the compiler for it to work with chm files
!     SUBROUTINE LaunchWinHelp()
!       USE VARIABLES
!       USE dfwin
!     CHARACTER*100 lpszHelpFileName, lpszContents
!       integer hWnd
!       logical ret

!       lpszHelpFileName ="G:\\ConQuest.chm"C
!      lpszContents = "CONTENTS"C

!      ret = WinHelp (hWnd, lpszHelpFileName, HELP_KEY, LOC(lpszContents) )
!       END SUBROUTINE LaunchWinHelp
!
!*****************************************************************************
!
!      SUBROUTINE TIC_file_Open()
!
!   This subroutine processes Open TIC file selection
!
!      USE WINTERACTER
!      USE VARIABLES
!
!      IMPLICIT NONE
!
!      CHARACTER(LEN=256) :: FILTER
!      INTEGER            :: IFLAGS
!      CHARACTER(LEN=80) STATBARSTR
!      COMMON /STATBAR/ STATBARSTR(10)
!C>> JCC Declaration for trapping tic file return
!      INTEGER TicRead
!      INTEGER Load_TIC_File
!      INTEGER IPTYPE
!      COMMON /PLTYPE/ IPTYPE

!   Check if file needs saving
!      IF (SAVEF) THEN
!        CALL WMessageBox(YesNo,QuestionIcon,CommonOK,'Program contains an'//&
!        ' unsaved project.'//CHAR(13)//'Do you wish to '// &
!        'continue?','Open Project')
!   If answer 'No', return
!        IF (WInfoDialog(4) .EQ. 2) RETURN
!      END IF
!   If answer 'Yes'
!      SAVEF = .FALSE.
!      CALL FieldUpdate()
!      IFLAGS = LoadDialog + DirChange + PromptOn
!      FILTER = 'Peak position files (*.tic)|*.tic|'
!      FNAME=' '
!      CALL WSelectFile(FILTER,IFLAGS,FNAME,'Open peak position file')
!   Place your file load code here
!C>> JCC Trap return, and if successful replot the data
!      TicRead = Load_TIC_File(LEN_TRIM(FNAME),FNAME)
!      IF (TicRead .EQ. 1) CALL Profile_Plot(iptype)
!C>> Was
!     CALL Load_TIC_File(LEN_TRIM(FNAME),FNAME)
!      STATBARSTR(1)=FNAME
!      CALL WindowOutStatusBar(1,STATBARSTR(1))
!      RETURN
!
!      END SUBROUTINE TIC_file_Open
!
!*****************************************************************************
!
!U      SUBROUTINE CCL_file_Open()
!U
!U!   This subroutine processes Open CCL file selection
!U
!U      USE WINTERACTER
!U      USE VARIABLES
!U
!U      IMPLICIT NONE
!U
!U      CHARACTER(LEN=256) :: FILTER
!U      INTEGER            :: IFLAGS
!U
!U      INCLUDE 'GLBVAR.INC'
!U
!U      LOGICAL Confirm ! Function
!U
!U!   Check if file needs saving
!U      IF (SAVEF) THEN
!U        IF (.NOT. Confirm('Program contains an unsaved project.'//CHAR(13)//'Do you wish to continue?')) RETURN
!U      END IF
!U      SAVEF  = .FALSE.
!U      CALL FieldUpdate()
!U      IFLAGS = LoadDialog + DirChange + PromptOn
!U      FILTER = 'CCL crystal data files (*.ccl)|*.ccl|'
!U      FNAME=' '
!U      CALL WSelectFile(FILTER,IFLAGS,FNAME,'Open CCL file')
!U!   Place your file load code here
!U      CALL Load_CCL_File(LEN_TRIM(FNAME),FNAME)
!U      STATBARSTR(1)=FNAME
!U      CALL WindowOutStatusBar(1,STATBARSTR(1))
!U      RETURN
!U
!U      END SUBROUTINE CCL_file_Open
!
!*****************************************************************************
!
!      SUBROUTINE Save(IDENT)
!
!   This subroutine processes Save/As selection
!
!      USE WINTERACTER
!      USE VARIABLES
!
!      IMPLICIT NONE
!
!      INTEGER, INTENT (IN) :: IDENT
!
!      CHARACTER(LEN=256)   :: FILTER
!      INTEGER              :: IFLAGS
!
!      IF ((FNAME .EQ. ' ') .OR. (IDENT .EQ. 1)) THEN
!        IFLAGS = SaveDialog + DirChange + PromptOn
!        FILTER = 'All files (*.*)|*.*|'
!        FNAME=' '
!        CALL WSelectFile(FILTER,IFLAGS,FNAME,'Save File')
!      END IF
!      IF (WInfoDialog(4) .EQ. 1) THEN
!   Place save code here
!        SAVEF = .FALSE.
!        CALL FieldUpdate()
!      END IF
!      RETURN

!      END SUBROUTINE Save
!
!*****************************************************************************
!
!      SUBROUTINE Edit()
!
!   This subroutine processes Edit selection
!
!      USE WINTERACTER
!      USE VARIABLES
!      USE druid_header
!
!      IMPLICIT NONE
!
!   Load and show edit dialog
!
!!!      CALL WDialogLoad(IDD_EDITDIAG)
!!!      CALL WDialogShow(-1,-1,0,Modal)
!
!      IF (WInfoDialog(1) .EQ. 1) THEN
!        SAVEF = .TRUE.
!        CALL FieldUpdate()
!      END IF
!
!      RETURN
!      END SUBROUTINE Edit
!
!*****************************************************************************
!
! Originally in Abcalc.for
!
C LEVEL 3      SUBROUTINE ABCALC(IR,AFCAL,BFCAL)
      SUBROUTINE ABCALC(IR,AFCAL,BFCAL)
C
C *** FCALC by JCM 19 Jul 83 ***
C
CX
CC 4B
CH Calculates the COMPLEX nuclear structure factor for the reflection H.
CA On entry H is a 1x3 read vector holding h,k,l.
CA On exit FCALC holds the COMPLEX nuclear structure factor
CP PREFIN, RECIP, SYMOP, SETFOR, ATOPOS and SETANI must be called before the
CP first call to FCALC.  (All these except PREFIN are all in SETFC)
CD Forms sin theta/lambda and leaves it in STHL in /BRAGG
CD Cycles over atomic positions, then over symmetry operators, forming
CD COMPLEX FCALC by the usual formula.
CD
CD Applies scattering factor, site occupation factor, multiplicity of atom and
CD individual isotropic or anisotropic temperature factors.
C
      INCLUDE 'params.inc'
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /FCSTOR/ MAXK,FOB(150,MFCSTO)
      LOGICAL LOGREF
      COMMON /FCSPEC/ NLGREF,IREFH(3,MFCSPE),LOGREF(8,MFCSPE)
      COMMON /CSQSTO/ COSQS(-20:20,3,150),SINQS(-20:20,3,150)
C
      INCLUDE 'FFCALC.INC'
C
      RETURN
      END
!
!*****************************************************************************
!
! Originally in SplineFit.f90
!
      SUBROUTINE Spline_Background
!U
!U! Algorithm:
!U!
!U! 1. Define all points on the profile by using user defined positions. Initially these are defined
!U! from the unit cell reflection positions using a fitness equation (as yet undefined) or from user-given 
!U! points in the profile
!U!
!U! 2. Fit a cubic spline to these points and use this for background correction
!U!
!U! Notes:
!U!
!U! This algorithm uses the information from the indexing. If your indexing is bad, then
!U! it has no chance!
!U
!U      USE WINTERACTER
!U      USE DRUID_HEADER
!U      USE VARIABLES
!U
!U      INCLUDE 'POLY_COLOURS.INC'
!U      INCLUDE 'PARAMS.INC'
!U      COMMON /PROFTIC/ NTIC,IH(3,MTIC),ARGK(MTIC),DSTAR(MTIC)
!U
!U      COMMON /PROFRAN/ XPMIN,XPMAX,YPMIN,YPMAX,XPGMIN,XPGMAX,&
!U        YPGMIN,YPGMAX,XPGMINOLD,XPGMAXOLD,YPGMINOLD,YPGMAXOLD, &
!U        XGGMIN,XGGMAX,YGGMIN,YGGMAX
!U
!U      COMMON /PROFOBS/ NOBS,XOBS(MOBS),YOBS(MOBS),YCAL(MOBS),YBAK(MOBS),EOBS(MOBS)
!U      COMMON /PROFBIN/ NBIN,LBIN,XBIN(MOBS),YOBIN(MOBS),YCBIN(MOBS),YBBIN(MOBS),EBIN(MOBS)
!U
!U      REAL TicVal(Mtic),XSpline(Mtic),YSpline(Mtic),DSpline(Mtic),NSpline,Xtem,Ytem
!U      INTEGER Npos,Count,Nstep
!U      REAL Del
!U
!U      Npos = 0
!U! Calculate the mean intensity over the profile and the mean intensity 
!U! over the reflection positions
!U      DO I = 1, MTIC
!U! Modify the position 
!U        IF (I .GT. 1) THEN
!U          Del =  ARGK(I) - ARGK(I-1)
!U        ELSE
!U          Del =  ARGK(I) - XOBS(1)
!U        ENDIF
!U! we want points between the peaks that are well separated
!U        IF (Del .GT. 0.25 ) THEN  ! This is selection is hard coded here but really should be
!U                              ! dependant on the estimated peak width at this position
!U           Npos = Npos + 1
!U           TicVal(Npos) = ARGK(I) - (Del/2.0)
!U        END IF
!U      END DO
!U      Count = 1
!U      DO I = 1, NOBS-1
!U        IF (XOBS(I).LE.TicVal(Count) .AND. XOBS(I+1).GE.TicVal(Count)) THEN
!U          XSpline(Count) = XOBS(I)
!U          YSpline(Count) = YOBS(I)
!U          Count = Count + 1
!U          IF (Count .GT. Npos) GOTO 99
!U        END IF
!U      END DO
!U 99   CONTINUE
!U      CALL IGrColourN(KolNumObs)
!U! JvdS IPgNewGraph is now obsolete and should be replaced by IPgNewPlot
!U! I don't know the equivalent of 'S'
!U!      CALL IPgNewPlot(PgPolyLine,1,NBIN,??)
!U      CALL IPgNewGraph(1,Npos,' ','S','X')
!U      CALL IPgStyle(1,0,0,0,KolNumDif,0)
!U      CALL IPgXYPairs(XSpline,YSpline)
!U      CALL IGrColourN(KolNumMain)
!U
      END SUBROUTINE Spline_Background
!U
!
!*****************************************************************************
!
! Originally in subplxopt.for
!
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE SUBPLXOPT(X,DX,COVAR,N,CCHI)
C     ----------------------------------
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C     A SUBPLEX-based routine which optimises the values of the N 
C parameters pertaining to the components of the vector X; it also 
C estimates the related covariance matrix. The SUBPLEX work-engine 
C is due to Dr. Tom Rowan (Ph.D., 1990), which he developed while 
C a Research student at University of Texas, Austin, USA.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    N        I*4    I       -      No. of parameters to be optimised.
C    X        R*4    I       N      Initial guess.
C    X        R*4    O       N      The optimal answer.
C    DX       R*4    I       N      Initial step-lengths for X.
C    COVAR    R*4    O     N x N    The covariance matrix.
C
C Other Requirements
C     The user must provide a FUNCTION CCHI(X) which evalutes 
C Chi-squared (un-normalised) given the vector X.
C
C History
C     D. S. Sivia   22 Jun 1999  Initial release.
C-----------------------------------------------------------------------
C
      REAL     X(N),DX(N),COVAR(N,N)
      REAL     HESS(9801),DELTA(99),C0,C1(2,99),C2(9801)
      INTEGER  IWORK(150)
      REAL*8   SUBCHI,TOL,DV(99),V(99),CHIV,WORK(250)
      EXTERNAL CCHI,SUBCHI
      DATA     NMAX,TOL /99,1.0D-2/
C
      IF (N.GT.NMAX) STOP' Sorry, too many parameters !'
      CHIMIN=CCHI(N,X)
c      WRITE(*,*)
C      WRITE(76,100) CHIMIN
C 100  FORMAT(' Chi-squared = ',1PE12.4)
      MODE=0
      NCHMAX=N*1000
      CALL VDBLE(X,V,N)
      CALL VDBLE(DX,DV,N)
   1  CALL SUBPLX(SUBCHI,CCHI,N,TOL,NCHMAX,MODE,DV,V,CHIV,NCHI,
     *            WORK,IWORK,IFLAG)
C      WRITE(76,100) SNGL(CHIV)
      CALL VSNGL(V,X,N)
      CALL VCOPY(X,WORK,N)
      CALL CHINIT(WORK,N,DELTA,C0,C1,C2,CCHI)
      CALL HSINT1(C0,C1,DELTA,N,HESS)
      CALL HSINT2(C0,C1,C2,DELTA,N,HESS)
      CALL INVERT(HESS,COVAR,N,INDX)
      END
C

C***<subplex interface>*************************************************
C
      REAL*8 FUNCTION SUBCHI(N,X,CCHI)
C     ---------------------------
C
      REAL*8   X(*)
      REAL     XS(99)
      EXTERNAL CCHI
C
      CALL VSNGL(X,XS,N)
      SUBCHI=DBLE(CCHI(N,XS))
      END
C
C***<utilities>*********************************************************
C
      SUBROUTINE VDBLE(X,Y,N)
C     -----------------------
C
      REAL   X(*)
      REAL*8 Y(*)
C
      DO 10 I=1,N
  10    Y(I)=DBLE(X(I))
      END
C
      SUBROUTINE VSNGL(X,Y,N)
C     -----------------------
C
      REAL*8 X(*)
      REAL   Y(*)
C
      DO 10 I=1,N
  10    Y(I)=SNGL(X(I))
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C            Dr. Tom Rowan's SUBPLEX code follows below.               C
C            -------------------------------------------               C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      subroutine calcc (ns,s,ih,inew,updatc,c)
c
      integer ns,ih,inew
      double precision s(ns,ns+3),c(ns)
      logical updatc
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c calcc calculates the centroid of the simplex without the
c vertex with highest function value.
c
c input
c
c   ns     - subspace dimension
c
c   s      - double precision work space of dimension .ge.
c            ns*(ns+3) used to store simplex
c
c   ih     - index to vertex with highest function value
c
c   inew   - index to new point
c
c   updatc - logical switch
c            = .true.  : update centroid
c            = .false. : calculate centroid from scratch
c
c   c      - centroid of the simplex without vertex with
c            highest function value
c
c output
c
c   c      - new centroid
c
c local variables
c
      integer i,j
c
c subroutines and functions
c
c   blas
      external daxpy,dcopy,dscal
c
c-----------------------------------------------------------
c
      if (updatc) then
        if (ih .eq. inew) return
        do 10 i = 1,ns
          c(i) = c(i)+(s(i,inew)-s(i,ih))/ns
   10   continue
      else
        call dcopy (ns,0.d0,0,c,1)
        do 20 j = 1,ns+1
          if (j .ne. ih) call daxpy (ns,1.d0,s(1,j),1,c,1)
   20   continue
        call dscal (ns,1.d0/ns,c,1)
      end if
      return
      end
C
      double precision function dist (n,x,y)
c
      integer n
      double precision x(n),y(n)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c dist calculates the distance between the points x,y.
c
c input
c
c   n      - number of components
c
c   x      - point in n-space
c
c   y      - point in n-space
c
c local variables
c
      integer i
      double precision absxmy,scale,sum
c
c subroutines and functions
c
c   fortran
      intrinsic abs,sqrt
c
c-----------------------------------------------------------
c
      absxmy = abs(x(1)-y(1))
      if (absxmy .le. 1.d0) then
        sum = absxmy*absxmy
        scale = 1.d0
      else
        sum = 1.d0
        scale = absxmy
      end if
      do 10 i = 2,n
        absxmy = abs(x(i)-y(i))
        if (absxmy .le. scale) then
          sum = sum+(absxmy/scale)**2
        else
          sum = 1.d0+sum*(scale/absxmy)**2
          scale = absxmy
        end if
   10 continue
      dist = scale*sqrt(sum)
      return
      end
C
      subroutine evalf (f,cchi,ns,ips,xs,n,x,sfx,nfe)
c
      integer ns,n,nfe
      integer ips(*)
      double precision f,xs(*),x(n),sfx
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c evalf evaluates the function f at a point defined by x
c with ns of its components replaced by those in xs.
c
c input
c
c   f      - user supplied function f(n,x) to be optimized
c
c   ns     - subspace dimension
c
c   ips    - permutation vector
c
c   xs     - double precision ns-vector to be mapped to x
c
c   n      - problem dimension
c
c   x      - double precision n-vector
c
c   nfe    - number of function evaluations
c
c output
c
c   sfx    - signed value of f evaluated at x
c
c   nfe    - incremented number of function evaluations
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
      double precision fbonus,sfstop,sfbest
      logical new
c
      common /isubc/ fbonus,sfstop,sfbest,new
c
c local variables
c
      integer i
      double precision fx
      logical newbst
c
      save
c
c subroutines and functions
c
      external f,fstats
      external cchi
c
c-----------------------------------------------------------
c
      do 10 i = 1,ns
        x(ips(i)) = xs(i)
   10 continue
      newx = new .or. irepl .ne. 2
      fx = f(n,x,cchi)
      if (irepl .eq. 0) then
        if (minf) then
          sfx = fx
        else
          sfx = -fx
        end if
      else if (new) then
        if (minf) then
          sfx = fx
          newbst = fx .lt. ftest
        else
          sfx = -fx
          newbst = fx .gt. ftest
        end if
        if (initx .or. newbst) then
          if (irepl .eq. 1) call fstats (fx,1,.true.)
          ftest = fx
          sfbest = sfx
        end if
      else
        if (irepl .eq. 1) then
          call fstats (fx,1,.false.)
          fx = fxstat(ifxsw)
        end if
        ftest = fx+fbonus*fxstat(4)
        if (minf) then
          sfx = ftest
          sfbest = fx
        else
          sfx = -ftest
          sfbest = -fx
        end if
      end if
      nfe = nfe+1
      return
      end
C
      subroutine fstats (fx,ifxwt,reset)
c
      integer ifxwt
      double precision fx
      logical reset
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c fstats modifies the common /usubc/ variables nfxe,fxstat.
c
c input
c
c   fx     - most recent evaluation of f at best x
c
c   ifxwt  - integer weight for fx
c
c   reset  - logical switch
c            = .true.  : initialize nfxe,fxstat
c            = .false. : update nfxe,fxstat
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
c local variables
c
      integer nsv
      double precision fscale,f1sv
c
      save
c
c subroutines and functions
c
c   fortran
      intrinsic abs,max,min,sqrt
c
c-----------------------------------------------------------
c
      if (reset) then
        nfxe = ifxwt
        fxstat(1) = fx
        fxstat(2) = fx
        fxstat(3) = fx
        fxstat(4) = 0.d0
      else
        nsv = nfxe
        f1sv = fxstat(1)
        nfxe = nfxe+ifxwt
        fxstat(1) = fxstat(1)+ifxwt*(fx-fxstat(1))/nfxe
        fxstat(2) = max(fxstat(2),fx)
        fxstat(3) = min(fxstat(3),fx)
        fscale = max(abs(fxstat(2)),abs(fxstat(3)),1.d0)
        fxstat(4) = fscale*sqrt((
     *              (nsv-1)*(fxstat(4)/fscale)**2+
     *              nsv*((fxstat(1)-f1sv)/fscale)**2+
     *              ifxwt*((fx-fxstat(1))/fscale)**2)
     *              /(nfxe-1))
      end if
      return
      end
C
      subroutine newpt (ns,coef,xbase,xold,new,xnew,small)
c
      integer ns
      double precision coef,xbase(ns),xold(ns),xnew(*)
      logical new,small
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c newpt performs reflections, expansions, contractions, and
c shrinkages (massive contractions) by computing:
c
c xbase + coef * (xbase - xold)
c
c The result is stored in xnew if new .eq. .true.,
c in xold otherwise.
c
c use :  coef .gt. 0 to reflect
c        coef .lt. 0 to expand, contract, or shrink
c
c input
c
c   ns     - number of components (subspace dimension)
c
c   coef   - one of four simplex method coefficients
c
c   xbase  - double precision ns-vector representing base
c            point
c
c   xold   - double precision ns-vector representing old
c            point
c
c   new    - logical switch
c            = .true.  : store result in xnew
c            = .false. : store result in xold, xnew is not
c                        referenced
c
c output
c
c   xold   - unchanged if new .eq. .true., contains new
c            point otherwise
c
c   xnew   - double precision ns-vector representing new
c            point if  new .eq. .true., not referenced
c            otherwise
c
c   small  - logical flag
c            = .true.  : coincident points
c            = .false. : otherwise
c
c local variables
c
      integer i
      double precision xoldi
      logical eqbase,eqold
c
c subroutines and functions
c
c   fortran
      intrinsic dble
c
c-----------------------------------------------------------
c
      eqbase = .true.
      eqold = .true.
      if (new) then
        do 10 i = 1,ns
          xnew(i) = xbase(i)+coef*(xbase(i)-xold(i))
          eqbase = eqbase .and.
     *             (dble(xnew(i)) .eq. dble(xbase(i)))
          eqold = eqold .and.
     *            (dble(xnew(i)) .eq. dble(xold(i)))
   10   continue
      else
        do 20 i = 1,ns
          xoldi = xold(i)
          xold(i) = xbase(i)+coef*(xbase(i)-xold(i))
          eqbase = eqbase .and.
     *             (dble(xold(i)) .eq. dble(xbase(i)))
          eqold = eqold .and.
     *            (dble(xold(i)) .eq. dble(xoldi))
   20   continue
      end if
      small = eqbase .or. eqold
      return
      end
C
      subroutine order (npts,fs,il,is,ih)
c
      integer npts,il,is,ih
      double precision fs(npts)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c order determines the indices of the vertices with the
c lowest, second highest, and highest function values.
c
c input
c
c   npts   - number of points in simplex
c
c   fs     - double precision vector of function values of
c            simplex
c
c   il     - index to vertex with lowest function value
c
c output
c
c   il     - new index to vertex with lowest function value
c
c   is     - new index to vertex with second highest
c            function value
c
c   ih     - new index to vertex with highest function value
c
c local variables
c
      integer i,il0,j
c
c subroutines and functions
c
c   fortran
      intrinsic mod
c
c-----------------------------------------------------------
c
      il0 = il
      j = mod(il0,npts)+1
      if (fs(j) .ge. fs(il)) then
        ih = j
        is = il0
      else
        ih = il0
        is = j
        il = j
      end if
      do 10 i = il0+1,il0+npts-2
        j = mod(i,npts)+1
        if (fs(j) .ge. fs(ih)) then
          is = ih
          ih = j
        else if (fs(j) .gt. fs(is)) then
          is = j
        else if (fs(j) .lt. fs(il)) then
          il = j
        end if
   10 continue
      return
      end
C
      subroutine partx (n,ip,absdx,nsubs,nsvals)
c
      integer n,nsubs,nsvals(*)
      integer ip(n)
      double precision absdx(n)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c partx partitions the vector x by grouping components of
c similar magnitude of change.
c
c input
c
c   n      - number of components (problem dimension)
c
c   ip     - permutation vector
c
c   absdx  - vector of magnitude of change in x
c
c   nsvals - integer array dimensioned .ge. int(n/nsmin)
c
c output
c
c   nsubs  - number of subspaces
c
c   nsvals - integer array of subspace dimensions
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
c local variables
c
      integer i,nleft,ns1,ns2,nused
      double precision asleft,as1,as1max,as2,gap,gapmax
c
      save
c
c subroutines and functions
c
c   fortran
      intrinsic min
c
c-----------------------------------------------------------
c
      nsubs = 0
      nused = 0
      nleft = n
      asleft = absdx(1)
      do 10 i = 2,n
        asleft = asleft+absdx(i)
   10 continue
   20 continue
      if (nused .lt. n) then
        nsubs = nsubs+1
        as1 = 0.d0
        do 30 i = 1,nsmin-1
          as1 = as1+absdx(ip(nused+i))
   30   continue
        gapmax = -1.d0
        do 40 ns1 = nsmin,min(nsmax,nleft)
          as1 = as1+absdx(ip(nused+ns1))
          ns2 = nleft-ns1
          if (ns2 .gt. 0) then
            if (ns2 .ge. ((ns2-1)/nsmax+1)*nsmin) then
              as2 = asleft-as1
              gap = as1/ns1-as2/ns2
              if (gap .gt. gapmax) then
                gapmax = gap
                nsvals(nsubs) = ns1
                as1max = as1
              end if
            end if
          else
            if (as1/ns1 .gt. gapmax) then
              nsvals(nsubs) = ns1
              return
            end if
          end if
   40   continue
        nused = nused+nsvals(nsubs)
        nleft = n-nused
        asleft = asleft-as1max
        go to 20
      end if
      return
      end
C
      subroutine setstp (nsubs,n,deltax,step)
c
      integer nsubs,n
      double precision deltax(n),step(n)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c setstp sets the stepsizes for the corresponding components
c of the solution vector.
c
c input
c
c   nsubs  - number of subspaces
c
c   n      - number of components (problem dimension)
c
c   deltax - vector of change in solution vector
c
c   step   - stepsizes for corresponding components of
c            solution vector
c
c output
c
c   step   - new stepsizes
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
c local variables
c
      integer i
      double precision dasum,stpfac
c
      save
c
c subroutines and functions
c
c   blas
      external dasum,dscal
c   fortran
      intrinsic max,min,sign
c
c-----------------------------------------------------------
c
c     set new step
c
      if (nsubs .gt. 1) then
        stpfac = min(max(dasum(n,deltax,1)/dasum(n,step,1),
     *           omega),1.d0/omega)
      else
        stpfac = psi
      end if
      call dscal (n,stpfac,step,1)
c
c     reorient simplex
c
      do 10 i = 1,n
        if (deltax(i) .ne. 0.) then
          step(i) = sign(step(i),deltax(i))
        else
          step(i) = -step(i)
        end if
   10 continue
      return
      end
C
      subroutine simplx (f,cchi,n,step,ns,ips,maxnfe,cmode,x,fx,
     *                   nfe,s,fs,iflag)
c
      integer n,ns,maxnfe,nfe,iflag
      integer ips(ns)
      double precision f,step(n),x(n),fx,s(ns,ns+3),fs(ns+1)
      logical cmode
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c simplx uses the Nelder-Mead simplex method to minimize the
c function f on a subspace.
c
c input
c
c   f      - function to be minimized, declared external in
c            calling routine
c
c   n      - problem dimension
c
c   step   - stepsizes for corresponding components of x
c
c   ns     - subspace dimension
c
c   ips    - permutation vector
c
c   maxnfe - maximum number of function evaluations
c
c   cmode  - logical switch
c            = .true.  : continuation of previous call
c            = .false. : first call
c
c   x      - starting guess for minimum
c
c   fx     - value of f at x
c
c   nfe    - number of function evaluations
c
c   s      - double precision work array of dimension .ge.
c            ns*(ns+3) used to store simplex
c
c   fs     - double precision work array of dimension .ge.
c            ns+1 used to store function values of simplex
c            vertices
c
c output
c
c   x      - computed minimum
c
c   fx     - value of f at x
c
c   nfe    - incremented number of function evaluations
c
c   iflag  - error flag
c            = -1 : maxnfe exceeded
c            =  0 : simplex reduced by factor of psi
c            =  1 : limit of machine precision
c            =  2 : reached fstop
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
      double precision fbonus,sfstop,sfbest
      logical new
c
      common /isubc/ fbonus,sfstop,sfbest,new
c
c local variables
c
      integer i,icent,ih,il,inew,is,itemp,j,npts
      double precision dist,dum,fc,fe,fr,tol
      logical small,updatc
c
      save
c
c subroutines and functions
c
      external f,calcc,dist,evalf,newpt,order,start
      external cchi
c   blas
      external dcopy
c   fortran
      intrinsic min
c
c-----------------------------------------------------------
c
      if (cmode) go to 50
      npts = ns+1
      icent = ns+2
      itemp = ns+3
      updatc = .false.
      call start (n,x,step,ns,ips,s,small)
      if (small) then
        iflag = 1
        return
      end if
      if (irepl .gt. 0) then
        new = .false.
        call evalf (f,cchi,ns,ips,s(1,1),n,x,fs(1),nfe)
      else
        fs(1) = fx
      end if
      new = .true.
      do 10 j = 2,npts
        call evalf (f,cchi,ns,ips,s(1,j),n,x,fs(j),nfe)
   10 continue
      il = 1
      call order (npts,fs,il,is,ih)
      tol = psi*dist(ns,s(1,ih),s(1,il))
c
c     main loop
c
   20 continue
        call calcc (ns,s,ih,inew,updatc,s(1,icent))
        updatc = .true.
        inew = ih
c
c       reflect
c
        call newpt (ns,alpha,s(1,icent),s(1,ih),.true.,
     *              s(1,itemp),small)
        if (small) go to 40
        call evalf (f,cchi,ns,ips,s(1,itemp),n,x,fr,nfe)
        if (fr .lt. fs(il)) then
c
c         expand
c
          call newpt (ns,-gamma,s(1,icent),s(1,itemp),
     *                .true.,s(1,ih),small)
          if (small) go to 40
          call evalf (f,cchi,ns,ips,s(1,ih),n,x,fe,nfe)
          if (fe .lt. fr) then
            fs(ih) = fe
          else
            call dcopy (ns,s(1,itemp),1,s(1,ih),1)
            fs(ih) = fr
          end if
        else if (fr .lt. fs(is)) then
c
c         accept reflected point
c
          call dcopy (ns,s(1,itemp),1,s(1,ih),1)
          fs(ih) = fr
        else
c
c         contract
c
          if (fr .gt. fs(ih)) then
            call newpt (ns,-beta,s(1,icent),s(1,ih),.true.,
     *                  s(1,itemp),small)
          else
            call newpt (ns,-beta,s(1,icent),s(1,itemp),
     *                  .false.,dum,small)
          end if
          if (small) go to 40
          call evalf (f,cchi,ns,ips,s(1,itemp),n,x,fc,nfe)
          if (fc .lt. min(fr,fs(ih))) then
            call dcopy (ns,s(1,itemp),1,s(1,ih),1)
            fs(ih) = fc
          else
c
c           shrink simplex
c
            do 30 j = 1,npts
              if (j .ne. il) then
                call newpt (ns,-delta,s(1,il),s(1,j),
     *                      .false.,dum,small)
                if (small) go to 40
                call evalf (f,cchi,ns,ips,s(1,j),n,x,fs(j),nfe)
              end if
   30       continue
          end if
          updatc = .false.
        end if
        call order (npts,fs,il,is,ih)
c
c       check termination
c
   40   continue
        if (irepl .eq. 0) then
          fx = fs(il)
        else
          fx = sfbest
        end if
   50   continue
        if (nfstop .gt. 0 .and. fx .le. sfstop .and.
     *      nfxe .ge. nfstop) then
          iflag = 2
        else if (nfe .ge. maxnfe) then
          iflag = -1
        else if (dist(ns,s(1,ih),s(1,il)) .le. tol .or.
     *           small) then
          iflag = 0
        else
          go to 20
        end if
c
c     end main loop, return best point
c
      do 60 i = 1,ns
        x(ips(i)) = s(i,il)
   60 continue
      return
      end
C
      subroutine sortd (n,xkey,ix)
c
      integer n
      integer ix(n)
      double precision xkey(n)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c sortd uses the shakersort method to sort an array of keys
c in decreasing order. The sort is performed implicitly by
c modifying a vector of indices.
c
c For nearly sorted arrays, sortd requires O(n) comparisons.
c for completely unsorted arrays, sortd requires O(n**2)
c comparisons and will be inefficient unless n is small.
c
c input
c
c   n      - number of components
c
c   xkey   - double precision vector of keys
c
c   ix     - integer vector of indices
c
c output
c
c   ix     - indices satisfy xkey(ix(i)) .ge. xkey(ix(i+1))
c            for i = 1,...,n-1
c
c local variables
c
      integer i,ifirst,ilast,iswap,ixi,ixip1
c
c-----------------------------------------------------------
c
      ifirst = 1
      iswap = 1
      ilast = n-1
   10 continue
      if (ifirst .le. ilast) then
        do 20 i = ifirst,ilast
          ixi = ix(i)
          ixip1 = ix(i+1)
          if (xkey(ixi) .lt. xkey(ixip1)) then
            ix(i) = ixip1
            ix(i+1) = ixi
            iswap = i
          end if
   20   continue
        ilast = iswap-1
        do 30 i = ilast,ifirst,-1
          ixi = ix(i)
          ixip1 = ix(i+1)
          if (xkey(ixi) .lt. xkey(ixip1)) then
            ix(i) = ixip1
            ix(i+1) = ixi
            iswap = i
          end if
   30   continue
        ifirst = iswap+1
        go to 10
      end if
      return
      end
C
      subroutine start (n,x,step,ns,ips,s,small)
c
      integer n,ns
      integer ips(n)
      double precision x(n),step(n),s(ns,ns+3)
      logical small
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c start creates the initial simplex for simplx minimization.
c
c input
c
c   n      - problem dimension
c
c   x      - current best point
c
c   step   - stepsizes for corresponding components of x
c
c   ns     - subspace dimension
c
c   ips    - permutation vector
c
c
c output
c
c   s      - first ns+1 columns contain initial simplex
c
c   small  - logical flag
c            = .true.  : coincident points
c            = .false. : otherwise
c
c local variables
c
      integer i,j
c
c subroutines and functions
c
c   blas
      external dcopy
c   fortran
      intrinsic dble
c
c-----------------------------------------------------------
c
      do 10 i = 1,ns
        s(i,1) = x(ips(i))
   10 continue
      do 20 j = 2,ns+1
        call dcopy (ns,s(1,1),1,s(1,j),1)
        s(j-1,j) = s(j-1,1)+step(ips(j-1))
   20 continue
c
c check for coincident points
c
      do 30 j = 2,ns+1
        if (dble(s(j-1,j)) .eq. dble(s(j-1,1))) go to 40
   30 continue
      small = .false.
      return
c
c coincident points
c
   40 continue
      small = .true.
      return
      end
C
      subroutine subopt (n)
c
      integer n
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c subopt sets options for subplx.
c
c input
c
c   n      - problem dimension
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
      save
c
c subroutines and functions
c
c   fortran
      intrinsic min
c
c-----------------------------------------------------------
c
c***********************************************************
c simplex method strategy parameters
c***********************************************************
c
c alpha  - reflection coefficient
c          alpha .gt. 0
c
      alpha = 1.d0
c
c beta   - contraction coefficient
c          0 .lt. beta .lt. 1
c
      beta = .5d0
c
c gamma  - expansion coefficient
c          gamma .gt. 1
c
      gamma = 2.d0
c
c delta  - shrinkage (massive contraction) coefficient
c          0 .lt. delta .lt. 1
c
      delta = .5d0
c
c***********************************************************
c subplex method strategy parameters
c***********************************************************
c
c psi    - simplex reduction coefficient
c          0 .lt. psi .lt. 1
c
      psi = .25d0
c
c omega  - step reduction coefficient
c          0 .lt. omega .lt. 1
c
      omega = .1d0
c
c nsmin and nsmax specify a range of subspace dimensions.
c In addition to satisfying  1 .le. nsmin .le. nsmax .le. n,
c nsmin and nsmax must be chosen so that n can be expressed
c as a sum of positive integers where each of these integers
c ns(i) satisfies   nsmin .le. ns(i) .ge. nsmax.
c Specifically,
c     nsmin*ceil(n/nsmax) .le. n   must be true.
c
c nsmin  - subspace dimension minimum
c
      nsmin = min(2,n)
c
c nsmax  - subspace dimension maximum
c
      nsmax = min(5,n)
c
c***********************************************************
c subplex method special cases
c***********************************************************
c nelder-mead simplex method with periodic restarts
c   nsmin = nsmax = n
c***********************************************************
c nelder-mead simplex method
c   nsmin = nsmax = n, psi = small positive
c***********************************************************
c
c irepl, ifxsw, and bonus deal with measurement replication.
c Objective functions subject to large amounts of noise can
c cause an optimization method to halt at a false optimum.
c An expensive solution to this problem is to evaluate f
c several times at each point and return the average (or max
c or min) of these trials as the function value.  subplx
c performs measurement replication only at the current best
c point. The longer a point is retained as best, the more
c accurate its function value becomes.
c
c The common variable nfxe contains the number of function
c evaluations at the current best point. fxstat contains the
c mean, max, min, and standard deviation of these trials.
c
c irepl  - measurement replication switch
c irepl  = 0, 1, or 2
c        = 0 : no measurement replication
c        = 1 : subplx performs measurement replication
c        = 2 : user performs measurement replication
c              (This is useful when optimizing on the mean,
c              max, or min of trials is insufficient. Common
c              variable initx is true for first function
c              evaluation. newx is true for first trial at
c              this point. The user uses subroutine fstats
c              within his objective function to maintain
c              fxstat. By monitoring newx, the user can tell
c              whether to return the function evaluation
c              (newx = .true.) or to use the new function
c              evaluation to refine the function evaluation
c              of the current best point (newx = .false.).
c              The common variable ftest gives the function
c              value that a new point must beat to be
c              considered the new best point.)
c
      irepl = 0
c
c ifxsw  - measurement replication optimization switch
c ifxsw  = 1, 2, or 3
c        = 1 : retain mean of trials as best function value
c        = 2 : retain max
c        = 3 : retain min
c
      ifxsw = 1
c
c Since the current best point will also be the most
c accurately evaluated point whenever irepl .gt. 0, a bonus
c should be added to the function value of the best point
c so that the best point is not replaced by a new point
c that only appears better because of noise.
c subplx uses bonus to determine how many multiples of
c fxstat(4) should be added as a bonus to the function
c evaluation. (The bonus is adjusted automatically by
c subplx when ifxsw or minf is changed.)
c
c bonus  - measurement replication bonus coefficient
c          bonus .ge. 0 (normally, bonus = 0 or 1)
c        = 0 : bonus not used
c        = 1 : bonus used
c
      bonus = 1.d0
c
c nfstop = 0 : f(x) is not tested against fstop
c        = 1 : if f(x) has reached fstop, subplx returns
c              iflag = 2
c        = 2 : (only valid when irepl .gt. 0)
c              if f(x) has reached fstop and
c              nfxe .gt. nfstop, subplx returns iflag = 2
c
      nfstop = 0
c
c fstop  - f target value
c          Its usage is determined by the value of nfstop.
c
c minf   - logical switch
c        = .true.  : subplx performs minimization
c        = .false. : subplx performs maximization
c
      minf = .true.
      return
      end
C
      subroutine subplx (f,cchi,n,tol,maxnfe,mode,scale,x,fx,nfe,
     *                   work,iwork,iflag)
c
      integer n,maxnfe,mode,nfe,iwork(*),iflag
      double precision f,tol,scale(*),x(n),fx,work(*)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c subplx uses the subplex method to solve unconstrained
c optimization problems.  The method is well suited for
c optimizing objective functions that are noisy or are
c discontinuous at the solution.
c
c subplx sets default optimization options by calling the
c subroutine subopt.  The user can override these defaults
c by calling subopt prior to calling subplx, changing the
c appropriate common variables, and setting the value of
c mode as indicated below.
c
c By default, subplx performs minimization.
c
c input
c
c   f      - user supplied function f(n,x) to be optimized,
c            declared external in calling routine
c
c   n      - problem dimension
c
c   tol    - relative error tolerance for x (tol .ge. 0.)
c
c   maxnfe - maximum number of function evaluations
c
c   mode   - integer mode switch with binary expansion
c            (bit 1) (bit 0) :
c            bit 0 = 0 : first call to subplx
c                  = 1 : continuation of previous call
c            bit 1 = 0 : use default options
c                  = 1 : user set options
c
c   scale  - scale and initial stepsizes for corresponding
c            components of x
c            (If scale(1) .lt. 0.,
c            abs(scale(1)) is used for all components of x,
c            and scale(2),...,scale(n) are not referenced.)
c
c   x      - starting guess for optimum
c
c   work   - double precision work array of dimension .ge.
c            2*n + nsmax*(nsmax+4) + 1
c            (nsmax is set in subroutine subopt.
c            default: nsmax = min(5,n))
c
c   iwork  - integer work array of dimension .ge.
c            n + int(n/nsmin)
c            (nsmin is set in subroutine subopt.
c            default: nsmin = min(2,n))
c
c output
c
c   x      - computed optimum
c
c   fx     - value of f at x
c
c   nfe    - number of function evaluations
c
c   iflag  - error flag
c            = -2 : invalid input
c            = -1 : maxnfe exceeded
c            =  0 : tol satisfied
c            =  1 : limit of machine precision
c            =  2 : fstop reached (fstop usage is determined
c                   by values of options minf, nfstop, and
c                   irepl. default: f(x) not tested against
c                   fstop)
c            iflag should not be reset between calls to
c            subplx.
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
      double precision fbonus,sfstop,sfbest
      logical new
c
      common /isubc/ fbonus,sfstop,sfbest,new
c
c local variables
c
      integer i,j,ifsptr,ins,insfnl,insptr,ipptr,isptr,
     *        istep,istptr,ns,nsubs
      double precision bnsfac(3,2),dum,scl,sfx,xpscl
      logical cmode
c
      save
c
c subroutines and functions
c
      external f,sortd,evalf,partx,setstp,simplx,subopt
      real*4 cchi
      external cchi
c   blas
      external dcopy
c   fortran
      intrinsic abs,mod
c
c data
c
      data ((bnsfac(i,j),i=1,3),j=1,2) /-1.d0,-2.d0,0.d0,
     *      1.d0,0.d0,2.d0/
c-----------------------------------------------------------
c
      if (mod(mode,2) .eq. 0) then
c
c       first call, check input
c
        if (n .lt. 1) go to 120
        if (tol .lt. 0.d0) go to 120
        if (maxnfe .lt. 1) go to 120
        if (scale(1) .ge. 0.d0) then
          do 10 i = 1,n
            xpscl = x(i)+scale(i)
            if (xpscl .eq. x(i)) go to 120
   10     continue
        else
          scl = abs(scale(1))
          do 20 i = 1,n
            xpscl = x(i)+scl
            if (xpscl .eq. x(i)) go to 120
   20     continue
        end if
        if (mod(mode/2,2) .eq. 0) then
          call subopt (n)
        else
          if (alpha .le. 0.d0) go to 120
          if (beta .le. 0.d0 .or. beta .ge. 1.d0) go to 120
          if (gamma .le. 1.d0) go to 120
          if (delta .le. 0.d0 .or. delta .ge. 1.d0)
     *        go to 120
          if (psi .le. 0.d0 .or. psi .ge. 1.d0) go to 120
          if (omega .le. 0.d0 .or. omega .ge. 1.d0)
     *        go to 120
          if (nsmin .lt. 1 .or. nsmax .lt. nsmin .or.
     *        n .lt. nsmax) go to 120
          if (n .lt. ((n-1)/nsmax+1)*nsmin) go to 120
          if (irepl .lt. 0 .or. irepl .gt. 2) go to 120
          if (ifxsw .lt. 1 .or. ifxsw .gt. 3) go to 120
          if (bonus .lt. 0.d0) go to 120
          if (nfstop .lt. 0) go to 120
        end if
c
c       initialization
c
        istptr = n+1
        isptr = istptr+n
        ifsptr = isptr+nsmax*(nsmax+3)
        insptr = n+1
        if (scale(1) .gt. 0.d0) then
          call dcopy (n,scale,1,work,1)
          call dcopy (n,scale,1,work(istptr),1)
        else
          call dcopy (n,scl,0,work,1)
          call dcopy (n,scl,0,work(istptr),1)
        end if
        do 30 i = 1,n
          iwork(i) = i
   30   continue
        nfe = 0
        nfxe = 1
        if (irepl .eq. 0) then
          fbonus = 0.d0
        else if (minf) then
          fbonus = bnsfac(ifxsw,1)*bonus
        else
          fbonus = bnsfac(ifxsw,2)*bonus
        end if
        if (nfstop .eq. 0) then
          sfstop = 0.d0
        else if (minf) then
          sfstop = fstop
        else
          sfstop = -fstop
        end if
        ftest = 0.d0
        cmode = .false.
        new = .true.
        initx = .true.
        call evalf (f,cchi,0,iwork,dum,n,x,sfx,nfe)
        initx = .false.
      else
c
c       continuation of previous call
c
        if (iflag .eq. 2) then
          if (minf) then
            sfstop = fstop
          else
            sfstop = -fstop
          end if
          cmode = .true.
          go to 70
        else if (iflag .eq. -1) then
          cmode = .true.
          go to 70
        else if (iflag .eq. 0) then
          cmode = .false.
          go to 90
        else
          return
        end if
      end if
c
c     subplex loop
c
   40 continue
        do 50 i = 1,n
          work(i) = abs(work(i))
   50   continue
        call sortd (n,work,iwork)
        call partx (n,iwork,work,nsubs,iwork(insptr))
        call dcopy (n,x,1,work,1)
        ins = insptr
        insfnl = insptr+nsubs-1
        ipptr = 1
c
c       simplex loop
c
   60   continue
          ns = iwork(ins)
   70     continue
          call simplx (f,cchi,n,work(istptr),ns,iwork(ipptr),
     *                 maxnfe,cmode,x,sfx,nfe,work(isptr),
     *                 work(ifsptr),iflag)
          cmode = .false.
          if (iflag .ne. 0) go to 110
          if (ins .lt. insfnl) then
            ins = ins+1
            ipptr = ipptr+ns
            go to 60
          end if
c
c       end simplex loop
c
        do 80 i = 1,n
          work(i) = x(i)-work(i)
   80   continue
c
c       check termination
c
   90   continue
        istep = istptr
        do 100 i = 1,n
          if (max(abs(work(i)),abs(work(istep))*psi)/
     *        max(abs(x(i)),1.d0) .gt. tol) then
            call setstp (nsubs,n,work,work(istptr))
            go to 40
          end if
          istep = istep+1
  100   continue
c
c     end subplex loop
c
      iflag = 0
  110 continue
      if (minf) then
        fx = sfx
      else
        fx = -sfx
      end if
      return
c
c     invalid input
c
  120 continue
      iflag = -2
      return
      end
C
      double precision function dasum(n,dx,incx)
c
c     takes the sum of the absolute values.
c     uses unrolled loops for increment equal to one.
c     jack dongarra, linpack, 3/11/78.
c     modified to correct problem with negative increment, 8/21/90.
c
      double precision dx(1),dtemp
      integer i,incx,ix,m,mp1,n
c
      dasum = 0.0d0
      dtemp = 0.0d0
      if(n.le.0)return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      ix = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      do 10 i = 1,n
        dtemp = dtemp + dabs(dx(ix))
        ix = ix + incx
   10 continue
      dasum = dtemp
      return
c
c        code for increment equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,6)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dtemp + dabs(dx(i))
   30 continue
      if( n .lt. 6 ) go to 60
   40 mp1 = m + 1
      do 50 i = mp1,n,6
        dtemp = dtemp + dabs(dx(i)) + dabs(dx(i + 1)) + dabs(dx(i + 2))
     *  + dabs(dx(i + 3)) + dabs(dx(i + 4)) + dabs(dx(i + 5))
   50 continue
   60 dasum = dtemp
      return
      end
C
      subroutine daxpy(n,da,dx,incx,dy,incy)
c
c     constant times a vector plus a vector.
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c
      double precision dx(1),dy(1),da
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if (da .eq. 0.0d0) return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dy(iy) = dy(iy) + da*dx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,4)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dy(i) = dy(i) + da*dx(i)
   30 continue
      if( n .lt. 4 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,4
        dy(i) = dy(i) + da*dx(i)
        dy(i + 1) = dy(i + 1) + da*dx(i + 1)
        dy(i + 2) = dy(i + 2) + da*dx(i + 2)
        dy(i + 3) = dy(i + 3) + da*dx(i + 3)
   50 continue
      return
      end
C
      subroutine  dcopy(n,dx,incx,dy,incy)
c
c     copies a vector, x, to a vector, y.
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c
      double precision dx(1),dy(1)
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dy(iy) = dx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,7)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dy(i) = dx(i)
   30 continue
      if( n .lt. 7 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,7
        dy(i) = dx(i)
        dy(i + 1) = dx(i + 1)
        dy(i + 2) = dx(i + 2)
        dy(i + 3) = dx(i + 3)
        dy(i + 4) = dx(i + 4)
        dy(i + 5) = dx(i + 5)
        dy(i + 6) = dx(i + 6)
   50 continue
      return
      end
C
      subroutine  dscal(n,da,dx,incx)
c
c     scales a vector by a constant.
c     uses unrolled loops for increment equal to one.
c     jack dongarra, linpack, 3/11/78.
c     modified to correct problem with negative increment, 8/21/90.
c
      double precision da,dx(1)
      integer i,incx,ix,m,mp1,n
c
      if(n.le.0)return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      ix = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      do 10 i = 1,n
        dx(ix) = da*dx(ix)
        ix = ix + incx
   10 continue
      return
c
c        code for increment equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dx(i) = da*dx(i)
   30 continue
      if( n .lt. 5 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        dx(i) = da*dx(i)
        dx(i + 1) = da*dx(i + 1)
        dx(i + 2) = da*dx(i + 2)
        dx(i + 3) = da*dx(i + 3)
        dx(i + 4) = da*dx(i + 4)
   50 continue
      return
      end
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!*****************************************************************************
!
! Originally in SA_INPUT.FOR
!
      subroutine sa_input(sa_file,nsa,IER)
      character*132 line
      character*80  sa_file
      logical   log_inf_file,log_nvar,log_bounds,log_reduce,
     &log_eps,log_ns,log_nt,log_neps,log_maxevl,log_iprint,
     &log_iseed1,log_iseed2,log_T0,log_target_value,
     &log_frag_file
      double precision cen,sig
      logical gaussb
      character*80  inf_file,zm_file
      double precision x,lb,ub,vm,xpreset
      double precision T0,rt,eps,target_value
      common /inffil/ lfinf,lfzm,inf_file,zm_file
      parameter (maxfrg=20)
      common /frgcom/ nfrag,lfrag(maxfrg)
      character*80 frag_file
      common /frgcha/ frag_file(maxfrg)
      parameter (mvar=100)
      common /gaubou/ cen(mvar),sig(mvar)
      common /gaulog/ gaussb(mvar)
      character*80  torfile
      logical ltorfil
      common /torfcm/ torfile(mvar)
      common /torlog/ ltorfil(mvar)
      common /jitter/ rjittr
      common /values/ x(mvar),lb(mvar),ub(mvar),vm(mvar)
      common /presetr/ xpreset(mvar)
      logical log_preset
      common /presetl/ log_preset
      logical log_hydrogens
      common /hydrogen/ log_hydrogens
c
      common /saparl/ T0,rt,eps,target_value
      common /sapars/ nvar,ns,nt,neps,maxevl,iprint,iseed1,iseed2
      common /shadl/ log_shad(mvar)
      common /shadi/ kshad(mvar)
c
      open(10,file=sa_file(:nsa),status='old')!,err=2)
c
      IER=0
      inf_file=' '
      do ifrg=1,maxfrg
         frag_file(ifrg)=' '
      end do
      nfrag=0
      do i=1,mvar
        log_shad(i)=.false.
      end do
      log_inf_file=.false.
      log_frag_file=.false.
      log_nvar=.false.
      log_bounds=.false.
      log_preset=.false.
      log_T0=.false.
      log_target_value=.false.
      log_reduce=.false.
      log_eps=.false.
      log_ns=.false.
      log_nt=.false.
      log_neps=.false.
      log_maxevl=.false.
      log_iprint=.false.
      log_iseed1=.false.
      log_iseed2=.false.
      log_hydrogens=.false.
c
 10   line=' '
      read(10,1010,end=100,ERR=998) line
 1010 format(a)
      i=132
      do i=132,1,-1
        if (line(i:i).ne.' ') then
          ie=i
          goto 12
        end if
      end do
c.. blank line 
      goto 10
 12   ix=index(line,'!')-1
      if (ix.eq.-1) ix=ie
      if (index(line(1:ix),'NVAR').ne.0) then
        ii=index(line(1:ix),'NVAR')
        read(line(ii+4:ix),*,err=10) nvar
        log_nvar=.true.
      else if (index(line(1:ix),'SHADOWS').ne.0) then
        ii=index(line(1:ix),'SHADOWS')
        read(line(1:ii-1),*,err=10) ishad
        read(line(ii+7:ix),*,err=10) ktem
        kshad(ishad)=ktem
        log_shad(ishad)=.true.
      else if (index(line(1:ix),'BOUNDS').ne.0) then
        ii=index(line(1:ix),'BOUNDS')
        if (log_nvar) then
          do iv=1,nvar
c            read(10,*,err=999) lb(iv),ub(iv),vm(iv)
c          end do
c          log_bounds=.true.
            line=' '
            read(10,1010,end=100) line
            ig=index(line(1:132),'G')
            itorf=index(line(1:132),'Torsion file')
            gaussb(iv)=(ig.ne.0)
            ltorfil(iv)=(itorf.ne.0)
            if (ltorfil(iv)) gaussb(iv)=.false.
            if (ltorfil(iv)) then
              read(line(1:itorf-1),*,err=999) lb(iv),ub(iv),vm(iv)
              torfile(iv)=' '
              read(line(itorf+12:132),5020,err=999) torfile(iv)
 5020         format(a)
ccc	write(6,*) iv,torfile(iv)(1:60)
            else if (gaussb(iv)) then
              read(line(1:ig-1),*,err=999) lb(iv),ub(iv),vm(iv)
              read(line(ig+1:132),*,err=999) cen(iv),sig(iv)
            else
              read(line(1:132),*,err=999) lb(iv),ub(iv),vm(iv)
            end if
ccc            write(6,*) lb(iv),ub(iv),vm(iv),cen(iv),sig(iv)
          end do
          log_bounds=.true.
        else
c.. we need to know the number of variables before we can read the bounds
          goto 999
        end if
      else if (index(line(1:ix),'PRESET').ne.0) then
        ii=index(line(1:ix),'PRESET')
        if (log_nvar) then
          do iv=1,nvar
            read(10,*,err=999) xpreset(iv)
          end do
          log_preset=.true.
        else
c.. we need to know the number of variables before we can read the preset values
          goto 999
        end if
      else if (index(line(1:ix),'INF').ne.0) then
        ii=index(line(1:ix),'INF')
        do jj=ii+3,ix
          if (line(jj:jj).ne.' ') then
            kk=1
            inf_file(kk:kk)=line(jj:jj)
            do k=jj+1,ix
              if (line(k:k).ne.' ') then
                kk=kk+1
                inf_file(kk:kk)=line(k:k)
                lfinf=kk
              else
                goto 14
              end if
            end do
            goto 14
          end if
        end do
 14     log_inf_file=.true.
        inf_file(lfinf+1:lfinf+4)='.inf'
        lfinf=lfinf+4
c        zm_file(:lfinf)=inf_file(:lfinf)
c        zm_file(lfinf+1:lfinf+8)='.zmatrix'
c        lfzm=lfinf+8
      else if (index(line(1:ix),'FRAG').ne.0) then
        nfrag=nfrag+1
        ii=index(line(1:ix),'FRAG')
        do jj=ii+4,ix
          if (line(jj:jj).ne.' ') then
            kk=1
            frag_file(nfrag)(kk:kk)=line(jj:jj)
            do k=jj+1,ix
              if (line(k:k).ne.' ') then
                kk=kk+1
                frag_file(nfrag)(kk:kk)=line(k:k)
                lfrag(nfrag)=kk
              else
                goto 141
              end if
            end do
            goto 141
          end if
        end do
 141    log_frag_file=.true.
        ltem=lfrag(nfrag)+1
        frag_file(nfrag)(ltem:ltem+7)='.zmatrix'
        lfrag(nfrag)=lfrag(nfrag)+8
      else if (index(line(1:ix),'T0').ne.0) then
        ii=index(line(1:ix),'T0')
        read(line(ii+2:ix),*,err=10) T0
        log_T0=.true.
      else if (index(line(1:ix),'TARGET').ne.0) then
        ii=index(line(1:ix),'TARGET')
        read(line(ii+6:ix),*,err=10) target_value
        log_target_value=.true.
      else if (index(line(1:ix),'REDUCE').ne.0) then
        ii=index(line(1:ix),'REDUCE')
        read(line(ii+6:ix),*,err=10) rt
        log_reduce=.true.
c.. hydrogens
      else if (index(line(1:ix),'HYDROGENS').ne.0) then
        log_hydrogens=.true.
      else if (index(line(1:ix),'EPSI').ne.0) then
        ii=index(line(1:ix),'EPSI')
        read(line(ii+4:ix),*,err=10) eps
        log_eps=.true.
      else if (index(line(1:ix),'#NS').ne.0) then
        ii=index(line(1:ix),'#NS')
        read(line(ii+3:ix),*,err=10) ns
        log_ns=.true.
      else if (index(line(1:ix),'#NT').ne.0) then
        ii=index(line(1:ix),'#NT')
        read(line(ii+3:ix),*,err=10) nt
        log_nt=.true.
      else if (index(line(1:ix),'NEPS').ne.0) then
        ii=index(line(1:ix),'NEPS')
        read(line(ii+4:ix),*,err=10) neps
        log_neps=.true.
      else if (index(line(1:ix),'MAXEVL').ne.0) then
        ii=index(line(1:ix),'MAXEVL')
        read(line(ii+6:ix),*,err=10) maxevl
        log_maxevl=.true.
      else if (index(line(1:ix),'IPRINT').ne.0) then
        ii=index(line(1:ix),'IPRINT')
        read(line(ii+6:ix),*,err=10) iprint
        log_iprint=.true.
      else if (index(line(1:ix),'ISEED1').ne.0) then
        ii=index(line(1:ix),'ISEED1')
        read(line(ii+6:ix),*,err=10) iseed1
        log_iseed1=.true.
      else if (index(line(1:ix),'ISEED2').ne.0) then
        ii=index(line(1:ix),'ISEED2')
        read(line(ii+6:ix),*,err=10) iseed2
        log_iseed2=.true.
      end if
      goto 10
c
c.. check if parameters have been specified - if not use defaults.
 100  if (.not.log_inf_file) goto 999
      if (.not.log_frag_file) goto 999
      if (.not.log_nvar) goto 999
      if (.not.log_bounds) goto 999
      if (.not.log_T0) T0=200.0
      if (.not.log_target_value) target_value=20.0
      if (.not.log_reduce) rt=0.1
      if (.not.log_eps) eps=0.1
      if (.not.log_ns) ns=20
      if (.not.log_nt) nt=min(100,5*nvar)
      if (.not.log_neps) neps=4
      if (.not.log_maxevl) maxevl=1000000
      if (.not.log_iprint) iprint=0
      if (.not.log_iseed1) iseed1=401
      if (.not.log_iseed2) iseed2=101
c
      GOTO 999
 998  IER=1
      CALL ERROR_MESSAGE(2)
 999  close(10)
      end
!
!*****************************************************************************
!
! Originally in zm_upload.f90
!
      subroutine zm_upload()
!
!
  USE WINTERACTER
  USE DRUID_HEADER
!
      character*80 line
      parameter (maxatm=100)
      parameter (maxfrg=20)
      double precision a,b,c,al,be,ga
      double precision tiso,occ
      double precision blen,alph,bet,f2cmat
      character*3 asym
      integer ioptb,iopta,ioptt,iz1,iz2,iz3
      common /zmcomi/ ntatm,natoms(maxfrg),&
     ioptb(maxatm,maxfrg),iopta(maxatm,maxfrg),ioptt(maxatm,maxfrg),&
     iz1(maxatm,maxfrg),iz2(maxatm,maxfrg),iz3(maxatm,maxfrg)
      common /zmcomr/ blen(maxatm,maxfrg),alph(maxatm,maxfrg),&
     bet(maxatm,maxfrg),f2cmat(3,3)
      common /zmcomc/ asym(maxatm,maxfrg)
      common /zmcomo/ a(maxfrg),b(maxfrg),c(maxfrg),&
      al(maxfrg),be(maxfrg),ga(maxfrg),tiso(maxatm,maxfrg),&
      occ(maxatm,maxfrg)              
!
      common /frgcom/ nfrag,lfrag(maxfrg)
      character*80 frag_file
      common /frgcha/ frag_file(maxfrg)
      common /zmcomg/ icomflg(maxfrg)
!
            CALL WDialogSelect(IDD_zmatrix_files)
            CALL WDialogPutInteger(IDF_nfrag,NFRAG)
            CALL WGridRows(IDF_zmatrixfile_grid,nfrag)
            DO i=1,nFRAG
              CALL WGridPutCellString(IDF_zmatrixfile_grid,1,i,frag_file(i)(:lfrag(i)))
            END DO
!
!
      end
!
!*****************************************************************************
!
! Originally in Ccslmain.for
!

C
C LEVEL 2      SUBROUTINE AINOUT(K,FBUF,N,N1,MODE)
      SUBROUTINE AINOUT(K,FBUF,N,N1,MODE)
C
C *** AINOUT by PJB June 92 ***
C
CX
CC 2B
CH Multiple function routine called by ARRNGE type programs to
CH process sort items.
CA The function is chosen by MODE:
CA   MODE = 0 Initialise: vector K of length N holds the limits for the
CA            sorting keys. Sets N1 items to be associated with the sorted
CA            quantity.
CA   MODE = 1 Enter the items in FBUF creating the sort key from K
CA   MODE = 2 Sort all items read
CA   MODE = 3 Return the next item from the sorted list in FBUF together with
CA            the unpacked key in K and the number of identically labelled
CA            items in N. N1 is set to indicate the most significant K that
CA            changes after the Nth item.
CA   MODE = 4 Simply return the next item in the sorted list in FBUF and
CA            the number remaining from the same group in N
C
C
      DIMENSION K(6),FBUF(1)
      COMMON /ARSORT/NREFS,KEYS,ITEMS,LRPACK(10,3),
     & MS,KP,JPOINT,ICOUNT,KOLD(6)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C%
C      COMMON /SCRAT/MSORT(%NOBS%),VALUES(%NO*5%),IPOINT(%NOBS%)
      COMMON /SCRAT/MSORT(4000),VALUES(20000),IPOINT(4000)
C%
C      DATA NOBS,NVALS/%NOBS%,%NO*5%/
      DATA NOBS,NVALS/4000,20000/
C
      GO TO (1,11,21,31,41) MODE+1
C
    1 CALL NPACK(I,K,N,0,LRPACK)
      KEYS=N
      ITEMS=N1
      JPOINT=1
      NREFS=0
      GO TO 100
C
   11 CALL ERRCHK(2,NREFS,NOBS,0,'reflections to sort')
      CALL ERRCHK(1,JPOINT+ITEMS,NVALS,0,'values to store for sorting')
      CALL GMEQ(FBUF,VALUES(JPOINT),ITEMS,1)
      JPOINT=JPOINT+ITEMS
      CALL NPACK(MSORT(NREFS),K,KEYS,1,LRPACK)
      GO TO 100
C
   21 IF (NREFS.EQ.0) CALL ERRMES(1,0,'No reflections to sort')
      CALL MESS(ITO,0,'Sort started . . . ')
      CALL SORTN(MSORT,IPOINT,NREFS)
      WRITE (ITO,2001)NREFS
 2001 FORMAT ('+Sort started . . sorted',I4,' records ')
      MS=MSORT(IPOINT(1))
      CALL NPACK(MS,KOLD,KEYS,2,LRPACK)
      KP=1
      N=NREFS
      GO TO 100
C
   31 CALL JGMEQ(KOLD,K,KEYS,1)
      I=1+(IPOINT(KP)-1)*ITEMS
      CALL GMEQ(VALUES(I),FBUF,ITEMS,1)
      N=1
   32 KP=KP+1
      ICOUNT=N
      IF (KP.GT.NREFS) THEN
        N1=0
        GO TO 100
      ENDIF
      IF (MSORT(IPOINT(KP)).NE.MS) THEN
        MS=MSORT(IPOINT(KP))
        CALL NPACK(MS,KOLD,KEYS,2,LRPACK)
        DO 33 I=1,KEYS
        IF (KOLD(I).NE.K(I)) THEN
          N1=I
          GO TO 100
        ENDIF
   33   CONTINUE
      ENDIF
      N=N+1
      GO TO 32
C
   41 ICOUNT=ICOUNT-1
      I=1+(IPOINT(KP-ICOUNT)-1)*ITEMS
      CALL GMEQ(VALUES(I),FBUF,ITEMS,1)
      N=ICOUNT
      GO TO 100
C
  100 RETURN
      END
C
C

C
C LEVEL 3      SUBROUTINE ALRPOL(H,ALR,POL,MODE)
      SUBROUTINE ALRPOL(H,ALR,POL,MODE)
C
C *** ALRPOL by JCM 24 Sep 85 ***
C
CX
CC 2B
CH Calculates the reciprocals of Lorentz and polarisation factors.
C
CA H is a 3-size real array holding h,k,l on entry
CA ALR on exit will hold the Lorentz factor
CA POL on exit will hold the polarisation factor
CA MODE on entry =1 if wavelength is already in WLGTH (or ALAMBD)
CA               =2 if wavelength is not set, but SINTH holds sin theta,
CA                  and the wavelength will not be required.
C
CP SETDC must have been obeyed to read necessary D cards to COMMON /DGEOM
C
CP SETLP calls SETDC; it also checks that if a monochromator angle is
CP needed it has been supplied, and ANGLIN(2) holds cos sqrd 2 theta
CP monochromator. POL will be modified appropriately.
CP
CP SETDC has set the geometry type into IGEOM;  possible types are:
CP       IGEOM = 1 Normal beam
CP       IGEOM = 2 Normal beam equatorial
CP       IGEOM = 3 Equi-inclination Weissenberg
CP       IGEOM = 6 4 circle bisecting
CP       IGEOM = 7 4 circle angles given
CP       IGEOM = 8 D3
CP       IGEOM = 9 Powder data, no polarisation
CP       IGEOM = 10 Powder data, X ray
CP       IGEOM = 11 4 circle high chi
CP       IGEOM = 12 SXD geometry
C
      DIMENSION H(3),OH(3),UL(3)
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(5,5),
     & NLAMB,ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C
C REFER H TO STANDARD ORTHOGONAL AXES IN OH, AND MAKE IT A UNIT VECTOR:
      CALL ORTHO(H,OH,2)
      CALL UNIVEC(OH,AK)
C MODE 2 ALLOWS FOR SINTH ALREADY SET ON INPUT (USEFUL IF NO SPECIFIC WLGTH)
      IF (MODE .NE. 2) SINTH = WLGTH*AK*0.5
      CALL SINCOS(SINTH,COSTH,'LP 1')
C THE CORE OF THE LORENTZ CORRECTION IS SIN 2 THETA:
      SIN2TH = 2.*SINTH*COSTH
      ALR=SIN2TH
C NOW ADJUST FOR PARTICULAR IGEOM:
      GO TO (1,2,3,4,4,2,2,8,9,9) , IGEOM
C
   4  CALL ERRIN2(IGEOM,0,'Geometry type','not avaiable in ALRPOL')
C
C NORMAL BEAM:
   1  CALL GMEQ(UM(1),UL,1,3)
      GO TO 6
C
C EQUI-INCLINATION WEISSENBERG:
   3  CALL GMEQ(UM(1),UL,1,3)
      CSPHI=SCALPR(OH,UL)
      CALL SINCOS(CSPHI,SNPHI,'LP 3')
      ALR=ALR*SNPHI
      GO TO 2
C
C D3:
   8  DO 11 I=1,3
  11  UL(I)=UM(I*3)
   6  CSPHI=SCALPR(OH,UL)
      SNRHO=CSPHI/COSTH
      IF (ABS(SNRHO-1.) .LT.  10.E-4) GO TO 5
      ALR=0.
      POL=0.
      WRITE (LPT,3001) H
      WRITE (ITO,3001) H
3001  FORMAT (' WARNING ** REFLEXION',3F4.0,' SHOULD NOT OCCUR')
      GO TO 100
C
   5  CALL SINCOS(SNRHO,CSRHO,'LP 2')
      ALR=ALR*CSRHO
      GO TO 2
C
C  POWDER DATA:
   9  ALR=ALR*SINTH
      GO TO 2
C
C POLARISATION CORRECTION:
   2  GO TO (21,22,22,4,4,22,22,21,29,22), IGEOM
C
C NO POLARISATION:
  29  POL=1.
      GO TO 100
C
C RHO = 0:
  22  CSQRHO=1.
      SSQRHO=0.
      GO TO 20
C
C RHO ALREADY SET UP IN LORENTZ CALCULATION:
  21  CSQRHO=CSRHO*CSRHO
      SSQRHO=SNRHO*SNRHO
C
C SET COS2TH = COS 2 THETA
  20  CALL SINCOS(SIN2TH,COS2TH,'LP 5')
      POL = (1. +ANGLIN(2))/((SSQRHO+ANGLIN(2)*CSQRHO)*COS2TH*COS2TH +
     & CSQRHO + ANGLIN(2)*SSQRHO)
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE ABSCOR(IS)
      SUBROUTINE ABSCOR(IS)
C
C *** ABSCOR updated by PJB 24-Apr-1995 ***
C
CX
CC 2B
CH Applies absorption corrections to groups of equivalent reflections.
C
CA On entry IS =0 for the initial seting up, or 1 for the calculation
C
CP SYMOP, RECIP, SETABS should be obeyed first to set up calls of ABSOR
CP A group of reflections should be present in /REFS/
C
CO If IOUT is > 9 on entry IS=0, creates output unit LP2
CO (Note that this is a non-standard use of IOUT & better change)
CO For entries IS=1, writes to that unit
C
CN A PJB speciality called from ABSMSF
C
      EXTERNAL ABSHED
      DIMENSION ANG(4),KK(3),W1(5),W2(5)
      LOGICAL NEW
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(5,5),
     & NLAMB,ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /HEDABS/HEDAB
      CHARACTER*104 HEDAB
      COMMON /HEDAB2/LP2,LINB,IANG
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /REFS/K(3,2),JJ(48,2),LL(48,2),R(500,2),SCALE(2),INC,II,NR,
     &FF(3,2),ITEMS
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C
C INITIAL ENTRY:
      IF (IS.NE.0) GO TO 5
      IF (IOUT.LT.10) GO TO 100
      GO TO (100,100,100,100,100,1,1,1,100,100,1) ,IGEOM
      GO TO 100
C
    1 IANG=3
      MESSAG(1:10)='ABSCOR.LIS'
      CALL UPONE(MESSAG,3)
      LP2=NOPFIL(2022)
      IF (INC.EQ.0) GO TO 20
      HEDAB(2:2)='6'
      HEDAB(9:9)='7'
      HEDAB(16:16)='7'
      HEDAB(23:23)='7'
   20 IF (IGEOM .EQ. 8)GO TO 21
      HEDAB(87:)='Chi       Phi''/)'
      IANG=4
   21 WRITE (LP2,HEDAB)
      LINB=3
      GO TO 100
C
C FURTHER ENTRIES:
    5 IR=1
      II=0
    2 L=LL(IR,IS)
      IF (L.EQ.3) GO TO 100
C   SET BEGINNING AND END OF DATA
      IE=II+L
      IB=II+4
      IF (IGEOM.NE.7 .AND. IGEOM.NE.12) THEN
        TRFAC=ABSOR(R(II+1,IS))
        ABSC=1./TRFAC
      ELSE
        NEW=.TRUE.
      ENDIF
C   INITIALIZE
      CALL WTMEAN(X1,Y1,0,W1)
      CALL WTMEAN(X2,Y2,0,W2)
      DO 6 I=IB,IE,ITEMS
      IF (IGEOM.EQ.7) THEN
        IF (.NOT. NEW) THEN
C CHECK FOR EXACT SAME MEASUREMENT
          CALL EQVEC(DIFANG,R(I+2,IS),1,M,0)
          IF (M.EQ.1) GO TO 23
        ENDIF
        CALL GMEQ(R(I+2,IS),ANG,4,1)
        CALL GMSCA(ANG,DIFANG,RAD,4,1)
        TRFAC=ABSOR(R(II+1,IS))
        ABSC=1./TRFAC
      ENDIF
C   ADD IN REPEATED MEASUREMENTS OF THE SAME REFLECTION
   23 CALL WTMEAN(R(I,IS),R(I+1,IS),1,W1)
      R(I,IS)=R(I,IS)*ABSC
      R(I+1,IS)=R(I+1,IS)*ABSC
C   AND ITS INTENSITY AFTER SCALING BY ABSORPTION CORRECTION
      CALL WTMEAN(R(I,IS),R(I+1,IS),1,W2)
    6 CONTINUE
C   FIND MEAN OF REPEATED MEASUREMENTS
      CALL WTMEAN(X1,Y1,-1,W1)
      CALL WTMEAN(X2,Y2,-1,W2)
      IF (IOUT.GT.10) THEN
        IF (IGEOM.NE.7) THEN
C   CALCULATE SETTING ANGLES AS A CHECK
          CALL ANGDIR(R(II+1,IS),ANG)
          DO 4 I=1,IANG
    4     ANG(I)=DEGREE(ANG(I))
        ENDIF
        CALL TESTP(LP2,LINB,1,HEDAB,2)
        IF (INC.EQ.0) THEN
          CALL INDFIX(R(II+1,IS),KK)
          WRITE (LP2,2000) KK,X1,X2,TRFAC,(ANG(I),I=1,IANG)
 2000     FORMAT (2X,3I5,2(2X,F10.2),2X,F10.4,2X,4F10.2)
        ELSE
          WRITE (LP2,2001) (R(II+I,IS),I=1,3),X1,X2,TRFAC,
     &    (ANG(I),I=1,IANG)
 2001     FORMAT (1X,3F8.3,2(2X,F10.2),2X,F10.4,2X,4F10.2)
        ENDIF
      ENDIF
C   ADVANCE POINTER TO NEXT PIECE OF DATA IN ARRAY R(II,IS)
      II=IE+2
      IR=IR+1
      GO TO 2
C
 100  RETURN
      END
C
C
C
C
C LEVEL 4      FUNCTION ABSOR(H)
      FUNCTION ABSOR(H)
C
C *** ABSOR by JCM 24 Sep 85 ***
C
CX
CC 2B
CH Forms a transmission (=1/absorption) factor or related integrals.
C
CA On entry H is a 3-size real array holding h,k,l
C
CP On entry, SETABS (or a MAIN program) has placed in COMMON /ABSDAT
CP         AMU = mu, the coefficient of absorption
CP         MODEA = which integral is required -
CP         MODEA = 1 usual exp(-mu(in+out)) transmission factor to ABSC(1)
CP         MODEA = 2 path in exp(-mu(in)) depolarisation to ABSC(2)
CP         MODEA = 3 derivative (in+out)*exp(-mu(in+out)) extinction to ABSC(3)
CP
CP SETABS has set up (via SETGAU) the Gaussian 3D integration in COMMON /GAUSS
CP
CP SETABS has set up the equations of the plane faces in COMMON /CPLANE.
C
CD Uses 3D Gaussian integration over the crystal as defined by its plane faces
CN There also exists SUBROUTINE ABMULT, which is capable of calcuating more
CN than one type of integral at one entry.  If, e.g., absorption and
CN depolarisation were both required, one call of ABMULT would be more
CN efficient than 2 calls of ABSOR
C
      LOGICAL TESTOV
      DIMENSION H(3),DIREC(3,2)
      COMMON /ABSDAT/AMU,MODEA
      COMMON /CPLANE/AA(15),BB(15),CC(15),DD(15),NP
      COMMON /GAUSS/XX(1000),YY(1000),ZZ(1000),WW(1000),NL,NM,NN,NQ
C
      CALL GETDC(H,DIREC)
      ABSC = 0.
      DO 1 J = 1,NQ
      D = 6000.
      E = 6000.
      DO 2 I = 1,NP
      A = DD(I) - AA(I)*XX(J) - BB(I)*YY(J) - CC(I)*ZZ(J)
      B=AA(I)*DIREC(1,1)+BB(I)*DIREC(2,1)+CC(I)*DIREC(3,1)
      IF (TESTOV(A,B)) GO TO 3
      C = A/B
      IF (C) 3,4,4
   4  IF (C-D) 5,5,3
   5  D = C
   3  B=AA(I)*DIREC(1,2)+BB(I)*DIREC(2,2)+CC(I)*DIREC(3,2)
      IF (TESTOV(A,B)) GO TO 2
      C = A/B
      IF (C) 2,6,6
   6  IF (C-E) 7,7,2
   7  E = C
   2  CONTINUE
      IF (MODEA .GT. 3) CALL ERRIN2(MODEA,0,'for FUNCTION ABSOR MODE',
     & 'not allowed - only 1-3')
      GO TO (8,9,10) , MODEA
   8  ABSC = ABSC + EXP(-AMU*(D+E))*WW(J)
      GO TO 1
   9  ABSC = ABSC + EXP(-AMU*D)*WW(J)
      GO TO 1
  10  ABSC = ABSC + (D+E)*EXP(-AMU*(D+E))*WW(J)
   1  ABSOR=ABSC
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE XYZREL
      SUBROUTINE XYZREL
C
C *** XYZREL by JCM 28 Nov 91 ***
C
CX
CC 6B
CH Collects all position parameter constraints implied by the symmetry.
CD Space group symmetry generated constraints are each between 2 parameters.
CD Some of the relations found may lead to fixings rather than constraints.
CD
CD On exit in /POSREL/ for each atom I the integer array NXYZ(I,1:3) and
CD real array XYZ(I,1:3) hold the constraints.
C
C
      DIMENSION RMAT(3,3)
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /POSREL/NXYZ(3,150),XYZ(3,150)
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
C SCAN ALL ATOMS, PICKING UP RELATIONS BETWEEN POSITION PARAMETERS:
      DO 3 IR=1,NATOM
C CLEAR OUT ALL FIX/RELA INFO FOR THIS ATOM:
      DO 2 K=1,3
      NXYZ(K,IR)=9999
   2  CONTINUE
C
C JUMP IF NOT SPECIAL:
      IF (ISGEN(1,IR) .EQ. 1) GO TO 3
C JUMP IF NOT SPECIAL BECAUSE OF A CENTRE OF SYMMETRY AT THE ORIGIN:
      IF (ISGEN(1,IR) .LE. 0) THEN
C FIX ALL POSITION:
        CALL GMZER(NXYZ(1,IR),1,3)
        GO TO 3
      ENDIF
C
C TAKE FIRST (OF POSSIBLE 2) SYMMETRY ELEMENTS MAKING THIS POSITION SPECIAL:
      DO 1 I=2,3
      K=IABS(ISGEN(I,IR))
      CALL GMEQ(SYM(1,1,K),RMAT,3,3)
      IF (ISGEN(I,IR) .LT. 0) CALL GMREV(RMAT,RMAT,3,3)
      CALL RELSM3(RMAT,NXYZ(1,IR),XYZ(1,IR))
C
C IS THERE A SECOND GENERATOR OF THE SUB-GROUP WHICH MAKES THIS ATOM SPECIAL?
      IF (ISGEN(3,IR) .EQ. 0) GO TO 3
   1  CONTINUE
   3  CONTINUE
 100  RETURN
      END

C
C LEVEL 1      FUNCTION WIYPOS(Y)
C
      FUNCTION WIYPOS(Y)
C
C *** WIYPOS by WIFD 6-JUNE-84 ***
C
CH      GIVES      EXP(Y*Y)ERFNC(Y) FOR +VE Y ONLY
C
      IMPLICIT DOUBLE PRECISION            (A-H,O-V)
      DOUBLE PRECISION LAMBDA
      LOGICAL B
      VY=DBLE(Y)
      IF (VY .LT. 4.29 ) GO TO 1
      H= 0.
      NC= 0
      N= 9
      LAMBDA= 0.
      B= .TRUE.
      GO TO 2
 1      S=(1.0-VY/4.29)
      H=1.6*S
      H2=2.0*H
      NC=6+IDINT(23.0*S)
      N=10+IDINT(21.0*S)
      LAMBDA=H2**NC
      B= .FALSE.
      IF (LAMBDA .EQ. 0.) B= .TRUE.
 2      R1=0.
      S1=0.
 3      N=N-1
      FN=N+1
      T1=VY+H+FN*R1
      R1=0.5/T1
      IF (H .LE. 0.0 .OR. N .GT. NC) GO TO 4
      S1=R1*(LAMBDA+S1)
      LAMBDA=LAMBDA/H2
 4      IF (N .GT. 0) GO TO 3
      IF (B) GO TO 6
      VR= S1
      GO TO 7
 6      VR= R1
 7      VR= 1.12837916709551*VR
      IF (VY .EQ. 0.0) VR= 1.
      WIYPOS= VR
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE WGHTSF(H)
      SUBROUTINE WGHTSF(H)
C
C *** WGHTSF updated by JCM 29 Jun 87 ***
C
CX
CC 6C
CH Deals with weights of LSQ observations for single crystal.
CA On entry H is a real 1x3 vector containg h,k,l
CD Puts weight of observation at H into WT, its square root into SQRTWT,
CD and WDIFF = SQRTWT times difference, all according to IWGHT.
C
      LOGICAL TESTOV
      DIMENSION H(3)
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
      GO TO (1,2) ,IWGHT
C
C  NO WEIGHTS
   1  WT=1.
      SQRTWT=1.
      GO TO 101
C
C GOES WITH MODER=2 OR 3 - IF 2, EXPECT WT TO BE ALREADY THERE,
C PROBABLY READ AT SAME TIME AS REFLECTION DATA.   IF 3, EXPECT
C SIGMA, THE STANDARD DEVIATION OF THE OBSERVATION, TO BE ALREADY
C THERE IN DOBS
   2  GO TO (1,21,22,22,22,22,22,22) , MODER
  21  SQRTWT=SQRT(WT)
      GO TO 101
C
  22  SQRTWT=0.
      IF (.NOT. TESTOV(1.,DOBS)) SQRTWT=ABS(1./DOBS)
      WT=SQRTWT*SQRTWT
 101  WDIFF=DIFF*SQRTWT
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE VARST2
      SUBROUTINE VARST2
C
C *** VARST2 by JCM 17 Aug 92 ***
C
CX
CC 7B
CH Makes variables for zero and cell for T2 type LSQ
CP Only useful if called from T2LSQ or similar.  Expects suitable type
CP of Least Squares to be set up.
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans all variables as made by VARMAK, identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /ZEROPT/ZERO,KZERO
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      CALL CELVAR(0,0)
      KZERO=0
C
C COUNT ALL VARIABLES:
      DO 1 I=1,LVARV
C J=WHICH BASIC VARIABLE:
      J=LVRBS(I)
C KPACK=WHICH PACKED PARAMETER SPEC:
      KPACK=LVRPR(I)
C
C AND ITS FAMILY, GENUS AND SPECIES:
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C FAMILY 1, GENUS 1 - CELL PARAMETERS:
      IF (IGEN .EQ. 1) THEN
        IF (ISPC .EQ. 7) THEN
          KZERO=I
        ELSE
          CALL CELVAR(ISPC,I)
        ENDIF
      ENDIF
C
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE VARSSF
      SUBROUTINE VARSSF
C
C *** VARSSF by JCM 16 Nov 90 ***
C
CX
CC 7A
CH Records variable pointers for all variables in structure-factor LSQ.
CP VARMAK has set up the variables
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans variables as made by VARMAK.  Identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      CALL LTFAC9
      CALL CELVAR(0,0)
      CALL EXTIN9
      CALL LSCAL9
      CALL F2VAR9
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
      KPACK=LVRPR(I)
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C
C BRANCH ON FAMILY:
      GO TO (11,12), IFAM
C
  11  GO TO (21,22) , IGEN
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SPECIES (TFAC,A*,B* . . F*,DOMR,MOSC):
  21  GO TO (31,32,32,32,32,32,32,33,33) , ISPC
C
C TFAC:
  31  CALL LTFAC8(I)
      GO TO 1
C
C DOMR OR MOSC (EXTINCTION CORRECTION PARAMETERS)
  33  CALL EXTIN8(ISPC-7,I)
      GO TO 1
C
C CELL PARAMETERS:
  32  CALL CELVAR(ISPC-1,I)
      GO TO 1
C
C FAMILY 1, GENUS 2 - IN SF THIS IS 'SCAL':
  22  CALL LSCAL8(ISPC,I)
      GO TO 1
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .LE. 12) CALL F2VAR8(IGEN,ISPC,I)
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE VARSDS
      SUBROUTINE VARSDS
C
C *** VARSDS updated by PJB 29-Sept-93  ***
C
CX
CC 7A
CH Makes variables for cell parameters and propagation vector for d-spacing LSQ.
CP Only useful if called from DSLSQ or similar.  Expects suitable type
CP of Least Squares to be set up.
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans all variables as made by VARMAK, identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
C SET ALL VARIABLES FIXED:
      CALL CELVAR(0,0)
      CALL PROPAG(0,0)
C
C COUNT ALL VARIABLES:
      DO 1 I=1,LVARV
C J=WHICH BASIC VARIABLE:
      J=LVRBS(I)
C KPACK=WHICH PACKED PARAMETER SPEC:
      KPACK=LVRPR(I)
C
C AND ITS FAMILY, GENUS AND SPECIES:
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C FAMILY 1, GENUS 1 - CELL PARAMETERS:
      IF (IFAM .EQ. 1 .AND. IGEN .EQ. 1) THEN
        IF (ISPC.LE.6) THEN
          CALL CELVAR(ISPC,I)
        ELSE
          CALL PROPAG(-ISPC+6,I)
        ENDIF
      ELSE
        CALL ERRMES(-1,0,' parameter in DSLSQ not of family 1 genus 1')
      ENDIF
C
   1  CONTINUE
 100  RETURN
      END
C
C
C
C LEVEL 13      SUBROUTINE VARSMP
      SUBROUTINE VARSMP
C
C *** VARSMP by JCM 8 Feb 91 ***
C
CX
CC 7A
CH Records pointers for all variables in multipole LSQ.
CP VARMAK has set up the variables
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans variables as made by VARMAK.  Identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      CALL LTFAC9
      CALL CELVAR(0,0)
      CALL MAGVAR(0,0,0)
      CALL EXTIN9
      CALL LSCAL9
      CALL F2VAR9
      CALL MPOVAR(0,0)
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
      KPACK=LVRPR(I)
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C
C BRANCH ON FAMILY:
      GO TO (11,12,1,1,15), IFAM
C
  11  GO TO (21,22) , IGEN
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SPECIES (TFAC,A*,B* . . F*,DOMR,MOSC):
  21  GO TO (31,32,32,32,32,32,32,33,33) , ISPC
C
C TFAC:
  31  CALL LTFAC8(I)
      GO TO 1
C
C DOMR OR MOSC (EXTINCTION CORRECTION PARAMETERS)
  33  CALL EXTIN8(ISPC-7,I)
      GO TO 1
C
C CELL PARAMETERS:
  32  CALL CELVAR(ISPC-1,I)
      GO TO 1
C
C FAMILY 1, GENUS 2 - IN SF THIS IS 'SCAL':
  22  CALL LSCAL8(ISPC,I)
      GO TO 1
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .LE. 12) CALL F2VAR8(IGEN,ISPC,I)
      IF (ISPC .GT. 12) CALL MAGVAR(IGEN,ISPC,I)
      GO TO 1
C
C MULTIPOLES:
  15  CALL MPOVAR(ISPC,I)
   1  CONTINUE
 100  RETURN
      END
C
C

C
C
C LEVEL 2      SUBROUTINE SHUFLE(JORD,IORD)
      SUBROUTINE SHUFLE(JORD,IORD)
C
C *** SHUFLE by PJB Jan 86 ***
C
CX
CC 1A
CH Reorders the symmetry operators for various specialist applications.
C
      LOGICAL BINDIG
C%
C      DIMENSION IORD(%SYMO%),JORD(%SYMO%),L(%SYMO%)
      DIMENSION IORD(24),JORD(24),L(24)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
      COMMON /SYMREP/REP(9,25),AKVEC(3),LREP(25),NREP,IVEC,ANORM,
     & NOPS,NOPP,NCSTAR,TREP(25,2,2)
      COMPLEX REP,TREP
      COMMON /SYMTAB/MULTAB(24,24),INVERS(24),
     & NORD(24),IGEN(3),KOM22
C
      IF (BINDIG(IOUT,16)) THEN
        WRITE (ITO,4000) (JORD(I),I=1,NOPC)
        WRITE (LPT,4000) (JORD(I),I=1,NOPC)
        WRITE (ITO,4000) (IORD(I),I=1,NOPC)
        WRITE (LPT,4000) (IORD(I),I=1,NOPC)
4000    FORMAT (/' ',2(12I4))
      ENDIF
      CALL JGMZER(L,1,NOPC)
C
C  NOW SHUFFLE TABLE
      DO 3 NN=2,NOPC
      NNN=NN
      IF (L(NN).EQ.1) GO TO 3
      INN=JORD(NN)
      IF (INN.EQ.NN) INN=1
C
C  SAVE A ROW IN PLACE OF ROW 1
C REPLACES CALL GMEQ(MULTAB(1,NN),MULTAB(1,1),NOPC,1)
      DO 88 IJ=1,NOPC
  88  MULTAB(IJ,1)=MULTAB(IJ,NN)
C  AND A SYMMETRY OPERATOR
      CALL GMEQ(SYM(1,1,NN),SYM(1,1,1),3,3)
      CALL GMEQ(TRANS(1,NN),TRANS(1,1),3,1)
      CALL CGMEQ(REP(1,NN),REP(1,1),NREP,NREP)
      INVERS(1)=INVERS(NN)
      NORD(1)=NORD(NN)
      LREP(1)=LREP(NN)
C
C  NOW SHUFFLE ROW INN INTO ROW NN
    6 DO 5 N=1,NOPC
      M=MULTAB(JORD(N),INN)
    5 MULTAB(N,NNN)=IORD(M)
C  AND REPLACE THE NNN TH SYMMMTRY OPERATOR
      CALL GMEQ(TRANS(1,INN),TRANS(1,NNN),3,1)
      CALL GMEQ(SYM(1,1,INN),SYM(1,1,NNN),3,3)
      CALL CGMEQ(REP(1,INN),REP(1,NNN),NREP,NREP)
      INVERS(NNN)=IORD(INVERS(INN))
      NORD(NNN)=NORD(INN)
      LREP(NNN)=LREP(INN)
C
C  NOW FIND OU WHAT TO DO NEXT
      IF (INN.EQ.1) GO TO 3
C  MARK INN 'DONE'
      L(INN)=1
      NNN=INN
      IF (JORD(INN).EQ.0) GO TO 9
      INN=JORD(INN)
      IF (L(INN).EQ.0) GO TO 8
      GO TO 3
    8 IF (INN.EQ.NN) INN=1
      GO TO 6
    9 INN=1
      GO TO 6
C
    3 CONTINUE
C
C  NOW REWRITE ROW 1
       DO 7 N=1,NOPC
    7 MULTAB(N,1)=N
C  AND SYMMETRY ELEMENT NUMBER 1, THE IDENTITY ELEMENT
      DO 4 I=1,3
      TRANS(I,1)=0.
      SYM(I,I,1)=1.
      DO 4 J=1,3
      IF (I.EQ.J) GO TO 4
      SYM(I,J,1)=0.
    4 CONTINUE
C
      IJ=0
      DO 20 I=1,NREP
      DO 20 J=1,NREP
      IJ=IJ+1
   20 REP(IJ,1)=CMPLX(SYM(I,J,1),0.)
      NORD(1)=1
      LREP(1)=1
      INVERS(1)=1
C
      IF (BINDIG(IOUT,16)) THEN
        WRITE (ITO,4000)
        WRITE (LPT,4000)
        DO 50 I=1,NOPC
        WRITE (ITO,4000) (MULTAB(J,I),J=1,NOPC)
   50   CONTINUE
      ENDIF
C
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ABMULT(H,ABSC)
      SUBROUTINE ABMULT(H,ABSC)
C
C *** ABMULT by JCM 24 Sep 85 ***
C
CX
CC 2B
CH Forms transmission (=1/absorption) factors or related integrals.
C
CA On entry:
CA    H is a 3-size real array holding h,k,l on entry
CA    ABSC is a 3-size real array to hold the requested integrals on exit
C
CP On entry, SETABS (or a MAIN program) has placed in COMMON /ABSDAT
CP         AMU = mu, the coefficient of absorption
CP         MODEA = which integral is required -
CP         MODEA = 1 usual exp(-mu(in+out)) transmission factor to ABSC(1)
CP         MODEA = 2 path in exp(-mu(in)) depolarisation to ABSC(2)
CP         MODEA = 3 derivative (in+out)*exp(-mu(in+out)) extinction to ABSC(3)
CP         MODEA = 4 means do 1 and 2
CP         MODEA = 5 means do 1 and 3
CP         MODEA = 6 means do 2 and 3
CP         MODEA = 7 means do all three integrals
CP
CP SETABS has set up (via SETGAU) the Gaussian 3D integration in COMMON /GAUSS
CP
CP SETABS has set up the equations of the plane faces in COMMON /CPLANE.
C
CD Uses 3D Gaussian integration
C
CN There exists also the FUNCTION ABSOR(H), which is similar to ABMULT but will
CN only do one answer at once.
C
      LOGICAL TESTOV
      DIMENSION H(3),DIREC(3,2),ABSC(3)
      COMMON /ABSDAT/AMU,MODEA
      COMMON /CPLANE/AA(15),BB(15),CC(15),DD(15),NP
      COMMON /GAUSS/XX(1000),YY(1000),ZZ(1000),WW(1000),NL,NM,NN,NQ
C
      CALL GETDC(H,DIREC)
      DO 11 I=1,3
  11  ABSC(I)=0.
      DO 1 J = 1,NQ
      D = 6000.
      E = 6000.
      DO 2 I = 1,NP
      A = DD(I) - AA(I)*XX(J) - BB(I)*YY(J) - CC(I)*ZZ(J)
      B=AA(I)*DIREC(1,1)+BB(I)*DIREC(2,1)+CC(I)*DIREC(3,1)
      IF (TESTOV(A,B)) GO TO 3
      C = A/B
      IF (C) 3,4,4
   4  IF (C-D) 5,5,3
   5  D = C
   3  B=AA(I)*DIREC(1,2)+BB(I)*DIREC(2,2)+CC(I)*DIREC(3,2)
      IF (TESTOV(A,B)) GO TO 2
      C = A/B
      IF (C) 2,6,6
   6  IF (C-E) 7,7,2
   7  E = C
   2  CONTINUE
      IF (MODEA .GT. 7) CALL ERRIN2(MODEA,0,'for ABMULT MODE',
     & 'not allowed - only 1-7')
C
      GO TO (20,21,20,20,20,20,20) , MODEA
  20  TERM=EXP(-AMU*(D+E))*WW(J)
  21  GO TO (8,9,10,8,8,9,8) , MODEA
   8  ABSC(1)=ABSC(1)+TERM
      GO TO (1,1,1,9,10,1,9) , MODEA
   9  ABSC(2)=ABSC(2)+EXP(-AMU*D)*WW(J)
      GO TO (1,1,1,1,1,10,10) , MODEA
  10  ABSC(3)=ABSC(3) + (D+E)*TERM
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ABMULT(H,ABSC)
      SUBROUTINE ABMULT(H,ABSC)
C
C *** ABMULT by JCM 24 Sep 85 ***
C
CX
CC 2B
CH Forms transmission (=1/absorption) factors or related integrals.
C
CA On entry:
CA    H is a 3-size real array holding h,k,l on entry
CA    ABSC is a 3-size real array to hold the requested integrals on exit
C
CP On entry, SETABS (or a MAIN program) has placed in COMMON /ABSDAT
CP         AMU = mu, the coefficient of absorption
CP         MODEA = which integral is required -
CP         MODEA = 1 usual exp(-mu(in+out)) transmission factor to ABSC(1)
CP         MODEA = 2 path in exp(-mu(in)) depolarisation to ABSC(2)
CP         MODEA = 3 derivative (in+out)*exp(-mu(in+out)) extinction to ABSC(3)
CP         MODEA = 4 means do 1 and 2
CP         MODEA = 5 means do 1 and 3
CP         MODEA = 6 means do 2 and 3
CP         MODEA = 7 means do all three integrals
CP
CP SETABS has set up (via SETGAU) the Gaussian 3D integration in COMMON /GAUSS
CP
CP SETABS has set up the equations of the plane faces in COMMON /CPLANE.
C
CD Uses 3D Gaussian integration
C
CN There exists also the FUNCTION ABSOR(H), which is similar to ABMULT but will
CN only do one answer at once.
C
      LOGICAL TESTOV
      DIMENSION H(3),DIREC(3,2),ABSC(3)
      COMMON /ABSDAT/AMU,MODEA
      COMMON /CPLANE/AA(15),BB(15),CC(15),DD(15),NP
      COMMON /GAUSS/XX(1000),YY(1000),ZZ(1000),WW(1000),NL,NM,NN,NQ
C
      CALL GETDC(H,DIREC)
      DO 11 I=1,3
  11  ABSC(I)=0.
      DO 1 J = 1,NQ
      D = 6000.
      E = 6000.
      DO 2 I = 1,NP
      A = DD(I) - AA(I)*XX(J) - BB(I)*YY(J) - CC(I)*ZZ(J)
      B=AA(I)*DIREC(1,1)+BB(I)*DIREC(2,1)+CC(I)*DIREC(3,1)
      IF (TESTOV(A,B)) GO TO 3
      C = A/B
      IF (C) 3,4,4
   4  IF (C-D) 5,5,3
   5  D = C
   3  B=AA(I)*DIREC(1,2)+BB(I)*DIREC(2,2)+CC(I)*DIREC(3,2)
      IF (TESTOV(A,B)) GO TO 2
      C = A/B
      IF (C) 2,6,6
   6  IF (C-E) 7,7,2
   7  E = C
   2  CONTINUE
      IF (MODEA .GT. 7) CALL ERRIN2(MODEA,0,'for ABMULT MODE',
     & 'not allowed - only 1-7')
C
      GO TO (20,21,20,20,20,20,20) , MODEA
  20  TERM=EXP(-AMU*(D+E))*WW(J)
  21  GO TO (8,9,10,8,8,9,8) , MODEA
   8  ABSC(1)=ABSC(1)+TERM
      GO TO (1,1,1,9,10,1,9) , MODEA
   9  ABSC(2)=ABSC(2)+EXP(-AMU*D)*WW(J)
      GO TO (1,1,1,1,1,10,10) , MODEA
  10  ABSC(3)=ABSC(3) + (D+E)*TERM
   1  CONTINUE
      RETURN
      END
C
C

C
C
C
C LEVEL 8      SUBROUTINE GAMEX(R,G,FC,QQ,IERR)
      SUBROUTINE GAMEX(R,G,FC,QQ,IERR)
C
C *** GAMEX updated by JCM 23 Sep 91 ***
C
CX
CC 2B
CH Calculates an extinction corrected gamma from a flipping ratio.
CA On entry R is a 1x2 real array holding the flipping ratio and its
CA            standard deviation
CA          FC is the value of the nuclear structure factor
CA          QQ is sin(alpha) the angle between Q and k
CA On exit  G(1)  holds the extinction corrected gamma
CA          IERR=0 if no error
CA               1 if no zero found in range
CA               2 if no convergence after 50 iterations
C
      DIMENSION R(2),G(2),F(2),PP(4)
      COMMON /EXTN/IEXTYP,DOMR,KDOMR,AMOSC,KMOSC,EXTCOR,CEXT(4),
     & DEXDFQ,DEXDRQ,DEXDGQ,LOREN,GAUSS
      LOGICAL LOREN,GAUSS
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POLDA/P,DP,E,DE,MODE,POLND(3)
      DATA ITER,PREC/100,10./
C
      IERR=0
C IF IN FACT NO EXTINCTION, SET RS TO BE GAMMAS AND EXIT:
      IF (IEXTYP .EQ. 0) THEN
        CALL GMEQ(G,R,1,2)
        GO TO 100
      ENDIF
C
C  SET LIMITS
      GLIM=SIGN(1.,G(1))
      A=AMIN1(GLIM,G(1))
      B=AMAX1(GLIM,G(1))
      ERR=G(2)/PREC
      K=0
    5 CALL NB01A(K,A,B,ERR,X,Y,ITER)
      GO TO (1,2,3,4) ,K
C
    3 WRITE (LPT,3000) A,B
3000  FORMAT (' No zero found in the range from',F8.4,' to',F8.4)
      IERR=1
      GO TO 100
C
   4  CALL ERRIN2(ITER,1,
     & 'Gamma value not converged after','iterations')
      IERR=2
      GO TO 100
C
C  CALCULATE R FOM GAMMA
    1 FF=1.+(QQ*X)**2
      F2=2.*QQ*X
      F(1)=FF+F2
      F(2)=FF-F2
      PP(1)=0.5*(1.+P)
      PP(2)=0.5*(1.-P)
      PE=P*E
      PP(3)=0.5*(1.-PE)
      PP(4)=0.5*(1.+PE)
      ANUM=0.
      DEN=0.
      DO 20 I=1,2
      FMOD=SQRT(F(I))*FC
      CALL EXTINC(2,FMOD)
      YY=EXTCOR**2
      ANUM=ANUM+YY*F(I)*PP(I)
      DEN=DEN+YY*F(I)*PP(2+I)
   20 CONTINUE
      Y=R(1)-ANUM/DEN
      GO TO 5
C
C  HERE AFTER CONVERGENCE
    2 G(1)=X
C
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE ESDFMT(X,DX,BUFF,IW)
      SUBROUTINE ESDFMT(X,DX,BUFF,IW)
C
C *** ESDFMT new by PJB 9 Mar 1994 ***
C
CH Writes X and its esd DX in the form X(DX)
C
CD A value X and its its ESD DX are written into the buffer BUFF in the form
CD X(DX) as often used in published tables.
CA X is the value and DX its standard deviation
CA BUFF is a character buffer to receive the result
CA IW is the maximum number of characters in BUFF to be used
C
      CHARACTER *(*) BUFF
      CHARACTER *40 VFMT
      LOGICAL TWOFIG
C
      DEL=DX
      IF (DEL.LT.10E-10) THEN
        WRITE (VFMT,13) IW
   13 FORMAT ('(E',I2,'.4)')
        WRITE (BUFF,VFMT) X
        GO TO 100
      ENDIF
      ISIG=NINT(DEL)
      IF (ISIG.EQ.0) THEN
        IS=0
    1   IS=IS+1
        DEL=10.*DEL
        ISIG=NINT(DEL)
        IF (ISIG.EQ.0) GO TO 1
        JW=IW-3
        IF (JW.LT.3) GO TO 99
        WRITE (VFMT,10) JW,IS
   10 FORMAT ('(F',I2,'.',I1,',''('',I1,'')'')')
        WRITE (BUFF,VFMT) X,ISIG
      ELSE
        IS=1
    2   TWOFIG=(ISIG.GE.10)
        IS=IS+1
        IF (ISIG.GT.15) THEN
          DEL=DEL/10.
          ISIG=NINT(DEL)
          GO TO 2
        ENDIF
        IS=IS-1
        MUL=10**(IS-1)
        IF (TWOFIG) IS=IS+1
        IX=(NINT(X/FLOAT(MUL)))*MUL
        ISIG=ISIG*MUL
        JW=IW-2-IS
        IF (JW.LT.IS) GO TO 99
        WRITE (VFMT,11) JW,IS
   11 FORMAT ('(I',I2,',''('',I',I1,','')'')')
        WRITE (BUFF,VFMT) IX,ISIG
      ENDIF
      GO TO 100
   99 WRITE (BUFF,12) ('*',I=1,IW)
   12 FORMAT (80A1)
  100 RETURN
      END
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION DFTRUE(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFTRUE(IFAM,IGEN,ISPC)
C
C *** DFTRUE by JCM 3 Dec 90 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of VARMAK in main programs, to vary
CH an otherwise unspecified parameter.
CA DFTRUE on exit is .TRUE. if parameter is by default varied, .FALSE. if fixed
CA      - in this case it is always TRUE
CA IFAM on entry = family
CA IGEN on entry = genus
CA ISPC on entry = species (in this case, all irrelevant)
C
CD Varies all by default:
C TO KEEP COMPILERS HAPPY:
      I=IFAM
      I=IGEN
      I=ISPC
      DFTRUE=.TRUE.
      RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION DFLTSF(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFLTSF(IFAM,IGEN,ISPC)
C
C *** DFLTSF updated by JCM 10 May 90 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of SUBROUTINE VARMAK, giving
CH default fix/vary information for structure parameters.
CA On entry IFAM, IGEN, ISPC specify the parameter.
CD On exit DFLTSF is .TRUE. if parameter IFAM,IGEN,ISPC is by default varied
CD         and .FALSE. if fixed.
C
CD In general varies, but fixes scattering factor, and only varies an itf
CD if there is no corresponding atf. Only allows A*-F* to vary if there
CD are slack constraints.
C
      COMMON /ANISO/ATF(6,50),KATF(6,50),IAPT(150),
     & IATYP(50),KOM1
      COMMON /SLAKDA/NSLAK(4),SLKSWD(4),SLAKWT(4),
     & CHISQD(4),ISLKTP,NSKTOT,KOM24
C
      DFLTSF=.TRUE.
      GO TO (1,2) , IFAM
      GO TO 100
C
C
C TRAP NON-EXISTENT CELL PARAMETERS:
   1  IF (IGEN .NE. 1) GO TO 100
      IF (NSLAK(1).EQ.0 .AND. (ISPC.GE.2 .AND. ISPC.LE.7)) GO TO 101
      GO TO 100
C
   2  IF (ISPC .LT. 10) GO TO 100
      IF (ISPC .LT. 12) GO TO 101
C IF VARYING ITF BY DEFAULT, CHECK NOT ALSO ATF:
      IF (IAPT(IGEN) .EQ. 0) GO TO 100
C
C FIX:
 101  DFLTSF=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION DFLTMP(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFLTMP(IFAM,IGEN,ISPC)
C
C *** DFLTMP by PJB Oct 88  ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of VARMAK, giving defaults fix/vary
CH for otherwise unspecified parameters of multipole refinements.
CA On entry, IFAM,ISPC,IGEN hold family, genus and species of a parameter
CA for which there exists no other information as to whether to fix or
CA vary it.
CD Varies all multipoles and fixes the rest.
C
      I=IGEN + ISPC
      DFLTMP=(IFAM.EQ.5)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE CIRCLE(XX,YY,R,M)
      SUBROUTINE CIRCLE(XX,YY,R,M)
C
C *** CIRCLE by PJB 25 May 90 ***
C
CX
CC 14C
CH Draws a circle of given radius and centre, with various options.
CA On entry XX,YY give the centre of the circle in the current space.
CA          R is the required radius, in cms.
CA          M lists the required options:
CA If M=0 the circle is open
CA If M=+/- 1 a plus or minus is inscribed
CA If M>1 the circle is hatched at intervals of M*.25 mm.
C
      COMPLEX ARG,PHASE,POS
      DIMENSION A(2),PTS(2,12),FPTS(2,12),IPT(4)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
      EQUIVALENCE (A,POS),(A(1),X),(A(2),Y)
      DATA FPTS/3.5,1.,1.,1.,1.,3.5,-1.,3.5,-1.,1.,
     & -3.5,1.,-3.5,-1.,-1.,-1.,-1.,-3.5,1.,-3.5,1.,-1.,3.5,-1./
      DATA IPT/1,6,7,12/
      DATA GRID/.025/
C>> JCC Implement error tracking rather than stopping

      INTEGER IBMBER
      COMMON / CCSLER / IBMBER
      IBMBER = 0
C
C  SAVE CURRENT SPACE
      MSPCE=NSPCE
      CALL PLCONV(XX,YY,NSPCE,A1,B1,3)
C>> JCC Added
      IF (IBMBER .NE. 0) RETURN
      CALL SPCSET(3)
C>> JCC Added
      IF (IBMBER .NE. 0) RETURN
C
C  DRAW CIRCLE
      CALL KANGA1(A1+R,B1,3)
      PHASE=CMPLX(1.,0.)
      ARG=CEXP(CMPLX(0.,TWOPI/200.))
      DO 1 I=1,200
      PHASE=PHASE*ARG
      POS=PHASE*R
      CALL KANGA1(A1+X,B1+Y,2)
    1 CONTINUE
C
      IF (M.EQ.0) GO TO 101
      IF (IABS(M).EQ.1) THEN
C  SCALE SIGNS
        CALL GMSCA(FPTS,PTS,R*.2,2,12)
        CALL GMEQ(PTS(1,12),A,2,1)
        CALL KANGA1(A1+X,B1+Y,3)
        IF (M.LT.0) THEN
          NPTS=4
        ELSE
          NPTS=12
        ENDIF
        DO 2 I=1,NPTS
        J=I
        IF (M.LT.0) J=IPT(I)
        CALL GMEQ(PTS(1,J),A,2,1)
        CALL KANGA1(A1+X,B1+Y,2)
    2   CONTINUE
C
C  SHADE SIGN
        STEP=.05
        IF (M.GT.0) THEN
          CALL KANGA1(A1+PTS(1,5),B1+PTS(2,5),3)
          DO 20 W=PTS(2,5),PTS(2,4),STEP
          CALL KANGA1(A1+PTS(1,4),B1+W,2)
          CALL KANGA1(A1+PTS(1,3),B1+W,2)
   20     CONTINUE
        ENDIF
        CALL KANGA1(A1+PTS(1,7),B1+PTS(2,7),3)
        DO 21 W=PTS(2,7),PTS(2,6),STEP
        CALL KANGA1(A1+PTS(1,7),B1+W,2)
        CALL KANGA1(A1+PTS(1,12),B1+W,2)
   21   CONTINUE
        IF (M.GT.0) THEN
          CALL KANGA1(A1+PTS(1,9),B1+PTS(2,9),3)
          DO 22 W=PTS(2,9),PTS(2,8),STEP
          CALL KANGA1(A1+PTS(1,9),B1+W,2)
          CALL KANGA1(A1+PTS(1,10),B1+W,2)
   22     CONTINUE
        ENDIF
      ELSE
        IF (M.LT.2) GO TO 101
      ENDIF
C
C  SHADE CIRCLES
      CALL KANGA1(A1+R,B1,3)
      STEP=GRID*FLOAT(M)
      DO 23 W=R,-R,-STEP
      V=(R*R-W*W)
      IF (V.LT.0) GO TO 23
      V=SQRT(V)
      CALL KANGA1(A1+W,B1-V,2)
      CALL KANGA1(A1+W,B1+V,2)
   23 CONTINUE
C
C  RESTORE ORIGINAL SPACE
  101 CALL SPCSET(MSPCE)
  100 RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE CALPOL(H,NEW,ICOMP,SFCALC,MGCALC)
      SUBROUTINE CALPOL(H,NEW,ICOMP,SFCALC,MGCALC)
C
C *** CALPOL corrected by PJB 31-May-1994 ***
C
CX
CC 7B
CH Calculates scattered polarisations and their derivatives for structures
CH which may have mixed magnetic and nuclear reflections.
C
CA On entry H is the 1x3 array holding h,k,l
CA          NEW is TRUE if this hkl differs from the previous one
CA                   FALSE if it is the same
CA          ICOMP is the component of polarisation required
CA          SFCALC is the name of the routine to get nuclear structure factors
CA                 and their derivatives.  This is usually LFCALC.
CA          MGCALC is the name of the routine to get magnetic structure factors
CA                and their derivatives.  This is now LMCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC to the ICOMPth component of the scattered polarisation.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      If NEW calculate the nuclear and magnetic structure factors and
CD      their derivatives.
CD      If ICOMP=1 (ie 1st component for this input polarisation)
CD      calculate the output polarisation, summing over all domains
CD      and its differential wrt all parameters.
CD      Otherwise just set GCALC to previously calculated component
CD      of polarisation and scale the appropriate component of the
CD      differentials.
CD On exit in /OBSCAL/ GCALC = calculated function to compare with observed
CD         in /DERVAR/ DERIVV is an array holding all derivatives of GCALC
CD                            wrt all variables.
C
      EXTERNAL SFCALC,MGCALC
      COMPLEX CVEC(3),QSTAR(3),CPRD,CRSCLP,QCROSP(3)
      COMPLEX DPOLDP(3),TENS(3,3)
      LOGICAL NEW
      DIMENSION H(3),VEC(3),VEC1(3),POLI(3),DIFFER(3,10),QCROSQ(3)
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /FCAL/FC,FCMOD,COSAL,SINAL,FCDERS(300),DERIVT(300)
      COMPLEX FC,DERIVT
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /QCAL/Q(3,12)
      COMPLEX Q
      COMMON /QCALD/FQCDER(3,12,100)
      COMPLEX FQCDER
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /OVER/ITFAC,OTFAC(10),KOTFAC(10),NTFAC,JTFAC,KOM15
      EQUIVALENCE (TFAC,OTFAC(1)),(KTFAC,KOTFAC(1))
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /POLDAT/POLIT(3,3),POLM(6),POLO(3,12),QSQR(12),
     & POLD(3),QSQRM,DXSDN,DXSDQ(3,12),DPOLDN(3),DPOLDQ(3,3,12),
     & NDOMN,ND180
      COMPLEX DXSDN,DXSDQ,DPOLDN,DPOLDQ
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(20),KSCALE(20),
     & NSCL,LSCD(10)
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C  CALCULATE STRUCTURE FACTORS ON FIRST ENTRY
      IF (NEW) THEN
        CALL SFCALC(H)
        CALL MGCALC(H)
      ENDIF
      IF (ICOMP.EQ.1) THEN
C  CLEAR SUMS
        CALL GMZER(POLD,1,3)
        CALL CGMZER(DPOLDQ,3,3)
        CALL CGMZER(DPOLDN,3,1)
        CALL CGMZER(DXSDQ,3,1)
        QSQRM=0.
        DXSDN=CMPLX(0.,0.)
C  SET POLARISATION
        CALL GMEQ(POLM,POLI,3,1)
C  LOOP OVER DOMAINS
        NND=0
        DO 22 N180=1,ND180
        DO 20 ND=1,NDOMN/ND180
        NND=NND+1
C  CALCULATION OF POLARISATION DIRECTIONS
        CALL CMCONJ(Q(1,ND),QSTAR,3,1)
        CALL CGMSCA(Q(1,ND),CVEC,CONJG(FC),3,1)
        CALL CMREAL(CVEC,POLO(1,NND),3,1)
C  QXQ* TERM
        CALL CMREAL(QSTAR,VEC,3,1)
        CALL CMIMAG(QSTAR,VEC1,3,1)
        CALL VECPRD(VEC,VEC1,QCROSQ)
        CALL GMADD(POLO(1,NND),QCROSQ,POLO(1,NND),3,1)
C  POLARISATION DEPENDENT PART OF CROSS-SECTION
        POLPRD=2.*SCALPR(POLO(1,NND),POLI)
C  N*PXQ PART OF POLARISATION
        CALL CMIMAG(CVEC,VEC,3,1)
        CALL VECPRD(POLI,VEC,VEC1)
        CALL GMADD(POLO(1,NND),VEC1,POLO(1,NND),3,1)
C  Q(P.Q*) PART OF POLARISATION
        CPRD=CRSCLP(QSTAR,POLI)
        CALL CGMSCA(Q(1,ND),CVEC,CPRD,3,1)
        CALL CMREAL(CVEC,VEC,3,1)
        CALL GMADD(POLO(1,NND),VEC,POLO(1,NND),3,1)
C  DOUBLE ALL THIS FOR TWICE REAL AND IMAG PARTS
        CALL GMSCA(POLO(1,NND),POLO(1,NND),2.,3,1)
C  PART PARALLEL TO INCIDENT POLN
        FNSQR=REAL(FC)*CONJG(FC)
        QMOD=RSCALP(Q(1,ND),Q(1,ND))
        CALL GMSCA(POLI,VEC,FNSQR-QMOD,3,1)
        CALL GMADD(POLO(1,NND),VEC,POLO(1,NND),3,1)
C
C DERIVATIVES WITH RESPECT TO FC AND Q
C FIRST DIFFERENTIATE THE CROSSECTION
        DXSDN=DXSDN+(CONJG(FC)+CPRD)*SCALE(NND)
        CALL CMCONJ(Q(1,ND),DXSDQ(1,NND),3,1)
        CALL C1MSCA(POLI,CVEC,CONJG(FC),3,1)
        CALL CGMADD(CVEC,DXSDQ(1,NND),DXSDQ(1,NND),3,1)
C FIDDLE THE QXQ TERM  -idQ{Q*xP}
        CALL CMREAL(QSTAR,VEC,3,1)
        CALL VECPRD(VEC,POLI,VEC1)
        CALL C1MSCA(VEC1,QCROSP,CMPLX(0.,-1.),3,1)
        CALL CMIMAG(QSTAR,VEC,3,1)
        CALL VECPRD(VEC,POLI,VEC1)
        CALL C1MSCA(VEC1,CVEC,CMPLX(1.,0.),3,1)
        CALL CGMADD(CVEC,QCROSP,QCROSP,3,1)
        CALL CGMADD(QCROSP,DXSDQ(1,NND),DXSDQ(1,NND),3,1)
C THE DIFFERENTIALS OF THE SCATTERED POLARISATION
C  FIRST WITH RESPECT TO NUCLEAR PART
        CALL C1MSCA(POLI,CVEC,CONJG(FC),3,1)
        CALL CGMADD(QSTAR,CVEC,CVEC,3,1)
        CALL CGMADD(QCROSP,CVEC,CVEC,3,1)
        CALL CMRSCA(CVEC,CVEC,SCALE(NND),3,1)
C SUM UP WEIGHTING WITH DOMAIN POPULATION
        CALL CGMADD(CVEC,DPOLDN,DPOLDN,3,1)
C THEN THE TENSOR FOR THE MAGNETIC DERIVATIVES
        DO 25 J=1,3
        DO 25 I=1,3
        DPOLDQ(I,J,NND)=QSTAR(I)*POLI(J)-POLI(I)*QSTAR(J)
        IF (I.EQ.J) THEN
          DPOLDQ(I,I,NND)=DPOLDQ(I,I,NND)+CONJG(FC)+CPRD
        ELSE
          DO 26 K=1,3
          IF (K.EQ.I .OR. K.EQ.J) GO TO 26
          IF (ABS(J-I).EQ.1) THEN
            SIG=FLOAT(ISIGN(1,J-I))
          ELSE
            SIG=FLOAT(ISIGN(1,I-J))
          ENDIF
          DPOLDQ(I,J,NND)=DPOLDQ(I,J,NND)+
     &    SIG*CMPLX(0.,1.)*(CONJG(FC)*POLI(K)+QSTAR(K))
   26     CONTINUE
        ENDIF
   25   CONTINUE
C
C  SCALE BY DOMAIN FRACTIONS ADD INTO SUMS FOR MEAN POLARISATION
        CALL GMEQ(POLO(1,NND),VEC,3,1)
C  CROSSSECTION FOR THIS INPUT POLARISATION
        QSQR(NND)=POLPRD+FNSQR+QMOD
        CALL GMSCA(POLO(1,NND),VEC,SCALE(NND),3,1)
        CALL GMADD(VEC,POLD,POLD,3,1)
        QSQRM=QSQRM+QSQR(NND)*SCALE(NND)
C  SUMS FOR DERIVATIVES
        CALL CMRSCA(DXSDQ(1,NND),DXSDQ(1,NND),SCALE(NND),3,1)
        CALL CMRSCA(DPOLDQ(1,1,NND),DPOLDQ(1,1,NND),SCALE(NND),3,3)
        IF (ND180.EQ.2) THEN
          DO 23 II=1,3
          Q(II,ND)=-Q(II,ND)
   23     CONTINUE
        ENDIF
   20   CONTINUE
   22   CONTINUE
C  CONVERT POLD WHICH IS AN INTENSITY TO POLARISATION
        CALL GMSCA(POLD,POLD,1./QSQRM,3,1)
C      WRITE (LPT,4004) (JJ,(Q(II,JJ),II=1,3),
C     1(FQCDER(II,JJ,1),II=1,3),JJ=1,NDOM)
C 4004 FORMAT (' Q and dQ/dmu for each domain: ',3(I4,2(6F6.3,2X)/38X))
C      WRITE (LPT,4000) POLI,POLD,FC
C 4000 FORMAT (' Input and Output polarisations:'  2(3F8.4,2X)/
C     1'  Nuclear SF : '2F8.4)
      ENDIF
C
C  DERIVATIVES WITH RESPECT TO SCALE FACTORS
      DO 24 ND=1,NDOMN
C  THE SCALES ARE THE DOMAIN POPULATIONS
      L=KSCALE(ND)
      IF (L .NE.0) DERIVV(L)=(POLO(ICOMP,ND)-POLD(ICOMP)*QSQR(ND))/QSQRM
   24 CONTINUE
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, TO DERIVATIVES OF POLARISATION
      DO 4 I=1,NVARF(2,JPHASE,1)
      SUM=0.
C FIRST NUCLEAR DERIVATIVES: THEY DONT DEPEND ON WHICH DOMAIN
      ANBIT=2.*REAL((DPOLDN(ICOMP)-DXSDN*POLD(ICOMP))*DERIVT(I))
C SUM OVER DOMAINS FOR MAGNETIC BIT
      DO 30 ND=1,NDOMN
      IF (ND180.EQ.2 .AND. ND .GT.NDOMN/2) THEN
        CALL CMRSCA(FQCDER(1,ND-NDOMN/2,I),CVEC,-1.,3,1)
      ELSE
        CALL CGMEQ(FQCDER(1,ND,I),CVEC,3,1)
      ENDIF
      DO 31 L=1,3
      DO 31 J=1,3
   31 TENS(L,J)=POLD(L)*DXSDQ(J,ND)
      CALL CMRSCA(TENS,TENS,-1.,3,3)
      CALL CGMADD(DPOLDQ(1,1,ND),TENS,TENS,3,3)
      CALL CGMPRD(TENS,CVEC,DPOLDP,3,3,1)
      SUM=SUM+2.*REAL(DPOLDP(ICOMP))
C      IF (ICOMP.EQ.1) WRITE (LPT,4001) ND,(POLO(IX,ND),IX=1,3),DPOLDP
C 4001 FORMAT (' Domain poln and diff.: ',I4,2X,3(3F8.4,2X))
   30 CONTINUE
      DERIVV(LVFST1(2,JPHASE,1)+I)=(ANBIT+SUM)/QSQRM
C  TEST OUTPUT
      IF (IOUT.GE.100) THEN
        DIFFER(ICOMP,I)=DERIVV(LVFST1(2,JPHASE,1)+I)
        IF (ICOMP.EQ.3) THEN
          IF (I.EQ.1) THEN
            WRITE (LPT,4002)I, (DIFFER(L,I),L=1,3)
        ELSE
            WRITE (LPT,4003)I, (DIFFER(L,I),L=1,3)
        ENDIF
 4002     FORMAT (/' Calculated Differentials Var no.',I3,2X,3F8.4)
 4003     FORMAT (26X,'Var no.',I3,2X,3F8.4)
        ENDIF
      ENDIF
    4 CONTINUE
C
   7  GCALC = POLD(ICOMP)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CALDSM(H,ISAT)
      SUBROUTINE CALDSM(H,ISAT)
C
C *** CALDSM to include PROPAGATION VECTOR by PJB 21-Sept-93 ***
C
CX
CC 17B
CH Calculates  d star squared, and its derivatives wrt reciprocal
CH cell quadratic products and components of propagation vector.
CA On entry H is a 1x3 vector holding h,k,l
CP In /CELPAR/ CPARS(1:6,2) should hold the 6 reciprocal quadratic products
CP             A* = a* squared
CP             D* =  b* c* cos alpha* etc
CP             KCPARS(1:6) should hold fix/vary information for each of the 6
CP             reciprocal cell quadratic products.
CP If magnetic /SATELL/ should have been set up with a call to PROPER
CP             and the corresponding symmetry constraints with PROPSM
CD Sets GCALC in /OBSCAL/ to be d star squared, the d spacing squared,
CD and DERIVV in /DERVAR/ to be the derivative, where relevant
C
      DIMENSION H(3),DER(3)
      COMMON /CELPAR/CELL(3,3,2),V(2),ORTH(3,3,2),CPARS(6,2),KCPARS(6),
     & CELESD(6,6,2),CELLSD(6,6),KOM4
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SATELL/PROP(3),KPROP(3),KSTAB(24),NKSTAR,IPROP,FKSTAR,
     & NKC,KCENT,INCOM,KOM21
      LOGICAL INCOM
C
      GCALC=0.
      J=2
      K=3
      DO 1 I=1,3
      C1=H(I)*H(I)
      C2=2.*H(J)*H(K)
      GCALC=GCALC+C1*CPARS(I,2)+C2*CPARS(I+3,2)
      L1=KCPARS(I)
      L2=KCPARS(I+3)
      IF (L1 .GT. 0) DERIVV(L1)=C1
      IF (L2 .GT. 0) DERIVV(L2)=C2
      J=K
   1  K=I
C
      IF (MAG .AND. ISAT .NE.0) THEN
        CALL PROPDR(H,ISAT,DER)
        DO 2 I=1,3
        L=KPROP(I)
        IF (L.GT.0) DERIVV(L)=DER(I)
    2   CONTINUE
      ENDIF
      RETURN
      END
C
C
C
C LEVEL 2      SUBROUTINE CALCT2(H)
      SUBROUTINE CALCT2(H)
C
C *** CALCT2 by JCM 25 Nov 86 ***
C
CX
CC 7B
CH Calculates a function to match an observation for 2theta-type refinement
CH of reciprocal cell parameters and a zero point.
CA On entry H holds a real 1x3 array of h,k,l
CD On exit in /OBSCAL/ GCALC holds calculated 2 theta degrees + zeropoint
CD         in /DERVAR/ DERIVV holds its derivatives wrt 6 cell parameters and
CD         the zeropoint.
C
      DIMENSION H(3)
      DIMENSION DERS(6)
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /CELPAR/CELL(3,3,2),V(2),ORTH(3,3,2),CPARS(6,2),KCPARS(6),
     & CELESD(6,6,2),CELLSD(6,6),KOM4
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(5,5),
     & NLAMB,ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /ZEROPT/ZERO,KZERO
C
C SET DSTAR2 TO BE D STAR SQUARED, AND KEEP H SQRD, K SQRD ETC IN DERS:
      CALL CELDER(H,DERS)
C CALCULATED FN IS 2THETA DEGREES + ZERO POINT:
      STH=0.5*WLGTH*SQRT(DSTAR2)
      CALL SINCOS(STH,CTH,'CALCT2')
      GCALC=2.*DEGREE(ASIN(STH)) + ZERO
      FAC=2.*DEGREE(WLGTH*WLGTH/(8.*STH*CTH))
      DO 1 I=1,6
      L=KCPARS(I)
      IF (L .GT. 0) DERIVV(L)=FAC*DERS(I)
   1  CONTINUE
      IF (KZERO .GT. 0) DERIVV(KZERO)=1.
      RETURN
      END
C
C
C
C LEVEL 8      SUBROUTINE CALCSF(H,SFCALC)
      SUBROUTINE CALCSF(H,SFCALC)
C
C *** CALCSF updated by PJB 31-May-1994 ***
C
CX
CC 7B
CH Makes the calculated function and derivatives for single crystal LSQ.
CA On entry H is a 3-sized array containing h,k,l
CA   SFCALC is a subroutine name used for the actual structure factor
CA   calculation, like LFCALC
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables
CD      Convert derivatives to be of P2, not just mod FCALC
CD      Form P3: convert derivatives
CD      Form GCALC and make all derivatives so that they are of GCALC
CD      Adjust for GCALC squared if necessary
C
      EXTERNAL SFCALC
      LOGICAL TESTOV
      DIMENSION H(3)
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /EXTN/IEXTYP,DOMR,KDOMR,AMOSC,KMOSC,EXTCOR,CEXT(4),
     & DEXDFQ,DEXDRQ,DEXDGQ,LOREN,GAUSS
      LOGICAL LOREN,GAUSS
      COMMON /FCAL/FC,FCMOD,COSAL,SINAL,FCDERS(300),DERIVT(300)
      COMPLEX FC,DERIVT
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /OVER/ITFAC,OTFAC(10),KOTFAC(10),NTFAC,JTFAC,KOM15
      EQUIVALENCE (TFAC,OTFAC(1)),(KTFAC,KOTFAC(1))
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(20),KSCALE(20),
     & NSCL,LSCD(10)
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      P1=SCALE(ISCALE)*EXP(-TFAC*SSQRD)
      IF (KTFAC .NE. 0) DERIVV(KTFAC)=-SSQRD
      L=KSCALE(ISCALE)
      IF (L .NE. 0) DERIVV(L)=1./SCALE(ISCALE)
C NEXT DO P2:
      CALL SFCALC(H)
      P2=FCMOD
      IF (IREF .EQ. 4) P2=REAL(FC)
      DP2DFQ=0.
      IF (.NOT. TESTOV(1.,FCMOD)) DP2DFQ=1./FCMOD
C
C P3:
      CALL EXTINC(3,FCMOD)
      P3=EXTCOR
      IF (KDOMR .NE. 0) DERIVV(KDOMR)=DEXDRQ
      IF (KMOSC .NE. 0) DERIVV(KMOSC)=DEXDGQ
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
      DO 4 I=1,NVARF(2,1,1)
   4  DERIVV(LVFST1(2,1,1)+I)=FCDERS(I)*(DP2DFQ+DEXDFQ)
C
      GCALC = P1*P2*P3
C ADJUST IF NECESSARY FOR GCALC SQUARED:
      FAC=GCALC
      IF (IREF .EQ. 2) THEN
        GCALC=GCALC*GCALC
        FAC=2.*GCALC
      ENDIF
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*FAC
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALCMP(H)
      SUBROUTINE CALCMP(H)
C
C *** CALCMP by PJB Oct 88 ***
C
CX
CC 7B
CH Makes the calculated function and derivatives for single crystal LSQ
CH with multipoles.
CA On input H is a 3-sized array containing h,k,l
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables
CD               This includes the multipoles.
CD      Convert derivatives to be of P2, not just mod FCALC.
CD      Form P3: convert derivatives.
CD      Form GCALC and make all derivatives so that they are of GCALC.
CD      Adjust for GCALC squared if necessary.
C
      LOGICAL TESTOV
      DIMENSION H(3)
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /EXTN/IEXTYP,DOMR,KDOMR,AMOSC,KMOSC,EXTCOR,CEXT(4),
     & DEXDFQ,DEXDRQ,DEXDGQ,LOREN,GAUSS
      LOGICAL LOREN,GAUSS
      COMMON /FCAL/FC,FCMOD,COSAL,SINAL,FCDERS(300),DERIVT(300)
      COMPLEX FC,DERIVT
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /OVER/ITFAC,OTFAC(10),KOTFAC(10),NTFAC,JTFAC,KOM15
      EQUIVALENCE (TFAC,OTFAC(1)),(KTFAC,KOTFAC(1))
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(20),KSCALE(20),
     & NSCL,LSCD(10)
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      DO 2  I=1,LVARV
   2  DERIVV(I)=0.
C
C FORM P1 AND THE FAMILY 1 DERIVATIVES:
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      P1=SCALE(ISCALE)*EXP(-TFAC*SSQRD)
      IF (KTFAC .GT. 0) DERIVV(KTFAC)=-SSQRD
      L=KSCALE(ISCALE)
      IF (L .GT. 0) DERIVV(L)=1./SCALE(ISCALE)
C NEXT DO P2:
      CALL LMPCAL(H)
      P2=FCMOD
      IF (IREF .EQ. 4) P2=REAL(FC)
      DP2DFQ=0.
      IF (.NOT. TESTOV(1.,FCMOD)) DP2DFQ=1./FCMOD
C
C P3:
      CALL EXTINC(3,FCMOD)
      P3=EXTCOR
      IF (KDOMR .NE. 0) DERIVV(KDOMR)=DEXDRQ
      IF (KMOSC .NE. 0) DERIVV(KMOSC)=DEXDGQ
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
      L25ST=LVFST1(2,1,1)
      IF (L25ST .EQ. -1) L25ST=LVFST1(5,1,1)
      DO 4 I=1,NVARF(5,1,1)+NVARF(2,1,1)
   4  DERIVV(L25ST+I)=FCDERS(I)*(DP2DFQ+DEXDFQ)
C
      GCALC = P1*P2*P3
C ADJUST IF NECESSARY FOR GCALC SQUARED:
      FAC=GCALC
      IF (IREF .EQ. 2) THEN
        GCALC=GCALC*GCALC
        FAC=2.*GCALC
      ENDIF
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*FAC
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALCMG(H,SFCALC,MGCALC)
      SUBROUTINE CALCMG(H,SFCALC,MGCALC)
C
C *** CALCMG updated by PJB 31-May-1994 ***
C
CX
CC 7B
CH Calculates GCALC and its derivatives for structures which may have
CH mixed magnetic and nuclear reflections.
C
CA On entry H is the 1x3 array holding h,k,l
CA       SFCALC is the name of the routine to get nuclear structure factors
CA              and their derivatives.  This is usually LFCALC.
CA       MGCALC is the name of the routine to get magnetic structure factors
CA              and their derivatives.  This is usually LMCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables,
CD               using both nuclear and magnetic structure factors
CD      The scattering factors are calculated using PFORMF with multipoles.
CD      Convert derivatives to be of P2, not just mod FCALC
CD      Form P3: convert derivatives
CD      Form GCALC and make all derivatives so that they are of GCALC
CD      Adjust for GCALC squared if necessary
CD On exit in /OBSCAL/ GCALC = calculated function to compare with observed
CD On exit in /DERVAR/ DERIVV is an array holding all derivatives of GCALC
CD wrt all variables
CD
CN If L REFI=5 the GOBS and GCALC are polarised neutron flipping ratios
C
      EXTERNAL SFCALC,MGCALC
      DIMENSION H(3)
      COMPLEX FND,FN,PHASE,PN(3),PND(3)
      LOGICAL TESTOV
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /EXTN/IEXTYP,DOMR,KDOMR,AMOSC,KMOSC,EXTCOR,CEXT(4),
     & DEXDFQ,DEXDRQ,DEXDGQ,LOREN,GAUSS
      LOGICAL LOREN,GAUSS
      COMMON /FCAL/FC,FCMOD,COSAL,SINAL,FCDERS(300),DERIVT(300)
      COMPLEX FC,DERIVT
      COMMON /MCAL/FMCMOD,FMCSQR,FMCDER(300)
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /OVER/ITFAC,OTFAC(10),KOTFAC(10),NTFAC,JTFAC,KOM15
      EQUIVALENCE (TFAC,OTFAC(1)),(KTFAC,KOTFAC(1))
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /POLDA/P,DP,E,DE,MODE,POLND(3)
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /QCAL/Q(3,12)
      COMPLEX Q
      COMMON /QCALD/FQCDER(3,12,100)
      COMPLEX FQCDER
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(20),KSCALE(20),
     & NSCL,LSCD(10)
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      IF (IREF.EQ.5) THEN
        P1=1.
      ELSE
        P1=SCALE(ISCALE)*EXP(-TFAC*SSQRD)
        IF (KTFAC .NE. 0) DERIVV(KTFAC)=-SSQRD
        L=KSCALE(ISCALE)
        IF (L .NE. 0) DERIVV(L)=1./SCALE(ISCALE)
      ENDIF
C
C NEXT DO P2:
      CALL SFCALC(H)
      CALL MGCALC(H)
      P2S=FCMOD**2+FMCSQR
      IF (IREF.EQ.5) THEN
        PHASE=CMPLX(COSAL,SINAL)
        FN=FCMOD*PHASE
        CALL C1MSCA(POLND,PN,FN,3,1)
        XST=2.*RSCALP(FMC,PN)
        RNUM=(P2S+P*XST)
        RDEN=P2S-P*E*XST
        P2=RNUM/RDEN
C P3:
        X1=SQRT(P2S+XST)
        CALL EXTINC(3,X1)
        P3=EXTCOR
        DEX1=DEXDFQ
        IF (KDOMR .NE. 0) DERIVV(KDOMR)=DEXDRQ
        IF (KMOSC .NE. 0) DERIVV(KMOSC)=DEXDGQ
        X2=SQRT(P2S-XST)
        CALL EXTINC(3,X2)
        P3=P3/EXTCOR
        DEX2=DEXDFQ
        IF (KDOMR .NE. 0) DERIVV(KDOMR)=DERIVV(KDOMR)-DEXDRQ
        IF (KMOSC .NE. 0) DERIVV(KMOSC)=DERIVV(KMOSC)-DEXDGQ
      ELSE
        P2=SQRT(P2S)
C  CHECK THAT P2 IS NOT ZERO
        IF (TESTOV(1.,P2)) GO TO 7
        DFTDFQ=1./P2
C P3:
        CALL EXTINC(3,P2)
        P3=EXTCOR
        IF (KDOMR .NE. 0) DERIVV(KDOMR)=DEXDRQ
        IF (KMOSC .NE. 0) DERIVV(KMOSC)=DEXDGQ
      ENDIF
      YCALC=P2
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
      DO 4 I=1,NVARF(2,JPHASE,1)
        IF (IREF .EQ.5) THEN
        FND=FCDERS(I)*PHASE
        CALL C1MSCA(POLND,PND,FND,3,1)
        XSTD=RSCALP(PN,FQCDER(1,1,I)) + RSCALP(PND,FMC)
        YSTD=FCDERS(I)*FCMOD + FMCDER(I)
C NOTE THAT MAGNETIC DERIVATIVES COME OUT MULTIPLIED BY FMCMOD **
        DERIVV(LVFST1(2,JPHASE,1)+I)=2.*((YSTD+P*XSTD)/RNUM)-
     &  ((YSTD-P*E*XSTD)/RDEN) + ((YSTD+XSTD)*DEX1)/X1 -
     &  ((YSTD-XSTD)*DEX2)/X2
      ELSE
        DERIVV(LVFST1(2,JPHASE,1)+I)=((FCDERS(I)*FCMOD)+FMCDER(I))*
     &  (DEXDFQ+DFTDFQ)*DFTDFQ
      ENDIF
    4 CONTINUE
C
   7  GCALC = P1*P2*P3
C ADJUST IF NECESSARY FOR GCALC SQUARED:
      FAC=GCALC
      IF (IREF .EQ. 2) THEN
        GCALC=GCALC*GCALC
        FAC=2.*GCALC
      ENDIF
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*FAC
 100  RETURN
      END
C
C
C
C LEVEL 1      SUBROUTINE ARREAD(H,FBUF,IEND)
      SUBROUTINE ARREAD(H,FBUF,IEND)
C
C *** ARREAD updated by PJB 22-Jun-1995 ***
C
CX
CC 2A
CH Multiple entry routine to deal with reading items for ARRNGE type programs.
CD Expects IICD3 to have been obeyed to read the data type DTYP. The following
CD formats are defined:
CD         = 0 user supplied subroutine QUARRIN to read the data
CD         = 1 D3 polarised neutron ratios as given by D3OP90 or D3OP94
CD         = 2 COLL5  1 card output
CD         = 3 COLL5  2 card output
CD         = 4 ADVANCE floating format output
CD         = 5 SXD format output including wave-length and path length
CD         = 6 LLB format (floating indices)
CD         = 7 D3 Integrated intensities (ext .ROC)
CD         = 8 COLL5 floating format (1 card ext .COL)
C
C
      DIMENSION H(3),K(3),FBUF(10),ANG(4)
      LOGICAL IEND,JEND,ANGLES
      CHARACTER *40 QUERY(2)
      CHARACTER *4 EXT(8)
      CHARACTER*10 FILNOM
C
      COMMON /ARRDAT/IFOR(6),INC,LINO,NREF,INLBUF,NBUF,IBUF,INFBUF,
     & INDLEN,NUMVAL,IPOS,ISTORE,ICHNGE,NEW,LPRINT,ICD,IS,NREF1,NREFL
      LOGICAL INC,NEW,LPRINT
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C
      DATA QUERY/'File with reflections to be arranged',
     &'Next reflection file (or c/r to end)'/
      DATA EXT/'.FLI','.DAT','.DAT','.COL','.SXD','.LLB','.ROC','.COL'/
C
      ANGLES=(IFOR(6).NE.0)
      ISTART=2
      IF (IEND) THEN
        ISTART=1
        WRITE (LPT,2010) IFOR(1)
 2010 FORMAT (/' Input type',I2,' - ')
        IF ((IFOR(1) .LT. 0) .OR. (IFOR(1) .GE.9)) GO TO 1
        GO TO (10,11,12,13,14,15,16,17,18) , IFOR(1)+1
C
  10    CALL MESS(LPT,0,'User to supply own routine QARRIN')
        GO TO 3
C
  11    CALL MESS(LPT,0,'D3 polarised neutron ratios 4I5,24X,2F1.6')
        GO TO 3
C
  12    CALL MESS(LPT,0,'College 5 input, 1 card, I6,3I4,2F10.2')
        GO TO 3
C
  13    CALL MESS(LPT,0,'College 5 input, 2 cards, I6,3I4,2F10.2/')
        GO TO 3
C
  14    CALL MESS(LPT,0,'"ADVANCE" floating indices, I6,3F6.2,I8,I4/')
        GO TO 3
C
  15    CALL MESS(LPT,0,'SXD intensities,wavelengths and pathlength'//
     &   ' from "SXDABS", I8,3F8.3,4F10.4/')
        GO TO 3
C
  16    CALL MESS(LPT,0,'LLB data: floating indices,' //
     &   'I4,3F6.2,2F10.4,4F8.2')
        GO TO 3
C
  17    CALL MESS(LPT,0,'D3 integrated intensities (2 cards),' //
     &   'I6,3F6.2,2F10.2,4F8.2')
        GO TO 3

  18    CALL MESS(LPT,0,'COLL5 1 card format with floating indices,'//
     &  ' I6,3F7.2,2F10.4,4F8.3')
        GO TO 3
C
  98    WRITE (ITO,2010)
        CALL MESS(ITO,0,'NOT YET IMPLEMENTED')
        CALL MESS(LPT,0,'NOT YET IMPLEMENTED')
        IERR=IERR+1
        GO TO 99
      ENDIF
C
   1  GO TO (51,52,53,54,55,56,57,58) , IFOR(1)
C
C READ DATA ITEM UNDER USER'S OWN FORMAT:
  50  CALL QARRIN(N,K,DUMMY,FBUF,JEND)
      IF (JEND) GO TO 2
      GO TO 60
C
C D3 POLARISED NEUTRON RATIOS:
  51  READ (LUNI,1001,END=2) N,K,(ANG(I),I=1,3),FBUF(2),FBUF(3)
1001  FORMAT (4I5,3F8.2,2F10.6)
      IF (ANGLES) THEN
C ON D3 OMEGA IS THE FIRST ANGLE
        FBUF(4)=ANG(2)
        FBUF(5)=ANG(1)
        FBUF(6)=ANG(3)
      ENDIF
      GO TO 60
C
C COLLEGE 5 INTEGRATED INTENSITIES - 1 CARD:
  52  READ (LUNI,1002,END=2) N,K,FBUF(2),FBUF(3),ANG
1002  FORMAT (I6,3I4,2F10.2,3F8.2)
C COLL5 PUTS OUT THETA NOT 2THETA
      ANG(1)=2.*ANG(1)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
      GO TO 60
C
C COLLEGE 5 INTEGRATED INTENSITIES - 2 CARDS:
  53  READ (LUNI,1003,END=2) N,K,FBUF(2),FBUF(3),ANG
1003  FORMAT (I6,3I4,2F10.2,3F8.2/)
C COLL5 PUTS OUT THETA NOT 2THETA
      ANG(1)=2.*ANG(1)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
      GO TO 60
C
C ADVANCE INTEGRATED INTENSITIES - FLOATING FORMAT:
  54  READ (LUNI,1030,END=2) N,H,LFIN,LDFIN,ANG
1030  FORMAT (I6,3F6.2,I8,I4,3F8.2)
      FBUF(2)=FLOAT(LFIN)
      FBUF(3)=FLOAT(LDFIN)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
C IGNORE BLANK CARDS:
      IF (N+LFIN+LDFIN.EQ.0) GO TO 1
      GO TO 61
C
C SXD INTENSITIES FROM SXDABS:
  55  READ (LUNI,1031,END=2) N,H,(FBUF(I),I=2,5)
1031  FORMAT (I8,3F8.2,4F10.4)
      IF (N.NE.0) GO TO 61
      GO TO 1
C
C LLB FORMAT:
  56  READ (LUNI,1032,END=2) N,H,FBUF(2),FBUF(3),ANG
1032  FORMAT (I4,3F6.2,2F10.4,4F8.3)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
      IF (N.NE.0) GO TO 61
      GO TO 1
C
C D3 Integrated intensities 2 card .ROC FORMAT:
  57  READ (LUNI,1033,END=2) N,H,FBUF(2),FBUF(3),ANG,FIELD,TEMP
1033  FORMAT (I6,3F6.2,2F10.2,4F8.2,F8.2,F7.2)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
C SKIP SECOND CARD
      READ (LUNI,1032)
      IF (N.NE.0) GO TO 61
      GO TO 1
c
C Floating COLL5 format:
  58  READ (LUNI,1034,END=2) N,H,FBUF(2),FBUF(3),ANG
1034  FORMAT (I6,3F7.2,2F10.4,4F8.3)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
      IF (N.NE.0) GO TO 61
      GO TO 1
C
C IGNORE BLANK CARDS:
  60  IF (IABS(K(1))+IABS(K(2))+IABS(K(3)) .EQ. 0) GO TO 1
      CALL INDFLO(H,K)
  61  IF (NREF1 .EQ.-1) NREF1=N
      FBUF(1)=FLOAT(N)
      NREFL=N
      GO TO 100
C
C START READING (NEXT) INPUT DATA FILE:
   2  WRITE (LPT,2005) NREF1,NREFL,FILNOM(LUNI)
2005  FORMAT (/' Reflection numbers ',I8,' to ',I8,' read from file ',
     &A10)
      CLOSE(LUNI)
   3  MESSAG=' '
      NREF1=-1
      NAMFIL=EXT(IFOR(1))
      WRITE (MESSAG,2000) QUERY(ISTART)
2000  FORMAT (A40)
      LUNI=NOPFIL(111)
      IF (LUNI .NE. 0) THEN
        IEND=.FALSE.
        GO TO 1
      ENDIF
C
  99  IEND=.TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE BIGGAM(K,IQ,CSMAX)
      SUBROUTINE BIGGAM(K,IQ,CSMAX)
C
C *** BIGGAM updated by PJB Nov 89 ***
C
CX
CC 2B
CH Deals with gammas whose value is greater than one, in SORGAM.
CH There is also the entry SETGAM to set up the calculation.
CA On entry K is a set of reflection indices to be tested
CA IQ is returned as 1 if gamma for this reflection is greater than 1
CA       returned as 0 otherwise
CA CSMAX is the maximum value of cos(rho) for which the effective gamma
CA       is >1
CA Entry SETGAM SOME is a logical which is set true if a GAMA 1 is found
CA                   on an I card.  It is false otherwise.
C
      DIMENSION K(3)
      LOGICAL ENDG,SOME,ONCARD
      CHARACTER *10 FILNOM
      COMMON /BIGAM/KG(3),CSRED,ENDG
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C
      IQ=0
      IF (ENDG) GO TO 100
C
      DO 1 I=3,1,-1
      IF (KG(I)-K(I)) 2,1,100
    1 CONTINUE
C MATCH:
      IF (CSRED.NE.0.) THEN
        WRITE (ITO,16)KG,CSRED
      ELSE
        WRITE (ITO,17)KG
      ENDIF
   16 FORMAT (' Gamma > 1 for ',3I3,' and Cos(rho) >',F7.4)
   17 FORMAT (' Gamma > 1 for ',3I3)
      IQ=1
      CSMAX=CSRED
      GO TO 5
C
C  INDICES OUT OF ORDER
    2 WRITE (ITO,12) K,KG
   12 FORMAT (' Error in order of indices matching',3I3,' with',3I3/
     & ' Gamma < 1 assumed from here on')
    4 ENDG =.TRUE.
      GO TO 100
C
C  SETUP ENTRY
      ENTRY SETGAM(SOME)
      ENDG=.FALSE.
      SOME=.FALSE.
C  SEARCH FOR GAMA ON ICARD = IF NOT FOUND ASSUME ALL GAMMA < 1
      IF (.NOT. ONCARD('I','GAMA',A)) GO TO 100
C
      IGAM=NINT(A)
      IF (IGAM.EQ.0) GO TO 100
      CALL ASK('File of labelling indices for gamma > 1 reflections ?')
      LBIG=NOPFIL(21)
      CALL MESS(LPT,1,'Reflections with abs(gamma) > 1 from file '//
     & FILNOM(LBIG)//' these marked ** on the output list')
      SOME = .TRUE.
    5 READ (LBIG,11,END=4) KG,CSRED
   11 FORMAT (3I5,F10.4)
  100 RETURN
      END
C
C
C LEVEL 2      SUBROUTINE BIGCHA(BWORD)
      SUBROUTINE BIGCHA(BWORD)
C
C *** BIGCHA corrected by PJB 31-May-1994 ***
C
CX
CC 13C
CH Writes on unit LPT up to 9 characters in large letters.
CA On entry, BWORD is the required word
CO Writes (up to 9) characters of BWORD to output LPT in letters/digits
CO 12 characters wide by 12 lines high, composed of the relevant character
CO and finishes with 2 blank lines
CN Turns lower case into upper
C
      CHARACTER *(*) BWORD
      DIMENSION NSTART(10)
      COMMON /BIGONE/ X(504)
      CHARACTER*12 X
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C
      MAXLEN=9
      LENGTH=LENGT(BWORD)
      NCHARS=90
C
      DO 1 J=1,MAXLEN
C DEFAULT SPACE:
      I=40
      IF (J .GT. LENGTH) GO TO 1
      IF (BWORD(J:J) .EQ. ' ') GO TO 1
      I=LETTER(BWORD(J:J))
      IF (I .GT. 0) GO TO 1
      I=NDIGIT(BWORD(J:J))+29
      IF (I .GE. 29) GO TO 1
      I=40
      IF (BWORD(J:J) .EQ. '.') I=27
      IF (BWORD(J:J) .EQ. '+') I=28
      IF (BWORD(J:J) .EQ. '/') I=39
   1  NSTART(J)=(I-1)*12
      DO 2 K=1,12
   2  WRITE(LPT,2000) (X(NSTART(I)+K),I=1,MAXLEN)
2000  FORMAT(10(1X,A12,1X))
      WRITE (LPT,2001)
2001  FORMAT(//)
      RETURN
      END
C
C
C
C
C
      BLOCK DATA BIGLET
      COMMON /BIGONE/ X
      CHARACTER*12 X(504),A(72),B(72),C(72),D(72),E(72),F(72),G(72)
      EQUIVALENCE (X(1),A(1)),(X(73),B(1)),(X(145),C(1)),
     & (X(217),D(1)),(X(289),E(1)),(X(361),F(1)),(X(433),G(1))
      DATA A/
     &   ' AAAAAAAAAA ','AAAAAAAAAAAA','AA        AA','AA        AA',
     &   'AA        AA','AAAAAAAAAAAA','AAAAAAAAAAAA','AA        AA',
     &   'AA        AA','AA        AA','AA        AA','AA        AA',
     &   'BBBBBBBBBBB ','BBBBBBBBBBBB','BB        BB','BB        BB',
     &   'BB       BB ','BBBBBBBBBB  ','BBBBBBBBBB  ','BB       BB ',
     &   'BB        BB','BB        BB','BBBBBBBBBBBB','BBBBBBBBBBB ',
     &   ' CCCCCCCCCC ','CCCCCCCCCCCC','CC        CC','CC          ',
     &   'CC          ','CC          ','CC          ','CC          ',
     &   'CC          ','CC        CC','CCCCCCCCCCCC',' CCCCCCCCCC ',
     &   'DDDDDDDDD   ','DDDDDDDDDD  ','DD       DD ','DD        DD',
     &   'DD        DD','DD        DD','DD        DD','DD        DD',
     &   'DD        DD','DD       DD ','DDDDDDDDDD  ','DDDDDDDDD   ',
     &   'EEEEEEEEEEEE','EEEEEEEEEEEE','EE          ','EE          ',
     &   'EE          ','EEEEEEEE    ','EEEEEEEE    ','EE          ',
     &   'EE          ','EE          ','EEEEEEEEEEEE','EEEEEEEEEEEE',
     &   'FFFFFFFFFFFF','FFFFFFFFFFFF','FF          ','FF          ',
     &   'FF          ','FFFFFFFF    ','FFFFFFFF    ','FF          ',
     &   'FF          ','FF          ','FF          ','FF          '/
      DATA B/
     &   ' GGGGGGGGGG ','GGGGGGGGGGGG','GG        GG','GG          ',
     &   'GG          ','GG          ','GG     GGGGG','GG     GGGGG',
     &   'GG        GG','GG        GG','GGGGGGGGGGGG',' GGGGGGGGGG ',
     &   'HH        HH','HH        HH','HH        HH','HH        HH',
     &   'HH        HH','HHHHHHHHHHHH','HHHHHHHHHHHH','HH        HH',
     &   'HH        HH','HH        HH','HH        HH','HH        HH',
     &   ' IIIIIIIIII ',' IIIIIIIIII ','     II     ','     II     ',
     &   '     II     ','     II     ','     II     ','     II     ',
     &   '     II     ','     II     ',' IIIIIIIIII ',' IIIIIIIIII ',
     &   '  JJJJJJJJJJ','  JJJJJJJJJJ','      JJ    ','      JJ    ',
     &   '      JJ    ','      JJ    ','      JJ    ','      JJ    ',
     &   'JJ    JJ    ','JJ    JJ    ','JJJJJJJJ    ',' JJJJJJ     ',
     &   'KK        KK','KK       KK ','KK      KK  ','KK     KK   ',
     &   'KK    KK    ','KKKKKKK     ','KKKKKKK     ','KK    KK    ',
     &   'KK     KK   ','KK      KK  ','KK       KK ','KK        KK',
     &   'LL          ','LL          ','LL          ','LL          ',
     &   'LL          ','LL          ','LL          ','LL          ',
     &   'LL          ','LL          ','LLLLLLLLLLLL','LLLLLLLLLLLL'/
      DATA C/
     &   'MM        MM','MMM      MMM','MMMM    MMMM','MM MM  MM MM',
     &   'MM  MMMM  MM','MM   MM   MM','MM        MM','MM        MM',
     &   'MM        MM','MM        MM','MM        MM','MM        MM',
     &   'NN        NN','NNN       NN','NNNN      NN','NN NN     NN',
     &   'NN  NN    NN','NN   NN   NN','NN    NN  NN','NN     NN NN',
     &   'NN      NNNN','NN       NNN','NN        NN','NN         N',
     &   'OOOOOOOOOOOO','OOOOOOOOOOOO','OO        OO','OO        OO',
     &   'OO        OO','OO        OO','OO        OO','OO        OO',
     &   'OO        OO','OO        OO','OOOOOOOOOOOO','OOOOOOOOOOOO',
     &   'PPPPPPPPPPP ','PPPPPPPPPPPP','PP        PP','PP        PP',
     &   'PP        PP','PPPPPPPPPPPP','PPPPPPPPPPP ','PP          ',
     &   'PP          ','PP          ','PP          ','PP          ',
     &   ' QQQQQQQQQQ ','QQQQQQQQQQQQ','QQ        QQ','QQ        QQ',
     &   'QQ        QQ','QQ        QQ','QQ        QQ','QQ    QQ  QQ',
     &   'QQ     QQ QQ','QQ      QQQQ','QQQQQQQQQQQ ',' QQQQQQQQ QQ',
     &   'RRRRRRRRRRR ','RRRRRRRRRRRR','RR        RR','RR        RR',
     &   'RR        RR','RRRRRRRRRRRR','RRRRRRRRRRR ','RR    RR    ',
     &   'RR     RR   ','RR      RR  ','RR       RR ','RR        RR'/
      DATA D/
     &   ' SSSSSSSSSS ','SSSSSSSSSSSS','SS        SS','SS          ',
     &   'SSS         ',' SSSSSSSSS  ','  SSSSSSSSS ','         SSS',
     &   '          SS','SS        SS','SSSSSSSSSSSS',' SSSSSSSSSS ',
     &   'TTTTTTTTTTTT','TTTTTTTTTTTT','     TT     ','     TT     ',
     &   '     TT     ','     TT     ','     TT     ','     TT     ',
     &   '     TT     ','     TT     ','     TT     ','     TT     ',
     &   'UU        UU','UU        UU','UU        UU','UU        UU',
     &   'UU        UU','UU        UU','UU        UU','UU        UU',
     &   'UU        UU','UU        UU','UUUUUUUUUUUU',' UUUUUUUUUU ',
     &   'VV        VV','VV        VV','VV        VV','VV        VV',
     &   'VV        VV','VV        VV','VV        VV',' VV      VV ',
     &   '  VV    VV  ','   VV  VV   ','    VVVV    ','     VV     ',
     &   'WW        WW','WW        WW','WW        WW','WW        WW',
     &   'WW        WW','WW        WW','WW   WW   WW','WW  WWWW  WW',
     &   'WW WW  WW WW','WWWW    WWWW','WWW      WWW','WW        WW',
     &   'XX        XX','XX        XX',' XX      XX ','  XX    XX  ',
     &   '   XX  XX   ','    XXXX    ','    XXXX    ','   XX  XX   ',
     &   '  XX    XX  ',' XX      XX ','XX        XX','XX        XX'/
      DATA E/
     &   'YY        YY','YY        YY',' YY      YY ','  YY    YY  ',
     &   '   YY  YY   ','    YYYY    ','     YY     ','     YY     ',
     &   '     YY     ','     YY     ','     YY     ','     YY     ',
     &   'ZZZZZZZZZZZZ','ZZZZZZZZZZZZ','         ZZ ','        ZZ  ',
     &   '       ZZ   ','      ZZ    ','     ZZ     ','    ZZ      ',
     &   '   ZZ       ','  ZZ        ',' ZZZZZZZZZZZ','ZZZZZZZZZZZZ',
     &   '            ','            ','            ','            ',
     &   '            ','            ','            ','            ',
     &   '     ..     ','    ....    ','    ....    ','     ..     ',
     &   '            ','     ++     ','     ++     ','     ++     ',
     &   '     ++     ',' ++++++++++ ',' ++++++++++ ','     ++     ',
     &   '     ++     ','     ++     ','     ++     ','            ',
     &   '  00000000  ',' 0000000000 ','00        00','00        00',
     &   '00        00','00        00','00        00','00        00',
     &   '00        00','00        00',' 0000000000 ','  00000000  ',
     &   '     11     ','    111     ','   1111     ','     11     ',
     &   '     11     ','     11     ','     11     ','     11     ',
     &   '     11     ','     11     ',' 1111111111 ',' 1111111111 '/
      DATA F/
     &   ' 2222222222 ','222222222222','22        22','          22',
     &   '          22','         22 ','       22   ','     22     ',
     &   '   22       ',' 22         ','222222222222','222222222222',
     &   ' 3333333333 ','333333333333','33        33','          33',
     &   '          33','       3333 ','       3333 ','          33',
     &   '          33','33        33','333333333333',' 3333333333 ',
     &   '      444   ','     4444   ','    44 44   ','   44  44   ',
     &   '  44   44   ',' 44444444444','444444444444','       44   ',
     &   '       44   ','       44   ','       44   ','       44   ',
     &   '555555555555','555555555555','55          ','55          ',
     &   '55          ','555555555   ','5555555555  ','         55 ',
     &   '          55','          55','555555555555','55555555555 ',
     &   ' 6666666666 ','666666666666','66        66','66          ',
     &   '66          ','66666666666 ','666666666666','66        66',
     &   '66        66','66        66','666666666666',' 6666666666 ',
     &   '777777777777','77777777777 ','77      77  ','       77   ',
     &   '      77    ','     77     ','     77     ','     77     ',
     &   '     77     ','     77     ','     77     ','     77     '/
      DATA G/
     &   ' 8888888888 ','888888888888','88        88','88        88',
     &   ' 88      88 ','  88888888  ','  88888888  ',' 88      88 ',
     &   '88        88','88        88','888888888888',' 8888888888 ',
     &   ' 9999999999 ','999999999999','99        99','99        99',
     &   '99        99','999999999999','999999999999','          99',
     &   '          99','99        99','999999999999',' 9999999999 ',
     &   '          //','         // ','        //  ','       //   ',
     &   '      //    ','     //     ','    //      ','   //       ',
     &   '  //        ',' //         ','//          ','            ',
     &               36*'            '/
      END
C
C
C
C LEVEL 1      SUBROUTINE BATCH
      SUBROUTINE BATCH
C
C *** BATCH by JCM 27 Jun 86 ***
C
CX
CC 16C
CH Signals batch running, not interactive.
C
CO Sets NBATCH in COMMON /GLOBAL to be the distinctive value 42
C
CN BATCH should be called AFTER INITIL, but before anything else.
CN The relevant input/output unit numbers should also be set up
CN in MAIN, AFTER BATCH, if they differ from the following settings:
C
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /GLOBAL/NINIT,NBATCH,NSYSTM,MULFAS,MULSOU,MULONE
      LOGICAL MULFAS,MULSOU,MULONE
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
      COMMON /MAPRD/ZRDVAL(20),ZCRD,IRD,IZRD,IDUMPR
      COMMON /MAPSV/ZSVVAL(20),ZCSV,ISV,IZSV,NDUMPS,NSAV
      COMMON /NEWOLD/SHIFT,XOLD,XNEW,ESD,IFAM,IGEN,ISPC,
     & NEWIN,KPACK,LKH,SHESD,ISHFT,AVSHFT,AMAXSH
      COMMON /PRSTAT/SMYC,SMYD,SMYO,SMIO,SMID,SMWYOS,IZCT,
     & P5,IOP1,IOP2,KMI(9),KMA(9)
C
      NBATCH=42
      ICRYDA=11
      LUNI=2
      NEWIN=9
      NDUMPS=3
      IDUMPG=4
      IDUMPR=4
      IOP1=2
      IOP2=1
      CALL MESS(LPT,2,'            Batch running - no interaction')
      RETURN
      END
C
C
C
C LEVEL 5      SUBROUTINE BNDLST(NAME1,NAME2)
      SUBROUTINE BNDLST(NAME1,NAME2)
C
C *** BNDLST updated by JCM 11 Sep 92 ***
C
CX
CC 8B
CH Writes out and saves a list of bonds from one atomic position.
CA On entry NAME1 is the name of source atom in list in /POSNS/,
CA                   NOT a general atom name (i.e. all letters) because that
CA                   would not group together bonds from a single atom, to
CA                   be used in angles.
CA          NAME2  is EITHER the name of one destination atom,
CA                    OR a general atom name.
CP In /BONDLA/ BMAX and BMIN give the limits of bonds to consider.
C
CD To find both NAME1 and NAME2, scans the list in ATNAME.  Accepts a complete
CD match;  also for NAME2 accepts a match of a general atom name with ALL the
CD starting letters of a name in the list.
C
CD So, e.g. for NAME2, Si2 matches with ONLY Si2 (not Si23)
CD                     Si matches with Si, Si1, Si2 etc (not SiA)
C
CD Makes from atom 2 all useful destination atoms related by symmetry to it.
CD Because bonds are also used as slack constraints in LSQ, the destination atom
CD formed by a particular symmetry operation, which may well fall outside the
CD original unit cell (i.e. have coordinates < 0 or > 1) is NOT now put
CD back into the original cell.  Previously it was, and the resulting
CD 3x3x3 cube of cells was scanned.  This makes a terrible mess of refined
CD coordinates which themselves hop over a cell edge.
CD So now a symmetry related position is formed, and the surrounding 5x5x5
CD cube of unit cells is scanned.
CD
CD A list of found bonds (and related information) is held in /BONDLA/ for
CD use when rejecting duplicate bonds, and perhaps later if angles are
CD required.
C
CO Writes found bonds to unit LPT
CO Writes generated cards to unit LSK
C
      CHARACTER *16 CH
      CHARACTER *4 NAME1,NAME2,GENNAM,TONAME
      LOGICAL DONT,HEAD,MIDD
      DIMENSION DX(3),CEL(3),XD(3),X1(3),X2(3),XD1(3),XD2(3),K(6),ODX(3)
      DIMENSION ZER(3),CELXYZ(3)
      COMMON /ATNAM/ATNAME(150),ATNA(150,9)
      CHARACTER *4 ATNA,ATNAME
      COMMON /ATNMPK/ATPACK(10,3)
      INTEGER ATPACK
      COMMON /BONDLA/NB,BSAVE(100),DXSAVE(3,100),NBSAVE(100),
     & N2SAVE(100),N3SAVE(100),I1LAST,BMAX,BMIN,BBMAX,SDMAX,
     & ANG1,ANG2,BON2,SD1,SD2,BONOUT,LSK,SLK
      LOGICAL SLK,BONOUT
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /SLKGEC/ATTNAM(500),BONNAM(500),ANGNAM(100),
     & TORNAM(100)
      CHARACTER *4 ATTNAM,BONNAM,ANGNAM,TORNAM
      COMMON /SLKGEO/NSTYP,BOBS(500),EOBS(500),IATM(500,2),
     & ISYM(500),ILAT(500),CELLTR(3,500),XSLAK(3,500),
     & COSIN(3,3),IABASE(500),NST1,SLONLY,TOSTAR(6,6),BCALC(500),
     & DERCEL(6,500),DERPOS(3,500,2),ITYPSK(500),INVBON(10,
     & 500),NINVB(500),INANG(100,3),INTOR(100,6),
     & DERBON(10),NVB(10),NUMBON,NTARNM,NUMANG,NUMTOR,KOM25
      LOGICAL SLONLY
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
      DATA ZER/0.,0.,0./
C
C
C IDENTIFY SOURCE:
      I1=IATOM(NAME1)
      IF (I1 .LE. 0) GO TO 100
C
C ADD TO LIST:
      CALL ADDATM(NAME1,I1,X(1,I1),1,1,ZER,N1)
C
C CLEAR COUNT OF SAVED BONDS IF NEW SOURCE:
      IF (I1 .NE. I1LAST) THEN
        NB=0
        HEAD=.TRUE.
      ENDIF
      I1LAST=I1
C
C IDENTIFY DESTINATION:
      DO 42 I2=1,NATOM
      IF (NAME2 .NE. ATNAME(I2) .AND. GENNAM(ATNAME(I2))
     & .NE. NAME2) GO TO 42
C
C SET START OF BOND COUNT FOR THIS DESTINATION
      DO 14 I=1,3
      X1(I)=X(I,I1)
C DO NOT NOW PUT SOURCE ATOM INTO CENTRAL CELL:
C      CALL FRACT(X1(I),Y,N)
      X2(I)=X(I,I2)
   14  CONTINUE
C
C OUTER CYCLE OVER CENTRE OF SYMMETRY IF PRESENT:
      DO 1 IC=1,NCENT
C NEXT CYCLE OVER SYMMETRY OPERATORS FOR SPACE GROUP
      DO 2 IS=1,NOPC
      CALL ROTSYM(X2,XD1,IS,1)
      CALL GMADD(XD1,TRANS(1,IS),XD1,1,3)
      IF (IC .EQ. 2) CALL GMREV(XD1,XD1,1,3)
C
C MIDDLE CYCLE OVER LATTICE SYMMETRY
      DO 3 IL=1,NLAT
      CALL GMADD(XD1,ALAT(1,IL),XD2,1,3)
C
C DO NOT NOW PUT DESTINATION ATOM INTO CENTRAL CELL
C      CALL FRAC3(XD2)
C
C INNER CYCLES OVER 5x5x5 UNIT CELLS, WHICH IS OVERKILL & SLOW BUT WON'T MISS
C MUCH:
      DO 4 NCELZ=1,5
      CEL(3)=FLOAT(NCELZ-3)
      DO 5 NCELY=1,5
      CEL(2)=FLOAT(NCELY-3)
      DO 6 NCELX=1,5
      CEL(1)=FLOAT(NCELX-3)
C
      CALL GMADD(XD2,CEL,XD,1,3)
      CALL GMSUB(X1,XD,DX,1,3)
C REJECT IF ONE LENGTH IS > MAX BOND:
      DO 38 I=1,3
      IF (DX(I) .GT. BMAX) GO TO 6
  38  CONTINUE
C
      B = VCTMOD(1.,DX,1)
      IF (B .GT. BMAX) GO TO 6
      IF (B .LT. BMIN) GO TO 6
      IF (B .LT. 0.00001) GO TO 6
C
C SAVE BOND:
      DO 12 I=1,NB
      DO 13 J=1,3
      IF (ABS(DXSAVE(J,I)-DX(J)) .GT. 0.00001) GO TO 12
  13  CONTINUE
C TO 6 IF LATEST BOND HAS OCCURRED PREVIOUSLY AND IS NOT WANTED AGAIN
      GO TO 6
  12  CONTINUE
C%
C   8  CALL ERRCHK(2,NB,%BSAV%,0,'bonds from 1 atom')
   8  CALL ERRCHK(2,NB,100,0,'bonds from 1 atom')
      BSAVE(NB)=B
      DXSAVE(1,NB)=DX(1)
      DXSAVE(2,NB)=DX(2)
      DXSAVE(3,NB)=DX(3)
      N2SAVE(NB)=I2
C
C FORM THETA, PHI ANGLES AND REPORT THEM WITH DELTAS(X,Y,Z)
      CALL ORTHO(DX,ODX,1)
      CALL GMREV(ODX,ODX,1,3)
      CALL UNIVEC(ODX,C)
      ANGT1=DEGREE(ACOS(ODX(3)))
      DONT = (ABS(ODX(3)) .GT. 0.9999)
      IF (.NOT. DONT) ANGT2=DEGREE(ATAN2(ODX(2),ODX(1)))
      MIDD = ((IL.EQ.1) .AND. (IS.EQ.1) .AND. (NCELX.EQ.3) .AND.
     & (NCELY.EQ.3) .AND. (NCELZ.EQ.3) .AND. (IC .EQ. 1))
      IF (HEAD) THEN
        CALL MESS(LPT,2,'    SOURCE ATOM: '//NAME1)
        CALL MESS(LPT,0,'Atom1-Atom2     Bond        Atom 2'//
     & '               Position                Atom 1 - Atom 2'//
     & '       Bond Angles')
        CALL MESS(LPT,0,'                       (if not original)   '//
     & '   x       y       z      delta x delta y delta z   theta phi')
      ENDIF
      HEAD=.FALSE.
C
C IF MAKING CARDS FOR SLACK CONSTRAINTS:
      IF (SLK) THEN
        IF (.NOT. MIDD) THEN
C INVENT NEW NAME INTO TONAME:
          CELXYZ(1)=FLOAT(NCELX-3)
          CELXYZ(2)=FLOAT(NCELY-3)
          CELXYZ(3)=FLOAT(NCELZ-3)
          ISC=IS*(3-2*IC)
          NOLD=NTARNM
          CALL ADDATM('    ',I2,XD,ISC,IL,CELXYZ,N2)
          IF (NOLD .LT. NTARNM) THEN
            TONAME=ATTNAM(NTARNM)
            WRITE (LSK,2005) TONAME,ATNAME(I2),ISC,IL,NCELX-3,
     &      NCELY-3,NCELZ-3
2005        FORMAT ('L ATOM ',A4,2X,A4,2X,I3,2X,I3,2X,3I3)
          ELSE
            TONAME=ATTNAM(N2)
            GO TO 43
          ENDIF
        ELSE
          TONAME=ATNAME(I2)
C ADD TO LIST:
          CALL ADDATM(TONAME,I2,X(1,I2),1,1,ZER,N2)
        ENDIF
  43    NOLD=NUMBON
        CALL ADDBON('    ',N1,N2,NN)
        NBSAVE(NB)=NN
        N3SAVE(NB)=N2
        IF (NOLD .EQ. NUMBON) GO TO 6
        IF (.NOT. BONOUT) THEN
          WRITE (LSK,2051) BONNAM(NN),NAME1,TONAME,BON2,SD2
2051      FORMAT ('L BOND ',A4,2X,A4,2X,A4,2F10.5)
        ELSE
          WRITE (LSK,2051) BONNAM(NN),NAME1,TONAME
        ENDIF
      ENDIF
      IF (MIDD) GO TO 10
C
      K(1)=I2
      K(2)=(3-2*IC)*IS
      K(3)=IL
      K(4)=NCELX-3
      K(5)=NCELY-3
      K(6)=NCELZ-3
      CALL NPACK(I3,K,6,1,ATPACK)
      N2SAVE(NB)=-I3
      CALL ATSPEC(I3,K,CH)
      IF (DONT) WRITE (LPT,2000) ATNAME(I1),ATNAME(I2),B,CH,XD,DX,ANGT1
      IF (.NOT. DONT) WRITE (LPT,2000) ATNAME(I1),ATNAME(I2),
     & B,CH,XD,DX,ANGT1,ANGT2
2000  FORMAT (1X,A4,' - ',A4,F10.4,2X,A16,2X,3F8.4,2X,3F8.4,2F8.2)
      GO TO 6
  10  IF (DONT) WRITE (LPT,2001) ATNAME(I1),ATNAME(I2),B,DX,ANGT1
      IF (.NOT. DONT) WRITE (LPT,2001) ATNAME(I1),ATNAME(I2),
     & B,DX,ANGT1,ANGT2
2001  FORMAT (1X,A4,' - ',A4,F10.4,46X,3F8.4,2F8.2)
   6  CONTINUE
   5  CONTINUE
   4  CONTINUE
   3  CONTINUE
   2  CONTINUE
   1  CONTINUE
  42  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE APSHSF(MAGSHF)
      SUBROUTINE APSHSF(MAGSHF)
C
C *** APSHSF updated by PJB 31-May-1994 ***
C
CX
CC 7B
CH Applies shifts to all variables in single crystal structure factor based
CH LSQ, and prints the results.
CA On entry MAGSHF is the name of a routine which applies shifts to magnetic
CA parameters.  It is DUMMY for non-magnetic applications.
CP Shifts are in array BLSQ, and ESDs in DERIVB (to save space)
C
CD Identifies each variable as a type of parameter, and call individual
CD routines to apply shift (possibly fudged).
C
CD For redundant variables, calculates shift from constituent parts of
CD relevant constraint.
C
CO Prints old and new values, shift and esd, with parameter name
CO If family 2 (structure parameter), does printing in blocks
C
      EXTERNAL MAGSHF
      CHARACTER *4 LNAM1,LNAM2
      CHARACTER *80 VFMT
      LOGICAL HEAD,SHFCEL
      COMMON /ATBLOC/NAME,IPNAME(12)
      CHARACTER *4 NAME,IPNAME
      COMMON /ATBLOK/IBUFF,PNEW(12),PESD(12),PSHIFT(12),POLD(12),
     & PSESD(12)
      COMMON /DERBAS/DERIVB(400),LVARB
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MATDAT/MATPNT(401),BLSQ(400)
      COMMON /NEWOLD/SHIFT,XOLD,XNEW,ESD,IFAM,IGEN,ISPC,
     & NEWIN,KPACK,LKH,SHESD,ISHFT,AVSHFT,AMAXSH
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
      DATA VFMT/'(1X,2(1X,A4),4F14.5,F14.4)'/
C
      IF (SIMUL) GO TO 100
      WRITE (LPT,2000) ICYC
2000  FORMAT (/////'1Shifts in variables for cycle',I3)
C
C SET UP QUANTITIES TO USE WITH DIFFERENT STYLES OF OUTPUT:
      IG=0
      IBUFF=0
      HEAD=.FALSE.
C SET NO CELL SHIFTS:
      SHFCEL=.FALSE.
C CLEAR SHIFT AVERAGING:
      CALL FETSHF(1,0.,0.)
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
      J=LVRBS(I)
      KPACK=LVRPR(I)
C IF VARIABLE IS BASIC:
      IF (J .GT. 0) THEN
        SHIFT=BLSQ(J)
        ESD=DERIVB(J)
C OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
      ELSE
        CALL SHFESD(-J)
      ENDIF
C
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
      IF (J .LT. 0 .AND. IFAM .EQ. 2 .AND. ISPC .EQ. 10) GO TO 1
C
C BRANCH ON FAMILY:
      GO TO (11,12), IFAM
C
  11  GO TO (21,22) , IGEN
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SPECIES (TFAC,A*,B* . . F*,DOMR,MOSC):
  21  GO TO (31,32,32,32,32,32,32,33,33,33,33,33) , ISPC
C
C TFAC:
  31  CALL LLTFAC(3)
      GO TO 40
C
C DOMR OR MOSC OR FOVLP (EXTINCTION CORRECTION PARAMETERS)
  33  CALL EXTIN3(ISPC-7)
      GO TO 40
C
C CELL PARAMETERS:
  32  CALL CELSHF(ISPC-1)
      SHFCEL=.TRUE.
      GO TO 40
C
C FAMILY 1, GENUS 2 - IN SF THIS IS 'SCAL':
  22  CALL LLSCAL(3)
      GO TO 40
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .LE. 12) CALL F2SHFT
      IF (ISPC .GT. 12) CALL MAGSHF(3)
      GO TO 40
C
C
C COMMON EXIT TO PRINT SHIFTS:
  40  CALL FETSHF(2,SHIFT,ESD)
      CALL PARNAM(LNAM1,LNAM2,3,KPACK)
      IF (IFAM .NE. 2) GO TO 6
C DETECT CHANGE OF GENUS (ATOM)
      IF (IG .EQ. IGEN) GO TO 7
      HEAD=.FALSE.
      CALL PRBLOK
C PUT FIRST ENTRY FOR NEW ATOM INTO BUFFERS:
      NAME=LNAM1
      IG=IGEN
   7  IF (IBUFF .GE. 12) CALL PRBLOK
      IBUFF=IBUFF+1
      IPNAME(IBUFF)=LNAM2
      PNEW(IBUFF)=XNEW
      PESD(IBUFF)=ESD
      PSHIFT(IBUFF)=SHIFT
      POLD(IBUFF)=XOLD
      PSESD(IBUFF)=SHESD
      GO TO 1
C
C HERE TO PRINT TYPE 1 SHIFT AS BEFORE:
   6  IF (.NOT. HEAD) CALL MESS(LPT,1,'  Variable         New'//
     & '           Esd          Shift          Old           Shift/Esd')
      HEAD=.TRUE.
      WRITE (VFMT(19:19),2006) NSIGFG(ESD)
 2006 FORMAT (I1)
      WRITE (LPT,VFMT) LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD,SHESD
   1  CONTINUE
C
C PRINT ANY REMNANTS FROM BUFFER:
      CALL PRBLOK
      CALL FETSHF(3,0.,0.)
C IF ANY SLACK CONSTRAINTS, UPDATE THEIR BOND ENDS:
      CALL GEOMCO(2)
C IF ANY CELL PARAMETERS CHANGED, UPDATE ALL:
      IF (SHFCEL) CALL RECELL(1,1)
 100  RETURN
      END
C
C
C
C LEVEL 8      SUBROUTINE APSHT2
      SUBROUTINE APSHT2
C
C *** APSHT2 updated by JCM 10 Feb 87 ***
C
CX
CC 7B
CH Applies shifts for reciprocal cell quadratic products and zero
CH during 2theta refinement.
C
CP Only of use from MAIN program T2LSQ, or similar;  only expects one family
CP of parameters, being the 6 reciprocal cell quadratic products
CP and a zero point.
CP Expects shifts (one for each basic variable) in array BLSQ, with
CP corresponding ESDs in array DERIVB.
C
CD Applies shifts as given to the parameters, dealing with constraints
CD if necessary.  Recalculates all cell quantities.
C
CO Writes to unit LPT the old and new values, the shift and its esd.
C
      CHARACTER *4 LNAM1,LNAM2
      COMMON /CELPAR/CELL(3,3,2),V(2),ORTH(3,3,2),CPARS(6,2),KCPARS(6),
     & CELESD(6,6,2),CELLSD(6,6),KOM4
      COMMON /DERBAS/DERIVB(400),LVARB
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MATDAT/MATPNT(401),BLSQ(400)
      COMMON /NEWOLD/SHIFT,XOLD,XNEW,ESD,IFAM,IGEN,ISPC,
     & NEWIN,KPACK,LKH,SHESD,ISHFT,AVSHFT,AMAXSH
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /ZEROPT/ZERO,KZERO
C
      WRITE (LPT,2000) ICYC
2000  FORMAT (/////'1Shifts in variables for cycle',I3/
     & '   Variable       New           Esd          Shift        ',
     & '  Old    ')
      DO 1 I=1,LVARV
      J=LVRBS(I)
      KPACK=LVRPR(I)
C IF VARIABLE IS BASIC:
      IF (J .GT. 0) THEN
        SHIFT=BLSQ(J)
        ESD=DERIVB(J)
C OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
      ELSE
        CALL SHFESD(-J)
      ENDIF
C
      CALL PARNAM(LNAM1,LNAM2,3,KPACK)
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
      IF (ISPC .GT. 6) GO TO 11
      CALL ADJUST(CPARS(ISPC,2))
      GO TO 12
C
C SHIFT IN ZERO POINT:
  11  CALL ADJUST(ZERO)
  12  WRITE (LPT,2001) LNAM1,LNAM2,XOLD,ESD,SHIFT,XNEW
2001  FORMAT (' ',1X,A4,1X,A4,4G14.5)
   1  CONTINUE
      CALL RECELL(1,1)
      RETURN
      END
C
C
C
C LEVEL 1      SUBROUTINE ARPRIN(H,FBUF,MODE)
      SUBROUTINE ARPRIN(H,FBUF,MODE)
C
C *** ARPRIN updated by PJB 24-Apr-1995 ***
C
CX
CC 2A
CH A multi-mode routine to produce the output in ARRNGE type main programs.
CA On entry H contains a set of floating indices
CA          FBUF is as set up in the main program. FBUF(1) is the record
CA               number and normally FBUF(2:3) the observation and its
CA               standard deviation.
CA MODE selects what is printed out
CA MODE = 0 Sets up the variable formats in accordance with IFOR
CA MODE = 1 Reject output
CA MODE = 2 Initial heading
CA MODE = 3 1st entry for a reflection (rec no indices and values)
CA MODE = 4 Add values to output file buffer
CA MODE = 5 Entry for repeated reflections (recno and values)
CA MODE = 6 End of sub-group
CA MODE = 7 End of group
CA MODE = 8 Average of configuration domains
C
      EXTERNAL ARRBLK
      DIMENSION H(3),FBUF(10),K(3)
      COMMON /ARRFMT/FILBUF,LPTBUF,HKLFMT,VALFMT,REJFMT,VFMT1,VFMT2,
     &VFMT3,VFMT4
      CHARACTER *80 FILBUF,LPTBUF*132,HKLFMT*7,VALFMT*16,REJFMT*30
      CHARACTER *30 VFMT1,VFMT2,VFMT3,VFMT4*45
      COMMON /ARRDAT/IFOR(6),INC,LINO,NREF,INLBUF,NBUF,IBUF,INFBUF,
     & INDLEN,NUMVAL,IPOS,ISTORE,ICHNGE,NEW,LPRINT,ICD,IS,NREF1,NREFL
      LOGICAL INC,NEW,LPRINT
      COMMON /HEDIN/HEADNG
      CHARACTER *300 HEADNG
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /WHEN/DAT,TIM(2),MAIN
      CHARACTER *5 TIM
      CHARACTER *10 DAT
      CHARACTER *6 MAIN
C
      N=NINT(FBUF(1))
      IF (.NOT.INC .AND. MODE.NE.2) CALL INDFIX(H,K)
      GO TO (1,10,20,30,40,50,60,70,80), MODE+1
C
C  FIDDLE THE FORMATS
    1 NUMVAL=3
C NUMVAL IS THE NUMBER OF ENTRIES IN FBUF
      IF (IFOR(1).EQ.1) THEN
        IF (IFOR(6) .EQ.0) THEN
          VALFMT='(2F10.6)'
        ELSE
          VALFMT='(2F10.6,3F10.2)'
          NUMVAL=6
        ENDIF
      ELSE IF (IFOR(1).EQ.5) THEN
        VALFMT='(2F10.2,2F10.5)'
        NUMVAL=5
      ELSE
        IF (IFOR(6) .EQ .0) THEN
          VALFMT='(2F10.2)'
        ELSE
         VALFMT='(2F10.2,4F10.2)'
         NUMVAL=7
       ENDIF
      ENDIF
C IPOS IS THE STARTING POSITION IN FBUF TO STORE
      IPOS=2-IFOR(3)
C ISTORE IS THE NUMBER OF CHARACTERS NEEDED PER MEASUREMENT
      ISTORE=(NUMVAL+1-IPOS)*10
C NBUF IS THE NUMBER OF MEASUREMENTS WHICH WILL FIT IN FILBUF
      NBUF=74/ISTORE
C FORCE NBUF TO 1 TO ENSURE THAT INPUAR WORKS PROPERLY
C THIS NEEDS TO BE CLEANED UP SOMETIME
      NBUF=1
C
      IF (INC) THEN
        HKLFMT='(3F8.3)'
        INDLEN=24
        HEADNG(14:15)='11'
        HEADNG(28:29)='12'
        HEADNG(69:70)=' 9'
        HEADNG(85:86)='11'
        HEADNG(122:123)='53'
        HEADNG(141:142)='13'
        HEADNG(153:154)='16'
        HEADNG(171:194)='16X,''h'',7X,''k'',7X,''l'',7X'
        HEADNG(236:258)='6X,''h'',7X,''k'',7X,''l'',9X'
      ELSE
C SET IS TO ZERO FOR ARRNGE (NO SATELLITES)
        IS=0
        HKLFMT='(3I5  )'
        INDLEN=15
      ENDIF
C
      IF (IFOR(5).NE.0) THEN
        REJFMT='('' Reject '',I9,'//HKLFMT(2:6)//','//VALFMT(2:)
      ENDIF
      VFMT1='(I9,2X,'//HKLFMT(2:6)//','//VALFMT(2:)
      VFMT2='(I5,'//HKLFMT(2:6)//',2I5)'
      VFMT3=HKLFMT(1:6)//','//VALFMT(2:)
      VFMT4='(53X,''Domain average  '','//VFMT3(2:)
      IF (INC) VFMT4(2:3)='62'
      INFBUF=0
C
      GO TO 100
C
C REPORT REJECTIONS
   10 IF (INC) THEN
        WRITE (LPT,REJFMT) N,H,(FBUF(I),I=2,NUMVAL)
      ELSE
        WRITE (LPT,REJFMT) N,K,(FBUF(I),I=2,NUMVAL)
      ENDIF
      GO TO 100
C
   20 WRITE (LPT,HEADNG)
      LINO=6
      INLBUF=1
      NEW=.TRUE.
      GO TO 100
C
C PRINTOUT DATA FOR INDIVIDUAL MEASUREMENTS
   30 J=NREF
      CALL TESTP(LPT,LINO,J,HEADNG,3)
      LINO=LINO-1
C CHECK WHETHER REFLECTIONS OCCURRING SINGLY ARE TO BE PRINTED
      IF (NEW) THEN
        LPRINT=((IFOR(2).GE.0) .OR. (NREF.GT.1) .OR. (ICHNGE.EQ.4))
        NEW=.FALSE.
      ENDIF
      IF (LPRINT) THEN
        IF (INLBUF.GT.1) THEN
          WRITE (LPT,3000) LPTBUF
 3000     FORMAT (A80)
          LINO=LINO+1
        ENDIF
        IF (INC) THEN
          WRITE (LPTBUF,VFMT1)  N,H,FBUF(2),FBUF(3)
        ELSE
          WRITE (LPTBUF,VFMT1) N,K,FBUF(2),FBUF(3)
        ENDIF
        INLBUF=31+INDLEN
      ENDIF
C
C  WRITE HEADER LINE TO OUTPUT FILE
        L=(NUMVAL-IPOS+1)*NREF+3
        IF (INFBUF.EQ.0. 0) WRITE (FILBUF(INDLEN:),2001) DAT,TIM(1)
2001    FORMAT (30X,A10,A5)
        INFBUF=INDLEN+44
        IF (INC) THEN
          WRITE (FILBUF(1:21+INDLEN),VFMT2) ICD,H,J,L
        ELSE
          WRITE  (FILBUF(1:21+INDLEN),VFMT2) ICD,K,J,L
        ENDIF
        WRITE (LUNI,3002) (FILBUF(I:I),I=1,INFBUF)
        ICD=ICD+1
        WRITE (FILBUF,3001) ICD
        INFBUF=6
        IBUF=0
        GO TO 100
C

C PUT VALUES INTO A BUFFER TO ACCUMULATE A LINE OF OUTPUT
   40 WRITE (FILBUF(INFBUF:),VALFMT) (FBUF(I),I=IPOS,NUMVAL)
      IBUF=IBUF
      INFBUF=INFBUF+ISTORE
      IBUF=IBUF+1
      IF (IBUF.GE.NBUF) THEN
        WRITE (LUNI,3002) (FILBUF(I:I),I=1,INFBUF-1)
 3002   FORMAT (80A1)
        ICD=ICD+1
        IBUF=0
        WRITE (FILBUF,3001) ICD
 3001   FORMAT (I5)
        INFBUF=6
      ENDIF
      GO TO 100
C
C REPEATED MEASUREMENT
   50 IF (LPRINT) THEN
C PRINT LINE JUST TERMINATED
        CALL TESTP(LPT,LINO,1,HEADNG,3)
        WRITE (LPT,2000) LPTBUF
 2000   FORMAT (A132)
        LINO=LINO+1
      ENDIF
      WRITE (LPTBUF,VFMT1) N
      WRITE (LPTBUF(12+INDLEN:),VALFMT) FBUF(2),FBUF(3)
      GO TO 100
C
C CHANGE OF SUBGROUP
C EMPTY BUFFER
   60 IF (IBUF.GT.0) THEN
        WRITE (LUNI,3002) (FILBUF(I:I),I=1,INFBUF-1)
        ICD=ICD+1
      ENDIF
      IF (LPRINT) THEN
        INLBUF=33+INDLEN
        WRITE (LPTBUF(INLBUF:),VALFMT) FBUF(2),FBUF(3)
      ENDIF
      GO TO 100
C
C END OF GROUP
   70 L=3
      INLBUF=INLBUF+22
      IF (INC) THEN
        J=100*IS+ICHNGE
        IF (LPRINT) WRITE (LPTBUF(INLBUF:),VFMT3) H,FBUF(2),FBUF(3)
        WRITE (LUNI,VFMT2) ICD,H,J,L
      ELSE
        IF (LPRINT) WRITE (LPTBUF(INLBUF:),VFMT3) K,FBUF(2),FBUF(3)
        WRITE (LUNI,VFMT2) ICD,K,J,L
      ENDIF
      ICD=ICD+1
      IF (LPRINT) THEN
        CALL TESTP(LPT,LINO,2,HEADNG,3)
        WRITE (LPT,2000) LPTBUF
        CALL NEWLIN(LPT)
        LINO=LINO+1
      ENDIF
      INLBUF=1
      NEW=.TRUE.
      GO TO 100
C
C AVERAGE OVER CONFIGURATION DOMAINS
   80 CALL TESTP(LPT,LINO,2,HEADNG,3)
       L=3
       J=0
      IF (INC) THEN
        WRITE (LPT,VFMT4)H,FBUF(2),FBUF(3)
        WRITE (LUNI,VFMT2) ICD,H,J,L
      ELSE
        WRITE (LPT,VFMT4)H,FBUF(2),FBUF(3)
        WRITE (LUNI,VFMT2) ICD,K,J,L
      ENDIF
      ICD=ICD+1
      CALL NEWLIN(LPT)
      LINO=LINO+1
      GO TO 100
C
  100 RETURN
      END
C
C
C LEVEL 1      SUBROUTINE TESTP(LUN,LINO,I,HEADNG,NL)
      SUBROUTINE TESTP(LUN,LINO,I,HEADNG,NL)
C
C *** TESTP by JCM 16 Oct 85 ***
C
CX
CC 13C
CH Puts a given heading at top of every printer page, counting lines.
CA On entry LUN is the required output unit number
CA          LINO is the number of lines already output on the current page
CA          I is the number of lines required to be output on this call
CA          HEADNG is the character variable holding the heading
CA          NL is the number of lines in HEADNG
CA On exit  LINO has been updated.
CD Tests the potential output against a page size of NLINES
CO If necessary, throws a page and puts out the heading on unit LUN
C
      CHARACTER*(*) HEADNG
C%
C      DATA NLINES/%LNPP%/
      DATA NLINES/115/
C
      LINO=LINO+1
      IF (LINO+I .LT. NLINES) GO TO 100
      IF (LINO .LT. NLINES-4) GO TO 100
      CALL NEWPAG(LUN)
      WRITE (LUN,FMT=HEADNG)
      LINO=NL+1
 100  RETURN
      END
C
C
C
C
      BLOCK DATA ARRBLK
C
C *** ARRBLK corrected by PJB Sept 94  ***
C
      COMMON /HEDIN/HEADNG
      CHARACTER *300 HEADNG
      DATA HEADNG/'(4X,''Record'', 6X,''Indices'', 6X,''Observations'',9
     &X,''Mean of repeated'', 5X,''Labelling'', 6X,''Mean of equivalent'
     &'/4X,''Number'',44X,''Observations'', 9X,''Index'',11X,''Reflectio
     &ns''/14X,''h'',4X,''k'',4X,''l'',6X,''Value'',5X,''SDevn'',7X,''Me
     &an'',5X,''SDevn'',4X,''h'',4X,''k'',4X,''l'',8X,''Mean'',5X,''SDev
     &n''/)'/
      END
C
C
C
C LEVEL 7      LOGICAL FUNCTION SYMFIX(KK)
      LOGICAL FUNCTION SYMFIX(KK)
C
C *** SYMFIX by JCM 7 Jun 88 ***
C
CX
CC 6C
CH Says whether a LSQ parameter is fixed by symmetry or not.
CA On entry KK holds packed parameter spec
CA On exit SYMFIX is TRUE if KK is fixed by symmetry (not just by user)
C
      LOGICAL KSAME
      COMMON /LINKAG/NUMFV,NUMPAK,KKFV(200),KTYPFV(200),KSTFV(200),
     & KTIME(200),KUNPFV(5,30),NTIME,NUMCON,KKCON(500),AMCON(500),
     & KPTCON(201),KSTCON(200),KTPCON(200)
C
      SYMFIX=.TRUE.
C
C SCAN ALL FIXING AND VARYING:
      DO 1 I=1,NUMFV
C IF ENTRY IS NOT KK ITSELF, AND DOES NOT ENCOMPASS KK, JUMP:
      IF (.NOT. KSAME(KK,KKFV(I)))  GO TO 1
C OTHERWISE, IF STATUS IS + (="FIX") 5 (="BY PROGRAM"), TRUE:
      IF (KSTFV(I) .EQ. 5) GO TO 100
   1  CONTINUE
      SYMFIX=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE STLSSF
      SUBROUTINE STLSSF
C
C *** STLSSF updated by JCM 20 Jul 88 ***
C
CX
CC 7A
CH Sets up any main program which does single crystal structure factor LSQ.
C
CI Reads and interprets:
CI An I card giving general instructions (including NCYC, CYC1, MCOR,
CI             and PRIN items, if required).
CI All L cards except FIX, VARY and RELA.
C
CD Reads in I and L cards.  If the refinement is actually a simple
CD application of geometric slack constraints, with no other observations,
CD sets this up (by recording "no. of scale factors=0" in LF1SP(2)),
CD deals with a possible absence of fudge factors, and exits.
CD
CD Otherwise deals with defaults for:
CD L TFAC: set TFAC=0 and fixed
CD L SCAL: set SCAL(1)=0, variable, and NSCALE=1
CD L REFI: assumes refinement type 1, "on mod Fc"
CD L MODE: assumes mode 3, data input as h,k,l, obs, sigma(obs), possible
CD         scale zone, possible code.
CD L WGHT: assumes weighting type 2, "use 1/sigma sqrd".
CD L FUDG: assumes no fudge factors.
C
CO Writes its findings to unit LPT.
C
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /LREAD/ILREA(22,5),KOM18
      DIMENSION ILREAD(22)
      EQUIVALENCE (ILREAD(1),ILREA(1,1))
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(20),KSCALE(20),
     & NSCL,LSCD(10)
      COMMON /SLAKDA/NSLAK(4),SLKSWD(4),SLAKWT(4),
     & CHISQD(4),ISLKTP,NSKTOT,KOM24
      COMMON /SLKGEO/NSTYP,BOBS(500),EOBS(500),IATM(500,2),
     & ISYM(500),ILAT(500),CELLTR(3,500),XSLAK(3,500),
     & COSIN(3,3),IABASE(500),NST1,SLONLY,TOSTAR(6,6),BCALC(500),
     & DERCEL(6,500),DERPOS(3,500,2),ITYPSK(500),INVBON(10,
     & 500),NINVB(500),INANG(100,3),INTOR(100,6),
     & DERBON(10),NVB(10),NUMBON,NTARNM,NUMANG,NUMTOR,KOM25
      LOGICAL SLONLY
C
      IF (INREAD(9) .GT. 0) CALL INPUTI
      CALL IICD1
C NOW ALL L CARDS EXCEPT FIX,RELA, VARY:
      CALL INPLSF
C AND INTERPRET THEM HAVING READ ALL:
C
C IF ONLY SLAK CONSTRAINTS & NO OBS, ONLY DEFAULT TO CONSIDER
C IS FUDG, AND WE NEED TO SET NO SCALES:
      IF (NSLAK(1) .LE. 0 .OR. .NOT. SLONLY) THEN
C DEFAULT IF NO L TFAC:
        IF (ILREAD(1) .EQ. 0) CALL LLTFAC(5)
C DEFAULT IF NO L SCAL:
        IF (ILREAD(2) .EQ. 0) CALL LLSCAL(0)
C SET ACTUAL NUMBER OF SCALE ZONES AS NUMBER OF PARAMETERS OF FAMILY 1, GENUS 2:
        LF1SP(2)=-NSCALE
C
C DEFAULT IF NO REFI - ASSUME REFINING ON MOD FC TO BE MOST USUAL:
        IF (ILREAD(3) .EQ. 0) THEN
          IREF=1
          CALL MESS(LPT,1,
     &    'No L REFI card - assuming refining on mod(Fc), type 1')
        ENDIF
C
C DEFAULT IF NO MODE CARD - TYPE 3:
        IF (ILREAD(4) .EQ. 0) THEN
          MODER=3
          CALL MESS(LPT,1,
     &    'No L MODE card - assuming mode 3, data input as h,k,l'//
     &    ' Gobs, sigma, (Scale), (Code)')
        ENDIF
C
C DEFAULT WEIGHTING IS TYPE 2 - ALSO SORT OUT INTERACTION BETWEEN IWGHT & MODER:
        IF (ILREAD(5) .EQ. 0) THEN
          IWGHT=2
          CALL MESS(LPT,1,'No L WGHT card given - assuming type 2')
        ENDIF
C
C IF WEIGHTING SCHEME 2, EXACT FORM OF INPUT FOR WEIGHTS DEPENDS ON MODER:
        IF (IWGHT .EQ. 2) THEN
C
C CANNOT HAVE MODER=1:
          IF (MODER .EQ. 1) THEN
            WRITE (LPT,3000) IWGHT,MODER
            WRITE (ITO,3000) IWGHT,MODER
3000        FORMAT (/' ERROR ** Weighting scheme=',I4,
     &      ' and input mode =',I4,' incompatible')
            IERR=IERR+1
          ELSE IF (MODER .EQ. 2) THEN
C
C WEIGHT TO BE USED AS READ:
            CALL MESS(LPT,1,
     &      'Weights to be used as read from reflection data')
          ELSE
C
C SIGMA READ, WEIGHT IS 1/SIGMA SQUARED:
            CALL MESS(LPT,1,
     &      'Sigma read from reflection data - weight is '//
     &      '1/sigma squared')
          ENDIF
        ENDIF
      ELSE
        LF1SP(2)=0
      ENDIF
C
      CALL ERRMES(0,0,'for structure factor LSQ')
C
      CALL GEOMIN(1)
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE STLSFW
      SUBROUTINE STLSFW
C
C *** STLSFW by JCM 17 Nov 84 ***
C
CX
CC 7A
CH Sets up the main program FWLSQ to perform LSQ on Forsyth & Wells
CH scattering factor coefficients.
C
CI Reads in and interprets an I card and an L VALS card giving
CI the 5, 7 or 9 initial values.
CO Writes its findings to unit LPT.
C
      COMMON /FWVALS/NVALS,COEFFS(9)
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
C SET 'FORSYTH & WELLS SCATTERING FACTOR TYPE LSQ':
      IREF=-1
C WRITE TITLE IN CASE USER HAS INVOKED WRONG SUB-LIBRARY:
      CALL CENTRE(LPT,3,'Least Squares Refinement',80)
      CALL CENTRE(LPT,0,'Forsyth and Wells Scattering Factors',80)
      IF (INREAD(9) .GT. 0) CALL INPUTI
      CALL IICD1
C
C READ L CARDS:   L VALS HAS 5, 7 OR 9 STARTING VALUES
      ILCD=ICDNO(12)
      IF (ILCD .LE. 0) CALL ERRMES(1,0,'No L cards')
C
      K=0
      NVLS=0
  1   CALL FINDCD('L','VALS',4,K,LCD)
      IF (LCD .GT. 0) THEN
        K=LCD
        NV=NVLS+1
        CALL RDNUMS(COEFFS(NV),7,9,NVLS,IER)
        NVLS=NVLS+NV-1
        GO TO 1
      ENDIF
C
      NVALS=NVLS
      WRITE (LPT,2010) NVALS,(COEFFS(I),I=1,NVALS)
2010  FORMAT (/1X,I4,' coefficients in approximation'/' Initial values',
     & 9F12.5)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE STATIS(MODE)
      SUBROUTINE STATIS(MODE)
C
C *** STATIS updated by PJB 22 Jun 92 ***
C
CX
CC 2B
CH Calculates means and other statistics for a set of measurements of a
CH single quantity.
CA MODE is an integer indicating which of the two sets of data held in
CA /REFS/ is to be used
CA  MODE=0 read and average both sets
CA  MODE=1 read and average the first block of data in REFS
CA  MODE=2 read and average the second block
CP INPUAR to fill in the data in /REFS/
CP The vector SUMS in COMMON /STATS/ is used to accumulate quantities
CA needed for statistical output. It should be cleared before the first call
CP to STATIS
CP   SUMS(1) holds the sum of the observations
CP   SUMS(2)       the sum of the standard deviations
CP   SUMS(3)       the sum of the means of repeated measurements
CP   SUMS(4)       the sum of the standard deviations of repeated measurements
CP   SUMS(5)       the sum for repeated observations of their weighted squares
CP                 minus the weighted square of the mean
CP   SUMS(6)       the number of repeated observations
CP   SUMS(7)       the sum of the means of equivalent observations
CP   SUMS(8)       the sum of the standard deviations of equivalent observations
CP   SUMS(9) as SUM(5) for equivalent observations
CP   SUMS(10) holds the number of equivalent observations
CP   SUMS(11)       the sum of all weighted observations
CP   SUMS(12)       the sum of the means for all observations
C
      COMMON /REFS/K(3,2),JJ(48,2),LL(48,2),R(500,2),SCALE(2),INC,II,NR,
     &FF(3,2),ITEMS
      COMMON /STATS/WRK1(5),WRK2(5),WRK3(5),AMEAN(2),DEV(2),SUMS(12),
     & X,DX,RAT,DRAT
C
      IF (MODE.NE.0) THEN
        MS=MODE
        ME=MS
      ELSE
        MS=1
        ME=2
      ENDIF
C
      DO 4 IS=MS,ME
      CALL WTMEAN(X,DX,0,WRK3)
      CALL WTMEAN(X,DX,0,WRK1)
      IR=1
      II=0
    2 L=LL(IR,IS)
      IF (L.EQ.3) GO TO 3
      IE=II+L
      IB=II+4
      CALL WTMEAN(X,DX,0,WRK2)
      DO 1 I=IB,IE,ITEMS
C WRK1 IS THE WORKING SPACE FOR STATISTICS OF ALL MEASUREMENTS TAKEN
C INDIVIDUALLY
      CALL WTMEAN(R(I,IS),R(I+1,IS),2,WRK1)
C WRK2 IS THE WORKING SPACE FOR STATISTICS OF REPEATED MEASUREMENTS
      CALL WTMEAN(R(I,IS),R(I+1,IS),2,WRK2)
      SUMS(1)=SUMS(1)+R(I,IS)
      SUMS(2)=SUMS(2)+R(I+1,IS)
    1 CONTINUE
      II=II+L
      CALL WTMEAN(R(II+1,IS),R(II+2,IS),-1,WRK2)
C WRK3 IS THE WORKING SPACE FOR STATISTICS OF EQUIVALENTS AFTER AVERAGING
C REPEATED MEASUREMENTS
      CALL WTMEAN(R(II+1,IS),R(II+2,IS),2,WRK3)
      IF (WRK2(4).GT.1.01) THEN
        SUMS(3)=SUMS(3)+R(II+1,IS)
        SUMS(4)=SUMS(4)+R(II+2,IS)
        SUMS(5)=SUMS(5)+WRK2(2)-R(II+1,IS)*WRK2(1)
        SUMS(6)=SUMS(6)+WRK2(4)
      ENDIF
        SUMS(11)=SUMS(11)+1.
        SUMS(12)=SUMS(12)+R(II+1,IS)
C  LEAVE SPACE FOR MEANS
      II=II+2
      IR=IR+1
      GO TO 2
C
C  FINISH ONE INDEPENDENT MEASUREMENT
    3 CALL WTMEAN(AMEAN(IS),DEV(IS),-1,WRK1)
      CALL WTMEAN(AMN,DEVN,-1,WRK3)
      IF (WRK1(4).GT.1.01) THEN
        SUMS(7)=SUMS(7)+AMEAN(IS)
        SUMS(8)=SUMS(8)+DEV(IS)
        SUMS(9)=SUMS(9)+WRK3(2)-AMN*WRK3(1)
        SUMS(10)=SUMS(10)+WRK3(4)
      ENDIF
    4 CONTINUE
C
      IF (MODE .EQ. 0) THEN
        RAT=AMEAN(2)/AMEAN(1)
        DRAT=SQRT((DEV(1)/AMEAN(1))**2+(DEV(2)/AMEAN(2))**2)
        CALL WTMEAN(RAT,DRAT,2,WRK1)
        CALL WTMEAN(X,DX,0,WRK2)
        DO 5 I=1,2
        CALL WTMEAN(AMEAN(I),DEV(I),2,WRK2)
    5   CONTINUE
        CALL WTMEAN(X,DX,-1,WRK2)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 12      SUBROUTINE SETPOL
      SUBROUTINE SETPOL
C
C *** SETPOL by PJB 17 Jan 85 ***
C
CX
CC 2A
CH Reads the polarisation and flipping efficiencies (for polarised neutrons).
CD Reads the "P" card giving the polarisation and flipping efficiency
CD both with their standard deviations. Stores the data in COMMON /POLDA/.
C
CI Reads the "P" card from the copy of the Crystal Data File on unit IO10.
CO Writes its findings to unit LPT
C
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POLDA/P,DP,E,DE,MODE,POLND(3)
C
      INREAD(16)=-IABS(INREAD(16))
      IF (ICDNO(16) .LE. 0) CALL ERRMES(1,0,
     & 'no polarisation data have been given')
C
      CALL CARDIN(IABS(INREAD(16)))
      CALL RDREAL(P,3,IPT,80,IER)
      CALL RDREAL(DP,IPT,IPT,80,IER)
      CALL RDREAL(E,IPT,IPT,80,IER)
      CALL RDREAL(DE,IPT,IPT,80,IER)
      CALL RDINTG(MODE,IPT,IPT,80,IER)
      WRITE (LPT,2000) P,DP,E,DE
2000  FORMAT (/' Polarisation of beam is',F10.5,' +or-',F10.5,
     & '.  Flipping efficiency is',F10.5,' +or-',F10.5)
      IMODE = MODE+1
      IF (IMODE .EQ. 3) THEN
        CALL MESS(LPT,1,
     &   'Depolarisation to be calculated as a volume effect')
        IF (INREAD(7) .GT. 0) CALL INPUTG
        CALL SETDC
        CALL SETGAU
      ENDIF
 100  RETURN
      END
C
C
C
C
C LEVEL 12      SUBROUTINE SETLP
      SUBROUTINE SETLP
C
C *** SETLP by JCM 8 Oct 85 ***
C
CX
CC 2A
CH Prepares to calculate (X-ray) Lorentz and polarisation corrections.
CP RECIP should have read the cell parameters.
CD Reads and checks the D cards necessary for LP corrections and puts
CD required data into COMMON /DGEOM/
CD Checks the presence of D WVLN and D TH2M (for type 10 IGEOM) cards.
CO Writes a title to unit LPT.
C
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(5,5),
     & NLAMB,ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /DREAD/IDREAD(8)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C
      CALL MESS(LPT,2,'Lp corrections')
      CALL SETDC
      IF (IDREAD(2) .LE. 0) THEN
        CALL ERRMES(2,1,'D WVLN card for LP')
        GO TO 100
      ENDIF
C
      IF (IGEOM .NE. 10) THEN
        IF (IDREAD(4) .LE. 0) CALL ERRMES(2,1,
     &  'D TH2M card for monochrometer 2theta')
      ENDIF
C
 100  RETURN
      END
C
C
C
C LEVEL 1      SUBROUTINE SERROR(M,N,F,X,W,S,H,SD)
      SUBROUTINE SERROR(M,N,F,X,W,S,H,SD)
C
C *** SERROR from PJB by R M Richardson 22 Sep 80 ***
C
CX
CC 6C
CH Called after VA05A to give the standard deviations of the parameters.
C
CP  Minimisation procedure VA05A from the Harwell library
CA  Input arguments:-
CA     M,N,F,X,W as defined in VA05A description
CA  Output arguments:-
CA     S=Sum of squares
CA     H=Fractional variance covariance matrix
CA     SD=Fractional standard error of parameter (provided that the
CA     covariance is negligible)
C
      DIMENSION F(M),X(N),W(1),H(1),SD(N)
      NWI=M*N
      S=0.0
      DO 2 J=1,M
    2 S=S+F(J)*F(J)
      DO 10 I=1,N
      DO 6 J=1,N
      HH=0.0
      K=NWI+I
      KK=NWI+J
      DO 5 L=1,M
      HH=HH+W(K)*W(KK)
      K=K+N
      KK=KK+N
    5 CONTINUE
      IJ=(J-1)*N+I
      H(IJ)=HH/(X(I)*X(J))
    6 CONTINUE
      I2=(I-1)*N+I
      SD(I)=SQRT(H(I2)*S/(M-N))
   10 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION MATCHF(F)
      FUNCTION MATCHF(F)
C
C *** MATCHF by JBF 19 Jun 87 ***
C
CX
CC 3C
CH Checks to see whether two sets of floating point reflection indices match.
CA On entry F(3,2) holds the two sets of indices, hkl1 hkl2.
CD The function is set to zero if the indices match
CD                     to 1 if hkl1 comes before hkl2 in the standard order
CD                          of reflection indices in which h varies fastest
CD                          then k then l
CD                     to 2 if hkl2 comes before hkl1
CN See MATCH for fixed point indices
C
      DIMENSION F(3,2)
C
      DO 1 I=3,1,-1
      IF (F(I,1)-F(I,2).GT.0.001) GO TO 2
      IF (F(I,1)-F(I,2).LT.-0.001) GO TO 3
    1 CONTINUE
C
C  INDICES MATCH
      MATCHF=0
      GO TO 100
C  POSITIVE DIFFERENCE STREAM 1 AHEAD
    2 MATCHF=2
      GO TO 100
C  NEGATIVE DIFFERENCE STREAM 2 AHEAD
    3 MATCHF=1
C
  100 RETURN
      END
C
C
C
C
C
C LEVEL 1      FUNCTION MATCH(K)
      FUNCTION MATCH(K)
C
C *** MATCH by PJB 1 Jul 86 ***
C
CX
CC 3C
CH Checks to see whether two sets of reflection indices match.
CA On entry K(3,2) holds the two sets of indices, hkl1 hkl2.
CD The function is set to zero if the indices match
CD                     to 1 if hkl1 comes before hkl2 in the standard order
CD                          of reflection indices in which h varies fastest
CD                          then k then l
CD                     to 2 if hkl2 comes before hkl1
CN See also MATCHF for floating indices
C
      DIMENSION K(3,2)
C
      DO 1 I=3,1,-1
      IF (K(I,1)-K(I,2)) 3,1,2
    1 CONTINUE
C
C  INDICES MATCH
      MATCH=0
      GO TO 100
C  POSITIVE DIFFERENCE STREAM 1 AHEAD
    2 MATCH=2
      GO TO 100
C  NEGATIVE DIFFERENCE STREAM 2 AHEAD
    3 MATCH=1
C
  100 RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE LSETUP(NW,LSPEC,LWORDS)
      SUBROUTINE LSETUP(NW,LSPEC,LWORDS)
C
C *** LSETUP updated by JCM 26 Jun 89 ***
C
CX
CC 6A
CH Sets up specific LSQ problem - copies the vocabulary to standard COMMON.
CA NW on entry is the number of words in this problem's vocabulary
CA LSPEC on entry is an array specifying the meaning of the words
CA       with 3 integers per word - family, genus, species
CA LWORDS on entry is an A4 array of words in this problem's vocabulary
CP The problem must have already been specified to the extent of:
CP    NFAM=number of families
CP    NGENS(I)=number of genera in family I
CP    NSPC(I)=number of species in each genus of family I
CD Packs the LSPEC integers to 1 word
CD Copies both arrays LSPEC and LWORDS into standard arrays IWDSPC  and
CD LSQWD in /WDSPEC/ and /WORDS/.
CD Sets up the packing of IFAM, IGEN, ISPC into one integer
C
      CHARACTER *4 LWORDS(NW)
      DIMENSION LSPEC(3,NW),LPAK(3)
      COMMON /LINKAG/NUMFV,NUMPAK,KKFV(200),KTYPFV(200),KSTFV(200),
     & KTIME(200),KUNPFV(5,30),NTIME,NUMCON,KKCON(500),AMCON(500),
     & KPTCON(201),KSTCON(200),KTPCON(200)
      COMMON /LSQPAK/KKPACK(10,3)
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /WDSPC/IWDNUM,IWDSPC(60)
      COMMON /WORDS/LSQWD(60)
      CHARACTER *4 LSQWD
C
C CHECK NFAM:
C%
C  20  CALL ERRCHK(1,NFAM,%FAMS%,0,'LSQ families of parameters')
  20  CALL ERRCHK(1,NFAM,6,0,'LSQ families of parameters')
C
      MGEN=0
      MSPC=0
      DO 1 I=1,NFAM
      IF (NGENS(I) .GT. MGEN) MGEN=NGENS(I)
      IF (NSPC(I) .GT. MSPC) MSPC=NSPC(I)
   1  CONTINUE
C
C SET UP PACKING OF IFAM,IGEN,ISPC:
      IWDNUM=NW
C CHECK ARRAY SIZES:
C%
C   4  CALL ERRCHK(1,NW,%WORD%,0,'words specifying LSQ problem')
   4  CALL ERRCHK(1,NW,60,0,'words specifying LSQ problem')
      IF (MGEN .LE. 0) CALL ERRMES(1,0,
     & 'maximum genera in any family is 0')
      IF (MSPC .LE. 0) CALL ERRMES(1,0,
     & 'maximum species in any genus is 0')
C
      LPAK(1)=NFAM
      LPAK(2)=MGEN
      LPAK(3)=MSPC
      CALL NPACK(N,LPAK,3,0,KKPACK)
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMM0N:
      DO 2 I=1,IWDNUM
      DO 7 J=1,3
   7  LPAK(J)=LSPEC(J,I)
      IF (LPAK(1) .LT. 0) IWDSPC(I)=LPAK(1)
      IF (LPAK(1) .GE. 0) CALL NPACK(IWDSPC(I),LPAK,3,1,KKPACK)
   2  LSQWD(I)=LWORDS(I)
C
C PREPARE FIX LIST AND CONSTRAINT LIST FOR CALLS OF ADDFIX, ADDCON
      NUMFV=0
      NUMPAK=0
      NUMCON=0
      KPTCON(1)=1
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE LSETSF(NW,LSPEC,LWORDS)
      SUBROUTINE LSETSF(NW,LSPEC,LWORDS)
C
C *** LSETSF by JCM 14 Jun 92 ***
C
CX
CC 6A
CH Sets up vocabulary for a specific LSQ problem involving structure factors.
CA NW on entry is the number of words in this problem's specific vocabulary
CA LSPEC on entry is an array specifying the meaning of the words
CA       with 3 integers per word - family, genus, species
CA LWORDS on entry is an A4 array of words in this problem's vocabulary
CP The problem must have already been specified to the extent of:
CP    NFAM=number of families
CP    NGENS(I)=number of genera in family I
CP    NSPC(I)=number of species in each genus of family I
CD Sets up the packing of IFAM, IGEN, ISPC into one integer
CD Packs the LSPEC integers to 1 word
CD First sets up the standard Structure Factor LSQ vocabulary for family 2
CD parameters (and cell from family 1).
CD Copies both arrays LSPEC and LWORDS into standard arrays IWDSPC  and
CD LSQWD in /WDSPEC/ and /WORDS/.
C
CN Because of its use of the standard family 2 names and numbers, it determines
CN these to be the same in every application (e.g. B11 is always species 4).
CN If this is not what is wanted, use LSETUP and give it the entire vocabulary.
C
      EXTERNAL F2PARS
      CHARACTER *4 LWORDS(NW)
      DIMENSION LSPEC(3,NW),LPAK(3)
      COMMON /F2NAMS/F2NAME(40)
      CHARACTER *4 F2NAME
      COMMON /F2NUMS/NF2NUM(3,40)
      COMMON /LINKAG/NUMFV,NUMPAK,KKFV(200),KTYPFV(200),KSTFV(200),
     & KTIME(200),KUNPFV(5,30),NTIME,NUMCON,KKCON(500),AMCON(500),
     & KPTCON(201),KSTCON(200),KTPCON(200)
      COMMON /LSQPAK/KKPACK(10,3)
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /WDSPC/IWDNUM,IWDSPC(60)
      COMMON /WORDS/LSQWD(60)
      CHARACTER *4 LSQWD
C
C CHECK NFAM:
C%
C  20  CALL ERRCHK(1,NFAM,%FAMS%,0,'LSQ families of parameters')
  20  CALL ERRCHK(1,NFAM,6,0,'LSQ families of parameters')
C
      MGEN=0
      MSPC=0
      DO 1 I=1,NFAM
      IF (NGENS(I) .GT. MGEN) MGEN=NGENS(I)
      IF (NSPC(I) .GT. MSPC) MSPC=NSPC(I)
   1  CONTINUE
      IF (MGEN .LE. 0) CALL ERRMES(1,0,
     & 'maximum genera in any family is 0')
      IF (MSPC .LE. 0) CALL ERRMES(1,0,
     & 'maximum species in any genus is 0')
C
C SET UP PACKING OF IFAM,IGEN,ISPC:
      LPAK(1)=NFAM
      LPAK(2)=MGEN
      LPAK(3)=MSPC
      CALL NPACK(N,LPAK,3,0,KKPACK)
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMM0N:
C
      IWDNUM=0
C FIRST PUT IN STANDARD FAMILY 2 PARAMETERS, AND CELL:
C%
C      CALL VOCAB(F2NAME,NF2NUM,%F2PR%)
      CALL VOCAB(F2NAME,NF2NUM,40)
C NOW THE SPECIAL ADDITIONAL VOCABULARY:
      CALL VOCAB(LWORDS,LSPEC,NW)
C
C PREPARE FIX LIST AND CONSTRAINT LIST FOR CALLS OF ADDFIX, ADDCON
      NUMFV=0
      NUMPAK=0
      NUMCON=0
      KPTCON(1)=1
 100  RETURN
      END
C
C
C
C LEVEL 7      SUBROUTINE LMPCAL(H)
      SUBROUTINE LMPCAL(H)
C
C *** LMPCAL updated by JCM 9 Feb 91 ***
C
CX
CC 7B
CH Calculates a structure factor and its derivatives using a multipole
CH description of the form factors.
CA On entry H is a 1x3 array containing h,k,l
CD On exit in /FCAL/
CD    FC is the complex structure factor
CD    FCMOD is its modulus
CD    COSAL is the cosine of its phase
CD    SINAL is the sine of its phase
CD    FCDERS is an array of derivatives of FCMOD wrt all family 2 (structure
CD           parameters and family 5 (multipole).  These are NOT multiplied
CD           or divided by anything else;  compare LMCALC
CD The above will all be zero if h,k,l gives a lattice absence;  note that
CD such would not be true of FCALC
C
      COMPLEX SUM1,TERM,HR,CRS,PSUM,PFACS(50)
      LOGICAL TESTOV,LATABS
      DIMENSION RH(3),H(3)
      COMMON /ANISO/ATF(6,50),KATF(6,50),IAPT(150),
     & IATYP(50),KOM1
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /FCAL/FC,FCMOD,COSAL,SINAL,FCDERS(300),DERIVT(300)
      COMPLEX FC,DERIVT
      COMMON /FORMDA/NFORMF(150),MODE(20),NT(20),F(40,20),
     & S(40,20),CMULT(20),KCMULT(150),NBAKF(20),
     & NUMFNM,KOM7
      COMMON /MPODA/NMPAT,NMPOL,MPATAB(20),MPNMTB(150),
     & NCLUMP,KCLUMP(100),MPTAB(21),POLAMP(200,6),KPOLMP(200),
     & NCMAT,CONMAT(600,2)
      COMMON /MPODAC/MPNAM(200)
      CHARACTER *4 MPNAM
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
C CLEAR ANSWERS IN CASE ABSENT:
C
C  FC COLLECTS THE CONVENTIONAL STRUCTURE FACTOR, COMPLEX:
      FC=CMPLX(0.,0.)
C CLEAR MODULUS AND ANGLES:
      FCMOD=0.
      COSAL=0.
      SINAL=0.
C
C STHL HOLDS SIN THETA/LAMBDA:
      STHL=VCTMOD(0.5,H,2)
      SSQRD=STHL*STHL
C
      L2=NVARF(2,1,1)
      L25=L2+NVARF(5,1,1)
      LO=LVFST1(2,1,1)
      IF (LO .EQ. -1) LO=LVFST1(5,1,1)
      LO5=LO+L2
C CLEAR DERIVATIVES:
      IF (L25.GT.0) THEN
        CALL GMZER(FCDERS,1,L25)
        CALL CGMZER(DERIVT,1,L25)
      ENDIF
C
C OUT IF ABSENT:
      IF (LATABS(H)) GO TO 100
C
C CYCLE OVER INDEPENDENT ATOMS:
      DO 1 IR=1,NATOM
C
C  SET MP TO THE MULTIPOLE ATOM AND NMP1, NMP2 TO SCAN ITS MULTIPOLES:
      MP=MPNMTB(IR)
      IF (MP.EQ.0) THEN
        NMP1=0
        NMP2=-1
      ELSE
        NMP1=MPTAB(MP)
        NMP2=MPTAB(MP+1)-1
      ENDIF
C
      SUM1=CMPLX(0.,0.)
C  CALCULATE RADIAL FORM-FACTORS
      CALL PFORMF(H,MP,PSUM,PFACS,0)
C
C INNER LOOP OVER SYMMETRY EQUIVALENTS:
      DO 3 IS=1,NOPC
      CALL ROTSYM(H,RH,IS,-1)
C CALCULATE NON-SPHERICAL FORM FACTORS
      CALL PFORMF(RH,MP,PSUM,PFACS,1)
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IS),H))
      ERS=ANITF(RH,IR)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      CRS=CEXP(CMPLX(0.,F1))*ERS
      TERM=CRS*PSUM
      ARS=REAL(TERM)
      BRS=AIMAG(TERM)
      SUM1=SUM1+TERM
C
C  NOW WE DO THE INNERMOST SUMS FOR THE DERIVATIVES OF MODFC WRT
C VARIABLES XYZ AND ALL BIJ.  WE USE THE
C COMPLEX VECTOR DERIVT FOR THE DERIVATIVES OF THE REAL & IMAGINARY PARTS
C OF THE COMPLEX FMC WRT EACH VARIABLE IN TURN.
C
      DO 7 I=1,3
      L=KX(I,IR)
      IF (L .NE. 0) DERIVT(L-LO)=RH(I)*CMPLX(-BRS,ARS) + DERIVT(L-LO)
   7  CONTINUE
C
C IF ANY ATF (NOT A LOOP, FOR SPEED):
      IA=IAPT(IR)
      IF (IA .NE. 0) THEN
        L=KATF(1,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(1)*TERM + DERIVT(L-LO)
        L=KATF(2,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(2)*RH(2)*TERM + DERIVT(L-LO)
        L=KATF(3,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(3)*RH(3)*TERM + DERIVT(L-LO)
        L=KATF(4,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(3)*RH(2)*TERM + DERIVT(L-LO)
        L=KATF(5,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(3)*TERM + DERIVT(L-LO)
        L=KATF(6,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(2)*TERM + DERIVT(L-LO)
      ENDIF
C
C DERIVATIVES OF FORM ("SCAT"):
      L=KCMULT(IR)
      IF (L.GT.0) DERIVT(L-LO)=CRS+DERIVT(L-LO)
C
C  DERIVATIVES OF MULTIPOLES:
      DO 21 I=NMP1,NMP2
      L=KPOLMP(I)
      IF (L.GT.0) DERIVT(L-LO5)=PFACS(I-NMP1+1)*CRS +DERIVT(L-LO5)
   21 CONTINUE
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
      IF (CENTRC) SUM1=SUM1+CONJG(SUM1)
      FAC=AMULT(IR)*EXP(-TF(IR)*SSQRD)
      HR=FAC*SITE(IR)
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS (BUT NOTE
C FORM ABSENT FROM USUAL EXPRESSION AS PSUM HAS BEEN MULTIPLIED IN EARLIER)
      FC=FC + HR*SUM1
C
C  NOW WE TIDY UP THE XYZ BIJ AND MP DERIVATIVES, ALLOWING FOR CENTRE:
      DO 8 I=1,3
      L=KX(I,IR)
      IF (L.GT.0) THEN
        DERIVT(L-LO)=TWOPI*HR*DERIVT(L-LO)
        IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
      ENDIF
      IF (IA .NE. 0) THEN
        L=KATF(I,IA)
        IF (L.GT.0) THEN
          DERIVT(L-LO)=-HR*DERIVT(L-LO)
          IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
        ENDIF
        L=KATF(I+3,IA)
        IF (L.GT.0) THEN
          DERIVT(L-LO)=-HR*2.*DERIVT(L-LO)
          IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
        ENDIF
      ENDIF
   8  CONTINUE
C
C FORM FACTOR (PARTLY FORMED WITHIN THE SYMMETRY LOOP):
      L=KCMULT(IR)
      IF (L.GT.0) THEN
        DERIVT(L-LO)=HR*DERIVT(L-LO)
        IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
      ENDIF
C SITE OCCUPATION FACTOR:
      L=KSITE(IR)
      IF (L.GT.0) DERIVT(L-LO)=FAC*SUM1
C ISOTROPIC TEMPERATURE FACTOR:
      L=KTF(IR)
      IF (L.GT.0) DERIVT(L-LO)=-SSQRD*HR*SUM1
C MULTIPOLE PARAMETERS (PARTLY FORMED WITHIN THE SYMMETRY LOOP):
      DO 24 I=NMP1,NMP2
      L=KPOLMP(I)
      IF (L.GT.0) THEN
        DERIVT(L-LO5)=HR*DERIVT(L-LO5)
        IF (CENTRC) DERIVT(L-LO5)=DERIVT(L-LO5)+CONJG(DERIVT(L-LO5))
      ENDIF
  24  CONTINUE
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C  TIDY FCALC AND COLLECT TRUE D(MODFC)/D(VARIABLE)
      A = REAL(FC)
      B = AIMAG(FC)
      FCMOD = SQRT(A*A+B*B)
      IF (.NOT. TESTOV(A,FCMOD)) THEN
        COSAL=A/FCMOD
        SINAL=B/FCMOD
      ENDIF
      DO 6 I=1,L25
C NO SUMMING - THESE ARE THE ACTUAL DERIVATIVES NOT DIVIDED BY ANYTHING, AS
C THEY ARE SUBJECT TO THE CHAIN RULE NEXT, NOT LOGARITHMIC DIFFERENTIATION:
      FCDERS(I)=REAL(DERIVT(I))*COSAL + AIMAG(DERIVT(I))*SINAL
   6  CONTINUE
 100  RETURN
      END
C

!
!*****************************************************************************
!
! Originally in 
!
