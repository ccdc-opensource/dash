!
!*****************************************************************************
!
! Originally in sa_subs.f90
!*==RANXGI.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!*****************************************************************************
!
      SUBROUTINE ranxgi

      COMMON /x2gran/ xs, ygran(200)

      xs = 0.05
      DO i = 1, 200
        xi = xs*float(i-1)
        ygran(i) = erf(xi)
      ENDDO

      END SUBROUTINE RANXGI
!*==ERF.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!*****************************************************************************
!
      FUNCTION erf(x)
!
      a = abs(x)
      t = 1./(1+0.5*a)
      erf = t*exp(-a*a-1.26551223+                                      &
     &      t*(1.00002368+t*(.37409196+t*(.09678418+                    &
     &      t*(-0.18628806+t*(.27886807+                                &
     &      t*(-1.13520398+t*(1.48851587+t*(-0.82215223+t*0.17087277))))&
     &      )))))
      erf = 1. - erf
      IF (x.LT.0) erf = -erf
!
      END FUNCTION ERF
!
!*****************************************************************************
!
! Originally in PF_Simplex.f90
!
!*==CHIQUAD.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
      FUNCTION CHIQUAD(N,P)
      PARAMETER (MPAR=50)
      REAL CHIQUAD, P(MPAR)
      PARAMETER (MVAL=50)
      COMMON /FUNVAL/ NVAL, XVAL(MVAL), YVAL(MVAL), ZVAL(MVAL),         &
     &                EVAL(MVAL)
!
      CHIQUAD = 0.
!
      DO I = 1, NVAL
        XI = XVAL(I)
        ZI = P(1)*XI*XI + P(2)*XI + P(3)
        CTEM = (ZI-YVAL(I))/EVAL(I)
        CHIQUAD = CHIQUAD + CTEM*CTEM
      ENDDO
!
      RETURN
      END FUNCTION CHIQUAD
!*==SIMOPT.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!***********************************************************************
!
      FUNCTION ROBCHI_CREF(DAT,SIG,FIT,NDAT)
C     ---------------------------------
C
      PARAMETER (MPAR=50)
      REAL ROBCHI_CREF,P(MPAR)
      PARAMETER (MVAL=50)
      COMMON /FUNVAL/ NVAL,XVAL(MVAL),YVAL(MVAL),ZVAL(MVAL),EVAL(MVAL)

      REAL DAT(*),SIG(*),FIT(*)
      DATA RT2,YJ0,YJ1 /0.7071067814,0.120782238,0.333333333/
      DATA ERSMAL,ERFBIG,SMALL /0.03,3.0,1.0E-20/
C
      CHI=0.0
      DO 10 I=1,NVAL
C.. Include the d*^2 calculated function on the following line
C        FITI= ...
! JvdS The following line generated a compiler error (Warning: Variable FITI is used before its value has been defined).
! JvdS I assume that FITI = FIT(I).
! JvdS FIT(*) is one of the arguments to this routine and is not used anywhere else,
! JvdS also, it is inside a loop over I.

! JvdS Note that due to this typo, ***NONE*** of the arguments passed to this routine was used.

! JvdS The good news is: this function isn't used anywhere anyway.

!JvdS the line of code was:
!        DIF=RT2*ABS(YVAL(I)-FITI)/EVAL(I)
! JvdS and now it is:
        DIF=RT2*ABS(YVAL(I)-FIT(I))/EVAL(I)
        IF (DIF.LT.ERSMAL) THEN
          CHI=CHI+YJ0-YJ1*DIF**2
        ELSEIF (DIF.GT.ERFBIG) THEN
          CHI=CHI-LOG(DIF)
        ELSE
          CHI=CHI-LOG(DIF)+LOG(ABS(1.0-ERFC_FUN(DIF))+SMALL)
        ENDIF
        IF (CHI.LE.-1.0E15) GOTO 1
  10  CONTINUE
   1  ROBCHI_CREF=-2.0*CHI
      END
C
C
      FUNCTION ERFC_FUN(X)
C     ----------------
C
      Z=ABS(X)
      T=1.0/(1.0+0.5*Z)
      ERFC_FUN=T*EXP(-Z*Z-1.26551223+T*(1.00002368+T*(0.37409196+
     *     T*(0.09678418+T*(-0.18628806+T*(0.27886807+T*(-1.13520398+
     *     T*(1.48851587+T*(-0.82215223+T*0.17087277)))))))))
      IF (X.LT.0) ERFC_FUN=2.0-ERFC_FUN
      END
C

!
!*****************************************************************************
!
! Originally in multipeak_fitter.f90
!
!*==PEAKFNVALUE.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
      FUNCTION PeakFnValue(IPFnV,XIn)
!
!.. Evaluate the parameters for the peak shape variables
!
      INCLUDE 'PARAMS.INC'
!
      INTEGER CurrentRange
      COMMON /PEAKFIT1/ XPF_Range(2,MAX_NPFR), IPF_Lo(MAX_NPFR),        &
     &                  IPF_Hi(MAX_NPFR), NumPeakFitRange, CurrentRange,&
     &                  IPF_Range(MAX_NPFR), NumInPFR(MAX_NPFR),        &
     &                  XPF_Pos(MAX_NPPR,MAX_NPFR),                     &
     &                  YPF_Pos(MAX_NPPR,MAX_NPFR), IPF_RPt(MAX_NPFR),  &
     &                  XPeakFit(MAX_FITPT), YPeakFit(MAX_FITPT)
!
      COMMON /PEAKFIT2/ PkFnVal(MPkDes,Max_NPFR),                       &
     &                  PkFnEsd(MPkDes,Max_NPFR),                       &
     &                  PkFnCal(MPkDes,Max_NPFR), PkFnVarVal(3,MPkDes), &
     &                  PkFnVarEsd(3,MPkDes),                           &
     &                  PkAreaVal(MAX_NPPR,MAX_NPFR),                   &
     &                  PkAreaEsd(MAX_NPPR,MAX_NPFR),                   &
     &                  PkPosVal(MAX_NPPR,MAX_NPFR),                    &
     &                  PkPosEsd(MAX_NPPR,MAX_NPFR), PkPosAv(MAX_NPFR)
!
      COMMON /WWPRPKFN/ ARGI, YNORM, PKFNSP(8,6,9,5), KPFNSP(8,6,9,5),  &
     &                  DERPFN(8,6), NPKFSP(8,9,5), TOLER(8,9,5),       &
     &                  NPKGEN(9,5), PKFNVA(8), DYNDVQ(8), DYNDKQ,      &
     &                  REFUSE, CYC1, NOPKRF, TOLR(2,5), NFFT, AKNOTS,  &
     &                  NBASF4(MPRPKF,2,9), L4END(9), L6ST, L6END
      LOGICAL REFUSE, CYC1, NOPKRF
!
!.. just do averages for the moment
      etem = -1.
      NTem = NumPeakFitRange - 1
      DO i = 1, NTem
        etem = max(etem,PkFnEsd(IPFnV,i))
      ENDDO
!
      IF (etem.EQ.0.) THEN
        DO i = 1, NTem
          PkFnEsd(IPFnV,i) = 10.
        ENDDO
      ENDIF
!
      atem = 0.
      btem = 0.
      DO i = 1, NTem
        wt = 1./PkFnEsd(IPFnV,i)**2
        atem = atem + wt*PkFnVal(IPFnV,i)
        btem = btem + wt
      ENDDO
!
      PeakFnValue = atem/btem
!
!
!      IF (I.eq.1) THEN
!.. Sigma
!      ELSE IF (I.eq.2) THEN
!.. Gamma
!      ELSE IF (I.eq.3) THEN
!.. HPSL
!      ELSE IF (I.eq.4) THEN
!.. HMSL
!      END IF
!
      END FUNCTION PEAKFNVALUE
!
!*****************************************************************************
!
! Originally in Wifd99.f90
!
!*==XXVRFILL.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
      SUBROUTINE XXVRFILL(X,A,N)
!     ------------------------
!
      REAL X(*)
!
      DO I = 1, N
        X(I) = A
      ENDDO
      END SUBROUTINE XXVRFILL
!*==XXVCOPY.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
      SUBROUTINE XXVCOPY(X,Y,N)
!     -----------------------
!
      REAL X(*), Y(*)
!
      DO I = 1, N
        Y(I) = X(I)
      ENDDO
      END SUBROUTINE XXVCOPY
!
!*****************************************************************************
!
! Originally in Eval.f90
!

!*==MAKEFRAC_PRT.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!----------<<<<<<<<<<<<<<<==========+++++++++==========>>>>>>>>>>>>>>>----------
!
      SUBROUTINE MAKEFRAC_PRT(CHROM,NGENES,IWRUN)
                                                 !,NATS,ICOM)
!     -------------------------------------------
!
      INCLUDE 'PARAMS.INC'
!
      REAL tiso, occ
      COMMON /zmcomo/ tiso(maxatm,maxfrg), occ(maxatm,maxfrg)
      DOUBLE PRECISION blen, alph, bet, f2cmat
      CHARACTER*3 asym
      INTEGER ioptb, iopta, ioptt, iz1, iz2, iz3
      INTEGER IWRUN
      COMMON /frgcom/ nfrag, lfrag(maxfrg)
      COMMON /zmcomi/ ntatm, natoms(maxfrg), ioptb(maxatm,maxfrg),      &
     &                iopta(maxatm,maxfrg), ioptt(maxatm,maxfrg),       &
     &                iz1(maxatm,maxfrg), iz2(maxatm,maxfrg),           &
     &                iz3(maxatm,maxfrg)
      COMMON /zmcomr/ blen(maxatm,maxfrg), alph(maxatm,maxfrg),         &
     &                bet(maxatm,maxfrg), f2cmat(3,3)
      COMMON /zmcomc/ asym(maxatm,maxfrg)
      COMMON /zmcomg/ icomflg(maxfrg)
!
      PARAMETER (mvar=100)
      COMMON /shadl / log_shad(mvar)
      COMMON /shadi / kshad(mvar)
!      DOUBLE PRECISION BLEN,ALPH,BET,F2CMAT
      REAL*8 CHROM(*)
      REAL*8 TRAN(3), ROTA(3,3), POS(3,MAXATM), CART(MAXATM,3)
      REAL*8 QUATER(4), QQSUM, QDEN, QUATT(MVAR)
      REAL*8 XC, YC, ZC, ZERO, ONE, XNORM, V1, V2, V3
!
!      COMMON  /ZMCOMI/ NATOMS,IOPTT(MAXATM),IZ1(MAXATM),IZ2(MAXATM),IZ3(MAXATM)
!      COMMON  /ZMCOMR/ BLEN(MAXATM),ALPH(MAXATM),BET(MAXATM),F2CMAT(3,3)
!      COMMON  /ZMCOMC/ ASYM(MAXATM)
      COMMON /POSNS / NATOM, X(3,150), KX(3,150), AMULT(150), TF(150),  &
     &                KTF(150), SITE(150), KSITE(150), ISGEN(3,150),    &
     &                SDX(3,150), SDTF(150), SDSITE(150), KOM17
      DATA ZERO, ONE/0.0D0, 1.0D0/
!
      KK = 0
      KATOM = 0
!.. Loop over all the fragments
      DO IFRG = 1, NFRAG
        NATS = NATOMS(IFRG)
!
        IF (IWRUN.GT.0) THEN
          IF (NATS.EQ.1) THEN
!
            WRITE (IWRUN,6009) IFRG
!
 6009       FORMAT ('  Fragment number ',I2,' is a single atom')
!
          ELSE
!
            WRITE (IWRUN,6010) IFRG, NATS
 6010       FORMAT ('  Fragment number ',I2,' contains ',I3,' atoms')
!
          ENDIF
        ENDIF
!
        KK1 = KK + 1
        KK2 = KK + 2
        KK3 = KK + 3
!       TRAN(1)=CHROM(KK1)*F2CMAT(1,1)
!       TRAN(2)=CHROM(KK1)*F2CMAT(1,2)+CHROM(KK2)*F2CMAT(2,2)
!       TRAN(3)=CHROM(KK1)*F2CMAT(1,3)+CHROM(KK2)*F2CMAT(2,3)+
!     *        CHROM(KK3)*F2CMAT(3,3)
        IF (LOG_SHAD(KK1)) THEN
          CKK1 = CHROM(KK1) + CHROM(KSHAD(KK1))
        ELSE
          CKK1 = CHROM(KK1)
        ENDIF
        IF (LOG_SHAD(KK2)) THEN
          CKK2 = CHROM(KK2) + CHROM(KSHAD(KK2))
        ELSE
          CKK2 = CHROM(KK2)
        ENDIF
        IF (LOG_SHAD(KK3)) THEN
          CKK3 = CHROM(KK3) + CHROM(KSHAD(KK3))
        ELSE
          CKK3 = CHROM(KK3)
        ENDIF
        TRAN(1) = CKK1*F2CMAT(1,1)
        TRAN(2) = CKK1*F2CMAT(1,2) + CKK2*F2CMAT(2,2)
        TRAN(3) = CKK1*F2CMAT(1,3) + CKK2*F2CMAT(2,3) + CKK3*F2CMAT(3,3)
!
        IF (IWRUN.GT.0) THEN
          WRITE (IWRUN,6020) CKK1, CKK2, CKK3
 6020     FORMAT ('   and is positioned at ',3F10.5)
        ENDIF
!
        KK = KK + 3
!.. If more than one atom then proceed
        IF (NATS.GT.1) THEN
          QQSUM = 0.
          DO JQ = 1, 4
            JQS = JQ + KK
            IF (LOG_SHAD(JQS)) THEN
              QUATT(JQS) = CHROM(JQS) + CHROM(KSHAD(JQS))
            ELSE
              QUATT(JQS) = CHROM(JQS)
            ENDIF
            QQSUM = QQSUM + QUATT(JQS)**2
          ENDDO
          QDEN = 1./SQRT(QQSUM)
          DO JQ = 1, 4
            JQS = JQ + KK
            QUATT(JQS) = QDEN*QUATT(JQS)
            QUATER(JQ) = QUATT(JQS)
          ENDDO
          CALL ROTMAK(QUATER,ROTA)
          KK = KK + 4
        ENDIF
!
        IF (NATS.GT.1) THEN
          IF (IWRUN.GT.0) THEN
            WRITE (IWRUN,6030) (SNGL(QUATER(I)),I=1,4)
 6030       FORMAT ('   with orientation 4-vector ',4F10.5)
          ENDIF
        ENDIF
!
        DO I = 1, NATS
          IF (IOPTB(I,IFRG).EQ.1) THEN
            KK = KK + 1
            IF (LOG_SHAD(KK)) THEN
              BLEN(I,IFRG) = CHROM(KSHAD(KK)) + CHROM(KK)
            ELSE
              BLEN(I,IFRG) = CHROM(KK)
            ENDIF
          ENDIF
          IF (IOPTA(I,IFRG).EQ.1) THEN
            KK = KK + 1
            IF (LOG_SHAD(KK)) THEN
              ALPH(I,IFRG) = CHROM(KSHAD(KK)) + CHROM(KK)
            ELSE
              ALPH(I,IFRG) = CHROM(KK)
            ENDIF
          ENDIF
          IF (IOPTT(I,IFRG).EQ.1) THEN
            KK = KK + 1
            IF (LOG_SHAD(KK)) THEN
              BET(I,IFRG) = CHROM(KSHAD(KK)) + CHROM(KK)
            ELSE
              BET(I,IFRG) = CHROM(KK)
            ENDIF
            IF (IWRUN.GT.0) THEN
              WRITE (IWRUN,6040) I, SNGL(BET(I,IFRG))
 6040         FORMAT ('   torsion number ',i2,' is ',f10.3)
            ENDIF
          ENDIF
        ENDDO
        CALL MAKEXYZ(NATS,BLEN(1,IFRG),ALPH(1,IFRG),BET(1,IFRG),        &
     &               IZ1(1,IFRG),IZ2(1,IFRG),IZ3(1,IFRG),CART(1,1),     &
     &               CART(1,2),CART(1,3))
!
        ICFRG = ICOMFLG(IFRG)
        IF (ICFRG.EQ.0) THEN
          XC = ZERO
          YC = ZERO
          ZC = ZERO
          DO I = 1, NATS
            XC = XC + CART(I,1)
            YC = YC + CART(I,2)
            ZC = ZC + CART(I,3)
          ENDDO
          XNORM = ONE/DFLOAT(NATS)
          XC = XC*XNORM
          YC = YC*XNORM
          ZC = ZC*XNORM
        ELSE
          XC = CART(ICFRG,1)
          YC = CART(ICFRG,2)
          ZC = CART(ICFRG,3)
        ENDIF
        DO I = 1, NATS
          CART(I,1) = CART(I,1) - XC
          CART(I,2) = CART(I,2) - YC
          CART(I,3) = CART(I,3) - ZC
        ENDDO
        DO I = 1, NATS
          POS(1,I) = CART(I,1)
          POS(2,I) = CART(I,2)
          POS(3,I) = CART(I,3)
        ENDDO
        CALL DO_ATOM_POS(TRAN,ROTA,POS,NATS)
        V1 = ONE/F2CMAT(1,1)
        V2 = ONE/F2CMAT(2,2)
        V3 = ONE/F2CMAT(3,3)
        DO I = 1, NATS
          POS(1,I) = POS(1,I)*V1
          POS(2,I) = (POS(2,I)-POS(1,I)*F2CMAT(1,2))*V2
          POS(3,I) = (POS(3,I)-POS(1,I)*F2CMAT(1,3)-POS(2,I)*F2CMAT(2,3)&
     &               )*V3
          KI = KATOM + I
          X(1,KI) = SNGL(POS(1,I))
          X(2,KI) = SNGL(POS(2,I))
          X(3,KI) = SNGL(POS(3,I))
        ENDDO
        KATOM = KATOM + NATS
      ENDDO
      END SUBROUTINE MAKEFRAC_PRT
!
!*****************************************************************************
!
! Originally in Mag.f90
!
!*==MAGVAR.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE MAGVAR(IG,IS,NV)
      SUBROUTINE MAGVAR(IG,IS,NV)
!
! *** MAGVAR updated by JCM 3 Jun 92 ***
!
!X
!C 17B
!H Records the initial fixing, or subsequent varying of magnetic parameters.
!A On entry IG is the genus of the parameter (which atom)
!A          IS is the species (13-16 PHIH, 17-20 ANGM, 21,22 SMOD)
!A          NV is 0 if the while lot of parameters are to be initially fixed
!A                the number of the variable, if it is to be varied.
!
      COMMON /MAGDAT/ NMAG, MAGAT(150), JMAGAT(10), NMFORM(10),         &
     &                ANGM(4,10), KANGM(4,10), SMOD(2,10), KSMOD(2,10), &
     &                PHIH(4,10), KPHIH(4,10), LPHI(4,10), NPHI(10),    &
     &                TPTAB(25,10), IPTAB(25,10), SPIND(3,3,2,10), KOM19
!
      IF (NV.EQ.0) THEN
! ENTRY 0 IS TO FIX ALL PARAMETERS:
!
! COUNT ALL MAGNETIC ATOMS:
        DO I = 1, NMAG
          DO J = 1, 2
            KSMOD(J,I) = 0
          ENDDO
          DO J = 1, 4
            KANGM(J,I) = 0
          ENDDO
          DO J = 1, 4
            KPHIH(J,I) = 0
          ENDDO
        ENDDO
      ELSE
! RECORD ONE VARIABLE:
        IM = MAGAT(IG)
        IF (IS.GE.13 .AND. IS.LE.16) KPHIH(IS-12,IM) = NV
        IF (IS.GE.17 .AND. IS.LE.20) KANGM(IS-16,IM) = NV
        IF (IS.GE.21 .AND. IS.LE.22) KSMOD(IS-20,IM) = NV
      ENDIF
!
      RETURN
      END SUBROUTINE MAGVAR
!*==SATGEN.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE SATGEN(HF,HS,MUL,NUM)
      SUBROUTINE SATGEN(HF,HS,MUL,NUM)
!
! *** SATGEN updated by PJB 22-Sept-93 ***
!
!X
!C 17B
!H Generates a set of magnetic satellite reflections.
!A On entry  HF contains the indices of the fundamental reflection
!A On exit   HS is an array of satellites of the fundamental which are
!A              inside the asymmetric unit
!A           MUL is an array containing the multiplicity of each satellite
!A           NUM is the number of distinct satellites found
!P SYMOP, SYMUNI and DOMAG must have set up the symmetry.
!
      DIMENSION HF(3), HS(3,1), MUL(1), H(3), HT(3), AK(3)
      COMMON /NSYM  / NOP, NCENT, NOPC, NLAT, NGEN, CENTRC, KOM13
      LOGICAL CENTRC
      COMMON /SATELL/ PROP(3), KPROP(3), KSTAB(24), NKSTAR, IPROP,      &
     &                FKSTAR, NKC, KCENT, INCOM, KOM21
      LOGICAL INCOM
!
      NUM = 0
      DO J = 1, NOPC
        IF (J.EQ.1) THEN
          CALL GMEQ(PROP,AK,3,1)
        ELSE
          NOP = IABS(KSTAB(J))
          IF (NOP.EQ.1) GOTO 1
          CALL ROTSYM(PROP,AK,2,1)
          IF (KSTAB(J).LT.0) CALL GMREV(AK,AK,3,1)
        ENDIF
        DO KC = 1, 2
!  ADD STAR VECTOR TO FUNDAMENTAL
          CALL GMADD(HF,AK,H,3,1)
!  TAKE CARE OF SPECIAL CASES WHEN PROP IS HALF A RLV
          IF (KC.EQ.1 .AND. KCENT.EQ.1) THEN
            CALL GMADD(H,AK,HT,3,1)
            M = MULBOX(HT)
            IF (M.NE.0) GOTO 2
          ENDIF
          M = MULBOX(H)
          IF (M.EQ.0) GOTO 2
          NUM = NUM + 1
          MUL(NUM) = M
          CALL GMEQ(H,HS(1,NUM),3,1)
    2     CALL GMREV(AK,AK,3,1)
        ENDDO
    1 ENDDO
!
      RETURN
      END SUBROUTINE SATGEN
!*==READRT.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE READRT(IAT,IEND)
      SUBROUTINE READRT(IAT,IEND)
!
! *** READRT corrected by PJB C17 17 Sept 93 ***
!
!X
!C 17A
!H Reads whatever follows on a "W atom-name ROTN" card.
!
!A On entry IAT indicates which is the atom (or the total number,  if IEND
!A              is -ve.
!A          IEND points in ICARD to the next character to read
!A               unless IEND is -ve, when it requests initialisation
!A          IEND=-1 initialises the first IAT rotations
!A          IEND=-2 initialises the IATth rotation to be a unit matrix
!A          IEND=0 prints what has been read.
!
!O If IAT=0 writes its finding on unit LPT.
!
      CHARACTER*4 WORD, JAX(3)*1, RCAX(3)*2
      COMMON /ATNAM / ATNAME(150), ATNA(150,9)
      CHARACTER*4 ATNA, ATNAME
      COMMON /CELPAR/ CELL(3,3,2), V(2), ORTH(3,3,2), CPARS(6,2),       &
     &                KCPARS(6), CELESD(6,6,2), CELLSD(6,6), KOM4
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /QROT  / ROT(3,3,10)
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      COMMON /SCRAT / MODE(20), IROT(20), TEMP(3,3), MFUN(10,20),       &
     &                LENG(3)
      DATA JAX, RCAX/'X', 'Y', 'Z', 'a*', 'b*', 'c*'/
!
      IF (IEND) 30, 20, 2
!
!   INITIALISE COUNT OVER AXES
   30 IF (IEND.EQ.-1) THEN
        CALL ERRCHK(1,IAT,10,0,' rotations in READRT')
        CALL JGMZER(IROT,1,IAT)
      ELSE
        CALL GMUNI(ROT(1,1,IAT),3)
        IROT(IAT) = 7
      ENDIF
      GOTO 100
!
    2 IPT = IEND
      CALL RDWORD(WORD,LWORD,IPT,IPT1,80,0,IER)
      IF (IER.NE.0) GOTO 50
!
!  WHICH AXIS IS IT?
      IF (LWORD.GT.1) GOTO 51
      I = NCFIND(WORD(1:1),JAX,3)
      DO J = 1, 3
        IPT = IPT1
        CALL RDREAL(ROT(J,I,IAT),IPT,IPT1,80,IER)
        IF (IER.NE.0) GOTO 50
      ENDDO
      IROT(IAT) = IROT(IAT) + 2**(I-1)
      GOTO 100
!
   20 DO J = 1, 3
        IF (MOD(IROT(IAT),2).NE.1) GOTO 52
        CALL GMEQ(ROT(1,J,IAT),TEMP(1,J),1,3)
        IROT(IAT) = IROT(IAT)/2
      ENDDO
      CALL GMPRD(ORTH(1,1,2),TEMP,ROT(1,1,IAT),3,3,3)
!  *** PJB CHANGED TO TRANSPOSE 4 Aug 88
      CALL TRANSQ(ROT(1,1,IAT),3)
      WRITE (LPT,2000) (JAX(J),(TEMP(K,J),K=1,3),J=1,3)
 2000 FORMAT (' Direction cosines of quantum axes relative to ',        &
     &        'orthogonal crystallographic axes are:'/3(3X,A1,1X,       &
     &        3F10.5/))
      WRITE (LPT,2001) (JAX(J),J=1,3),                                  &
     &                 (RCAX(J),(ROT(K,J,IAT),K=1,3),J=1,3)
 2001 FORMAT (' Components of reciprocal lattice vectors on ',          &
     &        'quantum axes are:'/5X,3(8X,A1,1X)/3(2X,A2,1X,3F10.5/))
      GOTO 100
!
!  REPORT ERRORS
   50 CALL ERRMES(1,1,'Reading rotation matrix')
      GOTO 100
!
   51 CALL ERRMES(1,1,'Axial direction'//WORD//' for '//ATNAME(IAT)     &
     &            //' atom not recognised')
      GOTO 100
!
   52 CALL ERRMES(1,1,'Direction of quantum axis '//JAX(J)              &
     &            //' not given')
      GOTO 100
!
  100 RETURN
      END SUBROUTINE READRT
*==LOGMAG.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
!
!
!
! LEVEL 3      SUBROUTINE LOGMAG
      SUBROUTINE LOGMAG
!
! *** LOGMAG by JCM 27 Aug 91 ***
!
!X
!C 17A
!H Sets mnemonic logicals from the type of magnetic structure.
!A On entry MTYP gives the type of structure, usually read from a Q STYP
!A               card.
!D Complains and stops if MTYP is not between 1 and 5.
!D Sets only one of FERO, FERA, HELI, AMOD and ANTI to be TRUE and the rest
!D to be FALSE.  Sets MODUL to be TRUE if either HELI or AMOD.
!
      COMMON /SYMMAG/ MTSYM(25), MSTAB(24), NMSYM, NFAC, OTRSYM(3,3,25),&
     &                MTYP, NDOM, FERO, FERA, HELI, AMOD, ANTI, MODUL,  &
     &                KOM20
      LOGICAL FERO, FERA, HELI, AMOD, ANTI, MODUL
!
      IF (MTYP.LT.1 .OR. MTYP.GT.5)                                     &
     &     CALL ERRMES(1,0,'Type of magnetic structure not recognised')
      FERO = MTYP.EQ.1
      FERA = MTYP.EQ.2
      HELI = MTYP.EQ.3
      AMOD = MTYP.EQ.4
      ANTI = MTYP.EQ.5
      MODUL = HELI .OR. AMOD
      RETURN
      END SUBROUTINE LOGMAG
!*==INPUTQ.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE INPUTQ(ID,NTYP,IAT,IPT,IER)
      SUBROUTINE INPUTQ(ID,NTYP,IAT,IPT,IER)
!
! *** INPUTQ updated by PJB Aug 91 ***
!
!X
!C 17A
!H Reads individual "Q" cards
!A On entry ID is the position in the CDF of the "Q" card, or 0 (= card present)
!A On exit NTYP = a number indicating what kind of "Q" card was read:
!A      NTYP=1 for STYP (magnetic structure type)
!A      NTYP=2 for PROP the propagation vector
!A      NTYP=3 for MSYM a magnetic symmetry operator
!A      NTYP=4 for NSYM a non-symmetric rotation
!A      NTYP=5 for FORM (a form factor label should be read first).
!A      NTYP=6 for MU   (Magnetic moment: an atom label should be read first).
!A      NTYP=7 for SDIR (Spin directions: an atom label should be read first).
!A      NTYP=8 for PSI  (Relative phases of helices: an atom label should be
!A                       read first).
!A On exit IAT = number corresponding to the atom or form factor label,
!A               if one was read.
!A On exit IPT = the next column on the card to be interpreted.
!A On exit IER = the error indicator, = 0 for no error.
!
      CHARACTER*4 WORD, WORD1, QWORD(8)
      COMMON /FONAM / FONA(20,9), FONAME(20)
      CHARACTER*4 FONAME, FONA
      COMMON /FORMDA/ NFORMF(150), MODE(20), NT(20), F(40,20), S(40,20),&
     &                CMULT(20), KCMULT(150), NBAKF(20), NUMFNM, KOM7
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      DATA NWRD/8/
      DATA QWORD/'STYP', 'PROP', 'MSYM', 'NSYM', 'FORM', 'MU', 'SDIR',  &
     &     'PSI'/
!
! SET NO ERROR
      IER = 0
!
! IF ID=0, EXPECT CARD ALREADY PRESENT:
      IF (ID.NE.0) CALL CARDIN(ID)
      CALL RDWORD(WORD,LWORD,3,IPT,80,0,IE)
      IF (IE.EQ.0) THEN
        IAT = IATOM(WORD)
        IF (IAT.EQ.0) THEN
          NTYP = NCFIND(WORD,QWORD,NWRD)
          IF (NTYP.NE.0) GOTO 100
        ENDIF
        IPT1 = IPT
        CALL RDWORD(WORD1,LWORD,IPT1,IPT,80,0,IE)
        NTYP = NCFIND(WORD1,QWORD,NWRD)
        IF (NTYP.EQ.0) THEN
          CALL ERRCH2(WORD,-2,'Word on "Q" card',                       &
     &                'is neither an atom name nor an allowed Q word')
          IER = IER + 1
        ELSE
          IF (NTYP.EQ.5) IAT = LMATCH(WORD,FONAME,NUMFNM,20)
          GOTO 100
        ENDIF
      ELSE
        CALL ERRCH2(ICARD(3:6),-2,'cannot recogise word','on "Q" card')
        IER = IER + 1
      ENDIF
!
  100 RETURN
      END SUBROUTINE INPUTQ
!*==VARSMG.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 13      SUBROUTINE VARSMG
      SUBROUTINE VARSMG
!
! *** VARSMG by JCM 16 Nov 90 ***
!
!X
!C 7A
!H Records variable pointers for all variables in magnetic structure-factor LSQ.
!P VARMAK has set up the variables
!
!D First clears all possible parameters for this application to be fixed.
!D Then scans variables as made by VARMAK.  Identifies each variable as a
!D type of parameter, and calls individual routines to record the information.
!
      COMMON /DERVAR/ DERIVV(500), LVARV
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /POINTS/ LVRBS(500), LVRPR(500), LBSVR(400), LRDVR(300)
      COMMON /REFINE/ IREF, NCYC, NCYC1, LASTCY, ICYC, MODERR(5),       &
     &                MODEOB(5), IPRNT(20), MAXCOR, IONLY(9), SIMUL,    &
     &                MAG, MPL, FIXED, DONE, CONV
      LOGICAL SIMUL, MAG, MPL, FIXED, DONE
      EQUIVALENCE (MODER,MODERR(1))
!
      IF (SIMUL) GOTO 100
! SET ALL VARIABLES FIXED:
      CALL LTFAC9
      CALL CELVAR(0,0)
      CALL EXTIN9
      CALL LSCAL9
      CALL F2VAR9
      CALL MAGVAR(0,0,0)
!
! SCAN ALL VARIABLES:
      DO I = 1, LVARV
        KPACK = LVRPR(I)
        CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
!
! BRANCH ON FAMILY:
        GOTO (11,12), IFAM
!
   11   GOTO (21,22), IGEN
!
! FAMILY 1, GENUS 1 - MISCELLANEOUS SPECIES (TFAC,A*,B* . . F*,DOMR,MOSC):
   21   GOTO (31,32,32,32,32,32,32,33,33), ISPC
!
! TFAC:
   31   CALL LTFAC8(I)
        GOTO 1
!
! DOMR OR MOSC (EXTINCTION CORRECTION PARAMETERS)
   33   CALL EXTIN8(ISPC-7,I)
        GOTO 1
!
! CELL PARAMETERS:
   32   CALL CELVAR(ISPC-1,I)
        GOTO 1
!
! FAMILY 1, GENUS 2 - IN SF THIS IS 'SCAL':
   22   CALL LSCAL8(ISPC,I)
        GOTO 1
!
! FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
   12   IF (ISPC.LE.12) CALL F2VAR8(IGEN,ISPC,I)
        IF (ISPC.GT.12) CALL MAGVAR(IGEN,ISPC,I)
    1 ENDDO
  100 RETURN
      END SUBROUTINE VARSMG
!*==SATFND.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 5      SUBROUTINE SATFND(H,HS,NR)
      SUBROUTINE SATFND(H,HS,NR)
!
! *** SATFND updated by PJB 23 Nov 90 ***
!
!X
!C 17B
!H Finds the indices HS of the satellite equivalent to H, offset by the
!H propagation vector PROP from a reciprocal lattice point.
!A On entry H is a 1x3 vector in reciprocal space.
!A On exit NR is the number of the symmetry operator which takes H
!A            into HS
!A         NR is set to zero if an allowed satellite was not found.
!A         HS is a 1x3 vector holding the satellite equivalent vector.
!
!P SYMOP and DOMAG must have set up the symmetry.
!
      DIMENSION H(3), HS(3)
      LOGICAL MAGABS
      COMMON /NSYM  / NOP, NCENT, NOPC, NLAT, NGEN, CENTRC, KOM13
      LOGICAL CENTRC
      COMMON /SATELL/ PROP(3), KPROP(3), KSTAB(24), NKSTAR, IPROP,      &
     &                FKSTAR, NKC, KCENT, INCOM, KOM21
      LOGICAL INCOM
!
      J = 1
      DO I = 1, NOPC
!
! KSTAB(1) MAY NOT ACTUALLY CONTAIN 1:
        IF (I.NE.1 .AND. KSTAB(I).NE.J) GOTO 1
        CALL ROTSYM(H,HS,I,-2)
        IF (.NOT.MAGABS(HS,IK)) GOTO 101
        J = J + 1
        IF (J.GT.NKSTAR) GOTO 2
    1 ENDDO
!
    2 I = 0
! IF NOTHING FOUND PUT H INTO HS
      CALL GMEQ(H,HS,1,3)
  101 NR = I
      RETURN
      END SUBROUTINE SATFND
!
!*****************************************************************************
!
! Originally in Pr.f90
!
!*==THETA2.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 6      SUBROUTINE THETA2(N)
      SUBROUTINE THETA2(N)
!
! *** THETA2 updated by JCM 10 Mar 92 ***
!
!X
!C 6A
!H Multiple entry routine to deal with 2theta in CELLSQ
!
!A On entry MODE says which action is required.
!A MODE=1: reads 2theta from an L THE2 card (or set a default of
!A         180 degrees, and set up related constants.
!A MODE=2: dummy entry
!A MODE=3: apply a shift to 2theta, and adjust the constants.
!A MODE=4: write out new L THE2 card.
!
!A ENTRY THET28 sets the parameter as a variable
!A ENTRY THET29 sets the parameter as initially fixed.
!
!D The various entries are used in the main program CELLSQ, which
!D refines cell parameters and 2theta.  Entry 2 would normally form
!D 2theta as a calculated function, but this is done in the main program.
!
!I Reads and interprets L THE2 card from copy of the Crystal Data File
!I on unit IO10.
!O Writes out new L THE2 to unit NEWIN.
!
      LOGICAL ONCARD
      COMMON /BRAGG / STHMXX(5), STHL, SINTH, COSTH, SSQRD, TWSNTH(5),  &
     &                DSTAR2, TWOTHD(5), DIFANG(6)
      EQUIVALENCE (STHLMX,STHMXX(1))
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /PRPKCN/ ARGK, PKCNSP(6,9,5), KPCNSP(6,9,5), DTDPCN(6),    &
     &                DTDWL, NPKCSP(9,5), ARGMIN(5), ARGMAX(5),         &
     &                ARGSTP(5), PCON
      COMMON /SOURCE/ NSOURC, JSOURC, KSOURC, NDASOU(5), METHOD(9),     &
     &                NPFSOU(9,5), NSOBS(5), SCALES(5), KSCALS(5),      &
     &                NPCSOU(9,5)
      COMMON /THET2 / THE2, KTHE2, THCON1
!
      GOTO (1,100,3,4), N
!
! FIND L THE2 CARD IF THERE IS ONE, AND READ 2THETA FROM IT:
    1 THE2 = 180.
      IF (ONCARD('L','THE2',THE2)) THEN
        WRITE (LPT,2001) THE2
 2001   FORMAT (/' 2 theta =',F10.3,' degrees')
      ELSE
        CALL MESS(LPT,1,'No L THE2 card - 2 theta = 180 degrees')
      ENDIF
! SET UP THETA-RELATED QUANTITIES:
      GOTO 101
!
! APPLY SHIFT:
    3 CALL ADJUST(THE2)
      GOTO 101
!
! NEW L THE2 CARD:
    4 WRITE (NEWIN,2000) THE2
 2000 FORMAT ('L THE2',F10.2)
      GOTO 100
!
! SET THE2 TO BE A VARIABLE:
      ENTRY THET28(NV)
      KTHET2 = NV
      GOTO 100
!
! SET THET2 TO BE INITIALLY FIXED:
      ENTRY THET29
      KTHET2 = 0
      GOTO 100
!
  101 THRAD = RADIAN(THE2/2.)
      TWSNTH(JSOURC) = 2.*SIN(THRAD)
      THCON1 = RADIAN(COS(THRAD))
  100 RETURN
      END SUBROUTINE THETA2
!*==OUTTIC.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 11       SUBROUTINE OUTTIC
      SUBROUTINE OUTTIC
!
! *** OUTTIC by JBF 17 June 93. ***
!
!H To write an ascii file of TIC marks for GENIE plots
!D Reads an I card for TICS followed by integer:
!D a non-zero integer requests TICs as amplitudes proportional
!D to calculated intensity in powder pattern. Default 0, amplitudes are +/- 10.
!D +ve for nuclear, -ve for magnetic.
!
      LOGICAL ONCARD
      CHARACTER*4 INEED
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /PHASE / NPHASE, IPHASE, JPHASE, KPHASE, NPHUNI(9),        &
     &                SCALEP(9), KSCALP(9), PHMAG(9)
      LOGICAL PHMAG
! JCC Moved to an include file
      INCLUDE 'REFLNS.INC'
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      COMMON /SOURCE/ NSOURC, JSOURC, KSOURC, NDASOU(5), METHOD(9),     &
     &                NPFSOU(9,5), NSOBS(5), SCALES(5), KSCALS(5),      &
     &                NPCSOU(9,5)
      DATA INEED/'TICS'/
!
      MESSAG = 'TIC list'
      NAMFIL = '.TIC'
      CALL OPNFIL(ITC,112)
      ITIC = 0
! INTERPRET I CARD:
      IF (.NOT.ONCARD('I',INEED,A)) GOTO 2
! TICS RECOGNISED
      IF (NINT(A).NE.0) ITIC = 1
    2 ESD = 0.1
      DO KNOW = 1, MAXKK(1)
        IF (ITIC.EQ.0) THEN
          ATIC = 10.
          IF (AIOBS(KNOW).LT.0.) ATIC = -10.
          WRITE (ITC,1000) AICALC(KNOW), ATIC, ESD
        ELSE
          WRITE (ITC,1000) AICALC(KNOW), AIOBS(KNOW), ESD
        ENDIF
      ENDDO
      RETURN
 1000 FORMAT (F10.2,2(F12.1))
      END SUBROUTINE OUTTIC
!*==SETTIC.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 11       SUBROUTINE SETTIC(PCXX)
      SUBROUTINE SETTIC(PCXX)
!
! *** SETTIC by JCM 8 Aug 91 ***
!
!H Prepare to write GENIE files by reading L cards and generating reflection
      EXTERNAL PCXX, DUMMY
      COMMON /BRAGG / STHMXX(5), STHL, SINTH, COSTH, SSQRD, TWSNTH(5),  &
     &                DSTAR2, TWOTHD(5), DIFANG(6)
      EQUIVALENCE (STHLMX,STHMXX(1))
      COMMON /DGEOM / IGEOM, UM(9), NLR, ANGLIN(3), ALAMBD(5,5), NLAMB, &
     &                ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /LREAD / ILREA(22,5), KOM18
      DIMENSION ILREAD(22)
      EQUIVALENCE (ILREAD(1),ILREA(1,1))
      COMMON /PHASE / NPHASE, IPHASE, JPHASE, KPHASE, NPHUNI(9),        &
     &                SCALEP(9), KSCALP(9), PHMAG(9)
      LOGICAL PHMAG
      COMMON /PRPKCN/ ARGK, PKCNSP(6,9,5), KPCNSP(6,9,5), DTDPCN(6),    &
     &                DTDWL, NPKCSP(9,5), ARGMIN(5), ARGMAX(5),         &
     &                ARGSTP(5), PCON
      COMMON /PRZERO/ ZEROSP(6,9,5), KZROSP(6,9,5), DKDZER(6),          &
     &                NZERSP(9,5)
      COMMON /REFIPR/ RIET, CAIL, SAPS, APES, RAPS, TOF, CN, LX, SR, ED,&
     &                PRECYC, TIC
      LOGICAL RIET, CAIL, SAPS, APES, RAPS, TOF, CN, LX, SR, ED, PRECYC,&
     &        TIC
      COMMON /SOURCE/ NSOURC, JSOURC, KSOURC, NDASOU(5), METHOD(9),     &
     &                NPFSOU(9,5), NSOBS(5), SCALES(5), KSCALS(5),      &
     &                NPCSOU(9,5)
!
! READ RELEVANT L CARDS:
      CALL INPLPR(PCXX,DUMMY)
!
! DEAL WITH THE CARDS WHICH ARE DIFFERENT ACCORDING TO TYPE OF DIFFRACTION:
!
! TF:
! NEED L THE2 CARD GIVING 2 THETA DEGREES:
      IF (TOF) THEN
        IF (ILREAD(18).EQ.0)                                            &
     &       CALL ERRMES(2,1,'L THE2 card giving counter angle')
! FOR TF MUST HAVE L PKCN CARD:
        IF (ILREAD(7).EQ.0) CALL ERRMES(2,1,                            &
     &                                  'L PKCN card giving peak centre'&
     &                                  )
      ELSE
!
! CN AND/OR LX - NEED L WVLN CARD:
        IF (ILREAD(13).EQ.0) THEN
          IF (CN) THEN
            NLAMB = 1
            ALAMBD(1,KSOURC) = 1.900
          ELSEIF (SR) THEN
            NLAMB = 1
            ALAMBD(1,KSOURC) = 0.85000
          ELSEIF (LX) THEN
            NLAMB = 2
            ALAMBD(1,KSOURC) = 1.544390
            ALAMBD(2,KSOURC) = 1.540562
          ENDIF
          WRITE (LPT,2002) NLAMB, (ALAMBD(I,KSOURC),I=1,NLAMB)
 2002     FORMAT (' ',I3,' Wavelength(s): ',5(1X,F9.6))
        ENDIF
        PKCNSP(1,JPHASE,JSOURC) = 96.0505
        TWOTHD(JSOURC) = RADIAN(168.329)
      ENDIF
!
!*??NOT USED ELSEWHERE:
! IF NO L ZERO CARD THEN ZEROPT=0:
      IF (ILREAD(8).EQ.0) ZEROSP(1,JPHASE,JSOURC) = 0.
!
      CALL PCXX(6)
      WRITE (LPT,2018) STHLMX
 2018 FORMAT (/' Maximum sin theta for generation of indices is',F10.4)
!
! GENERATE REFLECTIONS:
      CALL INRFPR(PCXX,DUMMY)
!
      RETURN
      END SUBROUTINE SETTIC
!*==WRDATA.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE WRDATA(EOD,IUNIT,IVAL,N)
      SUBROUTINE WRDATA(EOD,IUNIT,IVAL,N)
      PARAMETER (NBLCKS=128)
!  Routine to write out fixed length blocks(NBLCKS integers) to a file
!  It accepts an array of values and splits it into blocks. Whenever part
!  of a block is left over it is stored for blocking at a later run of
!  the routine. To clear  out the block at the end of a file a flag,EOD should
!  be set to .TRUE.
!
!  input parameters:
!      EOD      logical, .TRUE. if this is the last record, otherwise .FALSE.
!      IUNIT      unit number to write to
!      IVAL      array containing data
!      N      number of values to be written
      LOGICAL EOD
      DIMENSION IVAL(1), IWORK(NBLCKS)
! ensure IWORK cleared to start with and point to start of IWORK
! THIS SHOULD REALLY BE COMMON:
      DATA IWORK/NBLCKS*0/, INEXT/1/
!
!
!  calculate total number of values to be written
      ILEFT = N
      ITOT = ILEFT + INEXT - 1
!
!  if at least 1 block then write out as many whole blocks as possible
      IF (ITOT.GT.NBLCKS) THEN
!  First block is probably part IWORK, part IVAL
        IPART = NBLCKS + 1 - INEXT
        WRITE (IUNIT) (IWORK(I),I=1,INEXT-1), (IVAL(I),I=1,IPART)
        ITOT = ITOT - NBLCKS
!  next blocks are all wholly IVAL
        NBLOCK = ITOT/NBLCKS
        IF (NBLOCK.GT.0) THEN
          DO I = 1, NBLOCK
            WRITE (IUNIT) (IVAL(IPART+(I-1)*NBLCKS+J),J=1,NBLCKS)
          ENDDO
        ENDIF
!  then at the end there are probably a few values left over
        ILEFT = ITOT - NBLOCK*NBLCKS
        INEXT = 1
      ENDIF
!  transfer the left overs into the temporary work space and save for next time
      IF (ILEFT.GT.0) THEN
        DO I = 1, ILEFT
          IWORK(I+INEXT-1) = IVAL(N-ILEFT+I)
        ENDDO
        INEXT = INEXT + ILEFT
      ENDIF
!  However if I've been told that this is the last block of this file
!  clear it out totally, providing there is something to clear out!
      IF (EOD .AND. INEXT.GT.1) THEN
        WRITE (IUNIT) (IWORK(I),I=1,INEXT-1)
        INEXT = 1
      ENDIF
      RETURN
      END SUBROUTINE WRDATA
!*==WRSTRT.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 2      SUBROUTINE WRSTRT(N,NS)
      SUBROUTINE WRSTRT(N,NS)
!
! *** WRSTRT
!
!H Write start of Genie file
!A On entry N= no. of X, Y, or E values
!A          NS= number of spectra (1 for TIC, 3 for PICTIC)
!
      COMMON /WORKG / IWORK(256)
      REAL RWORK(256)
      CHARACTER*1024 CWORK
! NON-STANDARD FORTRAN 77:
!VMS
      EQUIVALENCE (IWORK,CWORK)
      EQUIVALENCE (IWORK,RWORK)
!
!
      CWORK(1:80) = ' '
! VERSION:
      IWORK(21) = 1
! ADDRESS OF HISTORY SECTION (NONE):
      IWORK(22) = 42
! ADDRESS OF DETECTOR SECTION:
      IWORK(23) = 0
! ADDRESS OF X VALUES SECTION:
      IWORK(24) = 0
! ADDRESS OF SPECTRA SECTION
      IWORK(25) = 92
! NO OF SPECTRA (TIC MARKS)
      IWORK(26) = NS
! LENGTH OF P BLOCK (GENIE HDR1+HDR2)
      IWORK(27) = 155 + 30
! LENGTH OF X BLOCK
      IWORK(28) = N
! LENGTH OF Y BLOCK
      IWORK(29) = N
! LENGTH OF E BLOCK
      IWORK(30) = N
! IWORK(31-41) LENGTHS OF U1-U11 BLOCKS
      DO I = 31, 41
        IWORK(I) = 0
      ENDDO
! COMMON HISTORY BLANK SO FAR:
      CWORK(165:364) = ' '
!
!      WRITE THESE PARAMETERS TO THE FILE
      CALL WRDATA(.FALSE.,IUNIT,IWORK,91)
!
      RETURN
      END SUBROUTINE WRSTRT
!*==LOWER.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 2      SUBROUTINE LOWER(C)
      SUBROUTINE LOWER(C)
!
! *** LOWER by JCM 3 Aug 92 ***
!
!X
!C 13C
!H Replaces any upper case letters in C by lower case.
!
      CHARACTER*(*) C
      COMMON /CHARS / LETUP(26), LETLOW(26), ISPCE, IDIGIT(10),         &
     &                ISMBOL(21)
      CHARACTER*1 LETUP, LETLOW, ISPCE, IDIGIT, ISMBOL
!
      L = LENGT(C)
      DO I = 1, L
        M = LETTER(C(I:I))
        IF (M.GT.0) C(I:I) = LETLOW(M)
      ENDDO
      RETURN
      END SUBROUTINE LOWER
!*==NWIND2.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 7      SUBROUTINE NWIND2
      SUBROUTINE NWIND2
!
! *** NWIND2 updated by JCM 20 Aug 92 ***
!
!X
!C 7B
!H Writes out a new Crystal Data File for the main program CELLSQ.
!P NWIND2 must be called in the context of CELLSQ, with an old Crystal
!P Data File held on the scratch unit number IO10.  A cycle of
!P LSQ refinement should have adjusted some of the parameters involved.
!D Writes out a new CDF with possibly changed values on the C card or
!D L PKCN, L ZERO or L THE2 cards.
!
!O Writes the updated file to unit NEWIN.
!
      CHARACTER*4 WORD
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
!
      CALL NEWCD
      ID = 0
    1 ID = ID + 1
      IF (ID.GT.NTOTAL(1)) GOTO 100
      READ (IO10,FMT=1000,REC=ID) ICARD
 1000 FORMAT (A80)
      L = LETTER(ICARD(1:1))
      IF (L.EQ.3) THEN
!
! OUTPUT NEW C CARD WITH NEW VALUES:
        CALL CELNEW
        GOTO 1
      ELSEIF (L.EQ.9) THEN
!
! OUTPUT NEW I CARD:
        CALL OTPUTI
        GOTO 1
      ELSEIF (L.EQ.12) THEN
!
! IF 'L' IS IT ALSO 'PKCN', 'ZERO' OR 'THE2'?
        CALL RDWORD(WORD,ILEN,3,IPT,80,0,IER)
! NEW L PKCN CARD:
        IF (WORD.EQ.'PKCN') THEN
          CALL PCTF01(4)
          GOTO 1
        ELSEIF (WORD.EQ.'ZERO') THEN
! NEW L ZERO CARD:
          CALL ZEROPR(4)
          GOTO 1
! NEW L THE2 CARD:
        ELSEIF (WORD.EQ.'THE2') THEN
          CALL THETA2(4)
          GOTO 1
        ENDIF
      ENDIF
! COPY UNCHANGED CARD:
      WRITE (NEWIN,2000) (ICARD(I:I),I=1,LENGT(ICARD))
 2000 FORMAT (80A1)
      GOTO 1
!
  100 RETURN
      END SUBROUTINE NWIND2
!*==APSHD2.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 8      SUBROUTINE APSHD2
      SUBROUTINE APSHD2
!
! *** APSHD2 updated by PJB Sept 93 ***
!
!X
!C 7B
!H Applies shifts for 2theta, time and cell for D2 type LSQ
!P Only useful if called from CELLSQ, D2LSQ or similar.  Expects suitable type
!P of Least Squares to be set up.
!
!P Also expects shifts in BLSQ and esds in DERIVB (as these are not now needed
!P for their original uses).
!D Scans all variables, deals with those which are redundant and whose shifts
!D are therefore not immediately available, deals with possible fudging, and
!D applies the shifts.
!
!O Outputs new values, shifts, esds, old values and shift/esd
!
      LOGICAL SHFCEL
      CHARACTER*4 LNAM1, LNAM2
      COMMON /DERBAS/ DERIVB(400), LVARB
      COMMON /DERVAR/ DERIVV(500), LVARV
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /MATDAT/ MATPNT(401), BLSQ(400)
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /POINTS/ LVRBS(500), LVRPR(500), LBSVR(400), LRDVR(300)
      COMMON /REFINE/ IREF, NCYC, NCYC1, LASTCY, ICYC, MODERR(5),       &
     &                MODEOB(5), IPRNT(20), MAXCOR, IONLY(9), SIMUL,    &
     &                MAG, MPL, FIXED, DONE, CONV
      LOGICAL SIMUL, MAG, MPL, FIXED, DONE
      EQUIVALENCE (MODER,MODERR(1))
!
      SHFCEL = .FALSE.
      WRITE (LPT,2000) ICYC
 2000 FORMAT (/////'1 ++++++++++ Shifts in variables for cycle',I3,     &
     &        ' ++++++++++ ')
      CALL MESS(LPT,2,'  Variable       New           Esd          '//  &
     &          'Shift          Old          Shift/Esd ')
!
! INITIALISE SHIFT AVERAGES:
      CALL FETSHF(1,0.,0.)
!
! COUNT ALL VARIABLES:
      DO I = 1, LVARV
! J=WHICH BASIC VARIABLE:
        J = LVRBS(I)
! KPACK=WHICH PACKED PARAMETER SPEC:
        KPACK = LVRPR(I)
! IF VARIABLE IS BASIC:
        IF (J.GT.0) THEN
          SHIFT = BLSQ(J)
          ESD = DERIVB(J)
! OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
        ELSE
          CALL SHFESD(-J)
        ENDIF
!
! GET ITS PRINTING NAME:
        CALL PARNAM(LNAM1,LNAM2,3,KPACK)
! AND ITS FAMILY, GENUS AND SPECIES:
        CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
! FAMILY 1, GENUS 1 - CELL PARAMETERS:
        IF (IGEN.EQ.1) THEN
          IF (ISPC.EQ.7) THEN
            CALL THETA2(3)
            GOTO 2
          ENDIF
          CALL CELSHF(ISPC)
          SHFCEL = .TRUE.
        ENDIF
! FAMILY 1, GENUS 2 - PKCN PARAMETERS:
        IF (IGEN.EQ.2) CALL PCTF01(3)
! FAMILY 1, GENUS 3 - ZEROPOINT
        IF (IGEN.EQ.3) CALL ZEROPR(3)
!
    2   CALL FETSHF(2,SHIFT,ESD)
        WRITE (LPT,2006) LNAM1, LNAM2, XNEW, ESD, SHIFT, XOLD, SHESD
 2006   FORMAT (' ',1X,A4,1X,A4,5G14.5)
      ENDDO
      CALL FETSHF(3,0.,0.)
      IF (SHFCEL) CALL RECELL(1,1)
      RETURN
      END SUBROUTINE APSHD2
!*==CALCD2.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 7      SUBROUTINE CALCD2(H)
      SUBROUTINE CALCD2(H)
!
! *** CALCD2 by JCM 14 Mar 85 ***
!
!X
!C 7B
!H Gives the calculated function for LSQ refinement for which the
!H observations are time-of-flight values, and calculates derivatives.
!A On entry H is a 1x3 vector holding h,k,l
!P /CELPAR/ holds the reciprocal cell quadratic products in CPARS(1:6,2), and
!P                their fix/vary information in KCPARS(1:6)
!P /THET2/ holds THE2, the refinabale value of 2 theta degrees
!P               KTHE2, the fix/vary information for THE2, and
!P               THCON1=cos theta (converted to radians)
!D Forms GCALC in /OBSCAL/ as PKCN(1)*252.777*lambda + PKVCN(2) lambda squared
!P                          + ZERO
!D and all derivatives in DERIVV in /DERVAR/
!
      DIMENSION H(3), C(6)
      COMMON /BRAGG / STHMXX(5), STHL, SINTH, COSTH, SSQRD, TWSNTH(5),  &
     &                DSTAR2, TWOTHD(5), DIFANG(6)
      EQUIVALENCE (STHLMX,STHMXX(1))
      COMMON /CELPAR/ CELL(3,3,2), V(2), ORTH(3,3,2), CPARS(6,2),       &
     &                KCPARS(6), CELESD(6,6,2), CELLSD(6,6), KOM4
      COMMON /DERVAR/ DERIVV(500), LVARV
      COMMON /DGEOM / IGEOM, UM(9), NLR, ANGLIN(3), ALAMBD(5,5), NLAMB, &
     &                ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /OBSCAL/ OBS, DOBS, GCALC, YCALC, DIFF, ICODE, SUMWD, NOBS,&
     &                IWGH(5), WTC(4), WT, SQRTWT, WDIFF, YBACK, YPEAK, &
     &                YMAX, CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /POINTS/ LVRBS(500), LVRPR(500), LBSVR(400), LRDVR(300)
      COMMON /PHASE / NPHASE, IPHASE, JPHASE, KPHASE, NPHUNI(9),        &
     &                SCALEP(9), KSCALP(9), PHMAG(9)
      LOGICAL PHMAG
      COMMON /PRPKCN/ ARGK, PKCNSP(6,9,5), KPCNSP(6,9,5), DTDPCN(6),    &
     &                DTDWL, NPKCSP(9,5), ARGMIN(5), ARGMAX(5),         &
     &                ARGSTP(5), PCON
!* THIS IS ONLY HERE FOR KNOW, WHICH IS NOT NICE
!>> JCC Moved to an include file
      INCLUDE 'REFLNS.INC'
      COMMON /PRZERO/ ZEROSP(6,9,5), KZROSP(6,9,5), DKDZER(6),          &
     &                NZERSP(9,5)
      COMMON /SOURCE/ NSOURC, JSOURC, KSOURC, NDASOU(5), METHOD(9),     &
     &                NPFSOU(9,5), NSOBS(5), SCALES(5), KSCALS(5),      &
     &                NPCSOU(9,5)
      COMMON /THET2 / THE2, KTHE2, THCON1
!
! FIRST FORM D* SQUARED AND ITS DERIVATIVE WRT A*, B* ETC:
      CALL CELDER(H,C)
!
! NOW D*:
      DSTAR(1) = SQRT(DSTAR2)
      KNOW = 1
      TWOTHD(JSOURC) = THE2
      CALL PCTF01(2)
      GCALC = ARGK
!
! DERIVATIVE WRT 2THETA DEGREES IF REQD:
      L = KTHE2
! DT/DLAM * DLAM/D(2THETA DEGREES) ; THCON1 HOLDS COS THETA * RADIANS
      IF (L.GT.0) DERIVV(L) = DTDWL*THCON1/DSTAR(1)
!
! DERIVATIVES WRT PEAK CENTRE PARAMETERS:
      L = KPCNSP(1,JPHASE,JSOURC)
      IF (L.GT.0) DERIVV(L) = DTDPCN(1)
      L = KPCNSP(2,JPHASE,JSOURC)
      IF (L.GT.0) DERIVV(L) = DTDPCN(2)
! AND ZERO
      L = KZROSP(1,JPHASE,JSOURC)
      IF (L.GT.0) DERIVV(L) = DKDZER(1)
!
! DERIVATIVES WRT CELL PARAMETERS A* B* ETC; IN STAGES, DT/DLAM,
! DLAM/D(DSTAR SQRD), D(DSTAR SQRD)/DA* (AS OUT OF CELDER):
      FAC = DTDWL*(-0.5*WLGTH/DSTAR2)
      DO I = 1, 6
        L = KCPARS(I)
        IF (L.GT.0) DERIVV(L) = C(I)*FAC
      ENDDO
!
      RETURN
      END SUBROUTINE CALCD2
!*==LIMITS.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE LIMITS(YVALS,N,MIN,MAX,YMIN,YMAX)
      SUBROUTINE LIMITS(YVALS,N,MIN,MAX,YMIN,YMAX)
!
! *** LIMITS corrected by JCM 28 Dec 92 ***
!
!H Finds the maximum and minimum of the members of a given array
!A On entry YVALS is an array of REAL numbers
!A          N is the number of elements in the array (and must be > 0)
!A On exit  YMIN is the smallest value found, occurring at element MIN
!A          YMAX is the largest value found, occurring at element MAX
!
!N If all elements are equal, MIN=1 and MAX=N
!
      DIMENSION YVALS(N)
!
      MIN = 1
      MAX = N
      YMIN = YVALS(1)
      YMAX = YVALS(1)
      DO I = 1, N
        IF (YVALS(I).LT.YMIN) THEN
          YMIN = YVALS(I)
          MIN = I
        ENDIF
        IF (YVALS(I).GT.YMAX) THEN
          YMAX = YVALS(I)
          MAX = I
        ENDIF
      ENDDO
      RETURN
      END SUBROUTINE LIMITS
!*==MATTOS.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE MATTOS(ALSQ,MATSZ)
      SUBROUTINE MATTOS(ALSQ,MATSZ)
!
! *** MATTOS updated by JCM 23 Jun 92 ***
!
! SPEEDED UP CAILS-TYPE VERSION OF  MATTOT
!
! ALL REFERENCE TO THE LSQ MATRIX, ALSQ, IS MADE THROUGH ROUTINES STARTING "MAT"
! THIS ENABLES ALSQ TO BE DIMENSIONED EVERYWHERE EXCEPT IN MAIN AS ALSQ(MATSZ)
!
!   MATTOT  ADDS IN CONTRIBUTIONS TO LSQ MATRIX AND RHS FOR THIS OBSERVATION
!
!
      INCLUDE 'PARAMS.INC'
!
      DIMENSION ALSQ(MATSZ), MM(400)
      EQUIVALENCE (MM(1),MATPNT(2))
      COMMON /DERBAS/ DERIVB(400), LVARB
      COMMON /MATDAT/ MATPNT(401), BLSQ(400)
      COMMON /OBSCAL/ OBS, DOBS, GCALC, YCALC, DIFF, ICODE, SUMWD, NOBS,&
     &                IWGH(5), WTC(4), WT, SQRTWT, WDIFF, YBACK, YPEAK, &
     &                YMAX, CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /PHASE / NPHASE, IPHASE, JPHASE, KPHASE, NPHUNI(9),        &
     &                SCALEP(9), KSCALP(9), PHMAG(9)
      LOGICAL PHMAG
      COMMON /PRBLEM/ NFAM, NGENPS(6,9), NSPCPS(6,9), LF1SP(5),         &
     &                LF3SP(10,9,5), LVFST1(6,9,5), LBFST1(6,9,5),      &
     &                NVARF(6,9,5), NBARF(6,9,5), LF6SP(3,5)
      DIMENSION NGENS(6), NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1))
      EQUIVALENCE (NSPC(1),NSPCPS(1,1))
      COMMON /PRPKFN/ ARGI, YNORM, PKFNSP(8,6,9,5), KPFNSP(8,6,9,5),    &
     &                DERPFN(8,6), NPKFSP(8,9,5), TOLER(8,9,5),         &
     &                NPKGEN(9,5), PKFNVA(8), DYNDVQ(8), DYNDKQ, REFUSE,&
     &                CYC1, NOPKRF, TOLR(2,5), NFFT, AKNOTS,            &
     &                NBASF4(MPRPKF,2,9), L4END(9), L6ST, L6END
      LOGICAL REFUSE, CYC1, NOPKRF
      COMMON /REFINE/ IREF, NCYC, NCYC1, LASTCY, ICYC, MODERR(5),       &
     &                MODEOB(5), IPRNT(20), MAXCOR, IONLY(9), SIMUL,    &
     &                MAG, MPL, FIXED, DONE, CONV
      LOGICAL SIMUL, MAG, MPL, FIXED, DONE
      EQUIVALENCE (MODER,MODERR(1))
!>> JCC Moved to an include file
      INCLUDE 'REFLNS.INC'
!
      IF (SIMUL) GOTO 100
      SQWDIF = SQRTWT*DIFF
!
! THIS ONLY WORKS IF THERE ARE NOT 2 CAIL PHASES, (& AT PRESENT IF THE CAIL
! PHASE IS AT THE END)
      DO I = 1, LBFST1(4,JPHASE,1)
        DERIVB(I) = SQRTWT*DERIVB(I)
      ENDDO
      IF (KMAX.NE.0) THEN
        DO I = NBASF4(KMIN,1,JPHASE), NBASF4(KMAX,2,JPHASE)
          DERIVB(I) = SQRTWT*DERIVB(I)
        ENDDO
      ENDIF
      DO I = L6ST, L6END
        DERIVB(I) = SQRTWT*DERIVB(I)
      ENDDO
!
      DO I = 1, LBFST1(4,JPHASE,1)
        IR = MM(I)
        DO J = I, LBFST1(4,JPHASE,1)
          ALSQ(IR+J) = ALSQ(IR+J) + DERIVB(I)*DERIVB(J)
        ENDDO
        IF (KMAX.NE.0) THEN
          DO J = NBASF4(KMIN,1,JPHASE), NBASF4(KMAX,2,JPHASE)
            ALSQ(IR+J) = ALSQ(IR+J) + DERIVB(I)*DERIVB(J)
          ENDDO
        ENDIF
        DO J = L6ST, L6END
          ALSQ(IR+J) = ALSQ(IR+J) + DERIVB(I)*DERIVB(J)
        ENDDO
        BLSQ(I) = BLSQ(I) + SQWDIF*DERIVB(I)
      ENDDO
!
      IF (KMAX.NE.0) THEN
        DO I = NBASF4(KMIN,1,JPHASE), NBASF4(KMAX,2,JPHASE)
          IR = MM(I)
          DO J = I, NBASF4(KMAX,2,JPHASE)
            ALSQ(IR+J) = ALSQ(IR+J) + DERIVB(I)*DERIVB(J)
          ENDDO
          DO J = L6ST, L6END
            ALSQ(IR+J) = ALSQ(IR+J) + DERIVB(I)*DERIVB(J)
          ENDDO
          BLSQ(I) = BLSQ(I) + SQWDIF*DERIVB(I)
        ENDDO
      ENDIF
!
      DO I = L6ST, L6END
        IR = MM(I)
        DO J = I, L6END
          ALSQ(IR+J) = ALSQ(IR+J) + DERIVB(I)*DERIVB(J)
        ENDDO
        BLSQ(I) = BLSQ(I) + SQWDIF*DERIVB(I)
      ENDDO
!
  100 RETURN
      END SUBROUTINE MATTOS
!*==CRMPRD.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE CRMPRD(A,B,C,I,J,K)
      SUBROUTINE CRMPRD(A,B,C,I,J,K)
!
! *** CRMPRD by PJB Nov 89 ***
!
!X
!C 12C
!H Performs COMPLEX by REAL matrix multiplication.
!A On entry A (of dimensions IxJ) is a COMPLEX matrix
!A          B (of dimensions JxK) is a REAL matrix
!A On exit  C (of dimensions IxK and COMPLEX) is the product of A and B.
!N C is unchanged if any of I,J or K is zero.
!N Note also the existence of SUBROUTINE RCMPRD which multiplies them
!N the other way round.
!
      DIMENSION B(1)
      COMPLEX A(1), C(1)
      DO II = 1, I
        IK = II
        JK = 1
        DO KK = 1, K
          IJ = II
          C(IK) = 0.
          DO JJ = 1, J
            C(IK) = C(IK) + A(IJ)*B(JK)
            IJ = IJ + I
            JK = JK + 1
          ENDDO
          IK = IK + I
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE CRMPRD
!*==DFLTD2.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      LOGICAL FUNCTION DFLTD2(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFLTD2(IFAM,IGEN,ISPC)
!
! *** DFLTD2 moved by JCM to PR section 23 March 92 ***
!
!X
!C 7A
!H Called as a substitute for DEFALT out of VARMAK in main program CELLSQ
!A On entry IFAM, ISPC, IGEN give family, genus, species of parameter
!A On exit LOGICAL DFLTD2 is TRUE if the parameter is to be varied, or
!A                           FALSE if to be fixed.
!
! ONLY VARY CELL BY DEFAULT:
! TO KEEP COMPILERS HAPPY:
      I = IFAM
      DFLTD2 = (IGEN.EQ.1 .AND. ISPC.LE.6)
      RETURN
      END FUNCTION DFLTD2
!
!*****************************************************************************
!
! Originally in Mvec.f90
!
!*==MB11A.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 3      SUBROUTINE MB11A(M,N,A,IA,W)
      SUBROUTINE MB11A(M,N,A,IA,W)
!
! *** MB11A from HARWELL 25 May 79 ***
!
!C 12C
!H Inverts a rectangular matrix whose order is the smaller dimension;
!H used by the Harwell refinement routine VA05A.
!
      DIMENSION A(IA,1), W(1)
!     PARTITION THE WORKING SPACE ARRAY W
!     THE FIRST PARTITION HOLDS THE FIRST COMPONENTS OF THE VECTORS OF
!     THE ELEMENTARY TRANSFORMATIONS
      NRW = M
!     THE SECOND PARTITION RECORDS ROW INTERCHANGES
      NCW = M + M
!     THE THIRD PARTITION RECORDS COLUMN INTERCHANGES
!     SET THE INITIAL RECORDS OF ROW AND COLUMN INTERCHANGES
      DO I = 1, M
        N1 = NRW + I
        W(N1) = 0.5 + FLOAT(I)
      ENDDO
      DO I = 1, N
        N1 = NCW + I
        W(N1) = 0.5 + FLOAT(I)
      ENDDO
!     'KK' COUNTS THE SEPARATE ELEMENTARY TRANSFORMATIONS
      KK = 1
!     FIND LARGEST ROW AND MAKE ROW INTERCHANGES
    3 RMAX = 0.0
      DO I = KK, M
        SUM = 0.
        DO J = KK, N
          SUM = SUM + A(I,J)**2
        ENDDO
        IF (RMAX.LT.SUM) THEN
          RMAX = SUM
          IR = I
        ENDIF
      ENDDO
      IF (RMAX.EQ.0.0) CALL ERRIN2(M-KK,0,'in MB11A:',                  &
     &                             'reduced rows found to be zero')
      IF (IR.LE.KK) GOTO 7
      N3 = NRW + KK
      SUM = W(N3)
      N4 = NRW + IR
      W(N3) = W(N4)
      W(N4) = SUM
      DO J = 1, N
        SUM = A(KK,J)
        A(KK,J) = A(IR,J)
        A(IR,J) = SUM
      ENDDO
!     FIND LARGEST ELEMENT OF PIVOTAL ROW, AND MAKE COLUMN INTERCHANGES
    7 RMAX = 0.
      SUM = 0.
      DO J = KK, N
        SUM = SUM + A(KK,J)**2
        IF (RMAX.GE.ABS(A(KK,J))) GOTO 10
        RMAX = ABS(A(KK,J))
        IR = J
   10 ENDDO
      IF (IR.LE.KK) GOTO 12
      N5 = NCW + KK
      RMAX = W(N5)
      N6 = NCW + IR
      W(N5) = W(N6)
      W(N6) = RMAX
      DO I = 1, M
        RMAX = A(I,KK)
        A(I,KK) = A(I,IR)
        A(I,IR) = RMAX
      ENDDO
!     REPLACE THE PIVOTAL ROW BY THE VECTOR OF THE TRANSFORMATION
   12 SIGMA = SQRT(SUM)
      BSQ = SQRT(SUM+SIGMA*ABS(A(KK,KK)))
      W(KK) = SIGN(SIGMA+ABS(A(KK,KK)),A(KK,KK))/BSQ
      A(KK,KK) = -SIGN(SIGMA,A(KK,KK))
      KP = KK + 1
      IF (KP.GT.N) GOTO 16
      DO J = KP, N
        A(KK,J) = A(KK,J)/BSQ
      ENDDO
!     APPLY THE TRANSFORMATION TO THE REMAINING ROWS OF A
      IF (KP.GT.M) GOTO 16
      DO I = KP, M
        SUM = W(KK)*A(I,KK)
        DO J = KP, N
          SUM = SUM + A(KK,J)*A(I,J)
        ENDDO
        A(I,KK) = A(I,KK) - SUM*W(KK)
        DO J = KP, N
          A(I,J) = A(I,J) - SUM*A(KK,J)
        ENDDO
      ENDDO
      KK = KP
      GOTO 3
!     AT THIS STAGE THE REDUCTION OF A IS COMPLETE
!     NOW WE BUILD UP THE GENERALIZED INVERSE
!     APPLY THE FIRST ELEMENTARY TRANSFORMATION
   16 KK = M
      KP = M + 1
      SUM = W(M)/A(M,M)
      IF (N.LE.M) GOTO 33
      DO J = KP, N
        A(M,J) = -SUM*A(M,J)
      ENDDO
   33 A(M,M) = 1./A(M,M) - SUM*W(M)
!     NOW APPLY THE OTHER (M-1) TRANSFORMATIONS
   36 KP = KK
      KK = KP - 1
      IF (KK.LE.0) GOTO 37
!     FIRST TRANSFORM THE LAST (M-KK) ROWS
      DO I = KP, M
        SUM = 0.
        DO J = KP, N
          SUM = SUM + A(KK,J)*A(I,J)
        ENDDO
        DO J = KP, N
          A(I,J) = A(I,J) - SUM*A(KK,J)
        ENDDO
        W(I) = -SUM*W(KK)
      ENDDO
!     THEN CALCULATE THE NEW ROW IN POSITION KK
      DO J = KP, N
        SUM = -W(KK)*A(KK,J)
        DO I = KP, M
          SUM = SUM - A(I,KK)*A(I,J)
        ENDDO
        A(KK,J) = SUM/A(KK,KK)
      ENDDO
!     AND REVISE THE COLUMN IN POSITION KK
      SUM = 1. - W(KK)**2
      DO I = KP, M
        SUM = SUM - A(I,KK)*W(I)
        A(I,KK) = W(I)
      ENDDO
      A(KK,KK) = SUM/A(KK,KK)
      GOTO 36
!     RESTORE THE ROW INTERCHANGES
   37 DO I = 1, M
   46   N1 = NRW + I
        IR = IFIX(W(N1))
        IF (I.GE.IR) GOTO 45
        SUM = W(N1)
        N2 = NRW + IR
        W(N1) = W(N2)
        W(N2) = SUM
        DO J = 1, N
          SUM = A(I,J)
          A(I,J) = A(IR,J)
          A(IR,J) = SUM
        ENDDO
        GOTO 46
   45 ENDDO
!     RESTORE THE COLUMN INTERCHANGES
      DO J = 1, N
   50   N1 = NCW + J
        IR = IFIX(W(N1))
        IF (J.GE.IR) GOTO 49
        SUM = W(N1)
        N2 = NCW + IR
        W(N1) = W(N2)
        W(N2) = SUM
        DO I = 1, M
          SUM = A(I,J)
          A(I,J) = A(I,IR)
          A(I,IR) = SUM
        ENDDO
        GOTO 50
   49 ENDDO
      RETURN
      END SUBROUTINE MB11A
!*==NB01A.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE NB01A(K,AZ,BZ,E2,X,Y,MAXIT)
      SUBROUTINE NB01A(K,AZ,BZ,E2,X,Y,MAXIT)
!
! *** NB01A updated by PJB 15-Nov-1994  ***
!
!X
!C 9C
!H Harwell routine NB01A to find the zero of a function.
!D Finds the value of X in the range AZ <= X <= BZ for which Y(X)=0
!A Called initially with K=0, AZ and BZ set to the minimum and maximum values
!A of X to be searched, E2 to the precision in X required and ABS(MAXIT) to
!A the maximum number of iterations allowed.
!A Subsequent calls depend on the value of K returned
!A     K=0 Initial call as above
!A     K=1 calculate Y for the value of X returned and call again
!A     K=2 The value of X retuned is the required solution
!A     K=3 No zero value of Y was found X=AZ and BZ
!A     K=4 MAXIT calls have been made without finding the zero value within the
!A         required precision
!N the private common /NB01AP has been included (C43) to preserve the values
!N of A,B,IT AND THE Js between calls
      COMMON /NB01AP/ A, B, IT, J1, J2, J3
!
      IF (K.GT.0) GOTO 30
!
!     CALCULATE Y(X) AT X=AZ.
      A = AZ
      B = BZ
      X = A
      J1 = 1
      IT = 1
      M = IABS(MAXIT)
   10 K = J1
      GOTO 100
!
!     PRINT X AND Y(X) WHEN REQUESTED.
   30 IF (MAXIT.LE.0) WRITE (6,2000) X, Y
 2000 FORMAT (2X,'NB01A   X=',E16.7,'  Y(X)=',E16.7)
!
!     TEST WHETHER Y(X) IS SUFFICIENTLY SMALL.
      IF (ABS(Y).GT.E2) GOTO 50
   45 K = 2
      GOTO 100
!
!     BRANCH DEPENDING ON THE VALUE OF J1.
   50 GOTO (60,70,88,170), J1
!
!     CALCULATE Y(X) AT X=BZ.
   60 YA = Y
      X = B
      J1 = 2
      GOTO 100
!
!     TEST WHETHER THE SIGNS OF Y(AZ) AND Y(BZ) ARE DIFFERENT.
   70 IF (YA*Y.LT.0.) GOTO 120
!
!     BEGIN THE BINARY SUBDIVISION TO SEARCH FOR A BRACKET.
      X1 = A
      Y1 = YA
      J1 = 3
      H = B - A
      J2 = 1
   80 X2 = A + 0.5*H
      J3 = 1
!
!     CHECK WHETHER MAXIT FUNCTION VALUES HAVE BEEN CALCULATED.
   90 IT = IT + 1
      IF (IT.GE.M) GOTO 10
      X = X2
      GOTO 100
!
!     TEST WHETHER A BRACKET HAS BEEN FOUND.
   88 IF (YA*Y.LT.0.) GOTO 120
!
!     CONTINUE THE SEARCH FOR A BRACKET.
      IF (J3.GE.J2) GOTO 110
      A = X
      YA = Y
      X2 = X + H
      J3 = J3 + 1
      GOTO 90
  110 A = X1
      YA = Y1
      H = 0.5*H
      J2 = J2 + J2
      GOTO 80
!
!     AT THIS POINT THE FIRST BRACKET HAS BEEN FOUND.
  120 B = X
      YB = Y
      J1 = 4
!
!     CALCULATE THE NEXT X BY THE SECANT METHOD BASED ON THE BRACKET.
  130 IF (ABS(YA).LE.ABS(YB)) GOTO 140
      X1 = A
      Y1 = YA
      X = B
      Y = YB
      GOTO 150
  140 X1 = B
      Y1 = YB
      X = A
      Y = YA
!
!     USE THE SECANT METHOD BASED ON THE FUNCTION VALUES Y1 AND Y.
  150 U = Y*(X-X1)/(Y-Y1)
  155 X2 = X - U
      IF (X2.EQ.X) GOTO 195
      X1 = X
      Y1 = Y
      YTEST = 0.5*AMIN1(ABS(YA),ABS(YB))
!
!     CHECK THAT X2 IS INSIDE THE INTERVAL (A,B).
      IF ((X2-A)*(X2-B).LT.0.) GOTO 90
!
!     CALCULATE THE NEXT VALUE OF X BY BISECTION.
  160 X2 = 0.5*(A+B)
      YTEST = 0.
!
!     CHECK WHETHER THE MAXIMUM ACCURACY HAS BEEN ACHIEVED.
      IF ((X2-A)*(X2-B)) 90, 45, 45
!
!     REVISE THE BRACKET (A,B).
  170 IF (YA*Y.GE.0.) GOTO 180
      B = X
      YB = Y
      GOTO 190
  180 A = X
      YA = Y
!
!     USE YTEST TO DECIDE THE METHOD FOR THE NEXT VALUE OF X.
  190 IF (YTEST.LE.0.) GOTO 130
      IF (ABS(Y)-YTEST) 150, 150, 160
  195 IF (U.EQ.0.) GOTO 45
      U = U + U
      GOTO 155
!
  100 RETURN
      END SUBROUTINE NB01A
!*==CGMPRD.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE CGMPRD(A,B,C,I,J,K)
      SUBROUTINE CGMPRD(A,B,C,I,J,K)
!
! *** CGMPRD by JCM ***
!
!X
!C 12C
!H Multiplies together two COMPLEX matrices.
!A On entry A (of dimensions IxJ) and B (of dimensions JxK) are COMPLEX matrices
!A On exit  C (of dimensions IxK) is the product of A and B
!N C is unchanged if any of I,J or K is zero.
!
      COMPLEX A(1), B(1), C(1)
      DO II = 1, I
        IK = II
        JK = 1
        DO KK = 1, K
          IJ = II
          C(IK) = 0.
          DO JJ = 1, J
            C(IK) = C(IK) + A(IJ)*B(JK)
            IJ = IJ + I
            JK = JK + 1
          ENDDO
          IK = IK + I
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE CGMPRD
!*==SUMVEC.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE SUMVEC(A,I,J,K,SUM)
      SUBROUTINE SUMVEC(A,I,J,K,SUM)
!
! *** SUMVEC by JCM 26 Sep 85 ***
!
!X
!C 12C
!H Calculates the sum of elements of a real array
!A On entry A is a real vector of length at least J
!A          I is the position in the array of the first element in the sum
!A          J is the position beyond which elements are not included
!A          K is the "step" between included elements
!A On exit  SUM is the sum of the chosen elements
!
!D Sets SUM=the sum of elements of array A by a DO LOOP 'I,J,K', dealing
!D correctly with J < I, and therefore usable in both FORTRAN 66 & 77.
!
      DIMENSION A(1)
!
      SUM = 0.
      IF (J.LT.I) GOTO 100
!
      DO N = I, J, K
        SUM = SUM + A(N)
      ENDDO
  100 RETURN
      END SUBROUTINE SUMVEC
!*==WTMEAN.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 2      SUBROUTINE WTMEAN(X,DX,IFUN,SUMS)
      SUBROUTINE WTMEAN(X,DX,IFUN,SUMS)
!
! *** WTMEAN by JCM 17 Jan 85 ***
!
!X
!C 9C
!H Multiple entry routine for the calculation of weighted averages.
!A On entry IFUN indicates which action is required:
!A          IFUN= 0 initialses an array SUMS for subsequent summing.
!A          IFUN= a positive integer adds an observation X with a  weight
!A                deduced from the value of IFUN:
!A                IFUN=1 gives unit weights
!A                IFUN=2 gives 1/DX squared
!A          IFUN= a negative integer returns the mean in X, the standard
!A                deviation in DX, and the number of observations in
!A                the 4th element of given array SUMS.
!A If an observation has zero DX, it is ignored.  -ve DX is treated as +ve.
!
!A SUMS is a 1x5 array holding values for an individual set of data, so that
!A      several sets may be collected simultaneously.
!A
!A SUMS HOLDS:
!A      Sum of weighted observations
!A      Sum of weighted squares of observations
!A      Sum of 1/DX squared
!A      Number of observations
!A      Denominator for mean
!A             If unit weights, this is the number of observations,
!A             If 1/DX sqrd weights this is the sum of the weights
!
!
      DIMENSION SUMS(5)
      IF (IFUN) 1, 2, 3
!
!  INITIALISE:
    2 CALL GMZER(SUMS,1,5)
      GOTO 100
!
!  ADD AN OBSERVATION:
    3 SUMS(4) = SUMS(4) + 1.
      W = 1.
      IF (DX.EQ.0.) GOTO 100
      D = 1./(DX)**2
      IF (IFUN.EQ.2) W = D
      SUMS(1) = SUMS(1) + X*W
      SUMS(2) = SUMS(2) + X*(X*W)
      SUMS(3) = SUMS(3) + D
      SUMS(5) = SUMS(5) + W
      GOTO 100
!
!  CALCULATE MEAN AND SDEV:
    1 X = 0.
      DX = 0.
      IF (SUMS(4)) 100, 100, 8
    8 X = SUMS(1)/SUMS(5)
      DEL = 1./SUMS(3)
      IF (SUMS(4).EQ.1.) GOTO 5
      DDX = SUMS(2) - SUMS(1)*X
      DX = DDX/(SUMS(5)*(SUMS(4)-1.))
    5 IF (DEL.GT.DX) DX = DEL
      DX = SQRT(DX)
  100 RETURN
      END SUBROUTINE WTMEAN
!*==TRANSC.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE TRANSC(A,ND)
      SUBROUTINE TRANSC(A,ND)
!
! *** TRANSC by JCM 12 Jul 83 ***
!
!X
!C 12C
!H Replaces a COMPLEX square matrix by its transposed conjugate.
!A On entry A is a COMPLEX NDxND matrix
!A On exit  the elements of A have been replaced by their conjugates, and A
!A          has been transposed.
!
      COMPLEX A(ND,ND), B
!
      DO I = 1, ND
        A(I,I) = CONJG(A(I,I))
      ENDDO
!
      DO I = 1, ND - 1
        DO J = I + 1, ND
          B = CONJG(A(I,J))
          A(I,J) = CONJG(A(J,I))
          A(J,I) = B
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE TRANSC
!*==SPHARM.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 2      SUBROUTINE SPHARM(Y,T,P,LMAX,NUM)
      SUBROUTINE SPHARM(Y,T,P,LMAX,NUM)
!
! *** SPHARM by PJB Apr 84 ***
!
!X
!C 9C
!H Calculates spherical harmonics.
!A  On entry T and P are the spherical polar angles theta and phi
!A             defining the orientation of the spherical harmonic function
!A             (in radians).
!A           LMAX is the number of different l values to calculate
!A             (LMAX=maximum l +1)
!A           NUM is the total number of spherical harmonic functions
!A              which will be calculated (NUM=LMAX(LMAX+1)/2)
!A On exit  Y(N) is complex and is set to the value of the Nth
!A              spherical harmonic, these being in sets of constant l
!A              arranged in order of increasing l with m running from
!A              0 to l within each l value.
!N Only values for positive m are stored
!
      COMPLEX Y(NUM), EXPHI(20)
      COMMON /CONSTA/ PI, RAD, DEG, TWOPI, FOURPI, PIBY2, ALOG2, SQL2X8,&
     &                VALMUB
!
      D = 1./SQRT(TWOPI)
      C = COS(T)
      S = SIN(T)
      Y(1) = CMPLX(SQRT(0.5),0.)
      IF (LMAX.EQ.1) GOTO 6
      Y(2) = CMPLX(SQRT(1.5),0.)*C
      Y(3) = CMPLX(-SQRT(.75),0.)*S
      IF (LMAX.LT.3) GOTO 6
      LL = LMAX - 2
      N = 2
      DO L = 1, LL
        A = SQRT(FLOAT((2*L+1)*(2*L+3)))
        B = SQRT(FLOAT((2*L+1)*(2*L-1)))
        MAX = L + 1
        DO MM = 1, MAX
          M = MM - 1
          Y(N+L+1) = C*Y(N)
          IF (L.NE.M) Y(N+L+1) = Y(N+L+1) - SQRT(FLOAT((L-M)*(L+M)))    &
     &                           *Y(N-L)/B
          Y(N+L+1) = Y(N+L+1)*A/SQRT(FLOAT((L+1-M)*(L+1+M)))
          N = N + 1
        ENDDO
!
        Y(N+L+1) = CMPLX(0.,0.)
        IF (S.LT..0001) GOTO 1
        Y(N+L+1) = -FLOAT(2*L)*C*Y(N+L)/S - SQRT(FLOAT(4*L+2))*Y(N+L-1)
        Y(N+L+1) = Y(N+L+1)/SQRT(FLOAT(2*L+2))
    1 ENDDO
!
    6 CALL TRIG(EXPHI,P,LMAX)
      N = 1
!
      DO L = 1, LMAX
        DO M = 1, L
          Y(N) = Y(N)*EXPHI(M)*D
          N = N + 1
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE SPHARM
!*==GMNORM.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
!
! LEVEL 2       SUBROUTINE GMNORM(A,B,II,JJ)
      SUBROUTINE GMNORM(A,B,II,JJ)
!
! *** GMNORM by PJB ***
!
!X
!C 12C
!H Normalises the rows of a matrix.
!A On entry A is an IIxJJ real matrix
!A On exit A has been normalised using B, A(I,J) out = A(I,J) in / B(J)
!A         B holds the normalising coefficients
!
      DIMENSION A(II,JJ), B(JJ)
!
      DO J = 1, JJ
        CALL GMPRD(A(1,J),A(1,J),B(J),1,II,1)
        IF (B(J).GT..0001) THEN
          B(J) = SQRT(B(J))
          ANORM = 1./B(J)
          CALL GMSCA(A(1,J),A(1,J),ANORM,II,1)
        ENDIF
      ENDDO
      RETURN
      END SUBROUTINE GMNORM
!*==VECOUP.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 4      FUNCTION VECOUP(J1,M1,J2,M2,J,M)
      FUNCTION VECOUP(J1,M1,J2,M2,J,M)
!
! *** VECOUP by PJB 17 Jan 85 ***
!
!X
!C 9C
!H Calculates Clebsch-Gordon vector coupling coefficients.
!
!A On exit VECOUP holds the answer
!
      DIMENSION IFAC(6)
!
      VECOUP = 0.
      IF (J.GT.J1+J2) GOTO 100
      IF (IABS(J1-J2).GT.J) GOTO 100
      IF (M.NE.M1+M2) GOTO 100
      ANUM = FACT(J1+J2-J)*FACT(J1-J2+J)*FACT(J2+J-J1)
      ANUM = ANUM*FACT(J1+M1)*FACT(J2+M2)*FACT(J+M)
      ANUM = ANUM*FACT(J1-M1)*FACT(J2-M2)*FACT(J-M)
      VECOUP = SQRT(FLOAT(2*J+1)*ANUM/FACT(J1+J2+J+1))
      VEC = VECOUP
      IFAC(1) = J1 + J2 - J
      IFAC(2) = J1 - M1
      IFAC(3) = J2 + M2
      IFAC(4) = J - J2 + M1
      IFAC(5) = J - J1 - M2
      IFAC(6) = 0
      N = 0
      DO I = 4, 6
        IF (IFAC(I).LT.N) N = IFAC(I)
      ENDDO
!
      K = 0
      DO I = 1, 3
        IFAC(I) = IFAC(I) + N
        IF (IFAC(I).EQ.0) K = 1
      ENDDO
!
      DO I = 4, 6
        IFAC(I) = IFAC(I) - N
      ENDDO
!
      SUM = 1
      DO I = 1, 6
        SUM = SUM/FACT(IFAC(I))
      ENDDO
!
      SUM = SUM*FLOAT(1-2*MOD(IABS(N),2))
      TERM = SUM
      IF (K.EQ.1) GOTO 101
    5 TERM = -TERM
!
      DO I = 4, 6
        IFAC(I) = IFAC(I) + 1
        TERM = TERM/FLOAT(IFAC(I))
      ENDDO
!
      DO I = 1, 3
        TERM = TERM*FLOAT(IFAC(I))
        IFAC(I) = IFAC(I) - 1
        IF (IFAC(I).EQ.0) K = 1
      ENDDO
      SUM = SUM + TERM
      IF (K.NE.1) GOTO 5
!
  101 VECOUP = VECOUP*SUM
  100 RETURN
      END FUNCTION VECOUP
!*==BJ.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 3      FUNCTION BJ(N,X)
      FUNCTION BJ(N,X)
!
! *** BJ by JCM 17 Jan 85 ***
!
!X
!C 9C
!H Calculates Bessel functions of order 1 or 2.
!A On entry N is the order required
!A          X is the argument
!A On exit BJ holds the required Bessel function
!D Uses Harwell Library FF01A or FF02A, which have been included as
!D part of the CCSL.
!
!
      IF (N-1) 1, 2, 99
!
! ORDER 1:
    1 CALL FF01A(BJ,Y,X,0)
      GOTO 100
!
! ORDER 2:
    2 CALL FF02A(BJ,Y,X,0)
      GOTO 100
!
! ANY OTHER ORDER:
   99 CALL ERRIN2(N,0,'Bessel function order',' not calculated by BJ')
  100 RETURN
      END FUNCTION BJ
!*==STERMS.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE STERMS(G,R,H,S)
      SUBROUTINE STERMS(G,R,H,S)
!
! *** STERMS by PJB 17 Jan 85 ***
!
!X
!C 9C
!H Calculates a term in the spherically symmetric form factor summation,
!H for a 3D averaged form-factor involving Sk and r only.
!
      COMMON /CONSTA/ PI, RAD, DEG, TWOPI, FOURPI, PIBY2, ALOG2, SQL2X8,&
     &                VALMUB
!
      FOURPI = 4.*PI
!  TEST FOR SPECIAL CASES:
      IF (H.LT.001) GOTO 1
      IF (S.LT..001) GOTO 2
      IF (ABS(H-S).LT..001) GOTO 3
      G = H*COS(H*R)*SIN(S*R) - S*COS(S*R)*SIN(H*R)
      G = FOURPI*G/(H*S*(S*S-H*H))
      GOTO 100
    1 IF (S.LT..001) GOTO 4
      G = SIN(S*R) - S*R*COS(S*R)
      G = FOURPI*G/S**3
      GOTO 100
    2 G = SIN(H*R) - H*R*COS(H*R)
      G = FOURPI*G/H**3
      GOTO 100
    3 G = -SIN((H+S)*R) + (H+S)*R
      G = TWOPI*G/(H+S)*H*S
      GOTO 100
    4 G = (FOURPI*R**3)/3.
  100 RETURN
      END SUBROUTINE STERMS
!*==JGMADD.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE JGMADD(JA,JB,JC,NI,NJ)
      SUBROUTINE JGMADD(JA,JB,JC,NI,NJ)
!
! *** JGMADD by JCM Jun 88 ***
!
!X
!C 12C
!H In integers, sets matrix C = matrix A plus matrix B.
!A On entry JA and JB are integer matrices both of dimension NIxNJ
!A On exit  JC=JA+JB also NIxNJ
!
      DIMENSION JA(NI,NJ), JB(NI,NJ), JC(NI,NJ)
      DO I = 1, NI
        DO J = 1, NJ
          JC(I,J) = JA(I,J) + JB(I,J)
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE JGMADD
!*==CALFUN.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
      SUBROUTINE CALFUN(M,N,F,X)
      RETURN
      END SUBROUTINE CALFUN
!*==CGMSUB.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE CGMSUB(A,B,C,NI,NJ)
      SUBROUTINE CGMSUB(A,B,C,NI,NJ)
!
! *** CGMSUB by PJB 20 Feb 91 ***
!
!X
!C 12C
!H Sets COMPLEX matrix C = COMPLEX matrix A - COMPLEX matrix B.
!A On entry A nnd B are NI by NJ COMPLEX matrices
!A On exit C is set to the difference of A and B
!
      COMPLEX A(NI,NJ), B(NI,NJ), C(NI,NJ)
      DO I = 1, NI
        DO J = 1, NJ
          C(I,J) = A(I,J) - B(I,J)
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE CGMSUB
!*==CGMUNI.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE CGMUNI(A,NI)
      SUBROUTINE CGMUNI(A,NI)
!
! *** CGMUNI modified by PJB c17 17 sept 93 ***
!
!X
!C 12C
!H Clears a COMPLEX square matrix to contain the unit matrix.
!A On exit A is an NIxNI unit matrix
!N NI must be at least 1
!
      COMPLEX A(NI,NI)
      DATA C0, C1/0., 1./
!
      DO I = 1, NI
        A(I,I) = CMPLX(C1,C0)
        I1 = I + 1
        IF (I1.GT.NI) GOTO 100
        DO J = I1, NI
          A(I,J) = CMPLX(C0,C0)
          A(J,I) = A(J,I)
        ENDDO
      ENDDO
  100 RETURN
      END SUBROUTINE CGMUNI
!*==EXPINT.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 4      FUNCTION EXPINT(A,P,N,L)
      FUNCTION EXPINT(A,P,N,L)
!
! *** EXPINT by PJB Dec 84 ***
!
!X
!C 9C
!H Calculates an exponential radial integral.
!A On entry A, P N and L are set up for the routine to calculate the integral
!A between 0 and infinity of the Lth order spherical Bessel function of
!A A*X times X**N*exp(-P*X)
!
!D Uses hypergeometric series.
!N Used to calculate form-factors from Slater type wave-functions
      DIMENSION B(4)
      B(1) = FLOAT(N+L+3)
      B(2) = 0.5*FLOAT(L-N-1)
      B(3) = FLOAT(L) + 1.5
      EX = 2.0
      GAM = B(3) - 1.0
      L1 = L + 1
      DO I = 1, L1
        EX = EX*GAM
        GAM = GAM - 1.0
      ENDDO
!
      EX = FACT(N+L+2)/EX
      IF (L.NE.0) THEN
        X = (0.5*A)**L
        EX = EX*X
      ENDIF
      X = A*A + P*P
      B(1) = 0.5*B(1)
      EX = EX/(X**B(1))
      X = A*A/X
!
!     HYPERGEOMETRIC SERIES
      SUM = 1.
      TERM = 1.
      B(4) = 1.
    3 T = TERM
      TERM = TERM*B(1)*B(2)*X/(B(3)*B(4))
      SUM = SUM + TERM
      E = ABS(TERM/SUM)
      IF (E.GT..001) THEN
        DO I = 1, 4
          B(I) = B(I) + 1.0
        ENDDO
        GOTO 3
      ENDIF
!
      EXPINT = EX*SUM
      RETURN
      END FUNCTION EXPINT
!*==FACT.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 3      FUNCTION FACT(K)
      FUNCTION FACT(K)
!
! *** FACT by PJB 19 Jan 85 ***
!
!X
!C 9C
!H Calculates factorial K.
!A On entry K holds an integer which is positive or zero.
!A On exit FACT holds factorial K
!
!
      FAC = 1.
      IF (K) 1, 101, 2
    1 CALL ERRIN2(K,1,'negative argument for factorial',' ')
!
    2 DO I = 1, K
        FAC = FAC*FLOAT(I)
      ENDDO
  101 FACT = FAC
      RETURN
      END FUNCTION FACT
!*==TRIG.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE TRIG(A,B,K)
      SUBROUTINE TRIG(A,B,K)
!
! *** TRIG by JCM 18 Apr 84 ***
!
!X
!C 10C
!H Sets up cos(nx) and sin(nx) for a range of n by recursion.
!A On entry B is the reqired argument x
!A          K is the required number of terms
!A On exit  A is the COMPLEX array holding the answers
!D Calculates the COMPLEX trigonometric functions A(i) = CEXP(0,m*B)
!D for i = m+1, m = 0,K-1.
!
      COMPLEX A(K), MULT
      A(1) = CMPLX(1.,0.)
      IF (K.LT.2) GOTO 100
      MULT = CEXP(CMPLX(0.,B))
      DO I = 2, K
        A(I) = A(I-1)*MULT
      ENDDO
  100 RETURN
      END SUBROUTINE TRIG
!*==BRILL.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 2      FUNCTION BRILL(T,TN,S)
      FUNCTION BRILL(T,TN,S)
!
! *** BRILL from PJB 14 Jun 88 ***
!
!X
!C 9C
!H Returns the value of the Brillouin function.
!A On entry T is the absolute temperature at which the function is required,
!A          TN the transition temperature,
!A          S is the spin.
!N  Uses the subprogram NB01A from the Harwell library.
!
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
!
      IF (T.LE.0) THEN
        BRILL = 1.
        GOTO 100
      ELSEIF (T.GE.TN) THEN
        BRILL = 0.
        GOTO 100
      ENDIF
      K = 0
      NUM = 0
      B = 1.
      ERR = .0001
      MAXIT = 100
      X = 0.002
      GOTO 1
    5 CALL NB01A(K,A,B,ERR,X,Y,MAXIT)
      GOTO (1,2,3,4), K
!
    1 S2 = (2*S+1)/(2*S)
      Z = 3*X*S*TN/((S+1)*T)
      Y = X - (S2/TANH(S2*Z)) + (1./(TANH(Z/(2*S))*2*S))
      IF (K.EQ.1) GOTO 5
      IF (Y.LE.ERR) THEN
        X = 2*X
        GOTO 1
      ENDIF
      A = X
      GOTO 5
!
    2 BRILL = X
      GOTO 100
!
    3 K = 0
      B = A
      A = A/2.
      NUM = NUM + 1
      IF (NUM.LE.10) GOTO 5
      I = 0
    6 WRITE (ITO,3000) I, T, TN, S
      WRITE (LPT,3000) I, T, TN, S
      BRILL = -1
      GOTO 100
!
    4 I = 1
      GOTO 6
!
  100 RETURN
 3000 FORMAT (' ERROR **',I2,' calculating Brillouin function: ',3F8.2)
      END FUNCTION BRILL
!*==TRINV3.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE TRINV3(A,D)
      SUBROUTINE TRINV3(A,D)
!
! *** TRINV3 by JCM ***
!
!X
!C 12C
!H Replaces a 3x3 matrix by the transpose of its inverse.
!A On entry A holds a 3x3 real matrix
!A On exit  D is the value of the determinant of the matrix.
!A          A has been replaced by its inverse
!D If D is less than 10E-5 no replacement takes place.
!
      DIMENSION A(9), P(9)
      D = 0.
      II = 0
      IO = 0
      JO = 3
      KO = 6
      DO IC = 1, 3
        J = 2
        K = 3
        DO I = 1, 3
          II = II + 1
          P(II) = A(JO+J)*A(KO+K) - A(JO+K)*A(KO+J)
          J = K
          K = I
        ENDDO
        D = D + P(II)*A(II)
        JO = KO
        KO = IO
        IO = IO + 3
      ENDDO
      IF (ABS(D).LT.10.E-5) GOTO 100
      DO I = 1, 9
        A(I) = P(I)/D
      ENDDO
  100 RETURN
      END SUBROUTINE TRINV3
!*==VA05A.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE VA05A(M,N,F,X,DSTEP,DMAX,ACC,MAXFUN,IPRINT,W)
      SUBROUTINE VA05A(M,N,F,X,DSTEP,DMAX,ACC,MAXFUN,IPRINT,W)
!
! *** VA05A updated by JCM from HARWELL ***
!
!X
!C 6C
!H Minimises the sum of squares of given functions without requiring
!H the explicit calculation of derivatives.
!A On entry M,N,X,DSTEP,DMAX,ACC,MAXFUN,IPRINT,W should be set according to the
!A          specification of VA05A
!A On exit  X is set to contain the refined values of the parameters
!A          F is set to the corresponding function values
!P A routine called CALFUN(M,N,F,X) must be provided to set the array F
!
!N IPRINT must be the name of an integer, NOT an explicit integer
!
      DIMENSION F(1), X(1), W(1)
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
!
! MAXC COUNTS CALLS OF CALFUN:
      MAXC = 0
      MPN = M + N
!     'NT' AND 'NTEST' CAUSE AN ERROR RETURN IF F(X) DOES NOT DECREASE
      NT = N + 2
      NTEST = 0
!     'DTEST' IS USED IN A TEST TO MAINTAIN LINEAR INDEPENDENCE
      DTEST = FLOAT(N+N) - 0.5
!     PARTITION THE WORKING SPACE ARRAY W
!     THE FIRST PARTITION HOLDS THE JACOBIAN APPROXIMATION
      NWI = M*N
!     THE NEXT PARTITION HOLDS THE GENERALIZED INVERSE
      NWX = NWI + MPN*N
!     THE NEXT PARTITION HOLDS THE BEST VECTOR X
      NWF = NWX + N
!     THE NEXT PARTITION HOLDS THE BEST VECTOR F
      NWC = NWF + M
!     THE NEXT PARTITION HOLDS THE COUNTS OF THE INDEPENDENT DIRECTIONS
      NWD = NWC + N
!     THE NEXT PARTITION HOLDS THE INDEPENDENT DIRECTIONS
      NWW = NWD + N*N
!     THE REMAINDER OF W IS USED FOR SCRATCH VECTORS
      NWV = NWW + N
      NWT = NWV + M
      NWU = NWT + N
!     USUALLY 'FMIN' IS THE LEAST CALCULATED VALUE OF F(X)
      FMIN = -1.
!     USUALLY 'DD' IS THE SQUARE OF THE CURRENT STEP LENGTH
      DD = 0.
      DSS = DSTEP*DSTEP
      DM = DMAX*DMAX
!     'PARM' IS THE LEAST VALUE OF THE MARQUARDT PARAMETER
      PARM = SQRT(ACC)/DMAX
!     'DPAR' AND 'NTPAR' ARE USED TO REGULATE THE MARQUARDT PARAMETER
      DPAR = 10.*DM
!     'IS' CONTROLS A GO TO STATEMENT FOLLOWING A CALL OF CALFUN
      IS = 4
      IC = 0
!     'TINC' IS USED IN THE CRITERION TO INCREASE THE STEP LENGTH
      TINC = 1.
!
!     START A NEW PAGE FOR PRINTING
      IF (IPRINT.NE.0) THEN
        CALL NEWPAG(LPT)
        CALL MESS(LPT,0,'   THE FOLLOWING OUTPUT IS PROVIDED BY '//     &
     &            'SUBROUTINE VA05A')
        CALL NEWLIN(LPT)
        CALL NEWLIN(LPT)
        IPC = 0
      ENDIF
      GOTO 3
!
!     TEST WHETHER THERE HAVE BEEN MAXFUN CALLS OF CALFUN
    4 IF (MAXFUN.GT.MAXC) GOTO 3
      IF (IPRINT.EQ.0) THEN
        IPRINT = 2
        GOTO 19
      ELSE
        WRITE (LPT,3000) MAXC
        WRITE (ITO,3000) MAXC
        GOTO 7
      ENDIF
!
!     CALL THE SUBROUTINE CALFUN
    3 MAXC = MAXC + 1
      CALL CALFUN(M,N,F,X)
!     CALCULATE THE SUM OF SQUARES
      FSQ = 0.
      DO I = 1, M
        FSQ = FSQ + F(I)*F(I)
      ENDDO
!     TEST FOR ERROR RETURN BECAUSE F(X) DOES NOT DECREASE
      GOTO (9,10,9,10), IS
    9 IF (FSQ.LT.FMIN) GOTO 11
      IF (DD.GT.DSS) GOTO 10
      NTEST = NTEST - 1
      IF (NTEST.GT.0) GOTO 10
      IF (IPRINT.NE.0) GOTO 15
      IPRINT = 1
      GOTO 19
   15 WRITE (LPT,3001)
      WRITE (ITO,3001)
!     PROVIDE PRINTING OF FINAL SOLUTION IF REQUESTED
    7 IF (IPRINT.EQ.0) GOTO 19
      WRITE (LPT,2001) MAXC
 2001 FORMAT (///5X,'THE FINAL SOLUTION CALCULATED BY VA05A REQUIRED',  &
     &        I5,' CALLS OF CALFUN, AND IS')
      WRITE (LPT,2002) (I,W(NWX+I),I=1,N)
      WRITE (LPT,2003) (I,W(NWF+I),I=1,M)
      WRITE (LPT,2004) FMIN
!     RESTORE THE BEST VALUES OF X AND F
   19 DO I = 1, N
        X(I) = W(NWX+I)
      ENDDO
      DO I = 1, M
        F(I) = W(NWF+I)
      ENDDO
      GOTO 100
!
   11 NTEST = NT
!     PROVIDE ORDINARY PRINTING IF REQUESTED
   10 IF (IABS(IPRINT)-1) 39, 38, 40
   38 WRITE (LPT,2005) MAXC
 2005 FORMAT (///5X,'AT THE',I5,' TH CALL OF CALFUN WE HAVE')
   42 WRITE (LPT,2002) (I,X(I),I=1,N)
      WRITE (LPT,2004) FSQ
      IF (IPRINT.GT.0) WRITE (LPT,2003) (I,F(I),I=1,M)
      GOTO 39
!
   40 IPC = IPC - 1
      IF (IPC.GT.0) GOTO 39
      WRITE (LPT,2006) MAXC
 2006 FORMAT (///5X,'THE BEST ESTIMATE AFTER',I5,' CALLS OF CALFUN IS')
      IPC = IABS(IPRINT)
      IF (FSQ.LT.FMIN) GOTO 42
      IF (FMIN.LT.0) GOTO 42
      WRITE (LPT,2002) (I,W(NWX+I),I=1,N)
      WRITE (LPT,2004) FMIN
      IF (IPRINT.GT.0) WRITE (LPT,2003) (I,W(NWF+I),I=1,M)
!
   39 GOTO (49,47,47,48), IS
!     STORE THE INITIAL VECTORS X AND F
   48 IF (IC.GT.0) GOTO 51
      DO I = 1, N
        W(NWX+I) = X(I)
      ENDDO
      GOTO 54
!
!     CALCULATE THE INITIAL JACOBIAN APPROXIMATION
   51 K = IC
      DO I = 1, M
        W(K) = (F(I)-W(NWF+I))/DSTEP
        K = K + N
      ENDDO
!     TEST WHETHER THE MOST RECENT X IS BEST
      IF (FMIN.GT.FSQ) GOTO 57
      X(IC) = W(NWX+IC)
      GOTO 58
!
   57 W(NWX+IC) = X(IC)
   54 DO I = 1, M
        W(NWF+I) = F(I)
      ENDDO
      FMIN = FSQ
!
!     SET X FOR THE NEXT CALL OF CALFUN
   58 IC = IC + 1
      IF (IC.GT.N) GOTO 60
      X(IC) = W(NWX+IC) + DSTEP
      GOTO 3
!     SET THE DIRECTION MATRIX
   60 K = NWD
      DO I = 1, N
        DO J = 1, N
          K = K + 1
          W(K) = 0.
        ENDDO
        W(K+I-N) = 1.
        W(NWC+I) = 1. + FLOAT(N-I)
      ENDDO
!     SET THE MARQUARDT PARAMETER TO ITS LEAST VALUE
   24 PAR = PARM
!     COPY THE JACOBIAN AND APPEND THE MARQUARDT MATRIX
   25 PPAR = PAR*PAR
      NTPAR = 0
   63 KK = 0
      K = NWI + NWI
      DO I = 1, N
        DO J = 1, M
          KK = KK + 1
          W(KK+NWI) = W(KK)
        ENDDO
        DO J = 1, N
          K = K + 1
          W(K) = 0.
        ENDDO
        W(K+I-N) = PAR
      ENDDO
!     CALCULATE THE GENERALIZED INVERSE OF J
      CALL MB11A(N,MPN,W(NWI+1),N,W(NWW+1))
!     NOTE THAT THE THIRD AND FIFTH ENTRIES OF THIS ARGUMENT LIST
!     STAND FOR ONE-DIMENSIONAL ARRAYS.
!     START THE ITERATION BY TESTING FMIN
   64 IF (FMIN.LE.ACC) GOTO 7
!     NEXT PREDICT THE DESCENT AND MARQUARDT MINIMA
      DS = 0.
      DN = 0.
      SP = 0.
      DO I = 1, N
        X(I) = 0.
        F(I) = 0.
        K = I
        DO J = 1, M
          X(I) = X(I) - W(K)*W(NWF+J)
          F(I) = F(I) - W(NWI+K)*W(NWF+J)
          K = K + N
        ENDDO
        DS = DS + X(I)*X(I)
        DN = DN + F(I)*F(I)
        SP = SP + X(I)*F(I)
      ENDDO
!     PREDICT THE REDUCTION IN F(X) DUE TO THE MARQUARDT STEP
!     AND ALSO PREDICT THE LENGTH OF THE STEEPEST DESCENT STEP
      PRED = SP + SP
      DMULT = 0.
      K = 0
      DO I = 1, M
        AP = 0.
        AD = 0.
        DO J = 1, N
          K = K + 1
          AP = AP + W(K)*F(J)
          AD = AD + W(K)*X(J)
        ENDDO
        PRED = PRED - AP*AP
        DMULT = DMULT + AD*AD
      ENDDO
!     TEST FOR CONVERGENCE
      IF (DN.GT.DM) GOTO 29
      AP = SQRT(DN)
      IF (PRED+2.*PPAR*AP*(DMAX-AP)-ACC) 7, 7, 70
   29 IF (PRED+PPAR*(DM-DN)-ACC) 7, 7, 70
!     TEST WHETHER TO APPLY THE FULL MARQUARDT CORRECTION
   70 DMULT = DS/DMULT
      DS = DS*DMULT*DMULT
   71 IS = 2
      IF (DN.GT.DD) GOTO 73
!     TEST THAT THE MARQUARDT PARAMETER HAS ITS LEAST VALUE
      IF (PAR.GT.PARM) GOTO 24
      DD = AMAX1(DN,DSS)
      DS = 0.25*DN
      TINC = 1.
      IF (DN.GE.DSS) GOTO 132
      IS = 3
      GOTO 103
!
!     TEST WHETHER TO INCREASE THE MARQUARDT PARAMETER
   73 IF (DN.GT.DPAR) GOTO 32
      NTPAR = 0
      GOTO 33
   32 IF (NTPAR.GT.0) GOTO 35
      NTPAR = 1
      PTM = DN
      GOTO 33
   35 NTPAR = NTPAR + 1
      PTM = AMIN1(PTM,DN)
      IF (NTPAR.LT.NT) GOTO 33
!     SET THE LARGER VALUE OF THE MARQUARDT PARAMETER
      PAR = PAR*(PTM/DM)**0.25
      IF (6.*DD.GE.DM) GOTO 25
      AP = SQRT(PRED/DN)
      IF (AP.LE.PAR) GOTO 25
      PAR = AMIN1(AP,PAR*(DM/(6.*DD))**0.25)
      GOTO 25
!
!     TEST WHETHER TO USE THE STEEPEST DESCENT DIRECTION
   33 IF (DS.LT.DD) GOTO 75
!     TEST WHETHER THE INITIAL VALUE OF DD HAS BEEN SET
      IF (DD.GT.0.) GOTO 78
      DD = AMIN1(DM,DS)
      IF (DD.GE.DSS) GOTO 78
      DD = DSS
      GOTO 71
!
!     SET THE MULTIPLIER OF THE STEEPEST DESCENT DIRECTION
   78 ANMULT = 0.
      DMULT = DMULT*SQRT(DD/DS)
      GOTO 80
!     INTERPOLATE BETWEEN THE STEEPEST DESCENT AND MARQUARDT DIRECTIONS
   75 SP = SP*DMULT
      ANMULT = (DD-DS)/((SP-DS)+SQRT((SP-DD)**2+(DN-DD)*(DD-DS)))
      DMULT = DMULT*(1.-ANMULT)
!     CALCULATE THE CORRECTION TO X, AND ITS ANGLE WITH THE FIRST
!     DIRECTION
   80 DN = 0.
      SP = 0.
      DO I = 1, N
        F(I) = DMULT*X(I) + ANMULT*F(I)
        DN = DN + F(I)*F(I)
        SP = SP + F(I)*W(NWD+I)
      ENDDO
      DS = 0.25*DN
!     TEST WHETHER AN EXTRA STEP IS NEEDED FOR INDEPENDENCE
      IF (W(NWC+1).LE.DTEST) GOTO 132
      IF (SP*SP.GE.DS) GOTO 132
!
!     TAKE THE EXTRA STEP AND UPDATE THE DIRECTION MATRIX
   83 DO I = 1, N
        X(I) = W(NWX+I) + DSTEP*W(NWD+I)
        W(NWC+I) = W(NWC+I+1) + 1.
      ENDDO
      W(NWD) = 1.
      IF (N.LE.1) GOTO 4
      DO I = 1, N
        K = NWD + I
        SP = W(K)
        DO J = 2, N
          W(K) = W(K+N)
          K = K + N
        ENDDO
        W(K) = SP
      ENDDO
      GOTO 4
!     EXPRESS THE NEW DIRECTION IN TERMS OF THOSE OF THE DIRECTION
!     MATRIX, AND UPDATE THE COUNTS IN W(NWC+1) ETC.
  132 IF (N.GE.2) GOTO 153
      IS = 1
      GOTO 152
  153 SP = 0.
      K = NWD
      DO I = 1, N
        X(I) = DW
        DW = 0.
        DO J = 1, N
          K = K + 1
          DW = DW + F(J)*W(K)
        ENDDO
        GOTO (89,90), IS
   90   W(NWC+I) = W(NWC+I) + 1.
        SP = SP + DW*DW
        IF (SP.LE.DS) GOTO 87
        IS = 1
        KK = I
        X(1) = DW
        GOTO 92
   89   X(I) = DW
   92   W(NWC+I) = W(NWC+I+1) + 1.
   87 ENDDO
      W(NWD) = 1.
!     REORDER THE DIRECTIONS SO THAT KK IS FIRST
      IF (KK.LE.1) GOTO 93
      KS = NWC + KK*N
      DO I = 1, N
        K = KS + I
        SP = W(K)
        DO J = 2, KK
          W(K) = W(K-N)
          K = K - N
        ENDDO
        W(K) = SP
      ENDDO
!     GENERATE THE NEW ORTHOGONAL DIRECTION MATRIX
   93 DO I = 1, N
        W(NWW+I) = 0.
      ENDDO
      SP = X(1)*X(1)
      K = NWD
      DO I = 2, N
        DS = SQRT(SP*(SP+X(I)*X(I)))
        DW = SP/DS
        DS = X(I)/DS
        SP = SP + X(I)*X(I)
        DO J = 1, N
          K = K + 1
          W(NWW+J) = W(NWW+J) + X(I-1)*W(K)
          W(K) = DW*W(K+N) - DS*W(NWW+J)
        ENDDO
      ENDDO
      SP = 1./SQRT(DN)
      DO I = 1, N
        K = K + 1
        W(K) = SP*F(I)
      ENDDO
!     PREDICT THE NEW RIGHT HAND SIDES
  152 FNP = 0.
      K = 0
      DO I = 1, M
        W(NWW+I) = W(NWF+I)
        DO J = 1, N
          K = K + 1
          W(NWW+I) = W(NWW+I) + W(K)*F(J)
        ENDDO
        FNP = FNP + W(NWW+I)**2
      ENDDO
!     CALCULATE THE NEXT VECTOR X, AND THEN CALL CALFUN
  103 DO I = 1, N
        X(I) = W(NWX+I) + F(I)
      ENDDO
      GOTO 4
!     UPDATE THE STEP SIZE
   49 DMULT = 0.9*FMIN + 0.1*FNP - FSQ
      IF (DMULT.GE.0.) GOTO 108
      DD = AMAX1(DSS,0.25*DD)
      TINC = 1.
      IF (FSQ-FMIN) 106, 107, 107
!     TRY THE TEST TO DECIDE WHETHER TO INCREASE THE STEP LENGTH
  108 SP = 0.
      SS = 0.
      DO I = 1, M
        SP = SP + ABS(F(I)*(F(I)-W(NWW+I)))
        SS = SS + (F(I)-W(NWW+I))**2
      ENDDO
      PJ = 1. + DMULT/(SP+SQRT(SP*SP+DMULT*SS))
      SP = AMIN1(4.,TINC,PJ)
      TINC = PJ/SP
      DD = AMIN1(DM,SP*DD)
      GOTO 106
!     IF F(X) IMPROVES STORE THE NEW VALUE OF X
   47 IF (FSQ.GE.FMIN) GOTO 110
  106 FMIN = FSQ
      DO I = 1, N
        SP = X(I)
        X(I) = W(NWX+I)
        W(NWX+I) = SP
      ENDDO
      DO I = 1, M
        SP = F(I)
        F(I) = W(NWF+I)
        W(NWF+I) = SP
      ENDDO
  110 GOTO (107,107,113), IS
  113 IS = 2
      IF (FMIN-ACC) 7, 7, 83
!     CALCULATE THE CHANGES IN X AND IN F
  107 DS = 0.
      DO I = 1, N
        X(I) = X(I) - W(NWX+I)
        DS = DS + X(I)*X(I)
      ENDDO
      DO I = 1, M
        F(I) = F(I) - W(NWF+I)
      ENDDO
!     CALCULATE THE GENERALIZED INVERSE TIMES THE CHANGE IN X
      K = NWI
      SS = 0.
      DO I = 1, MPN
        SP = 0.
        DO J = 1, N
          K = K + 1
          SP = SP + W(K)*X(J)
        ENDDO
        W(NWV+I) = SP
        SS = SS + SP*SP
      ENDDO
!     CALCULATE J TIMES THE CHANGE IN F
!     ALSO APPLY PROJECTION TO THE GENERALIZED INVERSE
      DO I = 1, N
        ST = 0.
        K = NWI + I
        DO J = 1, MPN
          ST = ST + W(K)*W(J+NWV)
          K = K + N
        ENDDO
        ST = ST/SS
        K = NWI + I
        DO J = 1, MPN
          W(K) = W(K) - ST*W(J+NWV)
          K = K + N
        ENDDO
        ST = PPAR*X(I)
        K = I
        DO J = 1, M
          ST = ST + W(K)*F(J)
          K = K + N
        ENDDO
        W(NWW+I) = ST
      ENDDO
!     REVISE J AND CALCULATE ROW VECTOR FOR CORRECTION TO INVERSE
      IC = 0
      K = 0
      KK = NWI
      SP = 0.
      SPP = 0.
      DO I = 1, M
        SS = F(I)
        ST = F(I)
        DO J = 1, N
          IC = IC + 1
          KK = KK + 1
          SS = SS - W(IC)*X(J)
          ST = ST - W(KK)*W(NWW+J)
        ENDDO
        SS = SS/DS
        W(NWV+I) = ST
        SP = SP + F(I)*ST
        SPP = SPP + ST*ST
        DO J = 1, N
          K = K + 1
          W(K) = W(K) + SS*X(J)
        ENDDO
      ENDDO
      DO I = 1, N
        ST = PAR*X(I)
        DO J = 1, N
          KK = KK + 1
          ST = ST - W(KK)*W(NWW+J)
        ENDDO
        W(NWT+I) = ST
        SP = SP + PAR*X(I)*ST
        SPP = SPP + ST*ST
      ENDDO
!     TEST THAT THE SCALAR PRODUCT IS SUFFICIENTLY ACCURATE
      IF (0.01*SPP-ABS(SP-SPP)) 63, 63, 127
!     CALCULATE THE NEW GENERALIZED INVERSE
  127 DO I = 1, N
        K = NWI + I
        ST = X(I)
        DO J = 1, M
          ST = ST - W(K)*F(J)
          K = K + N
        ENDDO
        SS = 0.
        DO J = 1, N
          SS = SS + W(K)*X(J)
          K = K + N
        ENDDO
        ST = (ST-PAR*SS)/SP
        K = NWI + I
        DO J = 1, MPN
          W(K) = W(K) + ST*W(NWV+J)
          K = K + N
        ENDDO
      ENDDO
      GOTO 64
!
  100 RETURN
 3000 FORMAT (///5X,'ERROR RETURN FROM VA05A BECAUSE THERE HAVE BEEN',  &
     &        I5,' CALLS OF CALFUN')
 3001 FORMAT (///5X,'ERROR RETURN FROM VA05A BECAUSE F(X) NO LONGER',   &
     &        ' DECREASES'//5X,'THIS MAY BE DUE TO THE VALUES OF DSTEP',&
     &        ' AND ACC, OR TO LOSS OF RANK IN THE JACOBIAN MATRIX')
 2002 FORMAT (//4X,'I',7X,'X(I)',10X,'I',7X,'X(I)',10X,'I',7X,'X(I)',   &
     &        10X,'I',7X,'X(I)',10X,'I',7X,'X(I)'//5(I5,E17.8))
 2003 FORMAT (//4X,'I',7X,'F(I)',10X,'I',7X,'F(I)',10X,'I',7X,'F(I)',   &
     &        10X,'I',7X,'F(I)',10X,'I',7X,'F(I)'//5(I5,E17.8))
 2004 FORMAT (/5X,'THE SUM OF SQUARES IS',E17.8)
      END SUBROUTINE VA05A
!*==SID.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE SID(A,N,ND1,ND2,D)
      SUBROUTINE SID(A,N,ND1,ND2,D)
!
! *** SID from PJB by A. Bartelemy ***
!
!X
!C 12C
!H Solves a set of simultaneous linear equations.
!A  A   is an N by N+1 sized matrix written in a table of dimension ND1
!A      by ND2
!A  On entry A(1:N,1:N) contains the matrix of coefficients
!A           A(1:N,N+1) contains the column of right-hand sides
!A  On exit  D is the value of the determinant
!A           A(1:N,N+1) contains the solution if D is not zero
!
!  SUBROUTINE *** SID ***         A BARTHELEMY  19/2/75        *
!  INVERSION DE MATRICE AVEC CALCUL DE DETERMINANT             *
!  MATRICE A(N,N+1)    DANS TABLEAU (ND1,ND2)                  *
!   EN ENTREE POUR APPEL PAR RAFIN MAIN :                      *
!        A(I=1 A N,J=1 A N)=AMAT                               *
!        A(I=1 A N,J=N+1  )=VVEC                               *
!  N=NOMBRE DE COLONNES DE A                                   *
!
      DIMENSION II(16), IL(16), IG(16), A(ND1,ND2)
!
      M = N + 1
      D = 1.
      IS = N - 1
      DO K = 1, N
        IL(K) = 0
        IG(K) = K
      ENDDO
!
!.....
      DO K = 1, N
        R = 0.
        DO I = 1, N
          IF (IL(I).NE.0) GOTO 40
          W = A(I,K)
          X = ABS(W)
          IF (X.LT.R) GOTO 40
          R = X
          P = W
          KF = I
   40   ENDDO
!
        II(K) = KF
        IL(KF) = KF
        D = D*P
!.....ERROR NUL DETERMINANT
        IF (D.EQ.0.) GOTO 100
!
        DO I = 1, N
          IF (I.EQ.KF) THEN
            A(I,K) = 1./P
          ELSE
            A(I,K) = -A(I,K)/P
          ENDIF
        ENDDO
!
        DO J = 1, M
          IF (J.EQ.K) GOTO 140
          W = A(KF,J)
          IF (W.EQ.0.) GOTO 140
          DO I = 1, N
            IF (I.EQ.KF) THEN
              A(I,J) = W/P
            ELSE
              A(I,J) = A(I,J) + W*A(I,K)
            ENDIF
          ENDDO
  140   ENDDO
!
      ENDDO
!.....
!
      DO K = 1, IS
        KF = II(K)
        KL = IL(KF)
        KG = IG(K)
        IF (KF.EQ.KG) GOTO 190
!
        DO I = 1, N
          R = A(I,KF)
          A(I,KF) = A(I,KG)
          A(I,KG) = R
        ENDDO
!
        DO J = 1, M
          R = A(K,J)
          A(K,J) = A(KL,J)
          A(KL,J) = R
        ENDDO
!
        IL(KF) = K
        IL(KG) = KL
        IG(KL) = IG(K)
        IG(K) = KF
        D = -D
  190 ENDDO
  100 RETURN
      END SUBROUTINE SID
!*==JTERMS.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE JTERMS(G,R,H,S)
      SUBROUTINE JTERMS(G,R,H,S)
!
! *** JTERMS by PJB 17 Jan 85 ***
!
!X
!C 9C
!H Calculates the terms in the 2D averaged spherically symmetric form factor
!H summation which depend on S,K, and R only.
!
      COMMON /CONSTA/ PI, RAD, DEG, TWOPI, FOURPI, PIBY2, ALOG2, SQL2X8,&
     &                VALMUB
!
!     TEST FOR SPECIAL CASES:
      IF (H.LT.001) GOTO 1
      IF (S.LT..001) GOTO 2
      IF (ABS(H-S).LT..001) GOTO 3
      G = H*BJ(1,H*R)*BJ(0,S*R) - S*BJ(1,S*R)*BJ(0,H*R)
      G = TWOPI*G*R/(H*H-S*S)
      GOTO 100
    1 IF (S.LT..001) GOTO 4
      G = TWOPI*R*BJ(1,S*R)/S
      GOTO 100
    2 G = TWOPI*R*BJ(1,H*R)/H
      GOTO 100
    3 G = PI*R*R*(BJ(1,H*R)*BJ(1,S*R)+BJ(0,H*R)*BJ(0,S*R))
      GOTO 100
    4 G = PI*R*R
  100 RETURN
      END SUBROUTINE JTERMS
!*==JGMPRD.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE JGMPRD(JA,JB,JC,NI,NJ,NK)
      SUBROUTINE JGMPRD(JA,JB,JC,NI,NJ,NK)
!
! *** JGMPRD by JCM Jun 88 ***
!
!X
!C 12C
!H In integers, sets matrix C = matrix A times matrix B.
!A On entry JA is an integer matrix of dimension NIxNJ
!A          JB is an integer matrix of dimension NJxNK
!A On exit  JC is an integer matrix of dimension NIxNK, being JA times JB
!
      DIMENSION JA(1), JB(1), JC(1)
      DO I = 1, NI
        IK = I
        JK = 1
        DO K = 1, NK
          IJ = I
          JC(IK) = 0.
          DO J = 1, NJ
            JC(IK) = JC(IK) + JA(IJ)*JB(JK)
            IJ = IJ + NI
            JK = JK + 1
          ENDDO
          IK = IK + NI
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE JGMPRD
!*==JGMREV.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE JGMREV(JA,JB,NI,NJ)
      SUBROUTINE JGMREV(JA,JB,NI,NJ)
!
! *** JGMREV by JCM Jun 88 ***
!
!X
!C 12C
!H Reverses the signs of the elements of an integer matrix.
!A On entry JA is an integer matrix of dimension NIxNJ
!A On exit  JB is an integer matrix, being a copy of JA with reversed signs.
!N JB may be the same as JA.
!
      DIMENSION JA(NI,NJ), JB(NI,NJ)
      DO I = 1, NI
        DO J = 1, NJ
          JB(I,J) = -JA(I,J)
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE JGMREV
!*==JGMSUB.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE JGMSUB(JA,JB,JC,NI,NJ)
      SUBROUTINE JGMSUB(JA,JB,JC,NI,NJ)
!
! *** JGMSUB by JCM Jun 88 ***
!
!X
!C 12C
!H In integers, sets matrix C = matrix A minus matrix B.
!A On entry JA and JB are integer matrices of dimension NIxNJ
!A On exit  JC is an integer matrix = JA - JB
!
      DIMENSION JA(1), JB(1), JC(1)
      NIJ = NI*NJ
      DO I = 1, NIJ
        JC(I) = JA(I) - JB(I)
      ENDDO
      RETURN
      END SUBROUTINE JGMSUB
!*==CMIMAG.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE CMIMAG(A,B,I,J)
      SUBROUTINE CMIMAG(A,B,I,J)
!
! *** CMIMAG by PJB Nov 89 ***
!
!X
!C 12C
!H Gives the imaginary parts of a COMPLEX matrix.
!A On entry A is a complex I by J matrix
!A On exit the I by J real matrix B contains the imaginary parts of A
!
      COMPLEX A(I,J)
      DIMENSION B(I,J)
      DO II = 1, I
        DO JJ = 1, J
          B(II,JJ) = AIMAG(A(II,JJ))
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE CMIMAG
!*==CMREAL.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE CMREAL(A,B,I,J)
      SUBROUTINE CMREAL(A,B,I,J)
!
! *** CMREAL by PJB Nov 89 ***
!
!X
!C 12C
!H Gives the real parts of a COMPLEX matrix.
!A On entry A is a complex I by J matrix
!A On exit the I by J real matrix B contains the real parts of A
!
      COMPLEX A(I,J)
      DIMENSION B(I,J)
      DO II = 1, I
        DO JJ = 1, J
          B(II,JJ) = REAL(A(II,JJ))
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE CMREAL
!*==CRSCLP.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 1      COMPLEX FUNCTION CRSCLP(A,B)
      COMPLEX FUNCTION CRSCLP(A,B)
!
! *** CRSCLP by PJB Nov 89 ***
!
!X
!C 12C
!H Finds the COMPLEX scalar product of a COMPLEX with a REAL vector.
!A On entry A is a complex vector of dimension 3
!A          B is a real vector of dimension 3 in a space orthogonal to
!A            that of A
!D On exit the function value is the scalar product of A and B
!
      COMPLEX A(3), C
      DIMENSION B(3)
      C = CMPLX(0.,0.)
      DO I = 1, 3
        C = C + A(I)*B(I)
      ENDDO
      CRSCLP = C
      RETURN
      END FUNCTION CRSCLP
!
!*****************************************************************************
!
! Originally in Fcn.f90
!
      SUBROUTINE FCN_PRT(N,THETA,H)


!
      use winteracter
      use druid_header
!
      DOUBLE PRECISION THETA(*), H

      INCLUDE 'PARAMS.INC'

      integer ioptb,iopta,ioptt,iz1,iz2,iz3
      common /zmcomi/ ntatm,natoms(maxfrg),&
      ioptb(maxatm,maxfrg),iopta(maxatm,maxfrg),ioptt(maxatm,maxfrg),&
      iz1(maxatm,maxfrg),iz2(maxatm,maxfrg),iz3(maxatm,maxfrg)
      common /zmcomg/ icomflg(maxfrg)

      call makefrac_prt(theta,n,6)
      call valchi(snglh)
      h=dble(snglh)

      RETURN

      END
!
!*****************************************************************************
!
! Originally in Plot_SA_Profile.f90
!
      subroutine Plot_SA_profile()

      CALL IGrArea(0.0,0.0,1.0,1.0)
      CALL IGrUnits(0.,0.,1.,1.)
      CALL IGrAreaClear
      CALL IGrCharFont(1)
      CALL IGrColourN(159)
      CALL IPgScaling('LIN','LIN')
!
!
      CALL WDialogGetRadioButton(IDF_ProfileType_Radio1,IRAD_ProfileType)
      SELECT CASE (IRAD_ProfileType)
          CASE (1)
! Observed and calculated profiles
              CALL IPgNewGraph(3,nobs,' ',' ','XY')
              yshift=0.5*(ypgmax-ypgmin)
          CASE (2)
! The difference profile
              CALL IPgNewGraph(2,nobs,' ',' ','XY')
              yshift=0.5*(ypmax-ypmin)
      END SELECT
!
      DO I=1,NOBS
        ydif(i)=yshift+yobs(i)-ycalbest(i)
      END DO
!
!  draw axes and add scales
!
      CALL IPgAxes
      CALL IPgArea(.12,.12,.9,.95)
      CALL IPgUnits(xpgmin,ypgmin,xpgmax,ypgmax)
      CALL IPgClipRectangle('P')
      CALL IPgBorder()
      CALL IGrCharSize(1.,1.)
      CALL IPgXScale('TN')
      CALL IPgXScaleTop('T')
      CALL IGrCharSize(1.,1.2)
      CALL IPgYScaleLeft('TN')
      CALL IPgYScaleRight('T')
      CALL IGrCharSize(1.,1.2)
      CALL IPgXLabel('2 theta','C')
!
      SELECT CASE (IRAD_ProfileType)
          CASE (1)
! Observed and calculated profiles
            CALL IPgYLabelLeft('Counts','C9')
            CALL IPgStyle(1,0,0,0,4,0)
            CALL IPgStyle(2,0,3,0,0,31)
            CALL IPgMarker( 2, 14)
            CALL IPgStyle(3,0,0,0,159,0)
            CALL IPgXYPairs(xobs,ydif)
            CALL IGrCharSize(.3,.3)
            CALL IPgXYPairs(xobs,yobs)
            CALL IPgXYPairs(xobs,ycalbest)
          CASE (2)
! The difference profile
            CALL IPgYLabelLeft('Difference profile','C9')
            CALL IPgStyle(1,0,0,0,4,0)
            CALL IPgStyle(2,0,0,0,159,0)
            CALL IPgXYPairs(xobs,yobs)
            CALL IPgXYPairs(xobs,ydif)
      END SELECT
      end subroutine Plot_SA_profile
!
!*****************************************************************************
!
! Originally in pr.for
!
!*==WRINST.f90  processed by SPAG 6.11Dc at 13:14 on 17 Sep 2001
!
!
!
!
! LEVEL 2      SUBROUTINE WRINST(N)
      SUBROUTINE WRINST(N)
!
! *** WRINST by JCM 13 Aug 91 ***
!
!H Set and write first 155 elements of IWORK, instument parameters etc,
!H for TIC & PICTIC
!A On entry N=no. of points to set in IWORK(55)
!
      INCLUDE 'params.inc'
!
      COMMON /FCCDAT/ DATFIL, INSTNM, LONGTI, RUNUSR, STTIME, WSHIST,   &
     &                XCAPT, YCAPT, MCAPT
      CHARACTER DATFIL*80, INSTNM*8, LONGTI*80, RUNUSR*20, STTIME*20,   &
     &          WSHIST*200, XCAPT*40, YCAPT*40, MCAPT*40
!
      COMMON /FOCDAT/ NOTC, NCYMIN, NCYMAX, DELTA, LDFIL, FI, INSTCO,   &
     &                INSTST, NXCODE, LNPDFN, AL1, AL2, NOSPEC, NPT,    &
     &                NUMRUN, RUNDUR, TTHET, XMN, XMX, YMN, YMX, NYCODE,&
     &                NEMODE, EFIXED, USERPR(30), TDATA(MFOCDA),        &
     &                OBSDAT(MFOCDA), CALDAT(33000),      &
     &                ERR(MFOCDA), STADAT(MFOCDA), YRANGE, IUNIT
!
      COMMON /WORKG / IWORK(256)
      REAL RWORK(256)
      CHARACTER*1024 CWORK
! NON-STANDARD FORTRAN 77:
!VMS
      EQUIVALENCE (IWORK,CWORK)
      EQUIVALENCE (IWORK,RWORK)
!
      IWORK(1) = NCYMIN
      IWORK(2) = NCYMAX
      RWORK(3) = DELTA
      IWORK(4) = LDFIL
      CWORK(17:96) = DATFIL
      RWORK(25) = FI
      IWORK(26) = INSTCO
      CWORK(105:112) = INSTNM
      IWORK(29) = INSTST
      IWORK(30) = NXCODE
      IWORK(31) = LNPDFN
      RWORK(32) = AL1
      RWORK(33) = AL2
      CWORK(133:212) = LONGTI
      IWORK(54) = 1
! N SET AS INPUT ARGUMENT:
      IWORK(55) = N
      IWORK(56) = NUMRUN
      CWORK(225:244) = RUNUSR
      RWORK(62) = RUNDUR
      CWORK(249:268) = STTIME
      RWORK(68) = TTHET
      CWORK(273:472) = WSHIST
      RWORK(119) = XMN
      RWORK(120) = XMX
      RWORK(121) = YMN
      RWORK(122) = YMX
!* NOW RELYING ON CAPTS SET OUTSIDE
      CWORK(489:528) = XCAPT
      CWORK(529:568) = YCAPT
      CWORK(569:608) = MCAPT
      IWORK(153) = NYCODE
      IWORK(154) = NEMODE
      IWORK(155) = EFIXED
!
!      WRITE THIS DATA TO FILE
!
      CALL WRDATA(.FALSE.,IUNIT,IWORK,155)
      RETURN
      END SUBROUTINE WRINST
C
C
C LEVEL 11       SUBROUTINE SETICN(PCXX)
       SUBROUTINE SETICN(PCXX)
C
C *** SETTIC revised by JBF to deal with magnetism 2-Jun-95 ***
C
CH Prepare to write ASCII files by reading L cards and generating reflection
      EXTERNAL PCXX,DUMMY
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(5,5),
     & NLAMB,ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /LREAD/ILREA(22,5),KOM18
      DIMENSION ILREAD(22)
      EQUIVALENCE (ILREAD(1),ILREA(1,1))
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /PRPKCN/ARGK,PKCNSP(6,9,5),
     & KPCNSP(6,9,5),DTDPCN(6),DTDWL,
     & NPKCSP(9,5),ARGMIN(5),ARGMAX(5),
     & ARGSTP(5),PCON
      COMMON /PRZERO/ZEROSP(6,9,5),KZROSP(6,
     & 9,5),DKDZER(6),NZERSP(9,5)
      COMMON /REFIPR/RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
      LOGICAL RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
      COMMON /SOURCE/NSOURC,JSOURC,KSOURC,NDASOU(5),METHOD(
     & 9),NPFSOU(9,5),NSOBS(5),SCALES(5),
     & KSCALS(5),NPCSOU(9,5)
C
C READ RELEVANT L CARDS:
      CALL INPLPR(PCXX,DUMMY)
C
C DEAL WITH THE CARDS WHICH ARE DIFFERENT ACCORDING TO TYPE OF DIFFRACTION:
C
C TF:
C NEED L THE2 CARD GIVING 2 THETA DEGREES:
      IF (TOF) THEN
        IF (ILREAD(18) .EQ. 0)
     &  CALL ERRMES(2,1,'L THE2 card giving counter angle')
C FOR TF MUST HAVE L PKCN CARD:
        IF (ILREAD(7) .EQ. 0)
     &  CALL ERRMES(2,1,'L PKCN card giving peak centre')
      ELSE
C
C CN AND/OR LX - NEED L WVLN CARD:
        IF (ILREAD(13) .EQ. 0) THEN
          IF (CN) THEN
            ALAMBD(1,KSOURC)=1.900
            NLAMB=1
          ELSE IF (SR) THEN
            ALAMBD(1,KSOURC)=0.850000
            NLAMB=1
          ELSE IF (LX) THEN
            ALAMBD(1,KSOURC)=1.544390
            ALAMBD(2,KSOURC)=1.540562
            NLAMB=2
          ENDIF
          WRITE(LPT,2002) NLAMB,(ALAMBD(I,KSOURC),I=1,NLAMB)
2002      FORMAT (' ',I3,' Wavelength(s): ',5(1X,F9.6))
        ENDIF
        PKCNSP(1,JPHASE,JSOURC)=96.0505
        TWOTHD(JSOURC)=RADIAN(168.329)
      ENDIF
C
**??NOT USED ELSEWHERE:
C IF NO L ZERO CARD THEN ZEROPT=0:
      IF (ILREAD(8) .EQ. 0) ZEROSP(1,JPHASE,JSOURC)=0.
C
      CALL PCXX(6)
      WRITE (LPT,2018) STHLMX
2018  FORMAT (/' Maximum sin theta for generation of indices is',F10.4)
C
C GENERATE REFLECTIONS:
      CALL INRFPR(PCXX,DUMMY)
C
      RETURN
      END
C
!
!*****************************************************************************
!
! Originally in PutSimplexChisq.f90
!
      SUBROUTINE PutSimplexChisq(CCHI)

      USE WINTERACTER
      USE DRUID_HEADER

      CHARACTER*7 chistr

      COMMON /chitemcmn/ ncchi,ncchimin,cchimin

      cchimin=min(cchimin,cchi)
      if (cchi.eq.cchimin) then
        chistr(1:7)='0000.00'
        write(chistr(1:7),'(f7.2)') cchimin
        CALL WDialogSelect(IDD_SA_Action1)
        CALL WDialogPutString(IDF_Simplex_Now,chistr)
        call valchipro(cpb)
      end if

	 END SUBROUTINE PutSimplexChisq
!
!*****************************************************************************
!
! Originally in sa_upload.f90
!
      SUBROUTINE sa_upload
!
      USE WINTERACTER
      USE DRUID_HEADER
!
! Define some parameters to match those in the resource file
!
      double precision cen,sig
      logical gaussb
      character*80  inf_file,zm_file
      double precision x,lb,ub,vm,xpreset
      double precision T0,rt,eps,target_value
      common /inffil/ lfinf,lfzm,inf_file,zm_file
      parameter (maxfrg=20)
      common /frgcom/ nfrag,lfrag(maxfrg)
      character*80 frag_file
      common /frgcha/ frag_file(maxfrg)
      parameter (mvar=100)
      common /gaubou/ cen(mvar),sig(mvar)
      common /gaulog/ gaussb(mvar)
      character*80  torfile
      logical ltorfil
      common /torfcm/ torfile(mvar)
      common /torlog/ ltorfil(mvar)
      common /jitter/ rjittr
      common /values/ x(mvar),lb(mvar),ub(mvar),vm(mvar)
      common /presetr/ xpreset(mvar)
      logical log_preset
      common /presetl/ log_preset
      common /saparl/ T0,rt,eps,target_value
      common /sapars/ nvar,ns,nt,neps,maxevl,iprint,iseed1,iseed2
      common /shadl/ log_shad(mvar)
      common /shadi/ kshad(mvar)
!
!.. check if parameters have been specified - if not use defaults.
      CALL WDialogSelect(IDD_SA_Action2)
      CALL WDialogSelect(IDD_input_parameters)
      CALL WDialogPutInteger(IDF_npar,nvar)
      CALL WGridRows(IDF_parameter_grid,nvar)
      DO i=1,nvar
        IF (LOG_PRESET) THEN
          CALL WGridPutCellReal(IDF_parameter_grid,7,i,sngl(xpreset(i)),'(F12.5)')
          CALL WGridPutCellCheckBox(IDF_parameter_grid,6,i,Checked)
        ELSE
          CALL WGridPutCellCheckBox(IDF_parameter_grid,6,i,Unchecked)
        END IF
        CALL WGridPutCellReal(IDF_parameter_grid,2,i,sngl(lb(i)),'(F12.5)')
        CALL WGridPutCellReal(IDF_parameter_grid,3,i,sngl(ub(i)),'(F12.5)')
        CALL WGridPutCellReal(IDF_parameter_grid,4,i,sngl(vm(i)),'(F12.5)')
      END DO
      CALL WDialogSelect(IDD_input_protocol)
      CALL WDialogPutReal(IDF_T0,sngl(T0),'(F7.2)')
      CALL WDialogPutTrackBar(IDF_T0_trackbar,nint(sngl(T0)))
      RT1000=sngl(RT*1000.)
      CALL WDialogPutReal(IDF_TREDRATE,RT1000,'(F7.2)')
      IRT=RT1000
      CALL WDialogPutTrackbar(IDF_Tredrate_trackbar,IRT)
      CALL WDialogPutReal(IDF_targetchisq,sngl(target_value),'(F7.2)')
      CALL WDialogPutTrackbar(IDF_targetchisq_trackbar,nint(sngl(target_value)))
      CALL WDialogPutInteger(IDF_ISEED1,iseed1)
      CALL WDialogPutInteger(IDF_ISEED2,iseed2)
      CALL WDialogPutInteger(IDF_NT,NT)
      CALL WDialogPutInteger(IDF_NS,NS)
!
! Initialise the total number of moves box
      CALL WDialogSelect(IDD_SA_Action1)
      CALL WDialogPutInteger(IDF_TOTAL_MOVES,NT*NS*NVAR)
!
    END SUBROUTINE sa_upload
!
!*****************************************************************************
!
! Originally in sa_plot.f90
!
     subroutine SA_PLOT(iter)
!
      use winteracter
      use druid_header
!
      parameter (maxiter=10000)
      common /pltstore/ xiter(maxiter),tstore(maxiter),&
      foptstore(maxiter),fpavstore(maxiter)
      COMMON /PLTSTO2/ CHIPROBEST(MAXITER)

	  integer IcurSel
!
!
!
      if (iter.le.1) return
      ICurSel = WInfoDialog(CurrentDialog)

!
      CALL WDialogSelect(IDD_Anneal_Status)
      CALL IGrSelect(3, IDF_Status_Graph)
      CALL IGrArea(0.0,0.0,1.0,1.0)
      CALL IGrAreaClear
      CALL IGrCharFont(1)
!      CALL IGrCharSpacing('P')
      CALL IGrColourN(175)
!
! Check on whether we want log or linear y axis
      CALL WDialogGetRadioButton(IDF_Anneal_LogY,IRAD_AnnealLogLinY)
      SELECT CASE (IRAD_AnnealLogLinY)
          CASE (1)
! Observed and calculated profiles
            CALL IPgScaling('LIN','LOG')
          CASE (2)
! The difference profile
            CALL IPgScaling('LIN','LIN')
      END SELECT


      CALL IPgNewGraph(4,iter,' ',' ','XY')
!
!  draw axes and add scales
!


      CALL IPgAxes
      xgmin=1.
      xgmax=float(iter)
      CALL IRealMaxMin1(tstore,iter,tmin,tmax)
      CALL IRealMaxMin1(foptstore,iter,fmin,fmax)
      CALL IRealMaxMin1(fpavstore,iter,amin,amax)
      CALL IRealMaxMin1(chiprobest,iter,cmin,cmax)
      ygmin=0.9*min(tmin,fmin,amin,cmin)
      ygmax=1.1*max(tmax,fmax,amax,cmax)
      CALL IPgArea(.12,.12,.9,.95)
      CALL IPgUnits(xgmin,ygmin,xgmax,ygmax)
      CALL IGrCharSize(1.2,1.2)
!      CALL IPgYUserScale(yticks,31)
      CALL IPgBorder()
      CALL IPgXScale('TN')
      CALL IPgXScaleTop('T')
      CALL IGrCharSize(1.2,1.2)
      CALL IPgYScaleLeft('TN')
      CALL IPgYScaleRight('T')
!
      CALL IGrCharSize(1.2,1.3)
      CALL IPgXLabel('iteration number','C')
      CALL IPgYLabelLeft('chi-squared & temperature','C9')
      CALL IPgStyle(1,0,0,0,16,0)
      CALL IPgStyle(2,0,0,0,112,0)
      CALL IPgStyle(3,0,0,0,80,0)
      CALL IPgStyle(4,0,0,0,192,0)
      CALL IPgXYPairs(xiter,tstore)
      CALL IPgXYPairs(xiter,foptstore)
      CALL IPgXYPairs(xiter,fpavstore) 
      CALL IPgXYPairs(xiter,chiprobest)
!
	  IF (ICurSel .NE. 0) CALL WDialogSelect(ICurSel)
	  return
      end
!
!*****************************************************************************
!
! Originally in sa_subs.for
!
C
      SUBROUTINE RANSETGEN
c
      real x(1000),yd(1000),xv(1000)
      common /rangenfun/npt,xs,y(1000)
c
      IM=29282
      IA=1255
      IC=6173
      JRAN=1
C
      do i=1,1000
        read(20,*,err=100) x(i),yd(i)
        npt=i
      end do
c
 100  continue
c
      sumv=0.
      xs=(x(2)-x(1))
      xv(1)=0.
      do i=1,npt
        xv(i+1)=x(i)+xs
        sumv=sumv+yd(i)
      end do
      y(1)=0.
      sumt=0.
      do i=1,npt
        sumt=sumt+yd(i)
        y(i+1)=sumt/sumv
      end do
c
      end SUBROUTINE RANSETGEN
c
!
!*****************************************************************************
!
      subroutine RANX2G(DRIN,DROUT)
c
      double precision drin,drout
      common /x2gran/ xs,ygran(200)
c
      rin=sngl(drin)
      rin=abs(rin)
      jn=1
        do j=199,1,-1
          if (rin.gt.ygran(j)) then
            jn=j
            goto 10
          end if
        end do
c.. rin is between yran(jn) and yran(jn+1) now iterate
 10     xl=xs*float(jn-1)
        xsn=0.5*xs
        xm=xl+xsn
        xh=xm+xsn
      yl=ygran(jn)
      yh=ygran(jn+1)
      ym=erf(xm)
 15   xlo=xl
      xmo=xm
      xho=xh
      ylo=yl
      ymo=ym
      yho=yh
      if (abs(yh-yl).lt.1e-5) goto 20
      if (rin.ge.ym) then
        xl=xmo
        xh=xho
        yl=ymo
        yh=yho
      else
        xl=xlo
        xh=xmo
        yl=ylo
        yh=ymo
      end if
      xm=0.5*(xh+xl)
      ym=erf(xm)
      goto 15
 20   rout=xm
      if (drin.lt.0) rout=-rout
      drout=dble(rout)
c
      return
      end subroutine RANX2G

      subroutine RANX2GEN(drin,drout)
c
      double precision drin,drout
      common /rangenfun/npt,xs,y(1000)
c
      npt1=npt+1
c
c.. At this point we have the integral stored from 0 to 360 degrees
c.. There are npt1 integral values.
c
      p5=0.5
      rin=sngl(drin)
c      do ir=1,40000
c        jran=mod(jran*ia+ic,im)

c        rin=float(jran)/float(im)
c
        do j=npt,1,-1
          if (rin.gt.y(j)) then
            jn=j
            goto 10
          end if
        end do
      xm=0.
      goto 20  
c.. rin is between y(jn) amd y(jn+1) now iterate
 10     xl=xs*float(jn-1)
        xsn=0.5*xs
        xm=xl+xsn
        xh=xm+xsn
      yl=y(jn)
      yh=y(jn+1)
      ym=yintpl(jn,p5)
      p=p5
      dp=0.5
 15   xlo=xl
      xmo=xm
      xho=xh
      ylo=yl
      ymo=ym
      yho=yh
      dp=0.5*dp
      if (abs(yh-yl).lt.1e-5) goto 20
      if (rin.ge.ym) then
        xl=xmo
        xh=xho
        yl=ymo
        yh=yho
        p=p+dp
      else
        xl=xlo
        xh=xmo
        yl=ylo
        yh=ymo
        p=p-dp
      end if
      xm=0.5*(xh+xl)
      ym=yintpl(jn,p)
      goto 15
 20   drout=dble(xm)
c
      end subroutine RANX2GEN
c


c
      function rantorget(x,i)
c
      double precision x
      double precision RANTORSTO
      common/rantst/ rantorsto(1001,20)
c
      ival=1.+1000.*x
      if (ival.eq.1001) then
        rantorget=rantorsto(1001,i)
      else
        del=1.+1000.*x-ival
        rantorget=(1.-del)*rantorsto(ival,i)
     &             +del*rantorsto(ival+1,i)
      end if
c
      end function rantorget
c
c
c
c
      function yintpl(jn,p)
c
      common /rangenfun/npt,xs,y(1000)
      real yt(-2:2)
      real vt(-2:2)
c
      do ii=-2,2
        jt=1+mod(jn+ii+npt-1,npt)
	  yt(ii)=y(jt)
      end do
c
      pm2=p-2
      pm1=p-1
      pp1=p+1
      pp2=p+2
c
      t2=pm1*pp1*p/24.
      t1=-pm2*pp2*p/6.
	yt0=yt(0)
      vt(-2)=t2*pm2
      vt(-1)=t1*pm1
      vt(0)=pm2*pm1*pp1*pp2/4.
      vt(1)=t1*pp1
      vt(2)=t2*pp2
	if (yt(-2).gt.yt0) yt(-2)=yt(-2)-1.
	if (yt(-1).gt.yt0) yt(-1)=yt(-1)-1.
	if (yt(1) .lt.yt0) yt(1)=yt(1)+1.
	if (yt(2) .lt.yt0) yt(2)=yt(2)+1.
      yintpl=0.
      do i=-2,2
        yintpl=yintpl+vt(i)*yt(i)
      end do
c
      end function yintpl
c
c
      SUBROUTINE PRTVEC(VECTOR,NCOLS,NAME)
C  This subroutine prints the double precision vector named VECTOR.
C  Elements 1 thru NCOLS will be printed. NAME is a character variable
C  that describes VECTOR. Note that if NAME is given in the call to
C  PRTVEC, it must be enclosed in quotes. If there are more than 10
C  elements in VECTOR, 10 elements will be printed on each line.

      INTEGER NCOLS
      DOUBLE PRECISION VECTOR(NCOLS)
      CHARACTER *(*) NAME

      WRITE(*,1001) NAME

      IF (NCOLS .GT. 10) THEN
         LINES = INT(NCOLS/10.)

         DO 100, I = 1, LINES
            LL = 10*(I - 1)
            WRITE(*,1000) (VECTOR(J),J = 1+LL, 10+LL)
  100    CONTINUE

         WRITE(*,1000) (VECTOR(J),J = 11+LL, NCOLS)
      ELSE
         WRITE(*,1000) (VECTOR(J),J = 1, NCOLS)
      END IF

 1000 FORMAT( 10(G12.5,1X))
 1001 FORMAT(5X,A)

      RETURN
      END


      SUBROUTINE PRT1
C  This subroutine prints intermediate output, as does PRT2 through
C  PRT10. Note that if SA is minimizing the function, the sign of the
C  function value and the directions (up/down) are reversed in all
C  output to correspond with the actual function optimization. This
C  correction is because SA was written to maximize functions and
C  it minimizes by maximizing the negative a function.

C      WRITE(*,'(  THE STARTING VALUE (X) IS OUTSIDE THE BOUNDS ',
C     1          /,'  (LB AND UB). EXECUTION TERMINATED WITHOUT ANY'
C     2          /,'   OPTIMIZATION. RESPECIFY X, UB OR LB SO THAT  '
C     3          /,'   LB(I) .LT. X(I) .LT. UB(I), I = 1, N. )')

      RETURN
      END

      SUBROUTINE PRT2(MAXLOG,N,X,F)

      DOUBLE PRECISION  X(*), F
      INTEGER  N
      LOGICAL  MAXLOG

C      CALL PRTVEC(X,N,'INITIAL X')
      IF (MAXLOG) THEN
	   WRITE(*,*)
         WRITE(*,1010) SNGL(F)
      ELSE
         WRITE(*,*)
         WRITE(*,1010) -SNGL(F)
      END IF
 1010 FORMAT('  Initial chi-squared value: ', F15.5) 

      RETURN
      END

      SUBROUTINE PRT3(MAXLOG,N,XP,X,FP,F)

      DOUBLE PRECISION  XP(*), X(*), FP, F
      INTEGER  N
      LOGICAL  MAXLOG

      CALL PRTVEC(X,N,'CURRENT X')
      IF (MAXLOG) THEN
         WRITE(*,1010) F
      ELSE
         WRITE(*,1010) -F
      END IF
 1010 FORMAT('  CURRENT F: ', G25.18) 
      CALL PRTVEC(XP,N,'TRIAL X')
      WRITE(*,*) ' POINT REJECTED SINCE OUT OF BOUNDS '

      RETURN
      END

      SUBROUTINE PRT4(MAXLOG,N,XP,X,FP,F)

      DOUBLE PRECISION  XP(*), X(*), FP, F
      INTEGER  N
      LOGICAL  MAXLOG

      CALL PRTVEC(X,N,'CURRENT X')
      IF (MAXLOG) THEN
         WRITE(*,1010) F
         CALL PRTVEC(XP,N,'TRIAL X')
         WRITE(*,1020) FP
      ELSE
         WRITE(*,1010) -F
         CALL PRTVEC(XP,N,'TRIAL X')
         WRITE(*,1020) -FP
      END IF
 1010 FORMAT('   CURRENT F: ', G25.18) 
 1020 FORMAT('  RESULTING F: ', G25.18) 

      RETURN
      END

      SUBROUTINE PRT5

C      WRITE(*,'(,''  TOO MANY FUNCTION EVALUATIONS; CONSIDER ''
C     1          /,''  INCREASING MAXEVL OR EPS, OR DECREASING ''
C     2          /,''  NT OR RT. THESE RESULTS ARE LIKELY TO BE ''
C     3          /,''  POOR.'',/)')

      RETURN
      END

      SUBROUTINE PRT6(MAXLOG)

      LOGICAL  MAXLOG

      IF (MAXLOG) THEN
         WRITE(*,*) '  THOUGH LOWER, POINT ACCEPTED '
      ELSE
         WRITE(*,*) '  THOUGH HIGHER, POINT ACCEPTED '
      END IF

      RETURN
      END

      SUBROUTINE PRT7(MAXLOG)

      LOGICAL  MAXLOG

      IF (MAXLOG) THEN
         WRITE(*,*) '  LOWER POINT REJECTED '
      ELSE
         WRITE(*,*) '  HIGHER POINT REJECTED '
      END IF

      RETURN
      END

      SUBROUTINE PRT8(N,VM,XOPT,X)

      DOUBLE PRECISION  VM(*), XOPT(*), X(*)
      INTEGER  N

      WRITE(*,*) 
     &' INTERMEDIATE RESULTS AFTER STEP LENGTH ADJUSTMENT'
      CALL PRTVEC(VM,N,'NEW STEP LENGTH (VM)')
      CALL PRTVEC(XOPT,N,'CURRENT OPTIMAL X')
      CALL PRTVEC(X,N,'CURRENT X')

      RETURN
      END

      SUBROUTINE PRT9(MAXLOG,N,T,XOPT,VM,
     &FOPT,FPAV,FPSD,NUP,NDOWN,NREJ,LNOBDS,NNEW)

      DOUBLE PRECISION  XOPT(*), VM(*), T, FOPT, FTEM, FPAV, FPSD
      INTEGER  N, NUP, NDOWN, NREJ, LNOBDS, NNEW, TOTMOV
      LOGICAL  MAXLOG
      COMMON /ITRINF/ iteration

      TOTMOV = NUP + NDOWN + NREJ
      WRITE(*,*)
      WRITE(*,*) 
     &' Intermediate results before next temperature reduction'
      WRITE(*,1010) SNGL(T)
 1010 FORMAT   ('  Current temperature:        ',F10.3)
      IF (MAXLOG) THEN
         WRITE(*,1020) SNGL(FOPT),SNGL(FPAV),
     &SNGL(FPSD),TOTMOV,NUP,NDOWN,NREJ,LNOBDS,NNEW
 1020    FORMAT('  Maximum cost function so far:  ',F10.3,' <<<<'/,
     &          '  Average for this temperature:  ',F10.3,/,
     &          '   +/- standard deviation     :  ',F10.3,/,
     &          '     Total moves:                  ',i8,/, 
     &          '        uphill:                    ',i8,/, 
     &          '        accepted downhill:         ',i8,/, 
     &          '        rejected downhill:         ',i8,/, 
     &          '     Out of bounds trials:         ',i8,/, 
     &          '     New maxima this temperature:  ',i8) 
      ELSE
         WRITE(*,1030) -SNGL(FOPT),-SNGL(FPAV),
     &SNGL(FPSD),TOTMOV,NUP,NDOWN,NREJ,LNOBDS,NNEW
 1030    FORMAT('  Minimum chi-squared so far:    ',F10.3,' <<<<'/, 
     &          '  Average for this temperature:  ',F10.3,/,
     &          '   +/- standard deviation     :  ',F10.3,/,
     &          '     Total moves:                ',I10,/, 
     &          '        downhill:                ',I10,/, 
     &          '        accepted uphill:         ',I10,/, 
     &          '        rejected uphill:         ',I10,/, 
     &          '     Out of bounds trials:       ',I10,/, 
     &          '     New minima this temperature:',I10) 
      END IF
c      iteration=iteration+1
c      write(60,*) iteration,-fopt,t
c      write(61,*) t,(sngl(xopt(i)),i=1,n)
C      CALL PRTVEC(XOPT,N,'CURRENT OPTIMAL X')
C      CALL PRTVEC(VM,N,'STEP LENGTH (VM)')

C
      CALL FCN_PRT(N,XOPT,FTEM)
C
      RETURN
      END

      SUBROUTINE PRT10

      WRITE(*,*) '  SA ACHIEVED TERMINATION CRITERIA. IER = 0.'

      RETURN
      END
!
!*****************************************************************************
!
! Originally in inf_upload.f90
!
      SUBROUTINE INF_UPLOAD()

      USE WINTERACTER
      USE DRUID_HEADER

      INCLUDE 'PARAMS.INC'

      COMMON /FCSTOR/MAXK,FOB(150,MFCSTO)
      COMMON /FPINF2/ NTERMS
      COMMON /CHISTO/ KKOR,WTIJ(MCHIHS),S2S(MCHIHS),S4S(MCHIHS),&
        IKKOR(MCHIHS),JKKOR(MCHIHS)
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150), &
        TF(150),KTF(150),SITE(150),KSITE(150), &
        ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17

      CALL WDialogSelect(IDD_input_data)
      CALL WDialogPutInteger(IDF_reflections,MAXK)
      CALL WDialogPutInteger(IDF_contributors,NTERMS)
      CALL WDialogPutInteger(IDF_correlations,KKOR)
      CALL WDialogPutInteger(IDF_numatoms,NATOM)

      END SUBROUTINE INF_UPLOAD
!
!*****************************************************************************
!
! Originally in SA_main.f90
!
!      SUBROUTINE SA_Parameter_Update(CheckSize,IZMCheck)
!
!      USE WINTERACTER
!      USE DRUID_HEADER
!      INTEGER CheckSize
!      INTEGER IZMCheck(CheckSize)
!
!      PARAMETER (NMAX = 100, MXEPS = 10)
!      DOUBLE PRECISION XOPT,CSH,FSTAR,XP,FOPT
!      COMMON /sacmn/ XOPT(NMAX),CSH(NMAX),FSTAR(MXEPS),XP(NMAX),FOPT
!
!      INTEGER  NACP(NMAX), NS, NT, NFCNEV, IER, ISEED1, ISEED2
!      INTEGER MAXEVL, IPRINT, NACC, NOBDS
!      LOGICAL  MAXLOG,RESTART,MAKET0
!
!      character*132 line
!      character*80  sa_file
!      logical   log_inf_file,log_nvar,log_bounds,log_reduce
!      logical log_eps,log_ns,log_nt,log_neps,log_maxevl,log_iprint
!      logical log_iseed1,log_iseed2,log_T0,log_target_value
!      logical log_frag_file
!      double precision cen,sig
!      logical gaussb
!      character*80  inf_file,zm_file
!      double precision T,T0,rt,eps,target_value
!      common /inffil/ lfinf,lfzm,inf_file,zm_file
!
!      parameter (maxatm=100)
!      parameter (maxfrg=20)
!      double precision a,b,c,al,be,ga
!      double precision tiso,occ
!      double precision blen,alph,bet,f2cmat
!      character*3 asym
!      integer ioptb,iopta,ioptt,iz1,iz2,iz3
!      common /zmcomi/ ntatm,natoms(maxfrg),&
!     ioptb(maxatm,maxfrg),iopta(maxatm,maxfrg),ioptt(maxatm,maxfrg),&
!     iz1(maxatm,maxfrg),iz2(maxatm,maxfrg),iz3(maxatm,maxfrg)
!      common /zmcomr/ blen(maxatm,maxfrg),alph(maxatm,maxfrg),&
!     bet(maxatm,maxfrg),f2cmat(3,3)
!      common /zmcomc/ asym(maxatm,maxfrg)
!      common /zmcomo/ a(maxfrg),b(maxfrg),c(maxfrg),&
!     al(maxfrg),be(maxfrg),ga(maxfrg),tiso(maxatm,maxfrg),&
!     occ(maxatm,maxfrg)
!
!      common /frgcom/ nfrag,lfrag(maxfrg)
!      character*80 frag_file
!      common /frgcha/ frag_file(maxfrg)
!      parameter (mvar=100)
!      common /gaubou/ cen(mvar),sig(mvar)
!      common /gaulog/ gaussb(mvar)
!      character*80  torfile
!      logical ltorfil
!      common /torfcm/ torfile(mvar)
!      common /torlog/ ltorfil(mvar)
!      common /jitter/ rjittr
!      double precision x,lb,ub,vm,xpreset
!      common /values/ x(mvar),lb(mvar),ub(mvar),vm(mvar)
!      common /presetr/ xpreset(mvar)
!      logical log_preset
!      common /presetl/ log_preset
!
!      common /saparl/ T0,rt,eps,target_value
!      common /sapars/ nvar,ns,nt,neps,maxevl,iprint,iseed1,iseed2
!      common /shadl/ log_shad(mvar)
!      common /shadi/ kshad(mvar)
!
!      character*36 parlabel(mvar)
!
!      character*36 czmpar
!      common /zmnpar/ izmtot,izmpar(maxfrg),&
!            czmpar(30,maxfrg),kzmpar(30,maxfrg),xzmpar(30,maxfrg)
!      logical gotzmfile
!      common /zmlgot/ gotzmfile(maxfrg)
!
!      INCLUDE 'GLBVAR.INC' ! Contains ALambda
!       COMMON /CELLREF/ CELLPAR(6),ZEROPOINT
!
!      kk = 0
!C>> JCC Only use those that are checked
!      DO ifrg = 1, CheckSize
!        IF (IZMCheck(ifrg) .EQ. Checked) THEN
!          DO ii = 1, izmpar(ifrg)
!            kk = kk + 1
!C!>> Leave these alone - save the edits
!          x(kk)=xzmpar(ii,ifrg)
!          parlabel(kk)=czmpar(ii,ifrg)
!!     sngl(x(kk)),sngl(lb(kk)),sngl(ub(kk)),sngl(vm(kk))
!          END DO
!!C>> JCC Check
!        ENDIF
!      END DO
!      nvar = kk
!!.. Now fill the grid
!      CALL WDialogSelect(IDD_SA_input2)
!      CALL WGridRows(IDF_parameter_grid,nvar)
!      DO i = 1, nvar
!         CALL WGridLabelRow(IDF_parameter_grid,i,parlabel(i))
!         CALL WGridPutCellReal(IDF_parameter_grid,1,i,sngl(x(i)),'(F12.5)')
!         CALL WGridPutCellReal(IDF_parameter_grid,2,i,sngl(lb(i)),'(F12.5)')
!         CALL WGridPutCellReal(IDF_parameter_grid,3,i,sngl(ub(i)),'(F12.5)')
!!         CALL WGridPutCellCheckBox(IDF_parameter_grid,4,i,Unchecked)
!!         CALL WGridPutCellCheckBox(IDF_parameter_grid,5,i,Checked)
!      END DO
!!      Call WDialogHide()      
!      RETURN
!
!      END SUBROUTINE SA_Parameter_Update
!
!*****************************************************************************
!
! Originally in PolyFitter_Subs.f90
!
      SUBROUTINE Check_KeyDown_PeakFind_Inner(KeyNumber,xval,yval)

      USE WINTERACTER

      INCLUDE 'PARAMS.INC'

      COMMON /PROFOBS/ NOBS,XOBS(MOBS),YOBS(MOBS),YCAL(MOBS),YBAK(MOBS),EOBS(MOBS)
      COMMON /PROFBIN/ NBIN,LBIN,XBIN(MOBS),YOBIN(MOBS),YCBIN(MOBS),YBBIN(MOBS),EBIN(MOBS)
      COMMON /PROFRAN/ XPMIN,XPMAX,YPMIN,YPMAX,XPGMIN,XPGMAX,&
        YPGMIN,YPGMAX,XPGMINOLD,XPGMAXOLD,YPGMINOLD,YPGMAXOLD, &
        XGGMIN,XGGMAX,YGGMIN,YGGMAX
      COMMON /PROFIPM/ IPMIN,IPMAX,IPMINOLD,IPMAXOLD

      COMMON /TICCOMM/ NUMOBSTIC,XOBSTIC(MOBSTIC),YOBSTIC(MOBSTIC),&
        itypot(mobstic),iordot(mobstic),uobstic(20,mobstic),zobstic(20,mobstic)
      REAL XCUR(2),YCUR(2),XGCUR(2),YGCUR(2)
      REAL XXTEM(MOBSTIC),YYTEM(MOBSTIC),UUTEM(20,MOBSTIC),ZZTEM(20,MOBSTIC)

      COMMON /PROFTIC/ NTIC,IH(3,MTIC),ARGK(MTIC),DSTAR(MTIC)

      INCLUDE 'GLBVAR.INC'

      INTEGER ITTEM(MOBSTIC),IOTEM(MOBSTIC)
      CHARACTER*100 HKLSTR
      CHARACTER*4   CHRFORM
      REAL ARGKPLT(10),DSPLT(10)
      INTEGER IHPLT(3,10)
      INCLUDE 'Poly_Colours.inc'
      REAL CHAR_SIZE,MARKER_SIZE
      LOGICAL ERROR_BAR
      COMMON /PROFDEF/ERROR_BAR,CHAR_SIZE,MARKER_SIZE

      LOGICAL Confirm ! Function

      xcur(2)=xval
      ycur(2)=yval
      IF (KeyNumber.eq.KeyReturn) THEN
        numobstic=numobstic+1
! Simple cursor location
        itypot(numobstic)=0
        xobstic(numobstic)=xcur(2)
        axdif=abs(xobs(nobs)-xobs(1))
        do ii=1,nobs
          atem=abs(xcur(2)-xobs(ii))
          if (atem.le.axdif) then
            axdif=atem
            yobstic(numobstic)=yobs(ii)
          end if
        end do
                call Upload_Positions()
                CALL IGrPlotMode(' ')
                call Profile_Plot(IPTYPE)
                CALL IGrPlotMode('EOR')
              ELSE IF (KeyNumber.eq.KeyInsert) THEN
                numobstic=numobstic+1
                itypot(numobstic)=1
! Fit to the top of the peak
                call fit_peaktop(xcur(2))
                CALL IGrPlotMode(' ')
                call Profile_Plot(IPTYPE)
                CALL IGrPlotMode('EOR')
              ELSE IF (KeyNumber.eq.KeyDeleteUnder) THEN
! Delete the nearest peak but ask first ...
                IF (NUMOBSTIC.EQ.0) THEN
                 CALL ErrorMessage('No tickmarks to delete!')
                ELSE
                 IF (Confirm('Do you really want to'//CHAR(13)//' delete this tickmark?')) THEN
! Delete the closest tickmark ...
                  ATEM=ABS(XOBSTIC(1)-XCUR(2))
                  LTEM=1
                  DO II=1,NUMOBSTIC
                    AATEM=ABS(XOBSTIC(II)-XCUR(2))
                    IF (AATEM.LT.ATEM) THEN
                      LTEM=II
                      ATEM=AATEM
                    END IF
                  END DO
                  KK=0
                  DO II=1,NUMOBSTIC
                    IF (II.NE.LTEM) THEN
                      KK=KK+1
                      XXTEM(KK)=XOBSTIC(II)
                      YYTEM(KK)=YOBSTIC(II)
                      ITTEM(KK)=ITYPOT(II)
                      IOTEM(KK)=IORDOT(II)
                      DO JJ=1,9
                        UUTEM(JJ,KK)=UOBSTIC(JJ,II)
                        ZZTEM(JJ,KK)=ZOBSTIC(JJ,II)
                      END DO
                    END IF
                  END DO
                  NUMOBSTIC=NUMOBSTIC-1
                  DO II=1,NUMOBSTIC
                      KK=II
                      XOBSTIC(II)=XXTEM(KK)
                      YOBSTIC(II)=YYTEM(KK)
                      ITYPOT(II)=ITTEM(KK)
                      IORDOT(II)=IOTEM(KK)
                      DO JJ=1,9
                        UOBSTIC(JJ,II)=UUTEM(JJ,KK)
                        ZOBSTIC(JJ,II)=ZZTEM(JJ,KK)
                      END DO
                  END DO                                  
                 END IF
                 CALL Upload_Positions()
                         CALL Upload_Widths()
                END IF
              ELSE IF (KeyNumber.eq.77 .or. KeyNumber.eq.109) THEN
! KeyNumber=M/m
! Find the Miller index of the nearest Bragg peak ...
                IF (NTIC.GT.0) THEN
                  ATEM=ABS(ARGK(1)-XCUR(2))
                  DO II=1,NTIC
                    AATEM=ABS(ARGK(II)-XCUR(2))
                    ATEM=MIN(ATEM,AATEM)
                  END DO
                  NNP=0
                  DO II=1,NTIC
                    AATEM=ABS(ARGK(II)-XCUR(2))
                    IF (AATEM.EQ.ATEM) THEN
                      NNP=NNP+1
                      DO I3=1,3
                       IHPLT(I3,NNP)=IH(I3,II)
                      END DO
                      ARGKPLT(NNP)=ARGK(II)
                      DSPLT(NNP)=1./DSTAR(II)
                    END IF
                  END DO
                  hklstr=' '
                  CHRFORM='(I1)'
                  ILOC=0
                  DO IPP=1,NNP
                    ILOC=ILOC+1
                    HKLSTR(ILOC:ILOC)='('
                    DO I3=1,3
                      IF (IHPLT(I3,IPP).LE.-10.) THEN
                        ISF=3
                      ELSE IF (IHPLT(I3,IPP).LT.0.AND.IHPLT(I3,IPP).GT.-10.) THEN
                        ISF=2
                      ELSE IF (IHPLT(I3,IPP).GE.0.AND.IHPLT(I3,IPP).LT.10.) THEN
                        ISF=1
                      ELSE
                        ISF=2
                      END IF
                      CALL IntegerToString(ISF,CHRFORM(3:3),'(I1)')
                      CALL IntegerToString(IHPLT(I3,IPP),&
                         HKLSTR(ILOC+1:ILOC+ISF),CHRFORM)
                      ILOC=ILOC+ISF+1
                      HKLSTR(ILOC:ILOC)=' '
                    END DO
                    HKLSTR(ILOC:ILOC)=')'
                  END DO
                  CALL WindowOutStatusBar(2,HKLSTR)
                  CALL IGrCharJustify('L')
                  CALL IGrColourN(KolNumCTic)
                  CHSTEM=0.75*Char_Size
                  CALL IGrCharSize(chstem,chstem)
                  CALL IGrCharRotate(90.)
                  xtem=xcur(2)-0.02*(xpgmax-xpgmin)
                  ytem=ycur(2)+0.01*(ypgmax-ypgmin)
                  CALL IPgUnitsToGrUnits(xtem,ytem,xgtem,ygtem)
                  CALL IGrCharOut(xgtem,ygtem,HKLSTR(:LEN_TRIM(HKLSTR)))
                  CALL IGrCharRotate(0.)
                  hklstr=' '
          IF (argkplt(nnp).ge.200.) THEN
            CALL IRealToString(ARGKPLT(NNP),&
            HKLSTR(1:),'(F10.2)')
          ELSE
            CALL IRealToString(ARGKPLT(NNP),&
            HKLSTR(1:),'(F10.4)')
          END IF
          CALL WindowOutStatusBar(3,HKLSTR)
        END IF
      ELSE
        CALL IGrPlotMode(' ')
        RETURN
      ENDIF

      END SUBROUTINE Check_KeyDown_PeakFind_Inner
!
!*****************************************************************************
!
      SUBROUTINE Check_KeyDown_PeakFind(MESSAGE)

      USE WINTERACTER

      TYPE(WIN_MESSAGE) :: MESSAGE
      REAL XCUR(2),YCUR(2),XGCUR(2),YGCUR(2)

! acts on various KeyDown options that are specific for peakfitting
      KeyNumber = MESSAGE%VALUE1
      xgcur(2) = MESSAGE%GX
      ygcur(2) = MESSAGE%GY
      CALL IPgUnitsFromGrUnits(xgcur(2),ygcur(2),xcur(2),ycur(2))
      CALL Check_KeyDown_PeakFind_Inner(KeyNumber,xcur(2),ycur(2))

      END SUBROUTINE Check_KeyDown_PeakFind
!
!*****************************************************************************
!
      SUBROUTINE PeakFind_Manual(IDVal_Current)

      USE WINTERACTER
      USE DRUID_HEADER
      USE VARIABLES

      TYPE(WIN_STYLE)    WINDOW
      LOGICAL FinishMenuMode

      INCLUDE 'GLBVAR.INC'

      DO
        CALL WMessage(EventType,EventInfo)
        SELECT CASE (EventType)
          CASE (MouseButDown)
            IF      (EventInfo%VALUE1 .EQ. LeftButton) THEN
              CALL Plot_Alter(EventInfo%GX,EventInfo%GY)
            ELSE IF (EventInfo%VALUE1 .EQ. RightButton) THEN
! Get to work on the cross-hair movement
              CALL MOVE_CROSSHAIR(EventInfo%GX,EventInfo%GY)
            END IF
          CASE (MenuSelect)
            IDVal_Current=EventInfo%Value1               
            IF (FinishMenuMode(IDVal_Current,ID_CrossHair_Cursor_Mode)) THEN
              CALL WMessageEnable(MouseMove, Disabled)
              CALL WMessageEnable(MouseButUp, Disabled)
              STATBARSTR(8)='Standard cursor'
              CALL WindowOutStatusBar(8,STATBARSTR(8))
              CALL WMenuSetState(IDCurrent_Cursor_mode,ItemChecked,WintOff)
              IDCurrent_Cursor_mode=ID_Default_Mode
              CALL WMenuSetState(IDCurrent_Cursor_mode,ItemChecked,WintOn)
              RETURN
            END IF
          CASE (KeyDown)                
            IF (EventInfo%VALUE1 .EQ. KeyEscape) THEN
              CALL WMessageEnable(MouseMove, Disabled)
              CALL WMessageEnable(MouseButUp, Disabled)
              STATBARSTR(8)='Standard cursor'
              CALL WindowOutStatusBar(8,STATBARSTR(8))
              CALL WMenuSetState(IDCurrent_Cursor_mode,ItemChecked,WintOff)
              IDCurrent_Cursor_mode=ID_Default_Mode
              CALL WMenuSetState(IDCurrent_Cursor_mode,ItemChecked,WintOn)
              RETURN
            ELSE
              CALL Check_KeyDown(EventInfo)
            END IF
          CASE (Expose,Resize)
            CALL Redraw()
        END SELECT
      END DO

      END SUBROUTINE PeakFind_Manual
!
!*****************************************************************************
!
      SUBROUTINE MOVE_CROSSHAIR(xgtem,ygtem)
!
      USE WINTERACTER

      TYPE(WIN_STYLE)    WINDOW
      TYPE(WIN_MESSAGE)  ZMESSAGE

      INCLUDE 'PARAMS.INC'

      COMMON /PROFTIC/ NTIC,IH(3,MTIC),ARGK(MTIC),DSTAR(MTIC)

      COMMON /PROFOBS/ NOBS,XOBS(MOBS),YOBS(MOBS),YCAL(MOBS),YBAK(MOBS),EOBS(MOBS)
      COMMON /PROFBIN/ NBIN,LBIN,XBIN(MOBS),YOBIN(MOBS),YCBIN(MOBS),YBBIN(MOBS),EBIN(MOBS)
      COMMON /PROFRAN/ XPMIN,XPMAX,YPMIN,YPMAX,XPGMIN,XPGMAX,&
        YPGMIN,YPGMAX,XPGMINOLD,XPGMAXOLD,YPGMINOLD,YPGMAXOLD, &
        XGGMIN,XGGMAX,YGGMIN,YGGMAX
      COMMON /PROFIPM/ IPMIN,IPMAX,IPMINOLD,IPMAXOLD
!
      REAL XCUR(2),YCUR(2),XGCUR(2),YGCUR(2)

      INCLUDE 'GLBVAR.INC'

      LOGICAL HVLINE_THERE

      COMMON /TICCOMM/ NUMOBSTIC,XOBSTIC(MOBSTIC),YOBSTIC(MOBSTIC),&
        itypot(mobstic),iordot(mobstic),uobstic(20,mobstic),zobstic(20,mobstic)
      REAL XXTEM(MOBSTIC),YYTEM(MOBSTIC),UUTEM(20,MOBSTIC),ZZTEM(20,MOBSTIC)
      INTEGER ITTEM(MOBSTIC),IOTEM(MOBSTIC)
      CHARACTER*100 HKLSTR
      CHARACTER*4   CHRFORM
      REAL     ARGKPLT(10),DSPLT(10)
      INTEGER IHPLT(3,10)
      INCLUDE 'Poly_Colours.inc'
      REAL    CHAR_SIZE,MARKER_SIZE
      LOGICAL ERROR_BAR
      COMMON /PROFDEF/ERROR_BAR,CHAR_SIZE,MARKER_SIZE 
!
! Get ready to put up the big cursor
      HVLINE_THERE=.FALSE.
      CALL WMessageEnable(MouseMove, Enabled)
      CALL WMessageEnable(MouseButUp, Enabled)
      CALL WCursorShape(CurCrossHair)
      CALL IPgUnitsToGrUnits(xpgmin,ypgmin,gxmin,gymin)
      CALL IPgUnitsToGrUnits(xpgmax,ypgmax,gxmax,gymax)
      gxav=0.5*(gxmax+gxmin)
      gyav=0.5*(gymax+gymin)
      gxwd=0.001*(gxmax-gxmin)
      gywd=0.001*(gymax-gymin)
      xgcur(1)=xgtem
      ygcur(1)=ygtem
      CALL IPgUnitsFromGrUnits(xgtem,ygtem,xcur(1),ycur(1))
      CALL WMessageEnable(MouseMove, Enabled)
      CALL WMessageEnable(MouseButUp, Enabled)
      IMOV = 0
      DO
        CALL WMessage(IZTYPE,ZMESSAGE)
          xgcur(2)=zmessage%GX
          ygcur(2)=zmessage%GY
          CALL IPgUnitsFromGrUnits(zmessage%GX,zmessage%GY,xcur(2),ycur(2))
          SELECT CASE (IZTYPE)
            CASE (Expose,Resize)
              CALL Redraw()
            CASE (KeyDown)
              KeyNumber=ZMessage%Value1
              CALL Check_KeyDown_PeakFind_Inner(KeyNumber,xcur(2),ycur(2))
            CASE (MouseButDown)
              IMOV = 0
            CASE (MouseMove)
! Set up the cross-hairs for peak finding
                  imov=imov+1
                  if (imov.eq.1) then
! Draw cross-hair
                    CALL IGrColourN(KolNumLargeCrossHair)
                    gxt0=xgcur(2)
                    gxt1=xgcur(2)-gxwd
                    gxt2=xgcur(2)+gxwd
                    gyt0=ygcur(2)
                    gyt1=ygcur(2)-gywd
                    gyt2=ygcur(2)+gywd
                    CALL IGrMoveTo(gxt1,gyt0)
                    CALL IGrLineTo(gxt2,gyt0)
                    CALL IGrMoveTo(gxt0,gyt1)
                    CALL IGrLineTo(gxt0,gyt2)
                  else
! Remove old cross-hair
                    if (imov.eq.2) then
                      call profile_plot(IPTYPE)
                      CALL IGrPlotMode('EOR')
                    else
                      CALL IGrMoveTo(gxmin,ygcurold)
                      CALL IGrLineTo(gxmax,ygcurold)
                      CALL IGrMoveTo(xgcurold,gymin)
                      CALL IGrLineTo(xgcurold,gymax)
!                     CALL IGrPlotMode('EOR')
                    endif
! Paint new cross-hair
                    CALL IGrColourN(KolNumLargeCrossHair)
!                    CALL IGrColourN(224)
                    CALL IGrMoveTo(gxmin,ygcur(2))
                    CALL IGrLineTo(gxmax,ygcur(2))
                    CALL IGrMoveTo(xgcur(2),gymin)
                    CALL IGrLineTo(xgcur(2),gymax)
                  end if
                  xgcurold=xgcur(2)
                  ygcurold=ygcur(2)
                if (xpgmax-xpgmin.le.200.) then
                  CALL IRealToString(xcur(2),statbarstr(2)(1:),'(f10.3)')
                else
                  CALL IRealToString(xcur(2),statbarstr(2)(1:),'(f10.1)')
                end if
                if (ypgmax-ypgmin.le.100.) then
                  CALL IRealToString(ycur(2),statbarstr(3)(1:),'(f10.3)')
                else
                  CALL IRealToString(ycur(2),statbarstr(3)(1:),'(f10.1)')
                end if
                DO ISB=2,3
                  CALL WindowOutStatusBar(ISB,STATBARSTR(ISB))
                END DO 
            CASE (MouseButUp)
! MouseButUp action for peak finding
! Remove old cross-hair
                CALL IGrMoveTo(gxmin,ygcurold)
                CALL IGrLineTo(gxmax,ygcurold)
                CALL IGrMoveTo(xgcurold,gymin)
                CALL IGrLineTo(xgcurold,gymax)
                CALL IGrPlotMode(' ')
                DO ISB=2,3
                 statbarstr(isb)='          '
                 CALL WindowOutStatusBar(ISB,STATBARSTR(ISB))
                END DO                
               CALL Profile_Plot(IPTYPE)
               RETURN 
            END SELECT
          END DO 
!
      END SUBROUTINE MOVE_CROSSHAIR
!
!*****************************************************************************
!
      SUBROUTINE Fit_PeakTop(xtem)
!
      EXTERNAL CHIQUAD
      REAL CHIQUAD
!
      INCLUDE 'PARAMS.INC'
      COMMON /PROFOBS/ NOBS,XOBS(MOBS),YOBS(MOBS),YCAL(MOBS),YBAK(MOBS),EOBS(MOBS)
      COMMON /PROFBIN/ NBIN,LBIN,XBIN(MOBS),YOBIN(MOBS),YCBIN(MOBS),YBBIN(MOBS),EBIN(MOBS)
      COMMON /PROFRAN/ XPMIN,XPMAX,YPMIN,YPMAX,XPGMIN,XPGMAX,&
      YPGMIN,YPGMAX,XPGMINOLD,XPGMAXOLD,YPGMINOLD,YPGMAXOLD, &
      XGGMIN,XGGMAX,YGGMIN,YGGMAX
      COMMON /PROFIPM/ IPMIN,IPMAX,IPMINOLD,IPMAXOLD
!
      INCLUDE 'GLBVAR.INC'

      COMMON /TICCOMM/ NUMOBSTIC,XOBSTIC(MOBSTIC),YOBSTIC(MOBSTIC),&
       itypot(mobstic),iordot(mobstic),uobstic(20,mobstic),zobstic(20,mobstic)
!
      REAL VAR(3),DVAR(3),COVAR(3,3)
      PARAMETER (MVAL=50)
      COMMON /FUNVAL/ NVAL,XVAL(MVAL),YVAL(MVAL),ZVAL(MVAL),EVAL(MVAL)
!
      axdif=abs(xobs(nobs)-xobs(1))
      klose=1
      do ii=1,nobs
        atem=abs(xtem-xobs(ii))
        if (atem.le.axdif) then
          axdif=atem
          klose=ii
        end if
      end do
!
      nval=9
      imin=klose-4
      imax=klose+4
      if (imin.lt.1) then
        imin=1
        imax=9
      end if
      if (imax.gt.nobs) then
        imax=nobs
        imin=nobs-8
      end if
!
      xav=0.5*(xobs(imax)+xobs(imin)) 
      xran=0.5*(xobs(imax)-xobs(imin))      
      do i=1,9
        ii=imin+i-1
        xval(i)=(xobs(ii)-xav)/xran
        yval(i)=yobs(ii)
        eval(i)=eobs(ii)
      end do
!
      nvar=3
      var(1)=0.5*(yobs(imax)+yobs(imin))-yobs(imin+3)
      var(2)=0.5*(yobs(imax)-yobs(imin))
      var(3)=yobs(imin+3)
      dvar(1)=0.1*var(1)
      dvar(2)=0.1*var(2)
      dvar(3)=0.1*var(3)
!
      call simopt(var,dvar,covar,nvar,chiquad)
      xb=-0.5*var(2)/var(1)
      yb=var(1)*xb*xb+var(2)*xb+var(3)
      uran=xobs(imax)-xobs(imin)
      xobstic(numobstic)=xav+xran*xb
      yobstic(numobstic)=yb
      do i=1,9
        utt=xobs(imin)+0.125*float(i-1)*uran
        uobstic(i,numobstic)=utt
        ut=(utt-xav)/xran
        zobstic(i,numobstic)=var(1)*ut*ut+var(2)*ut+var(3)
      END DO

      END SUBROUTINE fit_peaktop
!
!*****************************************************************************
!
! Originally in Wizard_routines.f90
!
      SUBROUTINE PolyFitter_Wizard
!   Open the first wizard child window
      USE WINTERACTER
      USE DRUID_HEADER
      USE VARIABLES

      IMPLICIT NONE                           
!
!   Variable declarations
!
!O      LOGICAL :: NODATA
      LOGICAL :: SKIP = .FALSE.
      INTEGER :: IPW_Option

      INCLUDE 'statlog.inc'
      INCLUDE 'DialogPosCmn.inc'
      INCLUDE 'Lattice.inc'

      INTEGER :: IRadSelection
      REAL Temp
      CHARACTER(LEN=256) :: CTEMP

      INCLUDE 'GLBVAR.INC' ! Contains JRadOption which replaces SourceState and IRadOption
      INTEGER IDummy

      LOGICAL FnUnitCellOK ! Function

      SKIP = .FALSE.
!.. Set up some defaults
 8    CONTINUE
 1    CONTINUE
      CALL WDialogSelect(IDD_Polyfitter_Wizard_01)
      CALL WDialogShow(IXPos_IDD_Wizard,IYPos_IDD_Wizard,0,Modeless)

! JvdS Wizard is now dealt with per window
      RETURN


! Now check on which button was pressed ...
      DO WHILE (.NOT. SKIP)
        IXPos_IDD_Wizard = WInfoDialog(6)
        IYPos_IDD_Wizard = WInfoDialog(7)
        CALL GetEvent
        SELECT CASE (EventInfo%WIN)
          CASE (0)
! Process main window messages
            CALL process_mainwindow_message
            CYCLE
        END SELECT
        SELECT CASE (EventType)
          CASE (PushButton)
            SELECT CASE (EventInfo%VALUE1)
              CASE (IDNEXT)
                IXPos_IDD_Wizard = WInfoDialog(6)
                IYPos_IDD_Wizard = WInfoDialog(7)
                CALL WDialogHide()
! We're off the main page and on to new pages depending on the option.
                CALL WDialogGetRadioButton(IDF_PW_Option1,IPW_Option)
                SELECT CASE (IPW_Option)
                  CASE(1) ! view data/ determine peak positions
                    GOTO 300
                  CASE(2) ! Pawley
                    GOTO 100
                  CASE(3) ! Simulated Annealing
                    GOTO 500
                  CASE(4) ! Read Druid pawley file
                    GOTO 600
                END SELECT
              CASE (IDF_PW0_Skip,IDCANCEL)
                SKIP = .TRUE.
                CALL WDialogHide()
                CALL ToggleMenus(1)
                RETURN
            END SELECT
        END SELECT
      END DO
      CALL ToggleMenus(1)
      RETURN
!.. Deal here with page 1 (cases 2 and 3)
 100  SKIP = .FALSE.
      CALL WDialogSelect(IDD_PW_Page1)
! If the cell is OK, the Next> button should be enabled
      IF (FnUnitCellOK()) THEN
! Enable the wizard next button
        CALL WDialogFieldState(IDNEXT,Enabled)
      ELSE
! Disable the wizard next button
        CALL WDialogFieldState(IDNEXT,Disabled)
      END IF
      CALL WDialogShow(IXPos_IDD_Wizard,IYPos_IDD_Wizard,0,Modeless)
      DO WHILE (.NOT. SKIP)
        IXPos_IDD_Wizard = WInfoDialog(6)
        IYPos_IDD_Wizard = WInfoDialog(7)
        CALL GetEvent
        SELECT CASE (EventInfo%WIN)
          CASE (0)
! Process main window messages
            CALL process_mainwindow_message
            CYCLE
        END SELECT
        SELECT CASE (EventType)
          CASE (PushButton)
            SELECT CASE (EventInfo%VALUE1)
              CASE(IDBACK)
                CALL WDialogHide()
                GOTO 1
              CASE(IDNEXT)
! We're off the second page and on to the last page
                CALL WDialogHide()
!C>>                          CALL WDialogSelect(IDD_PW_Page1)
                GOTO 200
              CASE(IDCLOSE,IDCANCEL)
                SKIP = .TRUE.
                CALL WDialogSelect(IDD_PW_Page1)
                CALL WDialogHide()
                CALL ToggleMenus(1)
                RETURN
            END SELECT
          CASE (FieldChanged)
            SELECT CASE (EventInfo%VALUE1)
              CASE (IDF_Space_Group_Menu)
                CALL Update_Space_Group(IDD_PW_Page1, IDummy, IDummy)
                NumPawleyRef = 0
              CASE (IDF_Crystal_System_Menu)
                CALL WDialogGetMenu(IDF_Crystal_System_Menu,LatBrav)
                CALL SetCrystalSystem(LatBrav)
                CALL SetSpaceGroupMenu(LatBrav)
                CALL Generate_TicMarks
              CASE (IDF_a_latt)
                CALL WDialogGetReal(IDF_a_latt,CellPar(1))
                CALL UpdateCell(IDD_PW_Page1)
              CASE (IDF_b_latt)
                CALL WDialogGetReal(IDF_b_latt,CellPar(2))
                CALL UpdateCell(IDD_PW_Page1)
              CASE (IDF_c_latt)
                CALL WDialogGetReal(IDF_c_latt,CellPar(3))
                CALL UpdateCell(IDD_PW_Page1)
              CASE (IDF_alp_latt)
                CALL WDialogGetReal(IDF_alp_latt,CellPar(4))
                CALL UpdateCell(IDD_PW_Page1)
              CASE (IDF_bet_latt)
                CALL WDialogGetReal(IDF_bet_latt,CellPar(5))
                CALL UpdateCell(IDD_PW_Page1)
              CASE (IDF_gam_latt)
                CALL WDialogGetReal(IDF_gam_latt,CellPar(6))
                CALL UpdateCell(IDD_PW_Page1)
            END SELECT                
        END SELECT
      END DO
!.. Deal here with page 2 of Pawley, i.e. Basic Diffraction Information
! Now called: Diffraction Setup
 200 SKIP = .FALSE.
      CALL WDialogSelect(IDD_PW_Page2)
      CALL SetSourceDataState(JRadOption)
      CALL WDialogShow(IXPos_IDD_Wizard,IYPos_IDD_Wizard,0,Modeless)
      DO WHILE(.NOT. SKIP)
        IXPos_IDD_Wizard = WInfoDialog(6)
        IYPos_IDD_Wizard = WInfoDialog(7)
        CALL GetEvent
        SELECT CASE (EventInfo%WIN)
          CASE (0)
! Process main window messages
            CALL process_mainwindow_message
            CYCLE
        END SELECT
        CALL WDialogGetRadioButton(IDF_PW_LabX_Source,JRadOption)
        CALL SetSourceDataState(JRadOption)
        SELECT CASE (EventType)
          CASE(FieldChanged)
            SELECT CASE (EventInfo%VALUE1)
              CASE (IDF_PW_wavelength1)
                CALL WDialogGetReal(IDF_PW_wavelength1,Temp)
                CALL UpdateWavelength(Temp)
!C>> JCC Add in function  
              CASE (IDF_Wavelength_Menu)
                CALL WDialogGetMenu(IDF_Wavelength_Menu,IRadSelection)
                CALL SetWavelengthToSelection(IRadSelection)
            END SELECT
          CASE (PushButton)
            SELECT CASE (EventInfo%VALUE1)
              CASE (ID_PW_DF_Open)
!C>> JCC Add callback for Open button
                CALL WDialogGetString(IDF_PW_DataFileName_String,CTEMP)
                CALL Diffraction_File_Open(CTEMP)
!C>> JCC Have to reselect after the file open
                CALL WDialogSelect(IDD_PW_Page2)
              CASE (IDBBROWSE)
                CALL Diffraction_File_Browse
!C>> JCC Have to reselect after the file open
                CALL WDialogSelect(IDD_PW_Page2)
              CASE (IDBACK)
                CALL WDialogHide()
                GOTO 100
              CASE (IDFINISH)
                SKIP = .TRUE.
                CALL WDialogHide()
                CALL ToggleMenus(1)
                RETURN
              CASE (IDCANCEL)
                SKIP = .TRUE.
                CALL WDialogHide()
                CALL ToggleMenus(1)
                RETURN
            END SELECT
        END SELECT
      END DO
!   view data/ determine peak positions
!.. Deal here with page 3 - only visited for options 1 & 2
 300  SKIP = .FALSE.
      CALL WDialogSelect(IDD_PW_Page3)
      CALL WDialogShow(IXPos_IDD_Wizard,IYPos_IDD_Wizard,0,Modeless)
      DO WHILE(.NOT. SKIP)
        IXPos_IDD_Wizard = WInfoDialog(6)
        IYPos_IDD_Wizard = WInfoDialog(7)
        CALL GetEvent
        SELECT CASE (EventInfo%WIN)
          CASE (0)
! Process main window messages
            CALL process_mainwindow_message
            CYCLE
        END SELECT
        SELECT CASE (EventType)
          CASE (PushButton)
            SELECT CASE (EventInfo%VALUE1)
!C>> JCC Add callback for Open button
              CASE(ID_PWa_DF_Open)
                CALL WDialogGetString(IDF_PWa_DataFileName_String,CTEMP)
                CALL Diffraction_File_Open(CTEMP)
!C>> JCC Need to reselect dialogue after the action
                CALL WDialogSelect(IDD_PW_Page3)
              CASE(ID_PWa_DF_Browse)
                CALL Diffraction_File_Browse
!C>> JCC Need to reselect dialogue after the action
                CALL WDialogSelect(IDD_PW_Page3)
              CASE(IDBACK)
                CALL WDialogHide()
                GOTO 1
!C>>                  CASE(IDF_PW3_Skip)
!C>>                    SKIP = .TRUE.
                CALL WDialogHide()
! JvdS It's kind of dirty that 'Cancel' and 'Finish' amount to the same thing.
              CASE(IDFINISH,IDCANCEL)
                SKIP = .TRUE.
                CALL WDialogHide()
                CALL ToggleMenus(1)
                RETURN
            END SELECT
        END SELECT
      END DO
!.. Deal with the simulated annealing ...
 500  SKIP = .FALSE.
      IXPos_IDD_SA_Input = IXPos_IDD_Wizard
      IYPos_IDD_SA_Input = IYPos_IDD_Wizard
      CALL SA_MAIN()
      GOTO 8
 600  IXPos_IDD_SA_Input = WInfoDialog(6)
      IYPos_IDD_SA_Input = WInfoDialog(7)
      CALL SA_MAIN()
      CALL ToggleMenus(1)
      RETURN

      END SUBROUTINE PolyFitter_Wizard
!
!*****************************************************************************
!
! Originally in Profile_Plot.f90
!
      SUBROUTINE Plot_SA_Profile()
!
      USE WINTERACTER
      USE DRUID_HEADER
!
      INCLUDE 'POLY_COLOURS.INC'

      INCLUDE 'PARAMS.INC'

      REAL ydif(MCHSTP)
!
      COMMON /CHISTOP/ NOBS,NFIT,IFIT(MCHSTP),CHIOBS,&
      WT(MCHSTP),XOBS(MCHSTP),YOBS(MCHSTP),YCAL(MCHSTP),ESD(MCHSTP)
!
      COMMON /sappcmn/ xpmin,xpmax,ypmin,ypmax
      COMMON /sapgcmn/ xpgmin,xpgmax,ypgmin,ypgmax
      COMMON /chibest/ ycalbest(MCHSTP)
!
      BACK=0.
      YOSUM=0.
      YCSUM=0.
      DO II=1,NFIT
        I=IFIT(II)
        YOSUM=YOSUM+YOBS(I)
        YCSUM=YCSUM+YCALbest(I)
      END DO
      RESCL=YOSUM/YCSUM
      DO I=1,NOBS
        YCALbest(i)=RESCL*YCALbest(I)
      END DO
      CALL IPgUnits(xpgmin,ypgmin,xpgmax,ypgmax)
       call IGrColourN(KolNumMain)
      CALL IPgYLabelLeft('Observed profile','C9')
!
!      CALL IPgNewGraph(3,nobs,' ',' ','XY')
      CALL IPgNewPlot(PgPolyLine,3,NOBS)
      YADD=0.5*(YPGMAX+YPGMIN)
      DO II=1,NOBS!IPMIN,IPMAX
        YDIF(II)=YADD+YOBS(II)-YCALBEST(II)
      END DO
      CALL IPgStyle(1,0,0,0,KolNumDif,0)
      CALL IPgStyle(2,0,3,0,0,KolNumObs)
      CALL IPgStyle(3,0,0,0,KolNumCal,0)
      CALL IPgXYPairs(xobs,ydif)
      CALL IGrCharSize(.3,.3)
      CALL IPgMarker( 2, 13)
!      sizmtem=marker_size*float(500)/float(ipmax-ipmin)
!      sizmtem=min(marker_size,sizmtem)
!      CALL IGrCharSize(sizmtem,sizmtem)
      CALL IPgXYPairs(xobs,yobs)
!
! Do the error bars - we've precalculated the min & max pointers
!
      CALL IGrColourN(KolNumObs)
      DO I=1,nobs!IPMIN,IPMAX
        xtem=xobs(i)
        ytem=max(yobs(i)-esd(i),ypgmin)
        ytem=min(ytem,ypgmax)
        call IPgUnitsToGrUnits(xtem,ytem,xgtem,ygtem)
        call IGrMoveTo(xgtem,ygtem)
        ytem=min(yobs(i)+esd(i),ypgmax)
        ytem=max(ytem,ypgmin)
        call IPgUnitsToGrUnits(xtem,ytem,xgtem,ygtem)
        call IGrLineTo(xgtem,ygtem)
      END DO
      CALL IPgXYPairs(xobs,ycalbest)
      CALL IGrCharSize(1.,1.)
      CALL IGrColourN(KolNumMain)
!
      END SUBROUTINE Plot_SA_Profile
!
!*****************************************************************************
!
! Originally in SA_structure_output.for
!


	subroutine sa_dash_solution_report(T,CHIMIN,CHIAV,CHIESD,
     & xopt,dxvav,xvsig,flav,lb,ub,vm,n,iteration)
!
!
      USE WINTERACTER
      USE DRUID_HEADER
      COMMON /PRCHISQ/ PAWLEYCHISQ,RWPOBS,RWPEXP
!
	real*8 xopt(*),dxvav(*),xvsig(*),flav(*),lb(*),ub(*),vm(*)
!
!
      parameter (maxiter=10000)
      common /pltstore/ xiter(maxiter),tstore(maxiter),
     &        foptstore(maxiter),fpavstore(maxiter)

	parameter (maxfrg=20)
      character*36 czmpar
      common /zmnpar/ izmtot,izmpar(maxfrg),
     &      czmpar(30,maxfrg),kzmpar(30,maxfrg),xzmpar(30,maxfrg)
      logical gotzmfile
      common /zmlgot/ gotzmfile(maxfrg)

      COMMON /PLTSTO2/ CHIPROBEST(MAXITER)

	INTEGER ipnum

      OPEN(UNIT=101,FILE='test.sum',STATUS='UNKNOWN',ERR=99)

	WRITE(101,'(a)')'# Dash summary file for current best solution'

      WRITE(101,'(a, f8.2)')
     & '# Best profile chi-squared:   ', CHIPROBEST(iteration)
	WRITE(101,'(a, f8.2)')
     & '# Best intensity chi-squared: ', chimin

      WRITE(101,'(a, f8.2)')
     & '# Current temperature:        ', T
!
	WRITE(101,'(a)')
     & '# Summary of new parameter values follows'

	



	write(101,'(a)')'# Translations'
	write(101,'(3a,12a,12a,12a)')
     &  '#  ','Value','Lower bound','Upper bound'
	write(101,'(a,3f12.5)')'X: ',
     &                       sngl(xopt(1)), sngl(lb(1))  ,sngl(ub(1))
	write(101,'(a,3f12.5)')'Y: ',
     &                       sngl(xopt(2)), sngl(lb(2))  ,sngl(ub(2))
	write(101,'(a,3f12.5)')'Z: ',
     &                       sngl(xopt(3)), sngl(lb(3))  ,sngl(ub(3))

	write(101,'(a)')'# Q-rotations'
	write(101,'(3a,12a,12a,12a)')
     &  '#  ','Value','Lower bound','Upper bound'
	do i = 4,7
	write(101,'(a,i1,1x,3f12.5)')'Q',i,
     &                       sngl(xopt(i)), sngl(lb(i))  ,sngl(ub(i))
	end do

	write(101,'(a)')
	

	


	close(101)
 99   return
	end

!
!*****************************************************************************
!
! Originally in Pr.for
!
C
C
C LEVEL 9       SUBROUTINE CALPRM(PCXX,PFXX)
      SUBROUTINE CALPRM(PCXX,PFXX)
C
C  *** CALPRM updated by JBF 13 JAN 1995 ***
C
CH Gives calculated function to match observed for all PR applications
CH which involve both nuclear and magnetic structure factors
CA PCXX is the name of the routine giving peak centre
CA PFXX is the name of the routine giving peak function
CP on entry in /PRPKFN/ expects ARGI, the argument for the I'th observation
C
CD Forms GCALC, then summed to make YPEAK
CD Adds derivatives of GCALC into previously cleared DERIVV, and via RFACPR
CD gives GGCALC and contributions to SOMEGA.
C
CD GCALC is made from several functions multiplied together.
CD We write GCALC = P1*P2*P3* . . . where:
CD    P1 is an outside multiplying factor containing scale, Lp, multiplicity,
CD       overal tf, etc - it does not contain any structure parameters
CD    P2 is a fuction of both types of structure factor, being
CD             Fc(nuc) squared + Fc(mag) squared
CD    P3 is an extinction correction
CD    P4 is an absorption correction
CD    P5 is the peak function
CD
CD YPEAK is then the sum over contributing k values of GCALC.
C
CD Should work for all refinement types (RIET, CAIL, SAPS, . .)
CD                 all data sources (TOF, CN, LX . . )
C
      EXTERNAL PCXX,PFXX
      LOGICAL TESTOV,LATABS
      COMPLEX FCALC

      INCLUDE 'PARAMS.INC'
C%
C      DIMENSION DERIVA(%VVAR%),CDERS(6),PDERS(3),DERIV4(5)
      DIMENSION DERIVA(500),CDERS(6),PDERS(3),DERIV4(5)
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /CELPAR/CELL(3,3,2),V(2),ORTH(3,3,2),CPARS(6,2),KCPARS(6),
     & CELESD(6,6,2),CELLSD(6,6),KOM4
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(5,5),
     & NLAMB,ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /FCAL/FC,FCMOD,COSAL,SINAL,FCDERS(300),DERIVT(300)
      COMPLEX FC,DERIVT
      COMMON /F4PARS/NGEN4(9,5),F4VAL(3,MF4PAR),
     & F4PAR(3,MF4PAR),KF4PAR(3,MF4PAR),F4PESD(3,MF4PAR),KOM6
      COMMON /MCAL/FMCMOD,FMCSQR,FMCDER(300)
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /OVER/ITFAC,OTFAC(10),KOTFAC(10),NTFAC,JTFAC,KOM15
      EQUIVALENCE (TFAC,OTFAC(1)),(KTFAC,KOTFAC(1))
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /PRABSC/NABTYP(5),ABSPR(2,5),KABSPR(2,5),
     & ABSCOR,DERABQ(2),NABSPR(5)
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /PREORI/NPRTYP,PRFDIR(3),PRFLEN,PRFPAR,KPRFPR,PRFCOR,DERPRQ
      COMMON /PREXTN/NEXTYP,EXTPR,KEXTPR,EXTCO,DEREXQ,DXDFQ
      COMMON /PRPKCN/ARGK,PKCNSP(6,9,5),
     & KPCNSP(6,9,5),DTDPCN(6),DTDWL,
     & NPKCSP(9,5),ARGMIN(5),ARGMAX(5),
     & ARGSTP(5),PCON
      COMMON /PRPKFN/ARGI,YNORM,PKFNSP(8,6,9,5),
     & KPFNSP(8,6,9,5),
     & DERPFN(8,6),NPKFSP(8,9,5),TOLER(8,9,
     & 5),NPKGEN(9,5),PKFNVA(8),DYNDVQ(8),
     & DYNDKQ,REFUSE,CYC1,NOPKRF,TOLR(2,5),NFFT,AKNOTS,
     & NBASF4(MPRPKF,2,9),L4END(9),L6ST,L6END

      LOGICAL REFUSE,CYC1,NOPKRF
      COMMON /PRSAVE/KPOINT(200),SAVP2(200),SAVDER(300,200),
     & SAVPRC(200),SAVDPC(200),SAVFCN(200)
      COMMON /PRSTAT/SMYC,SMYD,SMYO,SMIO,SMID,SMWYOS,IZCT,
     & P5,IOP1,IOP2,KMI(9),KMA(9)
      COMMON /PRZERO/ZEROSP(6,9,5),KZROSP(6,
     & 9,5),DKDZER(6),NZERSP(9,5)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /REFIPR/RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
      LOGICAL RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
C>> JCC Moved to an include file
	INCLUDE 'REFLNS.INC'
      COMMON /SATELL/PROP(3),KPROP(3),KSTAB(24),NKSTAR,IPROP,FKSTAR,
     & NKC,KCENT,INCOM,KOM21
      LOGICAL INCOM
      COMMON /SOURCE/NSOURC,JSOURC,KSOURC,NDASOU(5),METHOD(
     & 9),NPFSOU(9,5),NSOBS(5),SCALES(5),
     & KSCALS(5),NPCSOU(9,5)
      COMMON /TTHMNC/TTHMON(5),KTHMON(5),C2TMON(5),
     & S4TMON(5),OPCMON(5),ALPCOR,DLPCOR
C
C IF X-RAY, DEAL FIRST WITH LP FOR THIS ARGI:
      IF (LX) CALL TTHMLX(2)
C
C CYCLE OVER K:
      DO 11 KNOW=KMIN,KMAX
C
C THIS KNOW MAY HAVE OCCURRED RECENTLY:
C%
C      KMOD=MOD(KNOW-1,%OLAP%)+1
      KMOD=MOD(KNOW-1,200)+1
      REFUSE=(KNOW .EQ. KPOINT(KMOD))
C FORM D* SQUARED,S SQUARED, AND DERIVATIVES WRT RECIPROCAL CELL
C PARAMETERS:
        CALL CELDER(REFH(1,KNOW),CDERS)
        IF (MAG) CALL PROPDR(REFH(1,KNOW),ISMAG(KNOW),PDERS)
        DSTAR(KNOW)=SQRT(DSTAR2)
C
C SET ARGK AND LAMBDA FOR THIS REFLECTION:
      CALL PCXX(2)
C
C CLEAR INTERNAL DERIVATIVES:
      L2=NVARF(2,JPHASE,1)
      L123=NVARF(1,JPHASE,JSOURC)+L2+NVARF(3,JPHASE,JSOURC)*NSOURC
      L1ST=LVFST1(1,JPHASE,1)
C
C FORM P1 AND SOME FAMILY 1 QUOTIENT DERIVATIVES (ALL /P1):
C EACH DATA TYPE HAS DIFFERENT FACTOR:
      IF (TOF) FAC=1./(DSTAR2*DSTAR2)
      IF (CN) FAC=1./(SIN(RAD*ARGK)*SIN(0.5*RAD*ARGK))
      IF (LX) FAC=ALPCOR*V(2)*V(2)
      P1=SCALEP(JPHASE)*SCALES(JSOURC)*EXP(-2.*SSQRD*TFAC)*
     & AMUL(KNOW)*FAC
C TFAC DERIVATIVE:
      L=KTFAC
      IF (L .GT. 0) DERIVA(L)=-2.*SSQRD
C SCAL DERIVATIVE:
      L=KSCALS(JSOURC)
      IF (L .GT. 0) DERIVA(L)=1./SCALES(JSOURC)
      L=KSCALP(JPHASE)
      IF (L .GT. 0) DERIVA(L)=1./SCALEP(JPHASE)
C
C PREFERRED ORIENTATION:
      IF (NPRTYP .GT. 0) THEN
        L=KPRFPR
        IF (.NOT. REFUSE) THEN
          CALL PREFOR(2)
          SAVPRC(KMOD)=PRFCOR
          IF (L .GT. 0) SAVDPC(KMOD)=DERPRQ
        ENDIF
        P1=P1*SAVPRC(KMOD)
        IF (L .GT. 0) DERIVA(L)=SAVDPC(KMOD)
      ENDIF
C
C IF X-RAY, MONOCHROMATOR ANGLE:
      IF (LX) THEN
        L=KTHMON(JSOURC)
        IF (L .NE. 0) DERIVA(L)=DLPCOR
      ENDIF
C
C NEXT DO P2, THE PART DEPENDENT ON THE STRUCTURE FACTOR:
C IF CAIL, P2 IS SIMPLY F4PAR(1,KNOW):
      IF (CAIL .OR. APES) THEN
C MUST SET KPOINT FOR USE BY FFT NEXT TIME ROUND:
        KPOINT(KMOD)=KNOW
        L4=KF4PAR(1,KNOW)
        IF (L4 .EQ. 0) THEN
          F4PAR(1,KNOW)=1.
        ELSE
          DERIV4(1)=1.
        ENDIF
        IF (F4PAR(1,KNOW).NE. 0.) DERIV4(1)=1./F4PAR(1,KNOW)
        P2=F4PAR(1,KNOW)
      ELSE
C SET BASE FOR DERIVATIVES:
        III=LVFST1(2,JPHASE,1)
        IF (.NOT. REFUSE) THEN
C NEW K:
          IF (L2 .GT. 0) THEN
            CALL LFCALC(REFH(1,KNOW))
            CALL LMCALC(REFH(1,KNOW))
            P2=FCMOD*FCMOD + FMCSQR
            F=0.
            IF (.NOT. TESTOV(2.,P2)) F=2./P2
C CONVERT FAMILY 2 DERIVATIVES FROM BEING 'OF FCMOD' TO 'OF P2'
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2)
            DO 4 I=1,L2
            DERIVA(III+I)=F*(FCDERS(I)*FCMOD+FMCDER(I))
            SAVDER(I,KMOD)=DERIVA(III+I)
   4        CONTINUE
          ELSE
            IF(.NOT. LATABS(REFH(1,KNOW)))
     &      FC=FCALC(REFH(1,KNOW))
            CALL FMCALC(REFH(1,KNOW),FMCMOD,FMCSQR)
            P2NUC=FC*CONJG(FC)
            P2=P2NUC + FMCSQR
            FCMOD=SQRT(P2NUC)
          ENDIF
C
          KPOINT(KMOD)=KNOW
**NB IF WE ARE RIGHT ABOUT FCMOD & P2 & SAVING, WE NEED BOTH FCMOD & P2 HERE
** BECAUSE YOU CANNOT DEDUCE ONE FROM THE OTHER
          SAVP2(KMOD)=P2
          SAVFCN(KMOD)=FCMOD
        ELSE
C
C P2 FOR THIS K SAVED WHEN USED PREVIOUSLY:
          P2=SAVP2(KMOD)
          FCMOD=SAVFCN(KMOD)
          DO 420 I=1,L2
 420      DERIVA(III+I)=SAVDER(I,KMOD)
        ENDIF
      ENDIF
C
C P3:
      CALL EXCRPR(2)
      P3=EXTCO
      DP2DFQ=DP2DFQ+DXDFQ
      L=KEXTPR
      IF (L .GT. 0) DERIVA(L)=DEREXQ
C
C P4:
      CALL ABCRPR(2)
      P4=ABSCOR
      DO 88 IA=1,2
      L=KABSPR(IA,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DERABQ(IA)
  88  CONTINUE
C
C P5 - PEAK FUNCTION:
      CALL PFXX(2)
      P5=YNORM
C
C ADJUST DERIVATIVES WRT ZERO POINT:
      DO 14 I=1,NZERSP(JPHASE,JSOURC)
      L=KZROSP(I,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*DKDZER(I)
  14  CONTINUE
C
C ADJUST DERIVATIVES WRT PEAK CENTRE PARAMETERS, IF ANY:
      DO 13 I=1,NPKCSP(JPHASE,JSOURC)
      L=KPCNSP(I,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*DTDPCN(I)
  13  CONTINUE
C
C TAKE DERIVATIVES AS FORMED BY PFXX AND PUT INTO DERIVA
      DO 12 I=1,NPKGEN(JPHASE,JSOURC)
      DDDTEM=DYNDVQ(I)
C IF SAPS OR APES, AND REFINING THIS SIGS:
      IF (RIET .OR. CAIL) GO TO 29
C      IF (I .NE. 4) GO TO 29
      IG=I+1
      IF (TOF) IG=I-2
      IF (IG .NE. 2 .AND. IG .NE. 3) GO TO 29
      IF (KF4PAR(IG,KNOW) .GT. 0) THEN
**** CHECK THIS - SHOULD BE DERIVATIVE OF P5 WRT SIGS
        DERIV4(IG)=DDDTEM
        GO TO 12
      ENDIF
  29  DO 112 J=1,NPKFSP(I,JPHASE,JSOURC)
      L=KPFNSP(I,J,JPHASE,JSOURC)
      IF (L .GT. 0) DERIVA(L)=DDDTEM*DERPFN(I,J)
  112 CONTINUE
   12 CONTINUE
C
C NOW CELL PARAMETERS, A* - F*, WHOSE DERIVATIVES SO FAR ARE OF D*SQUARED:
      IF (CN .OR. LX) FAC=DKDDS
      IF (TOF) FAC=DTDWL*(-0.5*WLGTH)/DSTAR2
      DO 10 I=1,6
C CHAIN RULE: YNORM - ARGK - D*SQRD - CELL PARAM.
      L=KCPARS(I)
      IF (L .GT. 0) DERIVA(L)=DYNDKQ*CDERS(I)*FAC
   10 CONTINUE
C
C DERIVS OF PROPAGATION VECTOR
      DO 15 I=1,3
      L=KPROP(I)
      IF (L.GT.0) DERIVA(L)=DYNDKQ*PDERS(I)*FAC
   15 CONTINUE
C
      GCALC = P1*P2*P3*P4*P5
      YPEAK=YPEAK+GCALC
C
C PUT APPROXIMATION TO I(CALC) INTO COMMON:
      AICALC(KNOW)=P1*P2
C
C SET GGCALC(K FOR THIS I), AND ADD P5 IN TO SOMEGA(K):
      CALL RFACPR(6,PCXX)
C
C
C FAMILIES 1,2,3:
      DO 6 I=1,L123
   6  DERIVV(L1ST+I)=DERIVV(L1ST+I) + DERIVA(L1ST+I)*GCALC
C FAMILY 4:
      IF (.NOT. RIET) THEN
        IF (L4 .NE. 0) DERIVV(L4)=DERIVV(L4)+DERIV4(1)*GCALC
      ENDIF
C FAMILY 6:
C SCALE DERIVATIVES:
      L=KSCALS(JSOURC)
      IF (L.GT.0) DERIVV(L)=DERIVV(L) + DERIVA(L)*GCALC
      DO 7 IA=1,2
      L=KABSPR(IA,JSOURC)
      IF (L.GT.0) DERIVV(L)=DERIVV(L) + DERIVA(L)*GCALC
   7  CONTINUE
  11  CONTINUE
C
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE WRITIC
      SUBROUTINE WRITIC
C
C *** WRITIC updated by JCM 28 Dec 92 ***
C
C      SUBROUTINE TO WRITE A CORRECTLY FORMATTED GENIE INTERMEDIATE FILE
C
      COMMON /FCCDAT/DATFIL,INSTNM,LONGTI,RUNUSR,STTIME,
     & WSHIST,XCAPT,YCAPT,MCAPT
      CHARACTER DATFIL*80,INSTNM*8,LONGTI*80,RUNUSR*20,
     & STTIME*20,WSHIST*200,XCAPT*40,YCAPT*40,MCAPT*40
      COMMON /FOCDAT/NOTC,NCYMIN,NCYMAX,DELTA,LDFIL,FI,
     & INSTCO,INSTST,NXCODE,LNPDFN,AL1,AL2,NOSPEC,NPT,
     & NUMRUN,RUNDUR,TTHET,XMN,XMX,YMN,YMX,NYCODE,NEMODE,
     & EFIXED,USERPR(30),TDATA(33000),BACK(33000),OBSDAT(33000),
     & CALDAT(33000),ERR(33000),STADAT(33000),YRANGE,IUNIT
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /REFIPR/RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
      LOGICAL RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
C>> JCC Moved to an include file
	INCLUDE 'REFLNS.INC'
	INCLUDE 'params.inc'
C%
C      COMMON /SCRAT/IH(3),H(3),TEMREF(3,%REFS%),IORDER(%REFS%),
      COMMON /SCRAT/IH(3),H(3),TEMREF(3,ITMREF),IORDER(ITMREF),
     & TEMMUL(ITMREF),ARG(ITMREF),TF4P(6,ITMREF),TEMP(6),
     & ARGN(ITMREF),ANT(ITMREF),EINT(ITMREF)
C
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      COMMON /WHEN/DAT,TIM(2),MAIN
      CHARACTER *5 TIM
      CHARACTER *10 DAT
      CHARACTER *6 MAIN
C
      COMMON /WORKG/IWORK(256)
      REAL RWORK(256)
      CHARACTER*1024 CWORK
C NON-STANDARD FORTRAN 77:
CVMS
      EQUIVALENCE (IWORK,CWORK),(IWORK,RWORK)
C
C      OPEN THE DATA FILE AND FILL THE FIRST 91 PARAMETERS.
C
      MESSAG='TIC file'
      IUNIT=NOPFIL(21212)
C
      NTCB=MAXK+1
C
      CALL WRSTRT(NTCB,1)
C
C      WRITE USER PARAMETERS (NOTHING )
      CALL WRDATA(.FALSE.,IUNIT,USERPR,30)
C
C SET UP WHAT DIFFERS FROM THE TIC CALL OF WRINST:
      AINTMX=0.
      NCYMIN=1
      NCYMAX=MAXK
      DO 2 I=1,MAXK
      AINTMX=AMAX1(AINTMX,ANT(I))
** BEWARE IF ANY NEW MAIN PROGRAMS ARE WRITTEN IN THE TIC/PICTIC AREA:
      IF (MAIN .EQ. 'TIC') EINT(I) = 0.2*ANT(I)
   2  CONTINUE
C COMPLAIN ON ALL ZERO (OR -VE) INTS:
      IF (AINTMX .EQ. 0.) CALL ERRMES(1,0,
     & 'no positive integrated intensities')
      YMN=0.
      IF (MAIN .EQ. 'PICTIC') THEN
        YMX=0.20*YRANGE
        ATEM=0.20*YRANGE/AINTMX
        DO 3 I=1,MAXK
        ANT(I)=ATEM*ANT(I)
        EINT(I)=0.20*ANT(I)
   3    CONTINUE
      ELSE
        YMX=AINTMX
      ENDIF
C
C SET & WRITE INITIAL INSTRUMENT PARAMETERS ETC TO FILE:
      CALL WRINST(MAXK)
C
C      NOW WRITE RTCB, RCOUNT AND RERR ARRAYS TO DATA FILE
      CALL WRDATA(.FALSE.,IUNIT,ARGN,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,ANT,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,EINT,NTCB)
C
C      NOW ENSURE THAT FILE IS CLOSED PROPERLY
      CALL WRDATA(.TRUE.,IUNIT,IWORK,0)
      RETURN
      END
C
C
C
C LEVEL 5      SUBROUTINE WRIPIC
      SUBROUTINE WRIPIC
C
C      SUBROUTINE TO WRITE A CORRECTLY FORMATTED GENIE INTERMEDIATE FILE
C
      COMMON /FCCDAT/DATFIL,INSTNM,LONGTI,RUNUSR,STTIME,
     & WSHIST,XCAPT,YCAPT,MCAPT
      CHARACTER DATFIL*80,INSTNM*8,LONGTI*80,RUNUSR*20,
     & STTIME*20,WSHIST*200,XCAPT*40,YCAPT*40,MCAPT*40
      COMMON /FOCDAT/NOTC,NCYMIN,NCYMAX,DELTA,LDFIL,FI,
     & INSTCO,INSTST,NXCODE,LNPDFN,AL1,AL2,NOSPEC,NPT,
     & NUMRUN,RUNDUR,TTHET,XMN,XMX,YMN,YMX,NYCODE,NEMODE,
     & EFIXED,USERPR(30),TDATA(33000),BACK(33000),OBSDAT(33000),
     & CALDAT(33000),ERR(33000),STADAT(33000),YRANGE,IUNIT
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /REFIPR/RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
      LOGICAL RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C
      COMMON /WORKG/IWORK(256)
      REAL RWORK(256)
      CHARACTER*1024 CWORK
C NON-STANDARD FORTRAN 77:
CVMS
      EQUIVALENCE (IWORK,CWORK),(IWORK,RWORK)
C
C      OPEN THE DATA FILE AND FILL THE FIRST 91 PARAMETERS.
C
      MESSAG='PICTIC file'
      IUNIT=NOPFIL(21212)
C
      NTCB=NPT+1
      CALL WRSTRT(NTCB,3)
C
C      WRITE USER PARAMETERS (NOTHING )
      CALL WRDATA(.FALSE.,IUNIT,USERPR,30)
C
C SET & WRITE INITIAL INSTRUMENT PARAMETERS ETC TO FILE:
      CALL WRINST(NPT)
C
C      NOW WRITE RTCB, RCOUNT AND RERR ARRAYS TO DATA FILE
      CALL WRDATA(.FALSE.,IUNIT,TDATA,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,OBSDAT,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,ERR,NTCB)
C
C      WRITE USER PARAMETERS (NOTHING )
      CALL WRDATA(.FALSE.,IUNIT,USERPR,30)
C
C      WRITE INSTRUMENT PARAMETERS ETC. TO FILE.
      CALL LIMITS(CALDAT,NPT,NCYMIN,NCYMAX,YMN,YMX)
      IWORK(1)      = NCYMIN
      IWORK(2)      = NCYMAX
      IWORK(54)     = 2
** THIS WAS:
**      RWORK(119)    = XMN
**      RWORK(120)    = XMX
      RWORK(121)=YMN
      RWORK(122)=YMX
C
C      WRITE THIS DATA TO FILE
      CALL WRDATA(.FALSE.,IUNIT,IWORK,155)
C
C      NOW WRITE RTCB, RCOUNT AND RERR ARRAYS TO DATA FILE
      CALL WRDATA(.FALSE.,IUNIT,TDATA,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,CALDAT,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,ERR,NTCB)
C
C      WRITE USER PARAMETERS (NOTHING )
      CALL WRDATA(.FALSE.,IUNIT,USERPR,30)
C
C      WRITE INSTRUMENT PARAMETERS ETC. TO FILE.
      CALL LIMITS(STADAT,NPT,NCYMIN,NCYMAX,YMN,YMX)
      IWORK(1)      = NCYMIN
      IWORK(2)      = NCYMAX
      IWORK(54)     = 3
      RWORK(121)    = YMN
      RWORK(122)    = YMX
      CWORK(529:568)= '(OBS-CALC)/ESD'
      CWORK(569:608)= '(OBS-CALC)/ESD'
C
C      WRITE THIS DATA TO FILE
      CALL WRDATA(.FALSE.,IUNIT,IWORK,155)
C
C      NOW WRITE RTCB, RCOUNT AND RERR ARRAYS TO DATA FILE
      CALL WRDATA(.FALSE.,IUNIT,TDATA,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,STADAT,NTCB)
      CALL WRDATA(.FALSE.,IUNIT,ERR,NTCB)
C
C      NOW ENSURE THAT FILE IS CLOSED PROPERLY
      CALL WRDATA(.TRUE.,IUNIT,IWORK,0)
      RETURN
      END
C
C
C
C
C LEVEL 15      SUBROUTINE VARSPM
      SUBROUTINE VARSPM
C
C *** VARSPM updated by PJB 1 Feb 1994 ***
C
CX
CC 19B
CH Records which parameters are which variables for magnetic PR
C
CD Identifies species of parameter, then calls specific routines actually
CD    to set variables, thus not needing all COMMONs to be explicit here
CD
C
      COMMON /DERBAS/DERIVB(400),LVARB
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /GLOBAL/NINIT,NBATCH,NSYSTM,MULFAS,MULSOU,MULONE
      LOGICAL MULFAS,MULSOU,MULONE
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /REFIPR/RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
      LOGICAL RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
      COMMON /SOURCE/NSOURC,JSOURC,KSOURC,NDASOU(5),METHOD(
     & 9),NPFSOU(9,5),NSOBS(5),SCALES(5),
     & KSCALS(5),NPCSOU(9,5)
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      DO 111 JPHASE=1,NPHASE
      CALL PHMOVE(1,JPHASE)
      CALL LTFAC9
      CALL CELVAR(0,0)
      CALL PROPAG(0,0)
      CALL F2VAR9
      CALL FM4PR9
      CALL LPSCA9
      CALL MAGVAR(0,0,0)
      CALL PHMOVE(-1,JPHASE)
 111  CONTINUE
C
C BE SURE TO PUT THESE IN THE APPROPRIATE "ALL PHASE" OR "ALL SOURCE" LOOPS:
      CALL PFALL9
      CALL EXCPR9
      CALL PREFO9
      CALL LSSCA9
      CALL THMLX9
      CALL ABCPR9
      CALL BACKP9
      CALL ZERPR9
      CALL PCXX9
C
C SET STARTING PHASE & SOURCE:
      JP=0
      JS=0
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
C UNPACK PARAMETER SPEC:
      CALL KUNPAK(LVRPR(I),IFAM,IGEN,ISPC,JPHASE,JSOURC)
      IF (JPHASE .NE. IPHASE) THEN
        CALL PHMOVE(-1,IPHASE)
        CALL PHMOVE(1,JPHASE)
        CALL LOGPHA(JPHASE)
      ENDIF
       IF ((IFAM .EQ. 3 .OR. IFAM .EQ. 6) .AND. (JS .NE. JSOURC))
     & CALL LOGSOU(JSOURC)
      JP=JPHASE
      JS=JSOURC
C
C BRANCH ON FAMILY:
      GO TO (11,12,13,14,15,16), IFAM
C
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SINGLY NAMED SPECIES (TFAC, A* ETC,
C EXTN,PROR,SPHA)
  11  GO TO (31,35,35,35,35,35,35,36,37,38,39,39,39) , ISPC
C
C TFAC:
  31  CALL LTFAC8(I)
      GO TO 1
C
C FAMILY 1 GENUS 1 ALSO CONTAINS THE CELL PARAMETERS:
  35  CALL CELVAR(ISPC-1,I)
      GO TO 1
C
C EXTINCTION CORRECTION PARAMETER EXTN:
  36  CALL EXCPR8(I)
      GO TO 1
C
C PREFERRED ORIENTATION:
  37  CALL PREFO8(I)
      GO TO 1
C
C FAMILY 1, GENUS 1, SPECIES 10 - SCALE FOR PHASE, SPHA:
  38  CALL LPSCA8(I)
      GO TO 1
C
C FAMILY 1 GENUS 1, SPECIES 11-13 PROPAGATION VECTOR
   39 CALL PROPAG(-ISPC+10,I)
      GO TO 1
C
C FAMILY 6: MISCELLANEOUS SOURCE DEPENDENT;
  16  GO TO (61,62,63) , IGEN
C
C FAMIL6 GENUS 1 - SINGLY NAMED, SOURCE-DEPENDENT SPECIES (SCAL,TTHM)
  61  GO TO (51,52) , ISPC
C
C FAMILY 6, GENUS 1, SPECIES 1 - SCALE FOR SOURCE, SCAL:
  51  CALL LSSCA8(I)
      GO TO 1
C
C MONOCHROMATOR 2 THETA FOR LX:
  52  CALL THMLX8(I)
      GO TO 1
C
C FAMILY 6, GENUS 2 - ABSC:
  62  CALL ABCPR8(ISPC,I)
      GO TO 1
C
C FAMILY 6, GENUS 3 - BACK:
  63  CALL BACKP8(ISPC,I)
      GO TO 1
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .LE. 12) CALL F2VAR8(IGEN,ISPC,I)
      IF (ISPC .GT. 12) CALL MAGVAR(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 3 - ZERO POINT, PEAK CENTRE AND PEAK FUNCTION PARAMETERS:
C GENUS 1=ZERO POINT, 2=PEAK CENTRE, REST ARE PEAK FUNCTION:
  13  GO TO (41,42) , IGEN
      GO TO 43
C
C ZERO:
  41  CALL ZERPR8(ISPC,I)
      GO TO 1
C
C PEAK CENTRE PARAMETERS DEPEND ON TYPE OF REFINEMENT:
  42  CALL PCXX8(ISPC,I)
      GO TO 1
C
C REMAINING PEAK FUNCTION PARAMETERS:
  43  CALL PFALL8(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 4 - LONG VECTORS (SO FAR, INTS, SIGS, GAMS . . IN PAWLEY)
  14  CALL FM4PR8(IGEN,ISPC,I)
      GO TO 1
C
C FAMILY 5 ARE MULTIPOLES, EXCLUDED FOR NOW:
  15  GO TO 1
   1  CONTINUE
      IF (MULFAS) CALL PHMOVE(-1,IPHASE)
C
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE VARSD2
      SUBROUTINE VARSD2
C
C *** VARSD2 updated by JCM 23 Mar 92 ***
C
CX
CC 7B
CH Makes variables for 2theta, zero, peak centre and cell for D2 type LSQ
CP Only useful if called from CELLSQ, D2LSQ or similar.  Expects suitable type
CP of Least Squares to be set up.
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans all variables as made by VARMAK, identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      CALL THET29
      CALL CELVAR(0,0)
      CALL PCXX9
      CALL ZERPR9
C
C COUNT ALL VARIABLES:
      DO 1 I=1,LVARV
C J=WHICH BASIC VARIABLE:
      J=LVRBS(I)
C KPACK=WHICH PACKED PARAMETER SPEC:
      KPACK=LVRPR(I)
C
C AND ITS FAMILY, GENUS AND SPECIES:
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C FAMILY 1, GENUS 1 - CELL PARAMETERS:
      IF (IGEN .EQ. 1) THEN
        IF (ISPC .EQ. 7) THEN
          CALL THET28(I)
          GO TO 1
        ENDIF
        CALL CELVAR(ISPC,I)
      ENDIF
C FAMILY 1, GENUS 2 - PKCN PARAMETERS:
      IF (IGEN .EQ. 2) CALL PCXX8(ISPC,I)
C FAMILY 1, GENUS 3 - ZEROPOINT
      IF (IGEN .EQ. 3) CALL ZERPR8(ISPC,I)
C
   1  CONTINUE
 100  RETURN
      END
C
C
C
C LEVEL 11      SUBROUTINE RDPHA0(PCXX,PFXX)
      SUBROUTINE RDPHA0(PCXX,PFXX)
C
C *** RDPHA0 by JCM 4 Dec 91 ***
C
CH Starts a multiphase job and reads in phase 0
C
CP Expects that phases 0 and 1 are pointed to together in INREA(,1) and
CP ICDN(,1), and that the separate phase 0 'L' cards are pointed to by
CP INRLP0 and ICDLP0  in /PHAS0/.
CD
CD At present expects multiphase data.  Will sort it out eventually for
CD single phase also.
CD
CD Initialises for multiphase, and calls REFSET to sort out what we expect.
CD Calls INPLP0 to read and interpret the phase 0 'L' cards.
C
      EXTERNAL PCXX,PFXX
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /GLOBAL/NINIT,NBATCH,NSYSTM,MULFAS,MULSOU,MULONE
      LOGICAL MULFAS,MULSOU,MULONE
      COMMON /PHAS0/INRLP0,ICDLP0,INRLP1,ICDLP1,NCDF0
C
      IF (MULFAS) THEN
C SET UP PHASE DUMPING AND RETRIEVAL:
        CALL PHMOVE(0,0)
C
C SET UP TYPE OF REFINEMENT FOR EVERY PHASE, EVERY SOURCE:
        CALL REFSET
C
C READ PHASE 0 L CARDS IF PRESENT:
        CALL STLSP0(PCXX,PFXX)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 13      SUBROUTINE PTICN
      SUBROUTINE PTICN
C
C *** PTIC by JCM modified by JBF for magnetic materials 2-Jun-95 ***
C
CH Most of the Main program for either TIC or PICTIC
C
      EXTERNAL PCTF01,PCCN01,PCLX01,DUMMY,DOMAG,MAGCNL
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /REFIPR/RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
      LOGICAL RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
C
C READ AND INTERPRET "L REFI" CARD:
      CALL REFSET
C
      IF (ICDNO(17).NE.0) THEN
        CALL SETFCM(DOMAG)
        CALL MAGCNC
        CALL DOMAG(2)
      ELSE
        CALL SETFCM(DUMMY)
      ENDIF
C SET UP ASYMMETRIC UNIT:
      CALL SYMUNI
C
      IF (TOF) CALL SETICN(PCTF01)
      IF (CN.OR.SR.OR.LX) CALL SETICN(PCCN01)
C	Multi wavelength
C      IF (LX) CALL SETICN(PCLX01)
      RETURN
      END
C
C
C
C
C LEVEL 13      SUBROUTINE PTIC
      SUBROUTINE PTIC
C
C *** PTIC by JCM 14 Aug 91 ***
C
CH Most of the Main program for either TIC or PICTIC
C
      EXTERNAL PCTF01,PCCN01,PCLX01

	INCLUDE 'params.inc'

      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /FCCDAT/DATFIL,INSTNM,LONGTI,RUNUSR,STTIME,
     & WSHIST,XCAPT,YCAPT,MCAPT
      CHARACTER DATFIL*80,INSTNM*8,LONGTI*80,RUNUSR*20,
     & STTIME*20,WSHIST*200,XCAPT*40,YCAPT*40,MCAPT*40

      COMMON /FOCDAT/NOTC,NCYMIN,NCYMAX,DELTA,LDFIL,FI,
     & INSTCO,INSTST,NXCODE,LNPDFN,AL1,AL2,NOSPEC,NPT,
     & NUMRUN,RUNDUR,TTHET,XMN,XMX,YMN,YMX,NYCODE,NEMODE,
     & EFIXED,USERPR(30),TDATA(MFOCDA),BACK(MFOCDA),OBSDAT(MFOCDA),
     & CALDAT(MFOCDA),ERR(MFOCDA),STADAT(MFOCDA),YRANGE,IUNIT

      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /PRPKCN/ARGK,PKCNSP(6,9,5),
     & KPCNSP(6,9,5),DTDPCN(6),DTDWL,
     & NPKCSP(9,5),ARGMIN(5),ARGMAX(5),
     & ARGSTP(5),PCON
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /REFIPR/RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
      LOGICAL RIET,CAIL,SAPS,APES,RAPS,TOF,CN,LX,SR,ED,PRECYC,TIC
C>> JCC Moved to an include file
	INCLUDE 'REFLNS.INC'
      COMMON /SOURCE/NSOURC,JSOURC,KSOURC,NDASOU(5),METHOD(
     & 9),NPFSOU(9,5),NSOBS(5),SCALES(5),
     & KSCALS(5),NPCSOU(9,5)
C
C READ AND INTERPRET "L REFI" CARD:
      CALL REFSET
C
C ONLY IF A & F CARDS SET UP REST OF STRUCTURE FACTOR CALCULATION:
** SEE WHAT HAPPENS IF WE CALL SETFC ANYWAY
*      SFC= (ICDNO(1).NE.0.AND.ICDNO(6).NE.0)
*      IF (SFC) THEN
        CALL SETFC
*      ELSE
*        CALL RECIP
*        CALL OPSYM(1)
*      ENDIF
C SET UP ASYMMETRIC UNIT:
      CALL SYMUNI
C
      IF (TOF) CALL SETTIC(PCTF01)
      IF (CN.OR.SR.OR.LX) CALL SETTIC(PCCN01)
C	Multi lambda lab is next line
C      IF (LX) CALL SETTIC(PCLX01)
C
      INSTCO=1
      INSTNM='HRPD    '
C
      AL2=1.
      TTHET=RADIAN(TWOTHD(JSOURC))
      PATH=PKCNSP(1,JPHASE,JSOURC)
      AL1=PATH-AL2
      IF (PATH.LT.90.) THEN
        INSTCO=8
        INSTNM='POLARIS '
      ENDIF
C
C
      DELTA=0.0
      LDFIL= 1
      DATFIL(1:14)=' '
      NXCODE=2
      RUNDUR=1.
      NYCODE=-1
      LNPDFN=LDFIL
      NUMRUN=0
      IF (TOF) THEN
        XCAPT= 'TOF (microseconds)'
        YCAPT= 'NEUTRONS/MICROSECOND'
        MCAPT= ' '
      ELSE IF (CN) THEN
        XCAPT= '2 THETA (degrees)'
        YCAPT= 'NEUTRON COUNTS'
        MCAPT= ' '
      ELSE IF (LX.OR.SR) THEN
        XCAPT= '2 THETA (degrees)'
        YCAPT= 'X-RAY COUNTS'
        MCAPT= ' '
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE PREFAS(PROGRM)
      SUBROUTINE PREFAS(PROGRM)
C
C *** PREFAS updated by JCM 21 Jan 92
C
CH Reads in the crystal data file for multiphase job, making temporary files.
CD Makes all the cdfs readable in random order.
CD For details, see the specification of PREFIN.
CI Reads first cdf in same way as PREFIN.   If there is more material after the
CI terminator, sets "multiphase", notes the pointers to the L cards (which
CI are the only ones expected to be duplicated), then reads N more cdfs from
CI the same input dataset for an N-phase job.  Phase 1 must not first clear out
CI the card pointers, as we wish to make it the union of phases 0 and 1.
CN At one time expected its cdfs on separate files.  Now does not.
C
      CHARACTER *(*) PROGRM
      LOGICAL ENDIP
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /GLOBAL/NINIT,NBATCH,NSYSTM,MULFAS,MULSOU,MULONE
      LOGICAL MULFAS,MULSOU,MULONE
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /PHAS0/INRLP0,ICDLP0,INRLP1,ICDLP1,NCDF0
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C
C INITIALISE WHOLE SYSTEM - DATE, TIME, CONSTANTS, I/O UNIT NUMBERS ETC:
C AND SET ALL OF NPHASE, IPHASE, JPHASE , NSOURC, JSOURC to 1:
      CALL INITIL(PROGRM)
C
C OPEN CRYSTAL DATA:
      MESSAG='Crystal data file'
CILL      NAMFIL='.CRY'
CRAL
      NAMFIL='.CCL'
      CALL OPNFIL(ICRYDA,111)
C OPEN SCRATCH FILE TO HOLD COPIES OF ALL CRYSTAL DATA FILES SEQUENTIALLY:
      IO10=NOPFIL(10005)
C SET NO ERRORS DETECTED ON INPUT - SYSTEM PLOUGHS ON AS LONG AS IT CAN:
      IERR=0
C START COUNT OF OUTPUT RECORDS TO UNIT IO10:
      ID=0
C
C READ AS MANY PHASES AS ARE GIVEN:
      NPHASE=0
      MULFAS=.FALSE.
   1  NPHASE=NPHASE+1
      CALL CDFIN(NPHASE,ID,ENDIP)
      IF (ENDIP) GO TO 2
C WE HAVE FOUND MORE THAN ONE SECTION OF CDF, SO WE NOW EXPECT N+1 SECTIONS IN
C TOTAL FOR MULTIPHASE WITH N PHASES.  IF WE HAVE JUST READ PHASE 0, WE MUST
C KEEP ITS 'L' CARD POINTERS:
      IF (.NOT. MULFAS) THEN
        MULFAS=.TRUE.
        NPHASE=0
        INRLP0=INREAD(12)
        ICDLP0=ICDNO(12)
      ENDIF
      GO TO 1
C
C ALL CDFS IN:
   2  IF (MULFAS)  THEN
        CALL WRLINE(2,60,'*',0)
        WRITE (LPT,2005) NPHASE
2005    FORMAT (//15X,' JCM Multiphase refinement on',I3,' phases'//)
        CALL WRLINE(0,60,'*',2)
      ENDIF
C
      NTOTL=NTOTAL(NPHASE)
      RETURN
      END
C
C

!
!*****************************************************************************
!
! Originally in Mag.for
!
C
C
C LEVEL 4      SUBROUTINE MOLORB(IAT,IPTI)
      SUBROUTINE MOLORB(IAT,IPTI)
C
C *** MOLORB by PJB 6 Apr 87 ***
C
CX
CC 17B
CH To read molecular orbital wave-functions from "W atom-name FUNC" card.
C
CA IAT on entry gives which atom
CA IPTI on entry is the pointer in ICARD in /SCRACH/ from which to read
CA      unless IPTI=-ve, when it signals a request for initialisation
CA      or IPTI=0, which asks for the functions to be checked and printed
C
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C%
C      COMMON/SCRAT/MODE(%MPAT%),IROT(%MPAT%),TEMP(3,3),MFUN(10,%MPAT%)
      COMMON/SCRAT/MODE(20),IROT(20),TEMP(3,3),MFUN(10,20)
      COMMON /WAVCHR/IFUN(10,5)
      CHARACTER*4 IFUN
      COMMON /WAVEFN/NQUANT(70,5,5),IREST(70,5,5),AMP(70,5),
     & PAMP(10,5),NEL(5),IX(5),NFUN(10,5),NEIG(5)
      COMPLEX AMP,PAMP
      DIMENSION AMPLI(140,5)
      EQUIVALENCE (AMP(1,1),AMPLI(1,1))
C
      IF (IPTI) 30,20,1
C INITIALISE FUNCTION COUNT
  30  CALL JGMZER(NEIG,1,NATOM)
      GO TO 100
C
C ENTRY TO READ REST OF W <ATOM> FUNC CARD:
    1 NEIG(IAT)=NEIG(IAT)+1
      CALL RDWORD(IFUN(NEIG(IAT),IAT),LWORD,IPTI,IPT1,80,0,IER)
      IF (IER.NE.0) GO TO 50
      DO 3 I=1,2
      L=M
      IPT=IPT1
      CALL RDINTG(M,IPT,IPT1,80,IER)
      IF (IER.NE.0) GO TO 50
    3 CONTINUE
      NFUN(NEIG(IAT),IAT)=L
      MFUN(NEIG(IAT),IAT)=M
      LAB=(L*(L+1)+2*M)*2
      II=4
      IF (M.EQ.0) II=2
      DO 4 I=1,II
      IPT=IPT1
      CALL RDREAL(AMPLI(LAB+I,IAT),IPT,IPT1,80,IER)
      IF (IER.EQ.0) GO TO 4
      IF (IER.NE.100) GO TO 50
      AMP(LAB+I,IAT)=0.
    4 CONTINUE
      GO TO 100
C
C  ENTRY TO CHECK AND WRITE OUT FUNCTIONS
   20 IF (NEIG(IAT).EQ.0) GO TO 52
      II=NEIG(IAT)
      CALL MESS(LPT,1,'Molecular Orbital Wave-Functions:')
      DO 21 I=1,II
      L=NFUN(I,IAT)
      M=MFUN(I,IAT)
      IF (M.GT.L) GO TO 53
      LAB=(L*(L+1)+2*M)*2
      JJ=4
      IF (M.EQ.0) JJ=2
      WRITE (LPT,13) IFUN(I,IAT),L,M,(AMPLI(LAB+J,IAT),J=1,JJ)
   13 FORMAT (1X,'Function: ',A4,' L =',I3,' M =',I3,' Amplitudes:',2
     & (2F8.5,2X))
   21 CONTINUE
      GO TO 100
C
C  REPORT ERRORS
   50 WRITE (LPT,3000)IER,IPT,IPT1, ICARD
      WRITE (ITO,3000)IER,IPT,IPT1, ICARD
3000  FORMAT (' Error (IER=',I4,' in field',I3,'-',I2,') inter',
     & 'preting the card which reads:'/1X,80A1)
      GO TO 101
  52  CALL ERRMES(1,-1,'Molecular orbital wave-function not found')
      GO TO 101
   53 WRITE (LPT,3002) IFUN(I,IAT),L,M
      WRITE (ITO,3002) IFUN(I,IAT),L,M
3002  FORMAT (/' Implausible quantum numbers for function ',A4,
     & ' L =',I3,', M = ',I3)
      GO TO 101
C
  101 IERR=IERR+1
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE MAGDIR(H,A,C)
      SUBROUTINE MAGDIR(H,A,C)
C
C *** MAGDIR updated by PJB Nov 89 ***
C
CX
CC 17B
CH Calculates various geometric corrections for various magnetic states.
CH The ENTRY ENTMAG sets up the COMMON.
CD ENTMAG sets up /MOMDIR/ to contain the magnetisation direction in AMD,
CD and MM to specify the option:
CD      MM = 1 magnetisation parallel to the omega axis
CD      MM = 2 magnetisation parallel to an axis given on an I card
CD      MM = 3 magnetisation between 1 and 2 at cos-1(csphi) to 2
CD      MM = 4 Schwinger scattering
C
      DIMENSION H(3),OH(3),EASY(3),Q(3),Q1(3)
      CHARACTER*4 INEED(4)
      LOGICAL ONCARD,TESTOV
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(5,5),
     & NLAMB,ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MOMDIR/S(3),UU(3),MM
      DATA INEED/'X','Y','Z','PHI'/
C
      CALL ORTHO(H,OH,2)
      CALL UNIVEC(OH,D)
      IF (MM.EQ.4) GO TO 31
C
      CALL VECPRD(S,OH,Q1)
      CALL VECPRD(OH,Q1,Q)
      A=SCALPR(Q,UU)
      B=SCALPR(S,OH)
      CALL SINCOS(B,C,'MAGDI1')
      IF (TESTOV(A,C)) THEN
        A=10000.
      ELSE
        A=A/C
      ENDIF
      GO TO 100
C
C  SCHWINGER SCATTERING
   31 SINTH=0.5*WLGTH*D
      CALL SINCOS(SINTH,B,'MAGDI3')
      D=SCALPR(OH,UU)/B
      CALL SINCOS(D,A,'MAGDI2')
C FACTOR COT(THETA)/2
      C=(0.5*B)/SINTH
      GO TO 100
C
C  SETTING UP ENTRY
C  SETS S TO BE THE SPIN DIRECTION AND UU THE Z DIFFRACTOMETER AXIS
C  BOTH AS UNIT VECTORS ON ORTHOGONAL CRYSTAL AXES
      ENTRY ENTMAG
      UU(1)=UM(3)
      UU(2)=UM(6)
      UU(3)=UM(9)
      IF (ONCARD('I','MAGD',AA)) GO TO 21
C  NO I MAGD CARD FOUND ASSUME MAGNETISATION PARALLEL TO POLARIZATION
      CALL MESS(LPT,1,
     & 'No I MAGD card - assume magnetistion parallel to omega axis')
      MM=1
      GO TO 23
C
   21 MM=NINT(AA)
      GO TO (24,25,25,30) ,MM
C
C  MAGNETISATION PARALLEL TO POLARIZATION
   24 WRITE (LPT,11) MM
   11 FORMAT (/'MAGD =',I2,' magnetisation parallel to omega axis')
   23 CALL GMEQ(UU,S,3,1)
      GO TO 100
C
C  MAGNETISATION DIRECTION TO BE GIVEN
   25 JM=MM+1
      DO 26 J=1,JM
      IF (ONCARD('I',INEED(J),AA)) GO TO 28
C
C  SOMETHING MISSING
      WRITE (LPT,12) INEED(J)
   12 FORMAT (1X,A4,' direction data missing on I card')
      IERR=IERR+1
      GO TO 26
C
   28 IF (J.GT.3) GO TO 29
      Q(J)=AA
      GO TO 26
C
   29 ANGL=AA
      COSA=COS(RADIAN(ANGL))
      SINA=SIN(RADIAN(ANGL))
   26 CONTINUE
      CALL ORTHO(Q,EASY,1)
      CALL UNIVEC(EASY,D)
      IF (MM.EQ.2) THEN
        CALL GMEQ(EASY,S,3,1)
        WRITE (LPT,14) MM,Q
   14   FORMAT (/'MAGD =',I2,
     &  ' magnetisation direction parallel to',3F5.2)
      ENDIF
      IF (MM.EQ.3) THEN
        WRITE (LPT,15) MM,ANGL,Q
   15 FORMAT (/'MAGD =',I2,' Magnetisation direction at an angle',F7.2
     & ,' to the easy direction',3F5.2)
        CALL VECPRD(UU,EASY,Q)
        CALL UNIVEC(Q,D)
        CALL VECPRD(EASY,Q,Q1)
        CALL UNIVEC(Q1,D)
        CALL GMSCA(EASY,Q,COSA,3,1)
        CALL GMSCA(Q1,Q1,SINA,3,1)
        CALL GMADD(Q1,Q,S,3,1)
      ENDIF
      EANG=DEGREE(ACOS(UU(3)))
      WRITE (LPT,17) EANG
   17 FORMAT (' The easy direction is inclined at',F6.2,
     & ' degrees to the omega axis')
      GO TO 100
C
   30 WRITE (LPT,16) MM
   16 FORMAT (/'MAGD =',I2,' Schwinger Scattering')
  100 RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE FGAMMA(R,M)
      SUBROUTINE FGAMMA(R,M)
C
C *** FGAMMA/FGAMMS updated by PJB/JBF Dec 89 ***
C
CX
CC 2B
CH Calculates gamma, the ratio of magnetic and nuclear scattering,
CH and its standard deviation.
CH FGAMMS does this in the presence of spin-independent multiple scattering.
CA On entry R(1) holds the flipping ratio
CA          R(2) holds the standard deviation
CA          M = 0 for abs(gamma) >1
CA              1 for abs(gamma) <1
CA    and to FGAMMS, RMS is the ratio of nuclear to magnetic scattering.
CA On exit  R(1) holds the appropriate gamma
CA          R(2) holds the standard deviation.
CP SETPOL should have set up the elements P,DP in /POLDA/
C
      DIMENSION G(8),R(2)
      LOGICAL SIMS
      COMMON /POLDA/P,DP,E,DE,MODE,POLND(3)
C
      SIMS=.FALSE.
      GO TO 2
C
      ENTRY FGAMMS(R,M,RMS)
      SIMS=.TRUE.
C
C  SAVE VALUES OF R AND DR
   2  AR=R(1)
      DR=R(2)
C
      IF (.NOT. SIMS) THEN
        CALL CGAMMA(R(1),P,E,G(1))
        CALL CGAMMA(R(1)+SIGN(R(2),R(1)-1.),P,E,G(3))
        CALL CGAMMA(R(1),P-DP,E,G(5))
        CALL CGAMMA(R(1),P,E-DE,G(7))
      ELSE
        CALL CGAMMS(R(1),P,E,G(1),RMS)
        CALL CGAMMS(R(1)+SIGN(R(2),R(1)-1.),P,E,G(3),RMS)
        CALL CGAMMS(R(1),P-DP,E,G(5),RMS)
        CALL CGAMMS(R(1),P,E-DE,G(7),RMS)
      ENDIF
      A=ABS(G(1))
      K=1
      IF (A.GT.1 .AND. M.EQ.0) K=2
      IF (A.LT.1 .AND. M.EQ.1) K=2
      R(2) = 0.
      DO 1 J = 2,6,2
   1  R(2) = R(2) + (G(J+K)-G(K))**2
      R(2) = SQRT(R(2))
      R(1) = G(K)
C  BLIP TO PREVENT ZERO STANDARD DEVIATIONS
      IF (R(2).EQ.0.) R(2)=DR/AR
      RETURN
      END
C
C
C
C LEVEL 6      FUNCTION ASPHFF(H,IAT)
      FUNCTION ASPHFF(H,IAT)
C
C *** ASPHFF by PJB Jun 86 ***
C
CX
CC 17C
CH Calculates an aspherical form factor for a cubic space group.
CA On entry H is a 3-sized array holding h,k,l
CA          IAT=which atom
CA On exit ASPHFF holds the form factor.
C
      DIMENSION H(3)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON/MAVALUES/VAL(3,10),NVAL
C
      SUM=0.
C
C  CALCULATE CUBIC ASYMMETRY FACTOR
      AHKL=0.
      SHKL=0.
      J=2
      L=3
      DO 51 I=1,3
      AHKL=AHKL+(H(I)**4)-3*(H(J)*H(L))**2
      SHKL=SHKL+H(I)**2
      L=J
   51 J=I
      AHKL=AHKL/(SHKL**2)
C
      AK=VCTMOD(TWOPI,H,2)
      DO 1 L=1,3
      LL=2*(L-1)
      F=FORMFC(AK,LL,0,IAT)
      IF (L.EQ.2) F=F*VAL(2,IAT)
      IF (L.EQ.3) F=F*VAL(3,IAT)*AHKL
    1 SUM=SUM+F
C
      ASPHFF=SUM*VAL(1,IAT)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE LMCALC(H)
      SUBROUTINE LMCALC(H)
C
C *** LMCALC corrected by PJB/jbf 13-Jan-95 ***
C
CX
CC 17B
CH Calculates a magnetic structure factor and its derivatives.
CA On entry H is the 1x3 vector containing h,k,l
CP RECIP, SYMOP, SETANI, SETFOR and DOMAG must have been obeyed to set up
CP the structure factor calculation. (They are all called by SETFCM)
CP The LSQ environment must have been set up by a suitable MAIN program (like
CP SFLSQ) which has called LSETUP and VARMAK.
CP
CD On exit, in /MCAL/:
CD    FMCMOD = modulus of FMC
CD    FMCSQR = squared modulus of FMC
CD    FMCDER is an array containing the derivatives of FMCMOD wrt the family
CD           2 (structure) parameters, ALL MULTIPLIED BY FMCMOD.
CD    (Note the difference from the specification of LFCALC's derivatives)
CD On exit, in /QCAL/:
CD    Q is an array containing the magnetic interaction vectors for each domain
CD      in general there will be NDOM*KCENT domains
CD On exit, in /QCALD/:
CD    FQCDER is an array containing the derivatives of the Q's with respect to
CD           all the family 2 parameters.
CD
CD All the above will be zero if h,k,l is a magnetic absence
CN Note the existence also of LFCALC (nuclear structure factors for LSQ)
CN                            FMCALC (magnetic structure factors)
CN                            FCALC  (nuclear structure factors)
C
C%
C      COMPLEX DERIVM(3,%F2VA%),SUM1(3),TERM,TVEC(3),FORM,HR,FORMFA,P(3)
      COMPLEX DERIVM(3,300),SUM1(3),TERM,TVEC(3),FORM,HR,FORMFA,P(3)
      COMPLEX CFAC,TEMP,PSIFAC,PSIFCC,TDERS(3,16),TTVEC(3),TDVEC(3)
      COMPLEX FMC(3)
      LOGICAL SKIP,MAGABS,PSI,PSICEN,CENPSI,DOCENT
      DIMENSION RH(3),H(3),RS(3,3),HD(3,3),SDOM(3,3)
      COMMON /ANISO/ATF(6,50),KATF(6,50),IAPT(150),
     & IATYP(50),KOM1
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAGDAT/NMAG,MAGAT(150),JMAGAT(10),NMFORM(10),
     & ANGM(4,10),KANGM(4,10),SMOD(2,10),
     & KSMOD(2,10),PHIH(4,10),KPHIH(4,10),
     & LPHI(4,10),NPHI(10),TPTAB(25,10),
     & IPTAB(25,10),SPIND(3,3,2,10),KOM19
      COMMON /MCAL/FMCMOD,FMCSQR,FMCDER(300)
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /QCAL/Q(3,12)
      COMPLEX Q
      COMMON /QCALD/FQCDER(3,12,100)
      COMPLEX FQCDER
      COMMON /SATELL/PROP(3),KPROP(3),KSTAB(24),NKSTAR,IPROP,FKSTAR,
     & NKC,KCENT,INCOM,KOM21
      LOGICAL INCOM
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
      COMMON /SYMMAG/MTSYM(25),MSTAB(24),NMSYM,NFAC,OTRSYM(3,3,25),
     & MTYP,NDOM,FERO,FERA,HELI,AMOD,ANTI,MODUL,KOM20
      LOGICAL FERO,FERA,HELI,AMOD,ANTI,MODUL
      COMMON /SYMTAB/MULTAB(24,24),INVERS(24),
     & NORD(24),IGEN(3),KOM22
C
C CLEAR ALL ANSWERS IN CASE ABSENT:
C
C CLEAR MODULUS AND SQUARE:
      FMCMOD=0.
      FMCSQR=0.
      SSQRD=STHL*STHL
C CLEAR DERIVATIVES:
      L2=NVARF(2,JPHASE,1)
      IF (L2 .GT. 0) CALL GMZER(FMCDER,1,L2)
C
C OUT IF ABSENT:
      IF (MAGABS(H,IK)) GO TO 100
      TAU=-FLOAT(IK)
C
C  CYCLE OVER DOMAINS
      ND=0
      ICHIR=1
      IHELIX=1
      DOCENT=CENTRC
      IF (MODUL) THEN
        PSICEN=(MSTAB(1).LT.0)
        CENPSI=.NOT.PSICEN
        IF (HELI) THEN
          IHELIX=2
C  POSSIBILITY OF CHIRALITY DOMAINS
          IF (IABS(IPROP).EQ.1) ICHIR=2
        ENDIF
      ELSE
C DON'T WANT PHASE SHIFTS
        PSI=.FALSE.
        CENPSI=.FALSE.
        PSICEN=.TRUE.
      ENDIF
      SKIP=.FALSE.
      DO 15 ICHI=1,ICHIR
      DO 15 IDOMOP=1, NOPC
      IF (FERO .AND. IDOMOP .NE.1) GO TO 18
C DOMAINS EXIST FOR ALL ELEMENTS NOT IN THE MAGNETIC GROUP
      IF (IDOMOP.NE.1 .AND. IABS(MSTAB(IDOMOP)).NE.IDOMOP) GO TO 15
C FMC COLLECTS THE MAGNETIC STRUCTURE FACTOR, A COMPLEX VECTOR,
C ZEROED BEFORE CALCULATING THE VALUE FOR EACH DOMAIN
      CALL CGMZER(FMC,1,3)
C
C FIRST SCATTERING FACTOR:
      IFF=0
C
C OFFSET TO REACH THESE FAMILY 2 VARIABLES:
      LO=LVFST1(2,JPHASE,1)
C CLEAR DERIVATIVE VECTOR FOR ALL FAMILY 2:
      DO 82 I=1,L2
      DO 82 J=1,3
  82  DERIVM(J,I)=0.
C
C THIS LINE DID SAY:
C      NPSI=NSPC(2)-18
C%
C      NPSI=%PSIS%
      NPSI=4
C
C CYCLE OVER MAGNETIC ATOMS:
      DO 1 IM=1,NMAG
      IR=JMAGAT(IM)
C
C GET NEW FORM FACTOR IF DIFFERENT FROM THE PREVIOUS ONE
      IF (NMFORM(IM) .NE. IFF) THEN
        IFF=NMFORM(IM)
        FORM=FORMFA(STHL,IFF)
      ENDIF
C
C IS THERE A PHASE FACTOR ASSOCIATED WITH THE CENRE OF SYMMETRY FOR THIS ATOM
      IF (CENPSI)  THEN
C IS ATOM ON THE CENTRE
        PSICEN=(ISGEN(1,IR) .LT. 0)
        IF (.NOT. PSICEN) NIPC=NPHI(IM)/2
        DOCENT=(CENTRC .AND. (.NOT. PSICEN))
      ENDIF
C
C CYCLE OVER COMPONENTS OF HELIX
      DO 30 ICOMP=1,IHELIX
      CALL CGMZER(SUM1,3,1)
      CALL CGMZER(TDERS,3,16)
C IF IHELIX=1, THIS ONLY EVER DOES IC=0, & REFERS TO SPECIES 17 & 18 FOR ANGM,
C AND SPECIES 21 FOR SMOD(1)
C IF IHELIX=2, IC IS FIRST 0 (SPECIES 17 & 18) THEN 2 (SPECIES 19 & 20) FOR
C ANGM, AND SPECIES 21 THEN 22 FOR SMOD(1) THEN SMOD(2)
      IC=2*(ICOMP-1)
c
C PREPARE TO COUNT OPERATORS USED
      NFAC=0
C SYMMETRY CYCLE OVER SYMMETRIC AND NON-SYMMETRIC ROTATIONS:
      DO 3 IS=1,NOPC
C ONLY USE OPERATORS WHICH LEAVE THE PROPAGATION DIRECTION INVARIANT
      IF (IS.NE.1 .AND. IABS(KSTAB(IS)).NE.1) GO TO 3
C THE OPERATOR TO USE IS THE PRODUCT OF'IS' WITH THAT CREATING THE DOMAIN
      IROP=MULTAB(IDOMOP,IS)
C SKIP IF IROP DOESN'T GENERATE A DISTINCT SUB-LATTICE
      IF (MODUL .AND. LPHI(IPTAB(IROP,IM),IM).NE.IROP) GO TO 3
      CALL ROTSYM(H,RH,IROP,-1)
      IF (IDOMOP.NE.1 .AND. MSTAB(IDOMOP).LT.0) CALL GMREV(RH,RH,3,1)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IROP),H))
      ERS=ANITF(RH,IR)
      ARS=COS(F1)*ERS
      BRS=SIN(F1)*ERS
      TERM=CMPLX(ARS,BRS)
C FIND OUT WHAT THE SYMMETRY DOES TO THE SPIN DIRECTION
      CALL ROTMAG(SPIND(1,1,ICOMP,IM),SDOM,IS)
C  GET THE SPIN DIRECTION FOR THIS DOMAIN
      DO 2 I=1,3
    2 CALL ROTOSM(SDOM(1,I),RS(1,I),IDOMOP,1)
      CALL C1MSCA(RS,TVEC,TERM,3,1)
C??      IF (NORD(IDOMOP).LT.0) CALL GMREV(RS,RS,3,3)
      IF (MODUL) THEN
C INCLUDE A PHASE SHIFT FOR THIS SUB-LATTICE IF NECESSARY
        IP=IPTAB(IROP,IM)
C Use of TBTAB removed May 1994
        TEST=TAU*(RADIAN(PHIH(IP,IM)))
C        TEST=TAU*(TPTAB(IROP,IM)+RADIAN(PHIH(IP,IM)))
C        IF (IROP.NE.1) TEST=TEST*FLOAT(KSTAB(IROP))
        PSI=(ABS(TEST).GT..0001)
        IF (PSI) PSIFAC=CEXP(CMPLX(0.,TEST))
      ENDIF
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
      IF (DOCENT) THEN
        IF (.NOT. PSICEN) THEN
C Use of TBTAB removed May 1994
C          TEST=TAU*(RADIAN(PHIH(NIPC+IP,IM))-TPTAB(IP,IM))
          TEST=TAU*(RADIAN(PHIH(NIPC+IP,IM)))
          PSIFCC=CEXP(CMPLX(0.,TEST))
        ENDIF
C  OTRSYM(25) SHOULD CONTAIN THE MATRIX RELATING THE MAGNETIC COMPONENTS
C  OF ATOMS RELATED BY THE CENTRE OF SYMMETRY, WHETHER THIS IS IN THE
C  MAGNETIC GROUP OR NOT.
        CALL CENDIF(TVEC,TVEC,TTVEC,TDVEC,OTRSYM(1,1,25),
     &               PSIFAC,PSIFCC,PSI,PSICEN)
C  DERIVATIVES WITH REPECT TO PHASES
C  WE DO THESE HERE BECAUSE WE NEED THE TERMS BEFORE THE ACTION OF THE CENTRE
        IF (MODUL) THEN
          J=12+IP
          IF (KPHIH(IP,IM) .GT. 0) THEN
            CALL CGMSUB(TTVEC,TDVEC,TTVEC,1,3)
            CALL CGMSCA(TTVEC,TTVEC,CMPLX(0.,RADIAN(TAU)),1,3)
            CALL CGMADD(TDERS(1,J),TTVEC,TDERS(1,J),1,3)
          ENDIF
          IF (.NOT.PSICEN) THEN
            J=12+NIPC+IP
            IF (KPHIH(IP+NIPC,IM) .GT. 0) THEN
              CALL CGMSCA(TDVEC,TDVEC,CMPLX(0.,RADIAN(TAU)),1,3)
              CALL CGMADD(TDERS(1,J),TDVEC,TDERS(1,J),1,3)
            ENDIF
          ENDIF
        ENDIF
      ELSE
        IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,3,1)
        IF (PSI) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        IF (MODUL) THEN
          J=12+IP
          IF (KPHIH(IP,IM) .GT. 0) THEN
            CALL CGMSCA(TVEC,TTVEC,CMPLX(0.,RADIAN(TAU)),1,3)
            CALL CGMADD(TDERS(1,J),TTVEC,TDERS(1,J),1,3)
          ENDIF
        ENDIF
      ENDIF
      CALL CGMADD(SUM1,TVEC,SUM1,1,3)
C
C NOW WE DO THE INNERMOST SUMS FOR THE DERIVATIVES OF FMCMOD WRT
C VARIABLES XYZ AND ALL BIJ.  WE USE THE
C COMPLEX VECTOR DERIVM TO ACCUMULATE THE DERIVATIVES OF THE REAL &
C IMAGINARY PARTS OF THE COMPLEX FC WRT EACH VARIABLE IN TURN.
C
C TDERS IS USED FOR THOSE PARTS WHICH MUST BE ACCUMULATED SEPARATELY
C FOR THE TWO COMPONENTS OF A SPIRAL
C
      DO 7 I=1,3
      IF (KX(I,IR) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(I)*CMPLX(-BRS,ARS),3,1)
        IF (DOCENT) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,25),PSIFAC,PSIFCC,PSI,PSICEN)
        ELSE
          IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,3,1)
          IF (PSI) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,I),TVEC,TDERS(1,I),1,3)
      ENDIF
   7  CONTINUE
C
C JUMP IF NOT ATF AT ALL:
      IA=IAPT(IR)
      IF (IA .EQ. 0) GO TO 6
      IF (KATF(1,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(1)*TERM,3,1)
        IF (DOCENT) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,25),PSIFAC,PSIFCC,PSI,PSICEN)
        ELSE
          IF (PSI) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
          IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,4),TVEC,TDERS(1,4),1,3)
      ENDIF
      IF (KATF(2,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(2)*RH(2)*TERM,3,1)
        IF (DOCENT) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,25),PSIFAC,PSIFCC,PSI,PSICEN)
        ELSE
          IF (PSI) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
          IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,5),TVEC,TDERS(1,5),1,3)
      ENDIF
      IF (KATF(3,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(3)*RH(3)*TERM,3,1)
        IF (DOCENT) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,25),PSIFAC,PSIFCC,PSI,PSICEN)
        ELSE
          IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,3,1)
          IF (PSI) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,6),TVEC,TDERS(1,6),1,3)
      ENDIF
      IF (KATF(4,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(3)*RH(2)*TERM,1,3)
        IF (DOCENT) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,25),PSIFAC,PSIFCC,PSI,PSICEN)
        ELSE
          IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,3,1)
          IF (PSI) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        IF (PSI) CALL CGMSCA(TVEC,TVEC,PSIFAC,1,3)
        CALL CGMADD(TDERS(1,7),TVEC,TDERS(1,7),1,3)
      ENDIF
      IF (KATF(5,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(3)*TERM,3,1)
        IF (DOCENT) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,25),PSIFAC,PSIFCC,PSI,PSICEN)
        ELSE
          IF (PSI) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
          IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,8),TVEC,TDERS(1,8),1,3)
      ENDIF
      IF (KATF(6,IA) .GT. 0) THEN
        CALL C1MSCA(RS,TVEC,RH(1)*RH(2)*TERM,3,1)
        IF (DOCENT) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,25),PSIFAC,PSIFCC,PSI,PSICEN)
        ELSE
          IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,3,1)
          IF (PSI) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(TDERS(1,9),TVEC,TDERS(1,9),1,3)
      ENDIF
C NOW DERIVATIVES FOR ORIENTATION PARS
    6 DO 14 I=1,2
      L=KANGM(IC+I,IM)
      IF (L .GT. 0) THEN
        CALL C1MSCA(RS(1,I+1),TVEC,TERM,1,3)
        IF (DOCENT) THEN
          CALL CENTRO(TVEC,TVEC,OTRSYM(1,1,25),PSIFAC,PSIFCC,PSI,PSICEN)
        ELSE
          IF(CENTRC) CALL CMRSCA(TVEC,TVEC,2.0,3,1)
          IF (PSI) CALL CGMSCA(TVEC,TVEC,PSIFAC,3,1)
        ENDIF
        CALL CGMADD(DERIVM(1,L-LO),TVEC,DERIVM(1,L-LO),1,3)
      ENDIF
   14 CONTINUE
C
C INCREMENT COUNT OF OPERATORS USED
      NFAC=NFAC+1
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C  SET UP THE PHASE SHIFTS FOR EACH COMPONENT
      IF (ICOMP.EQ.1) THEN
        CFAC=CMPLX(1.,0.)
      ELSE
        CFAC=CMPLX(0.,-TAU)
C  PHASE SHIFT REVERSED FOR REVERSE CHIRALITY
        IF (ICHI.EQ.2) CFAC=-CFAC
      ENDIF
      CFAC=CFAC*AMULT(IR)*EXP(-TF(IR)*SSQRD)
C COMPENSATE FOR NOT USING ALL SYMMETRY ELEMENTS
      FACTOR=FLOAT(NOPC)/FLOAT(NFAC)
      CFAC=CFAC*FACTOR
C SCALE MOMENT TO CMS-12
      SM=SMOD(ICOMP,IM)*VALMUB
      HR=CFAC*FORM*SITE(IR)*SM
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
      CALL CGMSCA(SUM1,TVEC,HR,3,1)
      CALL CGMADD(FMC,TVEC,FMC,1,3)
C
C  NOW WE TIDY UP THE XYZ AND BIJ DERIVATIVES, AND MAKE ITF, SITE
C  AND MU
      DO 8 I=1,3
      IF (KX(I,IR) .GT. 0)
     & CALL CGMSCA(TDERS(1,I),TDERS(1,I),TWOPI*HR,3,1)
      IF (IA .GT. 0) THEN
        IF (KATF(I,IA) .GT. 0)
     &  CALL CGMSCA(TDERS(1,I+3),TDERS(1,I+3),HR,3,1)
        IF (KATF(I+3,IA) .GT. 0)
     &  CALL CGMSCA(TDERS(1,I+6),TDERS(1,I+6),HR*2.,3,1)
      ENDIF
   8  CONTINUE
C
C SKIP SCAT (PARAMETER 10)
      IF (KSITE(IR) .GT. 0)
     & CALL CGMSCA(SUM1,TDERS(1,11),FORM*CFAC*SM,3,1)
      IF (KTF(IR) .GT. 0)
     & CALL CGMSCA(SUM1,TDERS(1,12),-SSQRD*HR,3,1)
C RESCALE PSI DERIVATIVES
      DO 17 I=1,NPSI
      J=12+I
      IF (KPHIH(I,IM) .GT. 0) CALL CGMSCA(TDERS(1,J),TDERS(1,J),HR,3,1)
   17 CONTINUE
C RESCALE ORIENTATION DERIVATIVES
      DO 19 I=1,2
      L=KANGM(IC+I,IM)
      IF (L .GT. 0) CALL CGMSCA(DERIVM(1,L-LO),DERIVM(1,L-LO),HR,3,1)
   19 CONTINUE
C DERIVATIVES WITH RESPECT TO MUS
      L=KSMOD(ICOMP,IM)
      IF (L .GT. 0) THEN
        TEMP=HR/SMOD(ICOMP,IM)
        CALL CGMSCA(SUM1,DERIVM(1,L-LO),TEMP,3,1)
      ENDIF
C ADD THE TWO COMPONENTS (BUT NOT FOR ANGM OR SMOD):
C (IS THIS WHY THE PSIS ARE 13,14,15 . . ?)
      DO 9 I=1,16
C FOR THE MOMENT, LMAGPR IS A FUNCTION.  WHEN THINGS HAVE SETTLED DOWN IT CAN
C BE AN ARRAY, FOR SPEED.
      L=LMAGPR(I,IM,IR)
      IF (L.GT.0)
     & CALL CGMADD(TDERS(1,I),DERIVM(1,L-LO),DERIVM(1,L-LO),3,1)
    9 CONTINUE
   30 CONTINUE
C END OF A CYCLE OVER 1,2 IF IHELIX=2
C
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C     COMPENSATE FOR THE MULTIPLICITY OF THE STAR
      CALL CMRSCA(FMC,FMC,FKSTAR,3,1)
C
C NOW THE CYCLE FOR THE DOMAIN AVERAGE
   18 IF (IDOMOP .EQ.1 .OR. FERO) CALL MAGDOM(H,HD,IDOMOP,SKIP)
      CALL RCMPRD(HD,FMC,P,3,3,1)
      FMCSQR=FMCSQR+RSCALP(P,P)
      IF (.NOT.SKIP) ND=ND+1
      IF (FERO) THEN
C  PUT Q BACK INTO UNROTATED FRAME
        CALL CROTO(P,Q(1,ND),IS,1)
      ELSE
        CALL CGMEQ(P,Q(1,ND),3,1)
      ENDIF
C
C  TEST OUTPUT
      IF (IOUT.GT.100) WRITE (LPT,4000) ND,P
 4000 FORMAT (/' Q for domain',I2,4X,3(2F8.4,2X))
C
C WORK OVER ALL MAGNETIC ATOMS GETTING MODULI OF DERIVATIVES
      DO 16 IM=1,NMAG
      IR=JMAGAT(IM)
      DO 16 IP=1,22
      L=LMAGPR(IP,IM,IR)
      IF (L .EQ. 0) GO TO 16
      LL=L-LO
      CALL RCMPRD(HD,DERIVM(1,LL),TVEC,3,3,1)
      FMCDER(LL)=FMCDER(LL)+RSCALP(P,TVEC)
      IF (FERO) THEN
C  DERIVATIVES INTO UNROTATED FRAME
        CALL CROTO(TVEC,TTVEC,IS,-1)
      ELSE
        CALL CGMEQ(TVEC,TTVEC,3,1)
      ENDIF
      CALL CMRSCA(TTVEC,FQCDER(1,ND,LL),FKSTAR,3,1)
C  TEST OUTPUT
      IF (IOUT.GT.100) WRITE (LPT,4001) LL,(FQCDER(I,ND,LL),I=1,3)
 4001 FORMAT (' dQ/dp for p=',I2,4X,3(2F8.4,2X))
   16 CONTINUE
C
   15 CONTINUE
C
C  END OF THE DOMAIN LOOP, DO THE DOMAIN AVERAGE
C  DIVIDE BY NDOM AS REQUIRED AND RETURN Fm*DFm/DPar IN FMCDER
      DO 20 IM=1,NMAG
      IR=JMAGAT(IM)
      DO 20 IP=1,22
      L=LMAGPR(IP,IM,IR)
      IF (L.EQ.0) GO TO 20
      LL=L-LO
      FMCDER(LL)=FKSTAR*FMCDER(LL)/FLOAT(ND)
C  TEST OUTPUT
      IF (IOUT.GT.99) WRITE (LPT,4002) LL,FMCDER(LL)
 4002 FORMAT (' Fm*dFm/dp for p=',I2,4X,3(2E12.4,2X))
   20 CONTINUE
C
      FMCSQR=FMCSQR/FLOAT(ND)
      FMCMOD=SQRT(FMCSQR)
C
 100  RETURN
      END
C
C
C
C LEVEL 1      FUNCTION LMAGPR(IP,IM,IR)
      FUNCTION LMAGPR(IP,IM,IR)
C
C *** LMAGPR by JCM 29 May 92 ***
C
CX
CC 17B
CH Gives the fix/vary information for one of the family 2 parameters for
CH magnetic atoms.
CA On entry IP = which species required, in the range 1-22
CA          IM = which magnetic atom (if IP > 12)
CA          IR = which atom
CA On exit  LMAGPR = 0 if the parameter is fixed
CA                 = which variable it is if it is varied.
CD This function is necessary now we hold the fix/vary information with the
CD parameter (e.g. KX with X, KATF with ATF) instead of in a single array
CD regardless of the physical meaning of the parameter.
CN One could use this for non-magnetic applications, if IP =< 12
C
      COMMON /ANISO/ATF(6,50),KATF(6,50),IAPT(150),
     & IATYP(50),KOM1
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /MAGDAT/NMAG,MAGAT(150),JMAGAT(10),NMFORM(10),
     & ANGM(4,10),KANGM(4,10),SMOD(2,10),
     & KSMOD(2,10),PHIH(4,10),KPHIH(4,10),
     & LPHI(4,10),NPHI(10),TPTAB(25,10),
     & IPTAB(25,10),SPIND(3,3,2,10),KOM19
C
      IF (IP .LE. 3) L=KX(IP,IR)
      IA=IAPT(IR)
      IF ((IP .GE. 4 .AND. IP .LE. 9) .AND. IA .GT. 0) L=KATF(IP-3,IA)
C THIS IS FOR MAG - IF USED GENERALLY, REPLACE BY KSCAT & MAKE SURE IT STILL
C WORKS WITH MAG:
      IF (IP .EQ. 10) L=0
      IF (IP .EQ. 11) L=KSITE(IR)
      IF (IP .EQ. 12) L=KTF(IR)
      IF (IP .GE. 13 .AND. IP .LE. 16) L=KPHIH(IP-12,IM)
      IF (IP .GE. 17 .AND. IP .LE. 20) L=KANGM(IP-16,IM)
      IF (IP .GE. 21) L=KSMOD(IP-20,IM)
      LMAGPR=L
      RETURN
      END
C
C
C
C
C LEVEL 14      SUBROUTINE DOMAG(MODE)
      SUBROUTINE DOMAG(MODE)
C
C *** DOMAG updated by PJB 30-May-1995 ***
C
CX
CC 17B
CH Multiple entry subroutine to deal with parameters for magnetic
CH structures on Q cards (but not their fixing/varying).
CA On entry MODE indicates action required:
CA          MODE = 1 Read all Q cards
CA          MODE = 2 Tidy and check magnetic parameters
CA          MODE = 3 Apply shifts, one parameter per entry.
CA          MODE = 4 Write new Q card (one per entry)
CA          MODE = 5 Recalculate vector components and possible new constraints
CA                   at the end of a least squares cycle
CA          MODE = 6 as 5 but in profile refinement VARMAK is called anyway
CA                   at the start of each cycle.
CI Reads in and interprets all Q cards.
CO Reports what it read from Q cards on LPT.
C
      EXTERNAL DFLTMG,PARRUN,VARSMG
      CHARACTER*4 NAME,STYPES(5)
      DIMENSION S(4),SROT(3,3),PROP(3)
      COMMON /ATNAM/ATNAME(150),ATNA(150,9)
      CHARACTER *4 ATNA,ATNAME
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /FONAM/FONA(20,9),FONAME(20)
      CHARACTER *4 FONAME,FONA
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAGDAT/NMAG,MAGAT(150),JMAGAT(10),NMFORM(10),
     & ANGM(4,10),KANGM(4,10),SMOD(2,10),
     & KSMOD(2,10),PHIH(4,10),KPHIH(4,10),
     & LPHI(4,10),NPHI(10),TPTAB(25,10),
     & IPTAB(25,10),SPIND(3,3,2,10),KOM19
      COMMON /NEWOLD/SHIFT,XOLD,XNEW,ESD,IFAM,IGEN,ISPC,
     & NEWIN,KPACK,LKH,SHESD,ISHFT,AVSHFT,AMAXSH
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      COMMON /SYMMAG/MTSYM(25),MSTAB(24),NMSYM,NFAC,OTRSYM(3,3,25),
     & MTYP,NDOM,FERO,FERA,HELI,AMOD,ANTI,MODUL,KOM20
      LOGICAL FERO,FERA,HELI,AMOD,ANTI,MODUL
      DATA STYPES/'FERO','FERA','HELI','AMOD','ANTI'/
C%
C      DATA NSTYPE,NPSI/5,%PSIS%/
      DATA NSTYPE,NPSI/5,4/
C
      GO TO (1,20,30,40,50,50 ), MODE
C
C  READ ALL "Q" CARDS
    1 IER=IERR
C  INITIALISE PROPAGATION VECTOR TO ZERO
      CALL GMZER(PROP,1,3)
C  INITIALISE MAGNETIC SYMMETRY
      CALL MAGSYM(0)
C
      INREAD(17)=-IABS(INREAD(17))
      IF (ICDNO(17).EQ.0) THEN
        CALL ERRMES(2,1,'Q cards for magnetic structure refinements')
        GO TO 100
      ENDIF
      MAG=.TRUE.
      ID=IABS(INREAD(17))
      NMAG=0
      CALL JGMZER(MAGAT,1,NATOM)
C
C%
C      DO 8 I=1,%MGAT%
      DO 8 I=1,10
      ANGM(1,I)=999.5
      SMOD(1,I)=0.
    8 NMFORM(I)=0
      CALL JGMZER(LPHI,NPSI,1)
C
C NQ COUNTS Q CARDS:
      DO 7 NQ=1,ICDNO(17)
      CALL INPUTQ(ID,NTYP,IAT,IPT1,IE)
      IF (IE .NE.0) THEN
        IERR=IERR+1
        GO TO 6
      ENDIF
      GO TO (10,81,82,83,70,80,2,28) ,NTYP
C
C  STYP: MAGNETIC STRUCTURE TYPE
  10  CALL RDWORD(NAME,L,IPT1,IPT,80,0,IE)
      MTYP=NCFIND(NAME,STYPES,NSTYPE)
      IF (MTYP.EQ.0) CALL ERRCH2(NAME,1,'Magnetic structure type ',
     & 'not known')
      GO TO 6
C
C  SDIR
C  SET SPIN DIRECTIONS
    2 CALL GMZER(S,4,1)
      CALL RDNUMS(S,IPT1,4,NUM,IE)
      IF (IE.NE.0)THEN
        NUM=0
        GO TO 98
      ELSE
        IF (MAGAT(IAT).EQ.0) THEN
C%
C          CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
          CALL ERRCHK(2,NMAG,10,1,'magnetic atoms')
          MAGAT(IAT)=NMAG
          JMAGAT(NMAG)=IAT
        ENDIF
        JAT=MAGAT(IAT)
        DO 25 I=1,4
   25   CALL PUTPAR(S,I,NUM,ANGM(I,JAT),999.5)
      ENDIF
      GO TO 6
C
C  Q PSI: relative phases of spirals on different sublattices
   28 IF (MAGAT(IAT).EQ.0) THEN
C%
C       CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
       CALL ERRCHK(2,NMAG,10,1,'magnetic atoms')
        MAGAT(IAT)=NMAG
        JMAGAT(NMAG)=IAT
      ENDIF
      JAT=MAGAT(IAT)
      I=0
   29 CALL RDINTG(L,IPT1,IPT2,80,IE)
      IF (IE .EQ. 100) GO TO 6
      IF (IE .GT. 0) GO TO 98
      CALL RDREAL(P,IPT2,IPT1,80,IE)
      IF (IE .EQ. 100) GO TO 6
      IF (IE .GT. 0) GO TO 98
      IF (IABS(L).LT. 1 .OR. IABS(L).GT.NOPC)
     & CALL ERRIN2(L,1,'Illegal operator number',' on Q PSI card')
      CALL ERRCHK(2,I,NPSI,1,'PSI values')
      LPHI(I,JAT)=L
      PHIH(I,JAT)=P
      IF (I.LE.NPSI) GO TO 29
      GO TO 6
C
C  Q FORM:
   70 CALL RDWORD(NAME,L,IPT1,IPT,80,0,IE)
      IF (IE.EQ.100) GO TO 6
      NA=IATOM(NAME)
      IF (NA.EQ.0) CALL ERRATM(NAME,1,'Q card')
      IF (MAGAT(NA).EQ.0) THEN
C%
C        CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
        CALL ERRCHK(2,NMAG,10,1,'magnetic atoms')
        MAGAT(NA)=NMAG
        JMAGAT(NMAG)=NA
      ENDIF
      JAT=MAGAT(NA)
      IF (NMFORM(JAT).EQ.0) THEN
        NMFORM(JAT)=IAT
      ELSE
        CALL ERRMES(1,-1,
     &'Attempt to redefine magnetic form factor of '
     & //NAME//' ignored')
      ENDIF
       IPT1=IPT
      GO TO 70
C
C Q MU:
   80 CALL GMZER (S,4,1)
      CALL RDNUMS(S,IPT1,2,NUM,IE)
      IF (IE.NE.0) THEN
        NUM=0
        GO TO 98
      ENDIF
      IF (MAGAT(IAT).EQ.0) THEN
C%
C        CALL ERRCHK(2,NMAG,%MGAT%,1,'magnetic atoms')
        CALL ERRCHK(2,NMAG,10,1,'magnetic atoms')
        MAGAT(IAT)=NMAG
        JMAGAT(NMAG)=IAT
      ENDIF
      JAT=MAGAT(IAT)
      CALL PUTPAR(S,1,NUM,SMOD(1,JAT),999.)
      CALL PUTPAR(S,2,NUM,SMOD(2,JAT),999.)
      GO TO 6
C
C  Q PROP:
   81 CALL RDNUMS(PROP,IPT1,3,NUM,IE)
      IF (IE.EQ.0) GO TO 6
      GO TO 98
C
C  Q MSYM:
   82 CALL RDINTG(IOP,IPT1,IPT,80,IE)
      CALL RDREAL(VAL,IPT,IPT1,80,IE)
      IF (IE.EQ.100) GO TO 6
      IF (IE.NE.0) GO TO 98
      CALL MELIN(IOP,VAL)
      GO TO 82
C
C  Q NSYM:
  83  CALL RDINTG(IOP,IPT1,IPT,80,IE)
      CALL RDNUMS(SROT,IPT,9,NUM,IE)
      IF (IE .NE. 0 .OR. NUM .NE. 9) GO TO 98
      CALL NELIN(IOP,SROT)
      GO TO 6
C
C READING ERROR
  98  CALL ERRCH2('Q',2,'reading','card')
      GO TO 6
C
   6  ID=ID+NYZ
   7  CONTINUE
      IF (IER .NE. IERR) GO TO 100
C
C  END OF CARDS - CHECK THEM AND REPORT WHAT WAS READ:
      IF (NMAG.EQ.0) THEN
        CALL ERRMES(1,1,'no magnetic atoms')
      ELSE
        IF (MTYP .GT. 0) THEN
          CALL LOGMAG
          CALL MESS(LPT,1,'Magnetic structure type '//STYPES(MTYP))
          IF (FERO .OR. FERA) WRITE (LPT,2007)
 2007     FORMAT ('+',30X,'Ferromagnetic')
          IF (HELI) WRITE (LPT,2009) PROP
 2009     FORMAT (' Helimagnetic Structure with Propagation Vector ',
     &     3F8.4/)
          IF (AMOD) WRITE (LPT,2008) PROP
 2008     FORMAT (/' Amplitude Modulated Structure with Propagation ',
     &   ' Vector ',3F8.4/)
          IF (ANTI) WRITE (LPT,2010) PROP
2010      FORMAT (/' Commensurate magnetic structure with Propagation ',
     &   ' Vector ',3F8.4/)
        ENDIF
        CALL PROPER(PROP)
        CALL MAGSYM(1)
      ENDIF
      GO TO 100
C
C  TIDY UP AND CHECK MAGNETIC PARAMETERS
   20 CALL MESS(LPT,1,'Magnetic moments, form factors and polar'//
     & ' angles of spin directions')
      CALL MESS(LPT,0,'with respect to orthogonal crystallographic'//
     & ' axes are:')
      IF (HELI) THEN
        WRITE (LPT,2003)
 2003   FORMAT (5X,'Atom     Form',11X,'Major Axis',16X,
     & 'Minor Axis',12X,'Phase Angles'/13X,'factor',
     & 2(4X,'Moment   Theta    Phi '),3X,4('Op. Phase   '))
      ELSE IF (AMOD) THEN
        WRITE (LPT,2005)
 2005   FORMAT (5X,'Atom     Form    Moment    Theta','    Phi',
     &  16X,'Phase Angles'/13X,'factor',31X,4('Op. Phase   '))
      ELSE
        WRITE (LPT,2004)
 2004   FORMAT (5X,'Atom     Moment     Form       Theta',
     & '       Phi'/25X,'factor')
      ENDIF
      DO 9 I=1,NMAG
      IF (NMFORM(I).EQ.0) THEN
        CALL ERRCH2(ATNAME(JMAGAT(I)),1,
     &  'No magnetic form factor for',' ')
      ELSE
C
        IF (ANGM(1,I) .GT. 999) THEN
          CALL ERRCH2(ATNAME(JMAGAT(I)),1,'No Q SDIR card for',' ')
        ELSE
          NUM=2
          IF (HELI) NUM=4
          DO 51 J=2,NUM
          IF (ANGM(J,I) .LT. 999.) GO TO 51
          CALL ERRCH2(ATNAME(JMAGAT(I)),1,
     &    'Not enough data on SDIR card for',' ')
          GO TO 52
   51     CONTINUE
   52   ENDIF
        IF (SMOD(1,I).EQ.0. ) THEN
            WRITE (LPT,3008) ATNAME(JMAGAT(I))
            WRITE (ITO,3008) ATNAME(JMAGAT(I))
 3008       FORMAT (' WARNING ** Zero moment for ',A4)
        ELSE
          IF (HELI .AND. SMOD(2,I).GE.999.)
     &    CALL ERRCH2(ATNAME(JMAGAT(I)),1,
     &    'Not enough data on MU card for',' ')
        ENDIF
        IF (MODUL) THEN
          IF (NPHI(I).GT.0) THEN
            NP=NPHI(I)
            DO 53 J=1,NP
            IF (LPHI(J,I) .EQ.0) THEN
                N=NFIND(J,IPTAB(1,I),NOPC)
                IF (N.EQ.0)
     &          N=NFIND(J+IPTAB(NOPC+1,I),IPTAB(1,I),NOPC)
                CALL ERRIN2(N,1,
     &        'PSI value for operator','missing on PSI '
     &        //ATNAME(JMAGAT(I))//' card')
                GO TO 54
            ENDIF
   53       CONTINUE
   54     ENDIF
          IF (HELI) THEN
            WRITE (LPT,2001) ATNAME(JMAGAT(I)),
     &    FONAME(NMFORM(I)),SMOD(1,I),(ANGM(J,I),J=1,2),
     &    SMOD(2,I),(ANGM(J,I),J=3,4),(LPHI(J,I),
     &    PHIH(J,I),J=1,NP)
 2001       FORMAT (5X,A4,5X,A4,2X,2(F8.3,2F8.1,2X),2X,3(I3,F7.1,2X))
          ELSE
            WRITE (LPT,2011) ATNAME(JMAGAT(I)),
     &    FONAME(NMFORM(I)),SMOD(1,I),(ANGM(J,I),J=1,2),
     &    (LPHI(J,I),PHIH(J,I),J=1,NP)
 2011       FORMAT (5X,A4,5X,A4,2X,F8.3,2F8.1,5X,4(I3,F7.1,2X))
          ENDIF
        ELSE
          WRITE (LPT,2000) ATNAME(JMAGAT(I)),SMOD(1,I),
     &    FONAME(NMFORM(I)),ANGM(1,I),ANGM(2,I)
 2000     FORMAT (5X,A4,2X,F8.4,7X,A4,2X,2F10.2)
        ENDIF
      ENDIF
    9 CONTINUE
      CALL ERRMES(0,0,'from DOMAG(2)')
      GO TO 100
C
C  APPLY SHIFTS:
   30 IP=MAGAT(IGEN)
      J=ISPC-12
      IF (J.LE.NPSI) GO TO 23
      J=J-NPSI
      IF (J.LE.4) GO TO 21
      J=J-4
      GO TO 22
C
   21 CALL ADJUST(ANGM(J,IP))
      ANGM(J,IP)=ARANGE(ANGM(J,IP),180.,-180.)
      XNEW=ANGM(J,IP)
      GO TO 100
C
   22 CALL ADJUST(SMOD(J,IP))
      GO TO 100
C
   23 CALL ADJUST(PHIH(J,IP))
      GO TO 100
C
C  WRITE NEW Q CARDS
   40 CALL INPUTQ(0,NTYP,JAT,IPT,IE)
      IF (NTYP.EQ.2) THEN
        CALL PROPAG(4,NEWIN)
        GO TO 100
      ENDIF
      IF (NTYP.LT.6) GO TO 31
      IAT=MAGAT(JAT)
      IP=2
      IF (MTYP.EQ.3) IP=4
      IM=IP/2
      IF (NTYP.EQ.8) THEN
        NPH=NPHI(IAT)
        DO 41 J=1,NPH
        LP=LPHI(J,IAT)
        IF (LP.GT.NOPC) LP=-1
        WRITE (ICARD(IPT:),214) LP,PHIH(J,IAT)
  214 FORMAT (I5,F10.4)
        IPT=IPT+15
   41   CONTINUE
      ELSE IF (NTYP.EQ.7) THEN
        WRITE (ICARD(IPT:),213) (ANGM(J,IAT),J=1,IP)
  213   FORMAT (4F10.4)
      ELSE IF (NTYP.EQ.6) THEN
        WRITE (ICARD(IPT:),213) (SMOD(J,IAT),J=1,IM)
      ENDIF
  31  WRITE (NEWIN,209) (ICARD(I:I),I=1,LENGT(ICARD))
  209 FORMAT (80A1)
      GO TO 100
C
C  RECALCULATE SPIN VECTORS
   50 DO 61 IM=1,NMAG
      CALL SPHPOL(ANGM(1,IM),ANGM(2,IM),SPIND(1,1,1,IM),3)
      IF (HELI) THEN
        CALL SPHPOL(ANGM(3,IM),ANGM(4,IM),SPIND(1,1,2,IM),3)
        CALL SPHELI(IM,2)
      ENDIF
   61 CONTINUE
C IN PROFILE REFINEMENT VARMAK IS CALLED ANYWAY
      IF (HELI .AND. MODE .EQ.5) CALL VARMAK(DFLTMG,PARRUN,VARSMG)
C
  100 RETURN
      END
C
C
C
C LEVEL 2      LOGICAL FUNCTION DFLTMG(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFLTMG(IFAM,IGEN,ISPC)
C
C *** DFLTMG updated by PJB 27 May 92 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT via VARMAK, giving default fix/vary
CH for otherwise unspecified parameters for magnetic structures.
CA On entry IFAM, ISPC, IGEN give family, genus, species of parameter
CA On exit LOGICAL DFLTMG is TRUE if the parameter is to be varied, or
CA                           FALSE if to be fixed.
CD For magnetic structures, fix all conventional structure parameters,
CD and vary all possible magnetic parameters.
C
      COMMON /MAGDAT/NMAG,MAGAT(150),JMAGAT(10),NMFORM(10),
     & ANGM(4,10),KANGM(4,10),SMOD(2,10),
     & KSMOD(2,10),PHIH(4,10),KPHIH(4,10),
     & LPHI(4,10),NPHI(10),TPTAB(25,10),
     & IPTAB(25,10),SPIND(3,3,2,10),KOM19
      COMMON /SLAKDA/NSLAK(4),SLKSWD(4),SLAKWT(4),
     & CHISQD(4),ISLKTP,NSKTOT,KOM24
      COMMON /SYMMAG/MTSYM(25),MSTAB(24),NMSYM,NFAC,OTRSYM(3,3,25),
     & MTYP,NDOM,FERO,FERA,HELI,AMOD,ANTI,MODUL,KOM20
      LOGICAL FERO,FERA,HELI,AMOD,ANTI,MODUL
C%
C      DATA NPSI/%PSIS%/
      DATA NPSI/4/
C
      DFLTMG=.TRUE.
      GO TO (1,2) , IFAM
      GO TO 100
C
C FAMILY 1 - DEFAULT VARY SCALES, OR WHATEVER IS IN THEIR PLACE:
   1  IF (IGEN .NE. 1) GO TO 100
C IF GEOMETRIC SLACK CONSTRAINTS, DEFAULT VARY CELL PARAMETERS:
      IF (NSLAK(1).EQ.0 .AND. (ISPC.GE.2 .AND. ISPC.LE.7)) GO TO 101
C DEFAULT FIX DOMR & MOSC:
      IF (ISPC .EQ. 8 .OR. ISPC .EQ. 9) GO TO 101
      GO TO 100
C
C FAMILY 2 - DEFAULT FIX NUCLEAR PARAMETERS:
   2  IF (ISPC .LE. 12) GO TO 101
C
C  FIX MAGNETIC PARS OF NON-MAGNETIC ATOMS
      IF (MAGAT(IGEN).EQ.0) GO TO 101
C
C  IF HELICAL ALL MAGNETIC PARS ARE ALLOWED
      IF (HELI) GO TO 100
C  IF AMPLITUDE MODULATED PSI'S ARE VARIED
      J=ISPC-12-NPSI
      IF (J.LE.0) THEN
        IF (AMOD) GO TO 100
C ELSE FIX PSI'S
        GO TO 101
      ENDIF
C  FIX MINOR AXIS
      GO TO (100,100,101,101,100,101),J
C
C FIX:
 101  DFLTMG=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PROPDR(H,IS,DER)
      SUBROUTINE PROPDR(H,IS,DER)
C
CC 17B
C *** PROPDR updated by PJB 1 Feb 1994 ***
C
CH Makes derivatives of d*sqrd with respect to the magnetic propagation
CH vector

CA On entry H contains the indices of the magnetic reflection
CA          IS is +/- 1 depending on whether the propagation vector
CA             has been added or subtracted.
CA On exit DER contains the derivatives with respect to the three components
CA             of the pv.
C
      DIMENSION DER(3),H(3)
      COMMON /CELPAR/CELL(3,3,2),V(2),ORTH(3,3,2),CPARS(6,2),KCPARS(6),
     & CELESD(6,6,2),CELLSD(6,6),KOM4
C
      CALL GMZER(DER,3,1)
      IF (IS.EQ.0) GO TO 100
      AS=SIGN(2.,FLOAT(IS))
      J=2
      K=3
      DO 1 I=1,3
      DER(I)=AS*(CPARS(I,2)*H(I)+CPARS(J+3,2)*H(K)+CPARS(K+3,2)*H(J))
      J=K
      K=I
    1 CONTINUE
C
  100 RETURN
      END
C
C
C
C LEVEL 9      SUBROUTINE MAGCNL
      SUBROUTINE MAGCNL
C
C *** MAGCNL updated by PJB 10 Jun 92 ***
C
CX
CC 17A
CH Does the fixing associated with constraints found by MAGCON and PSICON.
C
C%
C      DIMENSION RELA(2),KK(2),IPSFIX(%PSIS%)
      DIMENSION RELA(2),KK(2),IPSFIX(4)
      LOGICAL LMFIX(3),FIRST,FIRSTP
      COMMON /MAGDAT/NMAG,MAGAT(150),JMAGAT(10),NMFORM(10),
     & ANGM(4,10),KANGM(4,10),SMOD(2,10),
     & KSMOD(2,10),PHIH(4,10),KPHIH(4,10),
     & LPHI(4,10),NPHI(10),TPTAB(25,10),
     & IPTAB(25,10),SPIND(3,3,2,10),KOM19
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /SYMMAG/MTSYM(25),MSTAB(24),NMSYM,NFAC,OTRSYM(3,3,25),
     & MTYP,NDOM,FERO,FERA,HELI,AMOD,ANTI,MODUL,KOM20
      LOGICAL FERO,FERA,HELI,AMOD,ANTI,MODUL
C%
C      DATA RELA,NPSI/1.,-1.,%PSIS%/
      DATA RELA,NPSI/1.,-1.,4/
C
      FIRST=.TRUE.
      FIRSTP=.TRUE.
C  WORK OVER ALL ATOMS
      DO 1 IAT=1,NATOM
      IATO=MAGAT(IAT)
C FIX THE MAGNETIC PARAMETERS FOR THE NON-MAGNETIC ATOMS:
      IF (IATO .EQ. 0) THEN
        DO 42 I=13,22
        CALL ADDFX5(2,IAT,I,JPHASE,1,5)
  42    CONTINUE
      ELSE
C  IF FERROMAGNETIC NO CONSTRAINTS:
        IF (FERO .OR. FERA) GO TO 3
C
C CONSTRAINTS FOR THIS ATOM:
        CALL MAGCON(IATO,LMFIX,FIRST)
C KEEP IN CASE THESE ARE LSQ PARAMETERS:
        DO 2 I=1,2
        IF (LMFIX(I)) CALL ADDFX5(2,IAT,12+NPSI+I,JPHASE,1,5)
    2   CONTINUE
        IF (LMFIX(3)) CALL ADDFX5(2,IAT,17+NPSI,JPHASE,1,5)
C FILL IN DIFFERENTIALS PARTS OF SD
   3    CALL SPHPOL(ANGM(1,IATO),ANGM(2,IATO),SPIND(1,1,1,IATO),3)
        IF (HELI) THEN
C PUT CONSTRAINTS ON SECOND COMPONENT
          DO 5 I=1,2
          IF (LMFIX(I)) CALL ADDFX5(2,IAT,14+NPSI+I,JPHASE,1,5)
    5     CONTINUE
          IF (LMFIX(3)) CALL ADDFX5(2,IAT,18+NPSI,JPHASE,1,5)
C  AND SET THE PERPENDICULARITY CONSTRAINTS
          CALL SPHPOL(ANGM(3,IATO),ANGM(4,IATO),SPIND(1,1,2,IATO),3)
          CALL SPHELI(IATO,1)
        ENDIF
        IF (MODUL) THEN
          CALL PSICON(IATO,IPSFIX)
C  FIX THE PSI'S IF REQUIRED
          DO 4 I=1,NPSI
          IF (IPSFIX(I).EQ.0) THEN
            CALL ADDFX5(2,IATO,12+I,JPHASE,1,5)
          ELSE IF (IPSFIX(I).NE.I) THEN
            KK(1)=KPAK(2,IATO,12+I,JPHASE,1)
            KK(2)=KPAK(2,IATO,12+IPSFIX(I),JPHASE,1)
            CALL ADDCON(2,KK,RELA,5)
          ELSE IF (FIRSTP) THEN
C  ONE (the first) PSI must be fixed
            CALL ADDFX5(2,IATO,12+I,JPHASE,1,5)
            FIRSTP=.FALSE.
          ENDIF
    4     CONTINUE
        ENDIF
      ENDIF
    1 CONTINUE
C
  100 RETURN
      END
C
C

!
!*****************************************************************************
!
! Originally in multipeak_chisq.for
!
C
C
      SUBROUTINE OUTPROSP
C
      INCLUDE 'PARAMS.INC'

      COMMON /ZSTORE/ NPTS,ZARGI(MPPTS),ZOBS(MPPTS),ZDOBS(MPPTS),
     &ZWT(MPPTS),ICODEZ(MPPTS),KOBZ(MPPTS)
      COMMON /YSTORE/ ZCAL(MPPTS),ZBAK(MPPTS)
C
      OPEN(43,FILE='TEMP.PRO',STATUS='UNKNOWN')
      DO I=1,NPTS
        WRITE(43,*) ZARGI(I),ZBAK(I),ZOBS(I),ZCAL(I),ZDOBS(I)
      END DO
      CLOSE(43)
C
      END
!
!*****************************************************************************
!
! Originally in PolyLoadFiles.f90
!
      INTEGER FUNCTION Load_CCL_File(FLEN,TheFileName)
!
      CHARACTER(LEN=256),           INTENT (IN) :: TheFileName
      INTEGER,                      INTENT (IN) :: FLEN
      CHARACTER(LEN=80) CCL_LINE
      INCLUDE 'GLBVAR.INC' ! Contains ALambda
      COMMON /CELLREF/ CELLPAR(6),ZEROPOINT
      INTEGER I
      REAL  WaveLengthOf ! Function
!
!>> JCC Initialise return value
!
      Load_CCL_File = 1
      ZEROPOINT = 0.0
      ALambda = WaveLengthOf('Cu')
!
!>> JCC Add in Error trap
!                          
      OPEN(11,FILE=TheFileName(:FLEN),STATUS='OLD', ERR = 999)
!>> JCC Set SA Output files
      CALL sa_SetOutputFiles(TheFileName)
   10 READ(11,5000,ERR=100,END=100) NLCCL,CCL_LINE
 5000 FORMAT(Q,A)
      IF (CCL_LINE(1:1) .EQ. 'C') THEN
        READ(CCL_LINE(2:NLCCL),*) (CELLPAR(I),I=1,6)
      ELSE IF (CCL_LINE(1:1) .EQ. 'L') THEN
        IF (CCL_LINE(3:6) .EQ. 'WVLN') THEN
          READ(CCL_LINE(7:NLCCL),*) ALambda
        ELSE IF (CCL_LINE(3:6) .EQ. 'ZERO') THEN
          READ(CCL_LINE(7:NLCCL),*) zeropoint
        END IF
      END IF
      GOTO 10
  100 CLOSE(11)
!
      CALL UpLoad_Crystal_Data()
!
!>> JCC Added in next few lines
      RETURN
 999  Load_CCL_File = 0
      RETURN
      END FUNCTION Load_CCL_File
!
!*****************************************************************************
!
! Originally in Fou.for
!
C
C
C
C
C LEVEL 6      SUBROUTINE ARROW(X,Y,L)
      SUBROUTINE ARROW(X,Y,L)
C
C *** ARROW by PJB Sep 87 ***
C
CX
CC 14C
CH Draws an arrow centred at X,Y in the current space.
CP General CCSL plotting must have been set up.
CA On entry L=0 requests outline arrow
CA          L=1 requests solid arrow
C
      DIMENSION SPTS(2,7),PTS(2,7)
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
      DATA SPTS/-8.,-1.,-8.,1.,4.,1.,4.,4.,8.,0.,4.,-4.,4.,-1./
      DATA NPTS/7/

C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C  ADD DISPLACEMENT
      DO 2 I=1,NPTS
      PTS(1,I)=SPTS(1,I)+X
    2 PTS(2,I)=SPTS(2,I)+Y
C
C  DRAW OUTLINE
      CALL KANGA1(PTS(1,NPTS),PTS(2,NPTS),3)
      DO 1 N=1,NPTS
      CALL KANGA1(PTS(1,N),PTS(2,N),2)
    1 CONTINUE
C
C  RETURN IF L=0
      IF (L.EQ.0) GO TO 100
C
C  GET EFFECTIVE GRID FOR SHADING
      CALL PLCONV(0.,0.,1,A1,B1,NSPCE)
	IF (IBMBER .NE. 0) RETURN
      CALL PLCONV(.02,0.,1,A,B,NSPCE)
	IF (IBMBER .NE. 0) RETURN
      A=A-A1
      B=B-B1
      STEP=SQRT(A**2+B**2)
C
C  NOW SHADE THE ARROW
C  FIRST THE TAIL
      CALL KANGA1(PTS(1,1),PTS(2,1),3)
      DO 3 XX=PTS(1,1)+STEP,PTS(1,7),STEP
      CALL KANGA1(XX,PTS(2,2),2)
    3 CALL KANGA1(XX,PTS(2,1),2)
C  THEN THE HEAD
      SY1=STEP*((PTS(2,5)-PTS(2,4))/(PTS(1,5)-PTS(1,4)))
      SY2=STEP*((PTS(2,5)-PTS(2,6))/(PTS(1,5)-PTS(1,6)))
      CALL KANGA1(PTS(1,6),PTS(2,6),3)
      Y1=PTS(2,4)
      Y2=PTS(2,6)
C
C NOTE FROM JCM - THIS OUGHT TO BE TIDIED:
      DO 4 XX=PTS(1,7)+STEP,PTS(1,5),STEP
      Y1=Y1+SY1
      Y2=Y2+SY2
      CALL KANGA1(XX,Y1,2)
      CALL KANGA1(XX,Y2,2)
    4 CONTINUE
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE ATMPLO(IFND,NFND,JP)
      SUBROUTINE ATMPLO(IFND,NFND,JP)
C
C *** ATMPLO by PJB Aug 86 ***
C
CX
CC 5B
CH Plots atom positions on a map.
CA On exit NFND=number of positions plotted
CA         IFND, an integer array, contains pointers to the atoms plotted
CA         JP, an integer array, points to the symbols used for each atom
C
      DIMENSION JP(4),IFND(4),Z(2)
      LOGICAL FOUND1
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON/SCRAT/AA(3,3),TRXX(3,48),TLAT(3,4),BOUNDS(2,6),XX(3,3),
     & TMPV1(3),TMPV2(3),TMPV3(3),TTXX(3,50),NT
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C SET MAP SPACE:
      CALL SPCSET(4)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      JP(1)=1
      JP(2)=2
      JP(3)=4
      JP(4)=9
C
      NT=NDIM
      NFND=0
C
C  GET INVERSE OF U
      CALL GMEQ(U,AA,3,3)
      CALL TRINV3(AA,D)
C  TRANSORM LATTICE VECTORS IF NECESSARY
      DO 6 L=1,NLAT
      IF (MODET.EQ.1) THEN
        CALL GMPRD(ALAT(1,L),AA,TLAT(1,L),1,3,3)
      ELSE
        CALL GMEQ(ALAT(1,L),TLAT(1,L),1,3)
      ENDIF
    6 CONTINUE
C  FIX BOUNDARIES
      CALL GMEQ(OUTLIM,BOUNDS,2,1)
      CALL GMEQ(OUTLIM(1,2),BOUNDS(1,2),2,1)
C  LIMIT IN Z
      AL=VCTMOD(1.,U(1,3),1)
      ALZ=.1/AL
      BOUNDS(1,3)=OUTLIM(1,3) -ALZ
      BOUNDS(2,3)=OUTLIM(1,3) +ALZ
C  COPY VECTOR
      CALL GMEQ(BOUNDS(1,1),BOUNDS(1,4),2,3)
      IF (MODET.EQ.0) GO TO 5
      II=1
      DO 20 I=1,2
      TMPV1(3)=BOUNDS(I,3)
      DO 20 J=1,2
      TMPV1(2)=BOUNDS(J,2)
      DO 20 L=1,2
      TMPV1(1)=BOUNDS(L,1)
      CALL GMPRD(U,TMPV1,TRXX(1,II),3,3,1)
   20 II=II+1
C  FIND MAXIMUM AND MINIMUM ON EACH CRYSTALLOGRAPHIC AXIS
      DO 21 I=1,3
      BOUNDS(1,I)=AMIN1(TRXX(I,1),TRXX(I,2),TRXX(I,3),TRXX(I,4),
     & TRXX(I,5),TRXX(I,6),TRXX(I,7),TRXX(I,8))
      BOUNDS(2,I)=AMAX1(TRXX(I,1),TRXX(I,2),TRXX(I,3),TRXX(I,4),
     & TRXX(I,5),TRXX(I,6),TRXX(I,7),TRXX(I,8))
   21 CONTINUE
C GENERATE ATOMIC POSITIONS
    5 DO 1 IAT=1,NATOM
C FOR SKEW BUT RATIONAL PLANE, POSITIONS MUST BE TRANSFORMED TO MATCH THE
C SYMMETRY OPERATORS
      IF (MODET.EQ.1) THEN
        CALL GMPRD(X(1,IAT),AA,TRXX(1,1),1,3,3)
      ELSE
        CALL GMEQ(X(1,IAT),TRXX(1,1),1,3)
      ENDIF
      CALL ATOGEN(MOLD)
      FOUND1=.FALSE.
      DO 3 M=1,MOLD
      IF (MODET.NE.1) THEN
        CALL GMEQ(TRXX(1,M),TMPV1,1,3)
      ELSE
        CALL GMPRD(TRXX(1,M),U,TMPV1,1,3,3)
      ENDIF
      CALL TBOUND(IFOUND)
      IF (IFOUND .EQ.0) GO TO 3
      FOUND1=.TRUE.
      DO 31 IFN=1,IFOUND
      DO 30 I=1,2
      Z(I)=(TTXX(I,IFN)-OUTLIM(1,I))/OUTLIM(3,I)
   30 CONTINUE
      CALL KANGA3(Z(1),Z(2),1.5*CHUNIT*CHSCAL(2,3),JP(NFND+1))
   31 CONTINUE
    3 CONTINUE
      IF (FOUND1) CALL ERRCHK(2,NFND,4,0,'atoms in ATMPLO')
      IFND(NFND)=IAT
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ATOGEN(MOLD)
      SUBROUTINE ATOGEN(MOLD)
C
C *** ATOGEN by PJB Aug 86 ***
C
CX
CC 5B
CH Generates a set of equivalent positions.
CA MOLD on exit is the number generated
CP In /SCRAT/ on entry (usually from ATMPLO) TRXX(1:3,1) holds the original
CP atomic position.
CD Generates all the related (different) positions in TRXX within 1 unit cell.
C
CN A PJB special for use with ATMPLO.
C
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON/SCRAT/AA(3,3),TRXX(3,48),TLAT(3,4),BOUNDS(2,6),XX(3,3),
     & TMPV1(3),TMPV2(3),TMPV3(3),TTXX(3,50),NT
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
      MOLD=0
      CALL GMEQ(TRXX(1,1),XX,1,3)
      DO 1 L=1,NLAT
      DO 1 N=1,NOPC
      CALL GMADD(TRANS(1,N),TLAT(1,L),TMPV1,1,3)
      CALL ROTSYM(XX,XX(1,2),N,1)
C  CYCLE OVER CENTRE OF SYMMETRY
      DO 2 IR=1,NCENT
      CALL GMADD(TMPV1,XX(1,2),TMPV2,1,3)
      IF (MOLD.EQ.0) THEN
        MOLD=1
      ELSE
        CALL EQPOS(TRXX,TMPV2,MOLD,M,48)
        IF (M.GT.MOLD) MOLD=M
      ENDIF
C
    2 CALL GMREV(XX(1,2),XX(1,2),1,3)
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CHOOSF(F,SF,ALPHA1,ALPHA,MODEF)
      SUBROUTINE CHOOSF(F,SF,ALPHA1,ALPHA,MODEF)
C
C *** CHOOSF by PJB ***
C
CX
CC 5C
CH Chooses modulus and phase for a particular Fourier.
C
CA On entry ALPHA1 is an original phase
CA          F is a 1x2 array of read coefficients
CA          MODEF is the type of Fourier:
CA            MODEF=1   FCAL
CA            MODEF=2   FOBS (Centrosymmetric)
CA            MODEF=3   mod(FOBS)*phase(FCAL)
CA            MODEF=4   FOBS-FCAL
CA            MODEF=5   (mod(FOBS)-mod(FCAL))*phase(FCAL)
CA            MODEF=6   FOBS*FOBS (Patterson)
CA On exit SF holds the modulus and ALPHA the required phase.
C
      DIMENSION F(2)
C
      ALPHA=ALPHA1
      GO TO (21,22,23,24,25,26),MODEF
C
  21  SF = ABS(F(1))
      GO TO 10
C
   22  SF = F(2)
      ALPHA = 0.
      GO TO 10
C
  23  SF = ABS(F(2))
      GO TO 10
C
  24  SF = F(2) -F(1)
      ALPHA = 0.
      GO TO 10
C
  25  SF = ABS(F(2)) - ABS(F(1))
      GO TO 10
C
  26  SF = F(2)*F(2)
      ALPHA = 0.
C
C SF AND ALPHA NOW SET UP:
C
   10 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE DOSIDE(A,B,ISIDE,NR,NC,X,Y)
      SUBROUTINE DOSIDE(A,B,ISIDE,NR,NC,X,Y)
C
C *** DOSIDE 24 Nov 83 by JCM ***
C
CX
CC 5C
CH A specialist routine for contour plotting, to help to decide where a
CH contour crosses the side of a square.
C
      IF (ISIDE .NE. 1) THEN
        DO 3 I=2,ISIDE
        C=B
        B=A
   3    A=1.0-C
      ENDIF
      Y = FLOAT(NC-1) + A
      X = B + FLOAT(NR-1)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE DPLOT(XXIN,YYIN,LINE)
      SUBROUTINE DPLOT(XXIN,YYIN,LINE)
C
C *** DPLOT by PJB Apr 85 ***
C
CX
CC 14C
CH Does plotting in current coordinate system.
CA On entry:
CA     XXIN,YYIN give the target position.
CA     LINE controls the kind of line being drawn:
CA          If LINE = 0 pen is "up"
CA          If LINE = 1 a continuous line is drawn
CA          If LINE = 2 a dashed line is drawn
CA          If LINE>10 but <21 the symbol LINE-10 is drawn at intervals of
CA                     DASH in /ADASH/
CP COMMON /ADASH/ is used to remember what is happening for dashed lines
CP        X1,Y1=where pen went to.
CD The pen is moved from its current position to XXIN,YYIN.
C
      COMMON /ADASH/DASH,X1,Y1,REM,IPEN,IDSH,DTRAN(2,2)
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP

C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C
      IF (LINE .LE. 1) GO TO 12
      ILINE=1
      IF (LINE.GT.10) ILINE=2
C  CHECK THAT THE SPACE HAS NOT CHANGED
      IF (IDSH.EQ.NSPCE) GO TO 10
C  MAKE A DUMMY CALL TO PLCONV
      CALL PLCONV(0.,0.,0,X,Y,3)
	IF (IBMBER .NE. 0) RETURN

C  AND SET DTRAN FROM THE NEW PTRAN
      CALL GMEQ(PTRAN(1,1,2),DTRAN,2,2)
      IDSH=NSPCE
      GO TO 10
C
C NOT DASHING - RESET DASH COUNT - JOIN HERE IF DASHING AT CONTOUR START:
   12 II=3-LINE
  11  REM = 0.
      IPEN = 2
      CALL KANGA1 (XXIN,YYIN,II)
C FOR NOW - AS IPN IS NOT SET THIS CANNOT BE RIGHT, BUT OFFHAND I DON'T KNOW
C WHAT IT SHOULD BE:
C      IF (IPN .GT. 0) GO TO 100
      GO TO 101
C AVOID STORAGE OF X1,Y1 IF NOT DASHING, AND EXIT
C
C HERE FOR DASHED LINE:
C IF "DASHING" BUT ACTUALLY PEN UP, DO NOT COMPUTE DASHES, BUT DO ARRANGE TO
C STORE CURRENT POSITION IN X1,Y1:
C LENGTH OF LINE TO BE PLOTTED
   10 U = XXIN-X1
      V = YYIN-Y1
      ALEN = SQRT((U*DTRAN(1,1)+V*DTRAN(1,2))**2+(U*DTRAN(2,1)+V*DTRAN(2
     & ,2))**2)
C
C  DEAL WITH ANY PART LEFT FROM LAST ENTRY:
      BLEN = ALEN-REM
      IF (BLEN .LE.0.) GO TO 1
C  IN CASE THAT VECTOR IS LESS THAN REMAINING DASH LENGTH
C
C  REMAINDER OF PREVIOUS DASH:
      FRAC = REM/ALEN
      X = X1 + FRAC*U
      Y = Y1 + FRAC*V
      GO TO (4,5),ILINE
    4 CALL KANGA1(X,Y,IPEN)
      IPEN=5-IPEN
      GO TO 6
   5  CONTINUE
      CALL KANGA3(X,Y,DASH/5,LINE-10)
C
C  CALCULATE NUMBER OF DASHES:
    6 NUM = IFIX(BLEN/DASH)
      REM = FLOAT(NUM+1)*DASH-BLEN
      IF (NUM .EQ.0) GO TO 2
      FRAC = DASH/ALEN
C
C  DO DASHES:
      DO 3 I=1,NUM
      X = X+FRAC*U
      Y = Y+FRAC*V
      GO TO (7,8),ILINE
    7 CALL KANGA1(X,Y,IPEN)
C  CHANGE MODE:
      IPEN = 5-IPEN
      GO TO 3
   8  CONTINUE
      CALL KANGA3(X,Y,DASH/5,LINE-10)
    3 CONTINUE
      GO TO 2
C
    1 REM = -BLEN
C  FINISH OFF
    2 IF (ILINE.EQ.2) GO TO 101
      CALL KANGA1(XXIN,YYIN,IPEN)
 101  X1=XXIN
      Y1=YYIN
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE ERRMAP
      SUBROUTINE ERRMAP
C
C *** ERRMAP updated by JCM 14 Apr 89 ***
C
CX
CC 5B
CH Calculates the standard deviation of the density in a Fourier map.
CP The results are meaningless if DELTA, the resolution length, is zero.
CP Should be set up in the same way as FOUR1Z
C
CD Uses the same kind of data as FOUR1Z, the normal Fourier routine, but the
CD calculation is much slower.  One should therefore use a coarser sampling
CD grid. Experience shows that the results vary very little throughout the
CD unit cell.
CD
CD Assumes errors in non-equivalent reflections are independent and those in
CD related reflections the same.
CI Reads data from unit LUNI in FORMAT given by MODED in /MAPDA/
CN Old.
C
      DIMENSION FIN(4)
C%
C      DIMENSION H(3,%SY*2%),EH(3),HI(3),K(3),SINCOX(100),SINCOY(100)
      DIMENSION H(3,48),EH(3),HI(3),K(3),SINCOX(100),SINCOY(100)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /SCRAT/SUM(10201)
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
      NOBSIN=-1
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
C     GET OUT THE SINES AND COSINES REQUIRED IN THE RECURSIONS.
      CALL TRIG(SINCOX,TWOPI*OUTLIM(3,1),(NH-1)/2+1)
      CALL TRIG(SINCOY,TWOPI*OUTLIM(3,2),NK)
C     CLEAR STORE FOR SUMS
      DO 1 I=1,NXY
      SUM(I) = 0.
    1 DENS(I) = 0.
C
C     READ REFLECTIONS FROM STREAM LUNI
C     MODED=1 H,K,L, FCAL,FOBS,DELF
C     MODED=2 H,K,L, ARG(FCAL),PHASE ANGLE,FOBS,DELF
C     MODED=3 H,K,L, A,B,FOBS,DELF
C     MODED=4 H,K,L, FOBS,DELF
   2  NOBSIN=NOBSIN+1
      CALL RDDATA(LUNI,K,HI,FIN,4,IOU)
      IF (IOU .EQ. -9999) GO TO 7
C     SWITCH ACCORDING TO FORMAT OF REFLECTION CARDS (MODED)
      GO TO (3,4,4,5), MODED
   3  F=FIN(2)
      SF=FIN(3)
      GO TO 6
C
   4  F=FIN(3)
      SF=FIN(4)
      GO TO 6
C
   5  F=FIN(1)
      SF=FIN(2)
C     ABSOLUTE PHASE DOESN'T MATTER AS TERMS ARE TO BE SQUARED
C     TEST FOR 0 0 0 REFLECTION
    6 IF ((K(1).EQ.0) .AND. (K(2).EQ.0) .AND. (K(3) .EQ.0)) GO TO 8
      IF (VCTMOD(0.5,HI,2) .GT. SMAX) GO TO 2
C     MULTIPLY BY 2 BECAUSE WE ASSUME -H,-K,-L, IS NOT GIVEN AND WILL
C     NOT BE GENERATED IF NCENT=2
      NUSED=NUSED+1
      SF = 2.*SF*RESOL(HI,DELTA)*SCALEF
      DO 26 N = 1,NOPC
      CALL ROTSYM(HI,EH,N,2)
      IF (N .NE. 1) GO TO 44
      DO 45 I = 1,3
   45 H(I,1) = EH(I)
      MI = 1
      GO TO 46
  44  CALL EQVEC(H,EH,MI,M,NOP)
      IF (M .LE. MI) GO TO 26
      MI = M
   46 IF (NDIM .NE. 2) GO TO 27
C     SYMMETRY MATRICES ALREADY ROTATED TO AXES OF MAP
      IF (EH(3) .NE. 0) GO TO 26
   27 TRA = 0.
      DO 23 I = 1,3
      K(I) = NINT(EH(I))
   23 TRA = TRA + EH(I)*(TRANS(I,N) - OUTLIM(1,I))
C     PHASE AT ORIGIN OF MAP
      TRA = TWOPI*TRA
C
C     NOW CALCULATE THE CONTRIBUTION FROM THIS REFLECTION AT ALL POINTS
      J = 2*IABS(K(1))+1
      SDX = SINCOX(J+1)
      CDX = SINCOX(J)
      IF (K(1) .GT. 0) SDX = -SDX
      J = 2*IABS(K(2))+1
      SDY = SINCOY(J+1)
      CDY = SINCOY(J)
      IF (K(2) .GT. 0) SDY = -SDY
      COX = COS(TRA)*SF
      SOX = SIN(TRA)*SF
      DO 30 IX = 1,NX
      I = IX
      SUM(I) = SUM(I) + COX
      COY = COX*CDY - SOX*SDY
      SOY = SOX*CDY + COX*SDY
      DO 31 IY = 2,NY
      I = I+NX
      SUM(I) = SUM(I) + COY
      SNEW = SOY*CDY + COY*SDY
      COY = COY*CDY - SOY*SDY
   31 SOY = SNEW
      SNEW = SOX*CDX + COX*SDX
      COX = COX*CDX - SOX*SDX
   30 SOX = SNEW
C
C     ACCUMULATE SUM OVER ALL EQUIVALENTS
   26 CONTINUE
C     NOW SQUARE SUM, ADD TO RESULT AND CLEAR FOR NEXT
      DO 32 I = 1,NXY
      DENS(I) = DENS(I) + SUM(I)**2
   32 SUM(I) = 0.
      GO TO 2
C     ADD CONTRIBUTION FROM 0,0,0 REFLECTION
    8 SF = (SF*SCALEF)**2
      DO 9 I = 1,NXY
    9 DENS(I) = DENS(I) + SF
      GO TO 2
C     HAVE RUN OUT OF REFLECTIONS ON STREAM LUNI
C     TAKE SQRT TO GET STANDARD DEVIATION
    7 DO 50 I = 1,NXY
   50 DENS(I) = SQRT(DENS(I))
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE FORIER(IIN,IOP,START)
      SUBROUTINE FORIER(IIN,IOP,START)
C
C *** FORIER updated by PJB 29 Apr 88 ***
C
CX
CC 5B
CH Controls Fourier calculations.
C
CA On entry START, a logical, indicates whether this is the first call of FORIER
CA On exit  IIN indicates how the next map is to be obtained:
CA          IIN = 1 means get back previously saved map
CA                2 means read back pre-calculated map in binary form
CA                3 means calculate map using FOUR1Z
CA                4 means calculate map using FOURGP (general plane)
CA                5 means calculate map using ERRMAP (error map)
CA          IOP indicates how the next map is to be sent out:
CA          IOP contains 1 bit = print
CA                       2 bit = plot
CA                       4 bit = save
C
CP Must be set up by a call of SETFOU, reading the relevant M cards
C
CD If 2D (NDIM=2), only one possible map, a projection, is involved.  If 3D
CD (NDIM=3), several layers may be involved.  Their values of Z are stored
CD in arrays:
CD    ZRDVAL for reading down pre-calculated maps
CD    ZGTVAL for getting back previously saved maps
CD    ZSVVAL for saving maps just calculated
CD    ZPRVAL for printing
CD    ZPLVAL for plotting
CD NDIM=4 is a request for a bounded section
C
      LOGICAL START
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
      COMMON /MAPPR/ZPRVAL(20),ZCPR,IPR,IZPR
      COMMON /MAPRD/ZRDVAL(20),ZCRD,IRD,IZRD,IDUMPR
      COMMON /MAPSV/ZSVVAL(20),ZCSV,ISV,IZSV,NDUMPS,NSAV
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C
C DOES NOT OPEN FILE FROM WHICH TO READ REFLECTIONS - ASSUMES USER WANTS
C TO DO IT HIMSELF IN MAIN
C SET ZERO FOR A START
      IOP=0
      IIN=0
C  THEN SWITCH IF NOT STARTING
      IF (START) THEN
      START=.FALSE.
C
C SET FLAG TO SAY NO MAPS SAVED YET (TO BE CONSULTED IN SAVMAP):
      NSAV=0
C
C IF SAVING , OPEN FILE (IF GETTING, FILE IS OPENED IN MAJUST):
      MESSAG='Saved maps'
      NAMFIL='.SAV'
      IF (IZSV .GT. 0) CALL OPNFIL(NDUMPS,1112)
C
C IF READING BINARY PRE-CALCULATED MAP, OPEN FILE:
      MESSAG='Pre-calculated maps'
      IF (IZRD .GT. 0) CALL OPNFIL(IDUMPR,1011)
C
      IF (NDIM .EQ. 2) GO TO 1
C
C 3D - FIND ALL VALUES OF Z IN ALL 5 LISTS:
      IPR=1
      IF (IZPR .EQ. 0) THEN
      ZCPR=99999.
      ELSE
      ZCPR=ZPRVAL(1)
      ENDIF
      IPL=1
      IF (IZPL .EQ. 0) THEN
      ZCPL=99999.
      ELSE
      ZCPL=ZPLVAL(1)
      ENDIF
      ISV=1
      IF (IZSV .EQ. 0) THEN
      ZCSV=99999.
      ELSE
      ZCSV=ZSVVAL(1)
      ENDIF
      IGT=1
      IF (IZGT .EQ. 0) THEN
      ZCGT=99999.
      ELSE
      ZCGT=ZGTVAL(1)
      ENDIF
      IRD=1
      IF (IZRD .EQ. 0) THEN
      ZCRD=99999.
      ELSE
      ZCRD=ZRDVAL(1)
      ENDIF
C
      ENDIF
C  START HERE AFTER FIRST ENTRY
C
      IF (NDIM.EQ.2) GO TO 1
C
C NEXT VALUE OF Z:
      Z=AMIN1(ZCPL,ZCSV,ZCPR,ZCGT,ZCRD)
      IF (Z.GT.99998.) GO TO 100
      OUTLIM(1,3)=Z
C
C DO WE NEED TO GET SAVED FILE FOR THIS VALUE OF Z?
      IF (ABS(ZCGT-Z) .GT. 10.E-5) GO TO 37
      IIN=1
      IGT=IGT+1
      ZCGT=ZGTVAL(IGT)
      IF (IGT.GT.IZGT) ZCGT=99999.
      GO TO 10
C
C DO WE NEED TO READ BINARY FILE FOR THIS VALUE OF Z?
  37  IF (ABS(ZCRD-Z) .GT. 10.E-5) GO TO 97
      IIN=2
      IRD=IRD+1
      ZCRD=ZRDVAL(IRD)
      IF (IRD.GT.IZRD) ZCRD=99999.
      GO TO 10
C
C WE WANT TO CALCULATE A NEW MAP:
  97  IF (MODET .EQ. 2) THEN
      IIN=4
      ELSE
      IF (MODEF .LT. 7) IIN=3
      IF (MODEF .EQ. 7) IIN=5
      ENDIF
C
C DO WE WANT TO PRINT AT THIS VALUE OF Z?
  10  IF (ABS(ZCPR-Z) .GT. 10.E-5) GO TO 17
      IOP=IOP+1
      IPR=IPR+1
      ZCPR=ZPRVAL(IPR)
      IF (IPR.GT.IZPR) ZCPR=99999.
C
C DO WE WANT TO PLOT AT THIS VALUE OF Z?
  17  IF (ABS(ZCPL-Z) .GT. 10.E-5) GO TO 7
      IOP=IOP+2
      IPL=IPL+1
      ZCPL=ZPLVAL(IPL)
      IF (IPL.GT.IZPL) ZCPL=99999.
C
C DO WE WANT TO SAVE THIS VALUE OF Z?
   7  IF (ABS(ZCSV-Z) .GT. 10.E-5) GO TO 8
      IOP=IOP+4
      ISV=ISV+1
      ZCSV=ZSVVAL(ISV)
      IF (ISV.GT.IZSV) ZCSV=99999.
   8  IF (NDIM.NE.4 .OR.IOP.EQ.0) GO TO 100
C
C  SPECIAL FOR BOUNDED SECTIONS
      SECEND=Z
      IF (ZCPL.LT.99999.) SECEND=ZCPL
      IF (ZCPR.LT.99999.) SECEND=AMAX1(SECEND,ZCPR)
      IF (ZCSV.LT. 99999.) SECEND=AMAX1(SECEND,ZCSV)
      IF (ZCPR .LT.99999.) THEN
        IF (ABS(SECEND-ZCPR).GT.10.E-4) THEN
          IPR=IPR-1
          ZCPR=ZPRVAL(IPR)
        ELSE
          IPR=IPR+1
          ZCPR=ZPRVAL(IPR)
          IF (IPR.GT.IZPR) ZCPR=99999.
        ENDIF
      ENDIF
      IF (ZCPL.LT. 99999.) THEN
        IF (ABS(SECEND-ZCPL).GT.10.E-4) THEN
          IPL=IPL-1
          ZCPL=ZPLVAL(IPL)
        ELSE
          IPL=IPL+1
          ZCPL=ZPLVAL(IPL)
          IF (IPL.GT.IZPL) ZCPL=99999.
        ENDIF
      ENDIF
      IF (ZCSV.LT.99999.) THEN
        IF (ABS(SECEND-ZCSV).GT.10.E-4) THEN
          ISV=ISV-1
          ZCSV=ZSVVAL(ISV)
        ELSE
          ISV=ISV+1
          ZCSV=ZSVVAL(ISV)
          IF (ISV.GT.IZSV) ZCSV=99999.
        ENDIF
      ENDIF
      GO TO 100
C
C 2D IS EASIER BECAUSE THERE IS NO Z COUNT:
    1 IF (IZGT .EQ. 0) GO TO 2
      IIN=1
      GO TO 3
   2  IF (IZRD .EQ. 0) GO TO 90
      IIN=2
      GO TO 3
  90  OUTLIM(1,3)=0.
      IIN=3
      IF (MODEF .EQ. 7) IIN=5
   3  IF (IZPR .NE. 0) IOP=IOP+1
      IF (IZPL .NE. 0) IOP=IOP+2
      IF (IZSV .NE. 0) IOP=IOP+4
      GO TO 100
C
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      SUBROUTINE FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
C
C *** FOUINP updated by JCM 14 Apr 89 ***
C
CX
CC 5C
CH Reads one data item for a given type of Fourier, in a given format.
CA On entry MODED indicates the data format type, from M DTYP card
CA     MODED=0: user-supplied routine QFOUIN should set K, F, ALPHA, ENDIP
CA     MODED=1: read H,K,L FCAL,FOBS,(D)
CA     MODED=2: read H,K,L, mod(FCAL), phase angle, FOBS
CA     MODED=3: read H,K,L, A, B, FOBS
CA     MODED=4: read H,K,L, FOBS (or FCAL)
CA On entry MODEF indicates the Fourier type required, from M FTYP card
CA     MODEF=1:   FCAL
CA     MODEF=2:   FOBS (Centrosymmetric)
CA     MODEF=3:   mod(FOBS)*phase(FCAL)
CA     MODEF=4:   FOBS-FCAL
CA     MODEF=5:   (mod(FOBS)-mod(FCAL))*phase(FCAL)
CA     MODEF=6:   FOBS*FOBS (Patterson)
CA On exit  K is a 1x3 integer vector holding h,k,l
CA          F is a 1x2 vector holding whichever of FOBS, etc were requested
CA          ALPHA, if relevant, holds the phase
CA          ENDIP is a logical set TRUE if the end of the input has occurred.
CO Checks that MODED and MODEF are compatible and complains and stops if not.
C
      LOGICAL ENDIP
      DIMENSION K(3),F(3),H(3)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C
      ENDIP=.FALSE.
      IF (MODED .GT. 0) GO TO 9
      CALL QFOUIN(K,F,ALPHA,ENDIP)
      GO TO 100
C
   9  CALL RDDATA(LUNI,K,H,F,3,IOU)
      IF (IOU .EQ. -9999) GO TO 101
      GO TO (11,12,13,14) , MODED
  11  ALPHA = PIBY2 - SIGN(PIBY2,F(1))
      GO TO 100
C
  12  ALPHA=F(2)
      F(2)=F(3)
      GO TO (100,99,100,99,100,100),MODEF
C
  13  FA=F(1)
      FB=F(2)
      F(2)=F(3)
      F(1) = SQRT(FA*FA+FB*FB)
      IF (F(1) .EQ. 0.) GO TO 9
      ALPHA = ATAN2(FB,FA)
      GO TO (100,99,100,99,100,100),MODEF
C
  14  F(2)=F(1)
      GO TO (99,100,99,99,99,100),MODEF
C
C ERROR:
  99  CALL ERRMES(1,0,'MODEF & MODED values incompatible')
C
C  MARK END OF DATA
  101 ENDIP=.TRUE.
  100 RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE FOUR1D
      SUBROUTINE FOUR1D
C
C *** FOUR1D by PJB Dec 85 ***
C
CX
CC 5B
CH Calculates a Fourier along a general line.
CP SETFOU should have been obeyed to read M, N and I  cards and set up
CP the calculation.
CD Uses FOUINP to allow all different data input and Fourier types.
CD Puts calculated 1-D Fourier in array DENS in /MAPDA
C
CN Expects that the h,k,l values cover a suitable asymmetric unit, from which it
CN uses the given symmetry to generate an entire reciprocal space full.  If the
CN data stray outside one asymmetric unit, some h,k,l values will occur more
CN than once.
C
      COMPLEX RHO(1500),CE(100,3),FAC(2),Y,YM
      LOGICAL USED,ENDIP
C%
C      DIMENSION H(3,%SY*2%),HI(3),K(3),F(2)
      DIMENSION H(3,48),HI(3),K(3),F(2)
      DIMENSION KLIM(3),SF(2),ALPH(2)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      EQUIVALENCE (DENS,RHO),(CE,DENS(3001)),(KLIM(1),NH)
C
C NOBSIN COUNTS DATA READ, NUSED COUNTS THOSE USED
      NOBSIN=-1
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
      NY=4*NX
C     CLEAR STORE FOR SUM OVER L
      DO 1 M = 1,NY
    1 DENS(M) = 0.
C
C  GET RQUIRED TRIG FUNCTIONS
      DO 2 I=1,3
      KK=KLIM(I)+1
      AMP=-TWOPI*OUTLIM(3,I)
      CALL TRIG(CE(1,I),AMP,KK)
    2 CONTINUE
C
C  NOW READ REFLECTIONS
    7 USED=.FALSE.
      CALL FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      IF (ENDIP) GO TO 20
C
      NOBSIN=NOBSIN+1
      CALL INDFLO(HI,K)
C DO NOT USE IF SIN THETA/LAMBDA TOO LARGE:
      VL =VCTMOD(0.5,HI,2)
      IF (VL .GT. SMAX) GO TO 7
C
C APPLY RESOLUTION FUNCTION AND USER'S SCALE:
      AMP = RESOL(HI,DELTA)*SCALEF
      DO 3 MODE=1,2
      CALL CHOOSF(F,SF(MODE),ALPHA,ALPH(MODE),MODE)
C SF AND ALPHA NOW SET UP:
C
C DOUBLE ALL BUT 000 REFLN. AS WE ARE ONLY USING HALF RECIPROCAL SPACE:
      IF  ((K(1).NE.0).OR.(K(2).NE.0).OR.(K(3).NE.0))
     & SF(MODE)=2.*SF(MODE)
C
      SF(MODE)=SF(MODE)*AMP
    3 CONTINUE
C
C DEAL WITH SYMMETRY EQUIVALENTS:
      MI=0
C TO MAKE EQVEC ACCEPT FIRST SET OF INDICES
      DO 8 N = 1,NOPC
      CALL SYMEQU(HI,H,K,N,MI,UU,BETA)
      IF (UU.EQ.0.) GO TO 8
      USED=.TRUE.
      FAC(1)=SF(1)*CEXP(CMPLX(0.,UU*ALPH(1)+BETA))
      FAC(2)=SF(2)*CEXP(CMPLX(0.,UU*ALPH(2)+BETA))
      DO 9 I=1,NX
      RHO(I)=RHO(I)+FAC(1)
      RHO(NX+I)=RHO(NX+I)+FAC(2)
      YM=CMPLX(1.,0.)
      DO 10 J=1,3
      Y=CE(IABS(K(J))+1,J)
      IF (K(J).LT.0) Y=CONJG(Y)
   10 YM=YM*Y
      FAC(1)=FAC(1)*YM
      FAC(2)=FAC(2)*YM
    9 CONTINUE
C
    8 CONTINUE
      IF (USED) NUSED=NUSED+1
      GO TO 7
C
C  HERE ON END OF DATA
   20 NY=2*NX
      II=2*NY
      DO 11 I=1,NY,2
      DENS(II+I)=DENS(NY+I)-DENS(I)
   11 CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE FOUR1Z
      SUBROUTINE FOUR1Z
C
C *** FOUR1Z corrected by PJB 17-Jun-1994 ***
C
CX
CC 5B
CH Calculates 1 layer of Fourier sum : a section if 3D, a projection if 2D,
CH or a bounded section if "4D".
C
CP Must be set up by call to SETFOU to read M, N, I cards
C
CD Uses FOUINP to allow all different data input and Fourier types.
CD Puts calculated  Fourier map in array DENS in /MAPDA
C
CN Expects that the h,k,l values cover a suitable asymmetric unit, from which it
CN uses the given symmetry to generate an entire reciprocal space full.  If the
CN data stray outside one asymmetric unit, some h,k,l values will occur more
CN than once.
CN
CN Ignores FRIEDL - if non-centrosymmetric, and Friedel's law not to be assumed,
CN the user must do something to combine F(H,K,L) and F(-H,-K,-L) outside
CN FOUR1Z.
C
      LOGICAL USED,ENDIP
C%
C      DIMENSION H(3,%SY*2%),HI(3),K(3),F(3),SINCO(200)
      DIMENSION H(3,48),HI(3),K(3),F(3),SINCO(200)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /SCRAT/SUM(10201)
C
C NOBSIN COUNTS DATA READ, NUSED COUNTS THOSE USED
      NOBSIN=0
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
C SET ORIGIN OF SECTION:
      DO 2 I=1,3
   2  SECZER(I)=OUTLIM(1,I)
C
C     CLEAR STORE FOR SUM OVER L
      DO 1 M = 1,NHK
    1 DENS(M) = 0.
C
C JJ=H MAX + 1
      JJ = ((NH-1)/2)+1
C  NOW READ REFLECTIONS
    7 USED=.FALSE.
      CALL FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      IF (ENDIP) GO TO 20
C
      NOBSIN=NOBSIN+1
      CALL INDFLO(HI,K)
C DO NOT USE IF SIN THETA/LAMBDA TOO LARGE:
      IF (VCTMOD(0.5,HI,2) .GT. SMAX) GO TO 7
C
C APPLY RESOLUTION FUNCTION AND USER'S SCALE:
      AMP = RESOL(HI,DELTA)*SCALEF
      CALL CHOOSF(F,SF,ALPHA,ALPH,MODEF)
C SF AND ALPHA NOW SET UP:
C
C DOUBLE ALL BUT 000 REFLN. AS WE ARE ONLY USING HALF RECIPROCAL SPACE:
      IF  ((K(1).NE.0).OR.(K(2).NE.0).OR.(K(3).NE.0))
     & SF=2.*SF
C
      SF=SF*AMP
    3 CONTINUE
C
C DEAL WITH SYMMETRY EQUIVALENTS:
C TO MAKE EQVEC ACCEPT FIRST SET OF INDICES
      MI=0
C TRANSFORM HI (GIVEN H) TO OCCUPY FIRST PLACE IN TABLE FOR EQVEC:
      CALL GMEQ(HI,H(1,1),1,3)
      CALL GMPRD(H(1,1),U,HI,1,3,3)
      DO 8 N = 1,NOPC
      CALL SYMEQU(HI,H,K,N,MI,UU,BETA)
      IF (UU.EQ.0.) GO TO 8
      USED=.TRUE.
C49 - SECTION updated by PJB
      ALPHA1=ALPH*SIGN(1.,UU)+BETA
      SFUU=SF*ABS(UU)
      KF=1
      KH = 2*(NK*(K(1)+JJ-1)+K(2)+KF)
      DENS(KH-1) = DENS(KH-1)+SFUU*COS(ALPHA1)
      DENS(KH) = DENS(KH) + SFUU*SIN(ALPHA1)
C49 - END OF UPDATED SECTION
C
    8 CONTINUE
      IF (USED) NUSED=NUSED+1
      GO TO 7
C
C     SUM OVER L COMPLETED - ALL REFLECTIONS HAVE BEEN READ
C CLEAR STORE FOR SUM OVER H:
  20  DO 30 N = 1,NKX
   30 SUM(N) = 0.
C
C SET UP COS AND SIN TABLES:
      CALL TRIG (SINCO,TWOPI*OUTLIM(3,1),JJ)
      KH = 1
      DO 34 IH=1,NH
      KXI = 1
      J = 2*IABS(IH-JJ)+1
      SD = -SINCO(J+1)
      CD = SINCO(J)
      IF (IH .LT. JJ) SD = -SD
      DO 34 IK=1,NK
      KX = KXI
      IF ((DENS(KH) .EQ. 0.) .AND. (DENS(KH+1) .EQ.0.)) GO TO 39
      C = DENS(KH)
      S = DENS(KH+1)
      DO 38 N=1,NX
      SUM(KX) = SUM(KX) + C
      SUM(KX+1) = SUM(KX+1) + S
      CNEW = C*CD - S*SD
      S = C*SD + S*CD
      C = CNEW
   38 KX = KX+2
   39 KH = KH+2
   34 KXI = KXI + 2*NX
C
C     SUM OVER H COMPLETE
C FINAL SUM OVER K:
      KF=NK
      CALL TRIG(SINCO,TWOPI*OUTLIM(3,2),KF)
C CLEAR DENS FOR ANSWERS:
      DO 40 N = 1,NXY
   40 DENS(N) = 0.
      KX = 1
      DO 41 IK=1,NK
      KK = 2*IK
      CD = SINCO(KK-1)
      SD = -SINCO(KK)
      DO 42 N = 1,NX
      M = N
      IF ((SUM(KX) .EQ. 0.) .AND. (SUM(KX+1) .EQ. 0.)) GO TO 42
      C = SUM(KX)
      S = SUM(KX+1)
      DO 43 IY = 1,NY
      DENS(M) = DENS(M) + C
      CNEW = C*CD - S*SD
      S = C*SD + S*CD
      C = CNEW
   43 M = M+NX
   42 KX = KX+2
   41 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE FOURGP
      SUBROUTINE FOURGP
C
C *** FOURGP by PJB Dec 85 ***
C
CX
CC 5B
CH Calculates a Fourier on a general plane.
C
CP Must be set up by call to SETFOU to read M, N, I cards
C
CD Uses FOUINP to allow all different data input and Fourier types.
CD Puts calculated  Fourier map in array DENS in /MAPDA
C
CN Expects that the h,k,l values cover a suitable asymmetric unit, from which it
CN uses the given symmetry to generate an entire reciprocal space full.  If the
CN data stray outside one asymmetric unit, some h,k,l values will occur more
CN than once.
CN
CN Ignores FRIEDL - if non-centrosymmetric, and Friedel's law not to be assumed,
CN the user must do something to combine F(H,K,L) and F(-H,-K,-L) outside
CN FOURGP
C
      COMPLEX RHO,CE,Y,YM(2),VAL
      LOGICAL USED,ENDIP
C%
C      DIMENSION H(3,%SY*2%),HI(3),K(3),F(2)
      DIMENSION H(3,48),HI(3),K(3),F(2)
      DIMENSION KLIM(3)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /SCRAT/RHO(100),CE(100,6)
      EQUIVALENCE (KLIM(1),NH)
C
C NOBSIN COUNTS DATA READ, NUSED COUNTS THOSE USED
      NOBSIN=0
      NUSED=0
      SCALEF=SCALF1*SCALF2
C
C     CLEAR STORE FOR SUM
      DO 1 M = 1,NXY
    1 DENS(M) = 0.
C
C
C  GET REQUIRED TRIG FUNCTIONS, AND TRANSFORMED STARTING POS
      L=1
      DO 2 J=1,3
      SECZER(J)=0.
      DO 2 I=1,3
      IF (J.EQ.3) GO TO 4
      KK=KLIM(I)+1
      AMP=-TWOPI*OUTLIM(3,J)*U(I,J)
      CALL TRIG(CE(1,L),AMP,KK)
      L=L+1
    4 SECZER(J)=SECZER(J)+OUTLIM(1,I)*U(J,I)
    2 CONTINUE
C
C  NOW READ REFLECTIONS
    7 USED=.FALSE.
      CALL FOUINP(K,F,ALPHA,MODED,MODEF,ENDIP)
      IF (ENDIP) GO TO 100
C
      NOBSIN=NOBSIN+1
      CALL INDFLO(HI,K)
C DO NOT USE IF SIN THETA/LAMBDA TOO LARGE:
      IF (VCTMOD(0.5,HI,2) .GT. SMAX) GO TO 7
C
C APPLY RESOLUTION FUNCTION AND USER'S SCALE:
      AMP = RESOL(HI,DELTA)*SCALEF
      CALL CHOOSF(F,SF,ALPHA,ALPH,MODEF)
C SF AND ALPHA NOW SET UP:
C
C DOUBLE ALL BUT 000 REFLN. AS WE ARE ONLY USING HALF RECIPROCAL SPACE:
      IF  ((K(1).NE.0).OR.(K(2).NE.0).OR.(K(3).NE.0))
     & SF=2.*SF
C
      SF=SF*AMP
    3 CONTINUE
C
C DEAL WITH SYMMETRY EQUIVALENTS:
      MI=0
C TO MAKE EQVEC ACCEPT FIRST SET OF INDICES
      DO 8 N = 1,NOPC
      CALL SYMEQU(HI,H,K,N,MI,UU,BETA)
      IF (UU.EQ.0.) GO TO 8
      USED=.TRUE.
      VAL=SF*CEXP(CMPLX(0.,UU*ALPH+BETA))
      L=1
      DO 9 I=1,2
      YM(I)=CMPLX(1.,0.)
      DO 9 J=1,3
      Y=CE(IABS(K(J))+1,L)
      L=L+1
      IF (K(J).LT.0) Y=CONJG(Y)
   9  YM(I)=YM(I)*Y
C
      L=1
      RHO(1)=VAL
      DO 10 J=1,NY
      VAL=RHO(J)
      RHO(J+1)=RHO(J)*YM(2)
      DO 10 I=1,NX
      DENS(L)=DENS(L)+REAL(VAL)
      L=L+1
      VAL=VAL*YM(1)
   10 CONTINUE
C
    8 CONTINUE
      IF (USED) NUSED=NUSED+1
      GO TO 7
C
C  HERE ON END OF DATA
  100 RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE FRAME(X1,Y1,X2,Y2)
      SUBROUTINE FRAME(X1,Y1,X2,Y2)
C
C *** FRAME by JCM 24 Nov 83 ***
C
CX
CC 14C
CH Draws a rectangle in the plotting context.
CA On entry (X1,Y1) and (X2,Y2) are the coordinates of opposite corners of
CA the required rectangle.  These are in "current coordinates"
CP The plotting must have been set up by, e.g. STPLOT, and a suitable space
CP selected by SPCSET.
C
      CALL KANGA1(X1,Y1,3)
      CALL KANGA1(X1,Y2,2)
      CALL KANGA1(X2,Y2,2)
      CALL KANGA1(X2,Y1,2)
      CALL KANGA1(X1,Y1,2)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE GETMAP
      SUBROUTINE GETMAP
C
C *** GETMAP updated C19 by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Retrieves 1 Fourier map previously filed using SAVMAP.
CP Assumes unit IDUMPG is positioned so that reading from it will
CP produce the "next" map dumped there.
CP
CP The required Z value must be set in OUTLIM(1,3)
C
CD Continues reading down maps until it finds one for the given Z.
CD
CD If no map is dumped for this value of Z, will eventually read the
CD trailer record of file IDUMPG and complain.
C
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
C>> JCC Use error flag instead of STOP

	INTEGER IBMBER
	COMMON / CCSLER / IBMBER 
C
   1  READ(IDUMPG) ZI,NOBSIN,NUSED,NXX,NYY
      IF (NXX .EQ. NX .AND. NYY .EQ. NY) GO TO 3
      WRITE (LPT,3001) NXX,NYY,NX,NY
      WRITE (ITO,3001) NXX,NYY,NX,NY
3001  FORMAT (/' ERROR ** MAP TO BE READ OF SIZE',I3,' BY',I3,
     & ' BUT CURRENT SET SIZE IS',I3,' BY',I3)
      IBMBER = 1
	RETURN
C
C CHECK NOT READING TRAILER:
   3  IF (ZI .GE. 99998.) CALL ERRRE2(OUTLIM(1,3),0,
     & 'no dumped map for z=',' ')
C
C READ RECTANGULAR ARRAY OF PREVIOUSLY CALCULATED MAP:
      I=0
      DO 4 IY=1,NY
      READ (IDUMPG) (DENS(I+J),J=1,NX)
   4  I=I+NX
C
C IF WRONG VALUE OF Z, BACK FOR NEXT:
      IF (ABS(OUTLIM(1,3)-ZI) .GT. 10.E-5) GO TO 1
      WRITE (LPT,2000) OUTLIM(1,3),NX,NY
2000  FORMAT(/' For Z=',F10.4,' map of size',I4,' by',I4,
     & ' read')
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE GETSCL(VMIN,VMAX,L)
      SUBROUTINE GETSCL(VMIN,VMAX,L)
C
C *** GETSCL updated by PJB Sep 87 ***
C
CX
CC 14A
CH Chooses a sensible scale for a graph.
CA On entry VMIN is minimum value to be plotted
CA          VMAX is maximum value to be plotted
CA          L=1 for x axis
CA            2 for y axis
CP X(L,2) must be set up as below:
CD The vector X(I,J) in /PLTS defines how the graph will be drawn.
CD           I=1  for X-axis, I=2 for Y-axis.
CD           J=1  length of axis in user units
CD           J=2  length of axis in cms.
CD           J=3  division of axis in user units
CD           J=4  minimum value in user units
CD           J=5  position of plotted axis in user units
CD Sets X(L,J) for J=1,3,4,5.
CO If VMAX and VMIN are not sensible, complains and bombs an error flag.
C
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /PLTS/X(2,5),S(2),CH,XS,ISIG(2),YS,NDIVS(2,2)

C>> JCC Use bomb out flag instead of stop
C
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
      AMAX=VMAX
      AMIN=VMIN
      XX=AMAX-AMIN
      I=0
C
    1 IF (XX.GT.10.) GO TO 2
    4 IF (XX.GT.1.) GO TO 3
      I=I-1
      IF (I.LT.-8) THEN
        WRITE (ITO,3000) AMAX,AMIN
3000  FORMAT (' Range from ',E12.4,' to ',E12.4,' too small for GETSCL')
C>> Was STOP
       CALL BMBOUT
	 RETURN
      ENDIF
      XX=XX*10.
      GO TO 4
C
    2 I=I+1
      IF (I.GT.8) THEN
        WRITE(ITO,3001) AMAX,AMIN
3001  FORMAT (' Range from ',E12.4,' to ',E12.4,' too big for GETSCL')
C>>        STOP
        CALL BMBOUT
	  RETURN
      ENDIF
      XX=XX/10.
      GO TO 1
C
    3 AMUL=10.**I
      STEP=2.
      IF (XX.LE.5.) STEP=1.
      IF (XX.LE.2.5) STEP=.5
      IF (XX.LE.1.4) STEP=.2
      BIGSTP=AMUL*STEP
      STEPX=BIGSTP/5.
      BIT=STEPX*0.49
C  SET POSITION OF AXIS TO BE PLOTTED
C BIGSTP USED INSTEAD OF ZERO FOR COSMETIC REASONS:
      IF (AMIN.LE.BIGSTP  .AND. AMAX.GE.-BIGSTP) THEN
        X(L,5)=0.
        IF (AMIN .GT. 0.) AMIN=0.
        IF (AMAX .LT. 0.) AMAX=0.
      ELSE
C  ORIGIN OUTSIDE GRAPH
        IF (AMIN .LE. 0.) THEN
          X(L,5)=FLOAT(IFIX(AMIN/BIGSTP))*BIGSTP
        ELSE
          X(L,5)=FLOAT(IFIX((AMIN-BIT)/BIGSTP)+1)*BIGSTP
        ENDIF
      ENDIF
      NDIVS(L,1)=NINT((ABS(AMIN-X(L,5))+BIT)/STEPX)
      NDIVS(L,2)=NINT((ABS(AMAX-X(L,5))+BIT)/STEPX)
      X(L,1)=FLOAT(NDIVS(L,1)+NDIVS(L,2))*STEPX
      X(L,3)=BIGSTP
      X(L,4)=X(L,5)-FLOAT(NDIVS(L,1))*STEPX
      ISIG(L)=I
      IF (STEP.LT.1) ISIG(L)=I-1
      RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE INPUTM
      SUBROUTINE INPUTM
C
C *** INPUTM updated by PJB 29 Apr 88 ***
C
CX
CC 5A
CH Reads and interprets all "M" cards.
CD Takes the information from "M" cards into the map or contouring COMMON,
CD usually as a prelude to a Fourier calculation
CD "M" cards have a significant word in columns 3,4,5,6.  Possible words are:
CD    M NDIM     Number of dimensions for Fourier, 2 (projection), 3 (3D)
CD               or 4 (bounded section).
CD    M FTYP     Fourier type (see below).
CD    M MESH     Output mesh - 6 numbers, being:
CD               X(START) X(END) X(STEP), and the same in Y
CD    M AXES     Matrix of 9 integers turning the Fourier to a different
CD               orientation, or 9 reals asking for a plane section.
CD    M PRIN     By itself means "print calculated map".  Followed by a
CD               list of Z values, means "print only at these selected
CD               Z values".  If absent, the default is not to print anything,
CD               so if there are no "M PRIN", "M PLOT" or "M SAVE" cards the
CD               run will not tell the user much.
CD    M PLOT     Present if plotting required - also gives values of Z at which
CD               plotting is required if NDIM=3, on several cards if necessary.
CD    M CM/A     If plotting, number of centimetres of plotter paper per
CD               Angstrom.
CD    M CONT     If plotting, list of required contour values (may be several
CD               cards, all starting M CONT)
CD    M SAVE     Save the calculated map(s) on a named file in such a way that
CD               a subsequent run with an "M GET" card will retrieve it/them
CD               with a view to drawing another contour map.  Details in the
CD               specification of SUBROUTINE FORIER.
CD    M GET      Do not calculate a map at all - read an already calculated map
CD               from unit IDUMPG, and interpret only those cards which make
CD               sense - e.g. the user may alter contours, scale of map in
CD               cms/Angstrom, etc, but he may not alter cell dimensions, space
CD               group, theta maximum etc.
CD    M DTYP     data input type
CD    M DELT     delta for resolution function
CD    M SCAL     scale to multiply Fourier coefficients
CD    M SMAX     sin theta/lambda maximun for this particular run
CD    M READ     do not calculate map - take the crystal data cards on trust,
CD               and read from a binary file some pre-calculated map.
C
CI Reads all "M" cards
CO Writes its findings on unit LPT.
C
      CHARACTER *4 MWD,MTABLE(15)
      DIMENSION IU(3,3)
C
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
      COMMON /MAPPR/ZPRVAL(20),ZCPR,IPR,IZPR
      COMMON /MAPRD/ZRDVAL(20),ZCRD,IRD,IZRD,IDUMPR
      COMMON /MAPSV/ZSVVAL(20),ZCSV,ISV,IZSV,NDUMPS,NSAV
      COMMON /MREAD/IMREAD(15)
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      DATA MTABLE/'NDIM','FTYP','MESH','AXES','PRIN','PLOT',
     & 'CM/A','CONT','SAVE','READ','DTYP','DELT','SCAL','GET',
     & 'SMAX'/
C
C SET "NO M CARDS READ":
C%
C      CALL JGMZER(IMREAD,1,%MCRD%)
      CALL JGMZER(IMREAD,1,15)
C
C INITIALISE COUNTS OF ITEMS WHICH MAY COME ON MORE THAN 1 CARD:
      IZPR=0
      IZPL=0
      IZSV=0
      IZGT=0
      IZRD=0
      NCONT=0
C
C READ ALL "M" CARDS:
      INREAD(13)=-IABS(INREAD(13))
      ID=IABS(INREAD(13))
      NCARD=ICDNO(13)
      IF (NCARD .LE. 0) THEN
        CALL MESS(LPT,1,'No "M" cards given')
        GO TO 100
      ENDIF
C
      DO 3 ICD=1,NCARD
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(MWD,LEN,3,IPT,80,0,IER)
C%
C  62  L=NCFIND(MWD,MTABLE,%MCRD%)
  62  L=NCFIND(MWD,MTABLE,15)
      IF (L .LE. 0) THEN
        CALL ERRCH2(MWD,2,'cannot recognise word','on "M" card')
        GO TO 3
      ENDIF
C
C SET "HAVE READ PARTICULAR WORD" (COUNTING NUMBER OF CARDS), THEN BRANCH:
   4  IMREAD(L)=IMREAD(L)+1
      GO TO (31,32,33,34,35,36,37,38,39,40,41,42,43,44,45) , L
C
C M NDIM:
C READ 1 INTEGER BEING NUMBER OF DIMENSIONS FOR FOURIER, 2 OR 3:
C NDIM=4 MEANS CALCULATE BOUNDED SECTIONS
  31  CALL RDINTG(NDIM,IPT,IPT,80,IER)
      IF (NDIM .EQ. 2) THEN
        CALL MESS(LPT,1,'Fourier projection required')
      ELSE IF (NDIM .EQ. 3) THEN
        CALL MESS(LPT,1,'3D Fourier required')
      ELSE IF (NDIM .EQ. 4) THEN
        CALL MESS(LPT,1,'Bounded sections of Fourier required')
      ELSE
        CALL ERRIN2(NDIM,2,'Number of dimensions on M NDIM card =',
     &  ' - only 2, 3 or 4 allowed')
      ENDIF
      GO TO 63
C
C M FTYP:
C READ 1 INTEGER GIVING TYPE OF FOURIER CALCULATION REQUIRED:
  32  CALL RDINTG(MODEF,IPT,IPT,80,IER)
      IF (MODEF .GE.1 .OR. MODEF .LT.8) GO TO 7
      CALL ERRIN2(MODEF,2,'Fourier type on M FTYP card =',
     & ' - only 1-7 allowed')
      GO TO 63
   7  WRITE (LPT,2003) MODEF
2003  FORMAT (/' Fourier type ',I3,' -')
      GO TO (21,22,23,24,25,26,27) , MODEF
C
  21  CALL MESS(LPT,0,'coeffs are F(cal)')
      GO TO 63
C
  22  CALL MESS(LPT,0,'coeffs are F(obs)')
      GO TO 63
C
  23  CALL MESS(LPT,0,'coeffs are mod(F(obs)*phase F(cal)')
      GO TO 63
C
  24  CALL MESS(LPT,0,'coeffs are F(obs)-F(cal)')
      GO TO 63
C
  25  CALL MESS(LPT,0,'coeffs are (mod(F(obs)-mod(F(cal))'//
     & ' * phase(F(cal))')
      GO TO 63
C
  26  CALL MESS(LPT,0,'coeffs are F(obs) sqrd '//
     & '(for Patterson function)')
      GO TO 63
C
  27  CALL MESS(LPT,0,'standard deviation of electron density')
      GO TO 63
C
C M MESH:
C READ 6 NUMBERS GIVING OUTPUT MESH IN X AND Y:
  33  DO 8 I=1,2
      DO 8 J=1,3
      CALL RDREAL(OUTLIM(J,I),IPT,IPT,80,IER)
      IF (IER .NE. 0 .AND. IER .NE. 100) IERR=IERR+1
   8  CONTINUE
   9  WRITE (LPT,2004) ((OUTLIM(I,J),I=1,3),J=1,2)
2004  FORMAT (/' Mesh for output of map is:  Initial     Final   Step'/
     & 2(26X,3F10.5/))
      GO TO 3
C
C M AXES:
C READ 9 INTEGERS  (OR 9 REALS) GIVING MATRIX TO TURN FOURIER MAP:
  34  IPKEEP=IPT
      DO 10 I=1,3
      DO 10 J=1,3
      CALL RDINTG(IU(J,I),IPT,IPT,80,IER)
C DETECT DECIMAL POINT:
      IF (IER .EQ. -1) GO TO 60
      IF (IER .NE. 0 .AND. IER .NE. 100) IERR=IERR+1
      U(J,I)=FLOAT(IU(J,I))
  10  CONTINUE
C
      WRITE (LPT,2005) IU
2005  FORMAT (/' Orientation matrix:'/3(4X,3I5/))
      MODET=1
      GO TO 3
C
C  HERE FOR GENERAL ORIENTATION
   60 IPT=IPKEEP
      DO 61 I=1,3
      DO 61 J=1,3
      CALL RDREAL(U(J,I),IPT,IPT,80,IER)
      IF (IER.NE.0 .AND. IER .NE.100) IERR=IERR+1
   61 CONTINUE
      WRITE (LPT,2020) U
 2020 FORMAT (/' General Fourier section with x parallel to',3F8.4/
     & 31X,'y         to',3F8.4/31X,'z         to',3F8.4)
      MODET=2
      GO TO 3
C
C M PRIN:
C READ PRINTING INSTRUCTIONS - A NUMBER OF Z VALUES (OR NOTHING) - MAY BE MORE
C THAN 1 CARD:
  35  IZKEEP=IZPR+1
C%
C      CALL RDNUMS(ZPRVAL(IZKEEP),IPT,%PRIN%,NUM,IER)
      CALL RDNUMS(ZPRVAL(IZKEEP),IPT,20,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZPR=IZPR+NUM
      IF (NUM .NE. 0) GO TO 3
      CALL MESS(LPT,1,'Print map')
      IZPR=1
      GO TO 3
C
C M PLOT:
C  READ NUMBER OF VALUES OF Z AT WHICH TO PLOT - MAY BE MORE THAN
C  ONE CARD:
  36  IZKEEP=IZPL+1
C%
C      CALL RDNUMS(ZPLVAL(IZKEEP),IPT,%PLOT%,NUM,IER)
      CALL RDNUMS(ZPLVAL(IZKEEP),IPT,20,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZPL=IZPL+NUM
      IF (NUM .NE. 0) GO TO 3
      CALL MESS(LPT,1,'Plot map')
      IZPL=1
      GO TO 3
C
C M CM/A - READ 1 REAL BEING THE SCALE OF PLOTTED MAPS IN CMS/ANGSTROM.
  37  CALL RDREAL(SCALMP,IPT,IPT,80,IER)
      IF (IER .NE. 0) IERR=IERR+1
      WRITE (LPT,2010) SCALMP
2010  FORMAT (/' Plot in',F10.4,' cms/Angstrom')
      GO TO 63
C
C M CONT - READ SOME CONTOURS TO PLOT - MAY BE MORE THAN 1 CARD:
  38  IZKEEP=NCONT+1
C%
C      CALL RDNUMS(CONT(IZKEEP),IPT,%CONT%,NUM,IER)
      CALL RDNUMS(CONT(IZKEEP),IPT,50,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      NCONT=NCONT+NUM
      IF (NUM .EQ. 0) GO TO 16
      CALL MESS(LPT,1,'Contour values')
      CALL PRILIS(CONT,IZKEEP,NCONT)
      GO TO 3
  16  CALL MESS(LPT,1,'No contours on card')
      GO TO 3
C
C M SAVE - READ Z VALUES IF GIVEN, AND KEEP INSTRUCTION TO DUMP
  39  IZKEEP=IZSV+1
C%
C      CALL RDNUMS(ZSVVAL(IZKEEP),IPT,%SAVE%,NUM,IER)
      CALL RDNUMS(ZSVVAL(IZKEEP),IPT,20,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZSV=IZSV+NUM
      IF (NUM .NE. 0) GO TO 3
      CALL MESS(LPT,1,'Save calculated map')
      IZSV=1
      GO TO 3
C
C M GET:
C READ NUMBER OF Z VALUES FOR WHICH MAPS REQUIRED TO BE GOT FROM SAVED FILE:
  44  IZKEEP=IZGT+1
C%
C      CALL RDNUMS(ZGTVAL(IZKEEP),IPT,%GETM%,NUM,IER)
      CALL RDNUMS(ZGTVAL(IZKEEP),IPT,20,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZGT=IZGT+NUM
      IF (NUM .GT. 0) THEN
        CALL MESS(LPT,1,
     &  'Undump previously calculated map for z values ')
        CALL PRILIS(ZGTVAL,IZKEEP,IZGT)
        GO TO 3
      ENDIF
      CALL MESS(LPT,1,'Undump previously calculated map')
      IZGT=1
      GO TO 3
C
C M READ:
C READ NUMBER OF Z VALUES FOR WHICH MAPS REQUIRED TO BE READ FROM BINARY:
  40  IZKEEP=IZRD+1
C%
C      CALL RDNUMS(ZRDVAL(IZKEEP),IPT,%READ%,NUM,IER)
      CALL RDNUMS(ZRDVAL(IZKEEP),IPT,20,NUM,IER)
      IF (IER .NE. 0) IERR=IERR+1
      IZRD=IZRD+NUM
      IF (NUM .GT. 0) THEN
        CALL MESS(LPT,1,'Read previously calculated map for z values ')
        CALL PRILIS(ZRDVAL,IZKEEP,IZRD)
        GO TO 3
      ENDIF
      CALL MESS(LPT,1,'Read previously calculated map')
      IZRD=1
      GO TO 3
C
C M DTYP:
C READ 1 INTEGER INTO MODED
  41  CALL RDINTG(MODED,IPT,IPT,80,IER)
      IF (IER .NE. 0 .AND. IER .NE. 100) IERR=IERR+1
      WRITE (LPT,2030) MODED
2030  FORMAT (/' Data input format type',I3)
      IF ((MODED .LT. 0) .OR. (MODED .GE. 5)) THEN
        CALL ERRMES(1,1,'Type is unacceptable')
        GO TO 63
      ENDIF
C
C MODED CHECKED OK - PRINT:
      GO TO (50,51,52,53,54) , MODED+1
C MODE 0 MEANS USER WILL SUPPLY INPUT ROUTINE TO READ OWN FORMAT:
  50  CALL MESS(LPT,0,'User to supply SUBROUTINE QFOUIN(K,F,ALPHA)'//
     & ' to read own format of data')
      GO TO 63
C
C MODES 1-4 AS IN MK2:
  51  CALL MESS (LPT,0,'h,k,l, F(cal), F(obs), possible Diff')
      GO TO 13
C
  52  CALL MESS(LPT,0,'h,k,l, mod F(cal), phase, F(obs)')
      GO TO 13
C
  53  CALL MESS(LPT,0,'h,k,l, A(cal), B(cal), F(obs)')
      GO TO 13
C
  54  CALL MESS(LPT,0,'h,k,l, F')
      GO TO 13
C
  13  CALL MESS(LPT,0,'In format 3I5,several F')
      GO TO 63
C
C M DELT:
C READ 1 REAL TO DELTA
  42  CALL RDREAL(DELTA,IPT,IPT,80,IER)
      D2=DELTA*2.
      WRITE (LPT,2011) D2
2011  FORMAT (/' Data to be averaged over a cube of edge ',F10.4)
      GO TO 63
C
C M SCAL:
C READ 1 REAL AS SCALE FACTOR TO APPLY TO INCOMING FOURIER COEFFICIENTS:
  43  CALL RDREAL(SCALF1,IPT,IPT,80,IER)
      IF (IER .NE. 0) IERR=IERR+1
      WRITE (LPT,2019) SCALF1
2019  FORMAT (/' Multiply Fourier coefficients by ',F10.4)
      GO TO 63
C
C M SMAX:
C READ SIN THETA/ LAMBDA MAXIMUM
  45  CALL RDREAL(SMAX,IPT,IPT,80,IER)
      IF (IER .NE. 0) IERR=IERR+1
      WRITE (LPT,2018) SMAX
2018  FORMAT (/' Maximum sin theta/lambda for this map =',F10.4)
      GO TO 63
C
C HERE AFTER ONE <WORD> <NUMBER> PAIR:
  63  CALL RDWORD(MWD,LEN,IPT,IPT,80,0,IER)
      IF (IER .NE. 100) GO TO 62
   3  CONTINUE
      IF (IZSV.NE.0) THEN
        IF (NDIM.EQ.4) THEN
          CALL MESS(LPT,1,'Save sections bounded by z values ')
          WRITE (LPT,2115) (ZSVVAL(I),I=1,IZSV)
2115      FORMAT ('+',33X,F8.4,' to',F8.4,/(34X,F8.4,' to',F8.4))
        ELSE
          CALL MESS(LPT,1,'Save calculated map at z values ')
          CALL PRILIS(ZSVVAL,IZKEEP,IZSV)
        ENDIF
      ENDIF
      IF (IZPL.NE.0) THEN
        IF (NDIM.EQ.4) THEN
          CALL MESS(LPT,1,'Plot sections bounded by z values ')
          WRITE (LPT,2115) (ZPLVAL(I),I=1,IZPL)
        ELSE
          CALL MESS(LPT,1,'Plot at z values ')
          CALL PRILIS(ZPLVAL,IZKEEP,IZPL)
        ENDIF
      ENDIF
      IF (IZPR.NE.0) THEN
        IF (NDIM.EQ.4) THEN
          CALL MESS(LPT,1,'Print sections bounded by z values ')
          WRITE (LPT,2115) (ZPRVAL(I),I=1,IZPR)
        ELSE
          CALL MESS(LPT,1,'Print at z values ')
          CALL PRILIS(ZPRVAL,IZKEEP,IZPR)
        ENDIF
      ENDIF
C
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE KANGA1(X,Y,MODE)
      SUBROUTINE KANGA1(X,Y,MODE)
C
C *** KANGA1 by JCM 24 Nov 83 ***
C
CX
CC 14C
CH Moves plotter pen (or equivalent) to X,Y in current coordinates.
CA On entry X,Y give the required destination of the pen.
CA          MODE indicates whether the pen is to be up or down while moving
CA          MODE=1 leaves pen in state it was last time
CA          MODE=2 lowers pen
CA          MODE=3 raises pen
CP Plotting must have been set up by, e.g., STPLOT.  In particular the
CP transformation PTRAN must be held in /PLTRAN to take current coordinates
CP into the basic hardware coordinates.
C
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
C
      M=MODE
C LEAVE M AS ONLY 2 OR 3, NOT 1, BECAUSE SPECIFIC PLOTTER SOFTWARE LIBRARIES
C MAY WELL NOT CATER FOR M=1:
      IF (M .EQ. 1) M=MPEN
      MPEN=M
C
C CONVERT CURRENT COORDINATES X,Y INTO PLOTTER'S COORDINATES X1,Y1:
      X1=X*PTRAN(1,1,1) + Y*PTRAN(1,2,1) + PTRAN(1,3,1)
      Y1=X*PTRAN(2,1,1) + Y*PTRAN(2,2,1) + PTRAN(2,3,1)
      CALL PIGLET(X1,Y1,M)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE KANGA2(X0,Y0,XF,ICHARS,NCHAR)
      SUBROUTINE KANGA2(X0,Y0,XF,ICHARS,NCHAR)
C
C *** KANGA2 updated by JCM 12 Nov 89 **
C
CX
CC 14C
CH Writes on a plot a string of characters, or simulates this in order
CH to measure the length of the string.
CA On entry ICHARS is a character string
CA          NCHAR is the number of characters in ICHARS;  if NCHAR is given
CA                negatively, KANGA2 goes through the motions of writing but
CA                does not actually plot anything.  This facility is for
CA                measuring strings.
CA          X0, Y0 give where, in the current (character) space, to start
CA                 writing (i.e. the bottom left hand side of the first letter)
CA On exit XF has been updated to be the X position for the "next" character,
CA                 it is adjusted (by the subtraction of X0) so that it is the
CA                 length of the string in character units.
C
CP Plotting must have already been set up by, e.g., STPLOT, and we must
CP already be in "character" space, though this may be of one of various
CP types of character previously set up.
C
CD Instructions to plot the characters are held in the array LINES.
CD A character is described on a 30 by 30 grid.  The X direction is numbered
CD 0 to 30 (including both ends), but the Y direction is -8 to 22.  The line
CD on which the character looks to be written is thus the X axis.  Lower case
CD letters with descenders use the 0 to -8 range.
CD
CD The array LINES holds for each character in turn:
CD     First element = width of character as an integer (in character coords)
CD     Subsequent elements are instructions, packed one per element.  If MPACK
CD     is an instruction, then its sign says whether pen should be up or down
CD     (+ve=up, -ve=down) and the modulus of MPACK is X*32 + Y+8 (where this
CD     is an instruction to move to (X,Y).)
C
CN The character # (hash) is a special character, signalling that the
CN one character which follows it is in a special alphabet (so far, Greek,
CN and so far only theta and lambda allowed, requested by #T and #L)
CN
CN Unidentifiable characters are converted to spaces.
C
      CHARACTER *80 ICHARS
      CHARACTER *1 IALCHR
      LOGICAL GREEK
      DIMENSION IALCHR(84),ITBLCH(96),LINES(1030),LINE1(130),LINE2(130)
      DIMENSION LINE3(130),LINE4(130),LINE5(130),LINE6(130),LINE7(130)
      DIMENSION LINE8(82)
      COMMON /CHARS/LETUP(26),LETLOW(26),ISPCE,IDIGIT(10),ISMBOL(21)
      CHARACTER *1 LETUP,LETLOW,ISPCE,IDIGIT,ISMBOL
      EQUIVALENCE (IALCHR(1),LETUP(1)),(LINE1(1),LINES(1))
      EQUIVALENCE (LINE2(1),LINES(131)),(LINE3(1),LINES(261))
      EQUIVALENCE (LINE4(1),LINES(391)),(LINE5(1),LINES(521))
      EQUIVALENCE (LINE6(1),LINES(651)),(LINE7(1),LINES(781))
      EQUIVALENCE (LINE8(1),LINES(911))
      DATA ITBLCH/1,8,30,49,64,73,80,102,109,112,123,130,135,
     & 144,151,173,186,210,225,246,251,262,267,276,281,287,
     & 294,311,328,343,360,378,386,408,418,426,437,444,447,
     & 464,474,492,509,526,534,552,560,570,575,584,589,598,
     & 605,606,611,626,642,648,666,690,695,725,749,767,773,
     & 782,793,807,815,835,838,843,868,871,882,893,896,899,
     & 904,909,916,925,960,964,968,968,968,968,968,968,968,968,
     & 988,988,988,993/
      DATA LINE1/18,317,-40,317,-552,143,-463,21,157,-136,157,-445,-540,
     & -571,-601,-599,-565,-532,-435,147,-435,-530,-561,-591,-588,-554,
     & -521,-424,-136,21,600,-570,-508,-445,-317,-252,-186,-152,-117,
     & -112,-141,-171,-233,-296,-424,-489,-555,-589,21,157,-136,157,
     & -381,-476,-538,-568,-597,-592,-557,-523,-457,-360,-136,19,157,
     & -136,157,-573,147,-403,136,-552,18,157,-136,157,-573,147,
     & -403,21,600,-570,-508,-445,-317,-252,-186,-152,-117,-112,-141,
     & -171,-233,-296,-424,-489,-555,-589,-592,432,-592,22,157,-136,
     & 605,-584,147,-595,8,157,-136,16,413,-397,-362,-329,-264,
     & -200,-137,-106,-77,-79,21,157,-136,605,-143,308,-584,17/
      DATA LINE2/157,-136,136,-520,24,157,-136,157,-392,669,-392,669,
     & -648,22,157,-136,157,-584,605,-584,22,317,-252,-186,-152,-117,
     & -112,-141,-171,-233,-296,-424,-489,-555,-589,-624,-629,-600,-570,
     & -508,-445,-317,21,157,-136,157,-445,-540,-571,-601,-598,-564,
     & -531,-434,-146,22,317,-252,-186,-152,-117,-112,-141,-171,-233,
     & -296,-424,-489,-555,-589,-624,-629,-600,-570,-508,-445,-317,396,
     & -582,21,157,-136,157,-445,-540,-571,-601,-599,-565,-532,-435,
     & -147,371,-584,20,570,-508,-413,-285,-188,-122,-120,-150,-181,
     & -244,-434,-497,-528,-558,-555,-489,-392,-264,-169,-107,16,285,
     & -264,61,-509,22,157,-142,-171,-233,-328,-392,-489,-555,-590/
      DATA LINE3/-605,18,61,-296,573,-296,24,93,-232,413,-232,413,
     & -552,733,-552,20,125,-552,573,-104,18,61,-307,-296,573,-307,
     & 20,573,-104,125,-573,104,-552,19,502,-488,499,-437,-374,
     & -278,-213,-147,-112,-110,-139,-201,-264,-360,-425,-491,19,157,
     & -136,147,-213,-278,-374,-437,-499,-528,-526,-491,-425,-360,-264,
     & -201,-139,18,499,-437,-374,-278,-213,-147,-112,-110,-139,-201,
     & -264,-360,-425,-491,19,509,-488,499,-437,-374,-278,-213,-147,
     & -112,-110,-139,-201,-264,-360,-425,-491,18,112,-496,-498,-468,
     & -437,-374,-278,-213,-147,-112,-110,-139,-201,-264,-360,-425,-491,
     & 12,349,-285,-220,-185,-168,86,-310,19,502,-486,-451,-418/
      DATA LINE4/-353,-257,-194,499,-437,-374,-278,-213,-147,-112,-110,
     & -139,-201,-264,-360,-425,-491,19,157,-136,146,-245,-310,-406,
     & -469,-498,-488,8,125,-156,-189,-158,-125,150,-136,10,189,-220,
     & -253,-222,-189,214,-197,-162,-97,-33,17,157,-136,470,-140,272,
     & -488,8,157,-136,30,150,-136,146,-245,-310,-406,-469,-498,
     & -488,498,-597,-662,-758,-821,-850,-840,19,150,-136,146,-245,
     & -310,-406,-469,-498,-488,19,278,-213,-147,-112,-110,-139,-201,
     & -264,-360,-425,-491,-526,-528,-499,-437,-374,-278,19,150,-129,
     & 147,-213,-278,-374,-437,-499,-528,-526,-491,-425,-360,-264,-201,
     & -139,19,502,-481,499,-437,-374,-278,-213,-147,-112,-110,-139/
      DATA LINE5/-201,-264,-360,-425,-491,13,150,-136,144,-179,-245,
     & -310,-406,17,467,-437,-342,-246,-149,-115,-145,-208,-367,-430,
     & -460,-459,-425,-328,-232,-137,-107,12,189,-172,-201,-264,-328,86,
     & -310,19,150,-140,-169,-232,-328,-393,-492,502,-488,16,86,-264,
     & 470,-264,22,118,-232,374,-232,374,-488,630,-488,17,118,
     & -456,470,-104,16,86,-264,470,-264,-196,-130,-65,-33,17,
     & 470,-104,118,-470,104,-456,16,20,217,-282,-381,-360,20,
     & 152,-153,-187,-220,-285,-413,-476,-507,-537,-535,-501,-434,-104,
     & -552,20,189,-541,-341,-437,-500,-531,-560,-558,-523,-457,-360,
     & -264,-169,-138,-108,20,445,-111,-591,445,-424,20,509,-189/
      DATA LINE6/-148,-181,-278,-374,-469,-531,-560,-558,-523,-457,
     & -360,-264,-169,-138,-108,20,538,-508,-413,-349,-252,-185,-148,
     & -143,-171,-233,-328,-360,-457,-523,-558,-559,-530,-468,-373,
     & -341,-244,-178,-143,20,573,-232,125,-573,20,285,-188,-154,-152,
     & -182,-245,-372,-467,-529,-559,-556,-522,-489,-392,-264,-169,
     & -138,-108,-111,-145,-211,-308,-437,-502,-536,-538,-508,-413,-285,
     & 20,534,-499,-433,-336,-304,-209,-147,-118,-119,-154,-220,-317,
     & -349,-444,-506,-534,-529,-492,-425,-328,-264,-169,-139,20,317,
     & -220,-153,-116,-113,-140,-201,-296,-360,-457,-524,-561,-564,-537,
     & -476,-381,-317,10,170,-137,-168,-201,-170,10,201,-168,-137,-170,
     & -201,-199,-165/
      DATA LINE7/-132,10,182,-149,-180,-213,-182,170,-137,-168,-201,
     &-170,10,182,-149,-180,-213,-182,201,-168,-137,-170,-201,-199,-165,
     & -132,10,189,-175,170,-137,-168,-201,-170,18,120,-121,-155,-188,
     & -253,-381,-444,-475,-505,-503,-469,-436,-306,-303,298,-265,-296,
     & -329,-298,8,157,-150,16,157,-150,413,-406,20,286,-262,
     & 414,-390,570,-508,-413,-285,-188,-122,-120,-150,-181,-244,-434,
     & -497,-528,-558,-555,-489,-392,-264,-169,-107,22,670,-68,14,
     & 318,-285,-252,-184,-147,-143,-170,-230,-261,-292,14,190,-221,
     & -252,-312,-339,-335,-298,-230,-197,-164,8,158,-131,26,145,
     & -721,26,442,-424,145,-721,26,148,-724,142,-718,16,279/
      DATA LINE8/-267,116,-430,436,-110,21,382,-131,574,-323,148,-596,
     &110,-558,26,756,-757,-726,-694,-661,-627,-558,-491,-425,-360,-232,
     & -169,-138,-108,-110,-144,-177,-405,-438,-472,-474,-444,-381,-316,
     & -282,-280,-309,-370,-523,-585,-648,-712,-745,-746,26,734,-19,
     & -30,26,30,-723,-8,20,317,-220,-153,-116,-113,-140,-201,-296,
     & -360,-457,-524,-561,-564,-537,-476,-381,-317,115,-563,22,
     & 286,-648,404,-136/
C
C SET NOT IN FUNNY CHARACTER SET:
      GREEK=.FALSE.
C
C XF FOLLOWS CHARACTERS ALONG LINE:
      XF=X0
C
      IF (NCHAR .EQ. 0) GO TO 100
      MODNC=IABS(NCHAR)
      DO 1 I=1,MODNC
C
C IDENTIFY CHARACTER  - IF UNKNOWN TO TABLES, SET SPACE (NUMBER 53)
      DO 2 J=1,84
      IF (IALCHR(J) .EQ. ICHARS(I:I)) GO TO 3
   2  CONTINUE
      J=53
C
C IF HASH, SET THAT NEXT CHARACTER WILL BE IN FUNNY SET:
   3  IF (J .NE. 81) GO TO 6
      GREEK=.TRUE.
      GO TO 1
C
C ARE WE ALREADY IN FUNNY CHARACTER SET?
   6  IF (.NOT. GREEK) GO TO 7
      GREEK=.FALSE.
      IF (J .EQ. 46) J=92
      IF (J .EQ. 38) J=95
C J=WHICH CHARACTER - SET K=START OF ITS INSTRUCTIONS IN ARRAY LINES
   7  K=ITBLCH(J)
      L=ITBLCH(J+1)
C IF ONLY MEASURING, NO NEED TO UNPACK INSTRUCTIONS:
      IF (NCHAR .LT. 0) GO TO 4
C
C WITH M SCAN EACH PACKED INSTRUCTION FOR THIS CHARACTER
      M=K+1
   5  IF (M .GE. L) GO TO 4
      MPACK=LINES(M)
      IPEN=2
      IF (MPACK .GT. 0) IPEN=3
      MP=IABS(MPACK)
      M1=MP/32
      M2=MP-M1*32-8
      X=FLOAT(M1)+XF
      Y=FLOAT(M2)+Y0
      CALL KANGA1(X,Y,IPEN)
      M=M+1
      GO TO 5
C
C CHARACTER WRITTEN - ADJUST XF
   4  XWIDE=FLOAT(LINES(K))
      XF=XF+XWIDE
   1  CONTINUE
      XF=XF-X0
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE KANGA3(X,Y,SIZE,MSYM)
      SUBROUTINE KANGA3(X,Y,SIZE,MSYM)
C
C *** KANGA3 updated by PJB 23 May 90 ***
C
CX
CC 14C
CH Plots a special symbol.
CA On entry X,Y give the position in current coordinates of the CENTRE of the
CA              symbol.  The current space will usually be graph or map space.
CA          MSYM is negative if the symbol should be "filled in";
CA               its absolute value indicates which symbol is required:
CA          MSYM=1   square
CA          MSYM=2   triangle, apex up
CA          MSYM=3   triangle, apex down
CA          MSYM=4   hexagon (which if drawn small will make a circle)
CA          MSYM=5   cross like X
CA          MSYM=6   cross like +
CA          MSYM=7   cross like X with top and bottom (egg-timer)
CA          MSYM=8   cross like X with sides (butterfly)
CA          MSYM=9   diamond
CA                   The symbols are "the right way up" for CCSL space.
CA On entry SIZE is set so that the symbol is drawn within a notional square
CA               of side SIZE cms. (Cms are CCSL units).
CP Plotting must be set up by, e.g., STPLOT, and a suitable space set by SPCSET
C
CN This is distinct from KANGA2, which can also draw symbols if they can
CN be represented as A1 characters, but expects them to be part of a
CN sentence, and draws them on a 30 x 30 character space grid with origin
CN at a point part way up the left hand side.  KANGA3 centres the symbol.
C
      LOGICAL SOLID,FOUND
      DIMENSION SMPTS(2,12),MLINE(43),MPOINT(10),S(8),C(8)
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
      DATA SMPTS/-2.,2.,2.,2.,2.,-2.,-2.,-2.,-2.,0.,0.,2.,2.,0.,0.,
     & -2.,-2.,-1.,-2.,1.,2.,1.,2.,-1./
      DATA MPOINT/1,6,10,14,21,25,29,34,39,44/
      DATA MLINE/1,-2,-3,-4,-1,9,-6,-12,-9,8,-10,-11,-8,6,-11,
     & -12,-8,-9,-10,-6,1,-3,2,-4,6,-8,5,-7,1,-2,-4,-3,-1,1,-4,-2,
     & -3,-1,6,-7,-8,-5,-6/

C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C
      S4=SIZE/4.
C
      MSYMB=IABS(MSYM)
      SOLID=(MSYM.LT.0 .AND. (MSYMB.GT.-5 .OR. MSYMB.EQ.-9))
      IF (SOLID) THEN
        YSTEP=1./(100.*S4)
        XMIN=0.
        XMAX=0.
        YMIN=0.
        YMAX=0.
      ENDIF
C
      GO TO (2,3,3,3,2,4,2,2,4) ,MSYMB
C
C TIMES 1 OVER ROOT 2:
   2  S4=S4*0.7071
      GO TO 4
C
C TIMES ROOT 3 OVER 2:
   3  S4=S4*0.8660
C CONVERT POINT AT SYMBOL CENTRE TO BE IN PLOTTER SPACE:
   4  CALL PLCONV(X,Y,0,X0,Y0,1)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C MAKE UNIT VECTORS IN BOTH DIRECTIONS IN PLOTTER SPACE:
      CALL PLCONV(0.,0.,2,XX0,YY0,1)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
      CALL PLCONV(S4,0.,2,XX1,YY1,1)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
      CALL PLCONV(0.,S4,2,XX2,YY2,1)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      XX1=XX1-XX0
      YY1=YY1-YY0
      XX2=XX2-XX0
      YY2=YY2-YY0
      K=MPOINT(MSYMB)
      L=MPOINT(MSYMB+1)-1
      DO 1 I=K,L
      M=MLINE(I)
      MPEN=2
      IF (M .GT. 0) MPEN=3
      M=IABS(M)
      XIN=SMPTS(1,M)*XX1+SMPTS(2,M)*XX2+X0
      YIN=SMPTS(1,M)*YY1+SMPTS(2,M)*YY2+Y0
      CALL PIGLET(XIN,YIN,MPEN)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      IF (SOLID .AND. I.LT.L) THEN
        J=I+1
        IF (SMPTS(1,M).GT.XMAX) XMAX=SMPTS(1,M)
        IF (SMPTS(1,M).LT.XMIN) XMIN=SMPTS(1,M)
        IF (SMPTS(2,M).GT.YMAX) YMAX=SMPTS(2,M)
        IF (SMPTS(2,M).LT.YMIN) YMIN=SMPTS(2,M)
C GET SLOPES AND INTERCEPTS OF LINES JOINING POINTS
        MM=IABS(MLINE(J))
        DEN=(SMPTS(2,MM)-SMPTS(2,M))
        IF (ABS(DEN).LT.10E-6) THEN
          S(I-K+1)=1.1*10E6
        ELSE
          S(I-K+1)=(SMPTS(1,MM)-SMPTS(1,M))/DEN
          C(I-K+1)=(SMPTS(2,MM)*SMPTS(1,M)-SMPTS(2,M)*SMPTS(1,MM))
     &     /DEN
        ENDIF
      ENDIF
    1 CONTINUE
      IF (SOLID) THEN
        NY=IFIX((YMAX-YMIN)/YSTEP)
        MPEN=3
        YPT=YMIN
C FIND THE SMALLEST POSITIVE X ON AN EDGE
        DO 5 IY=1,NY
        YPT=YPT+YSTEP
        FOUND=.FALSE.
        XP=XMAX
        DO 6 I=1,L-K
        IF (S(I).GT.10.E6) GO TO 6
        XPT=YPT*S(I)+C(I)
        IF (XPT.GT. 0. .AND. XPT.LT.XP) XP=XPT
   6    CONTINUE
C USE THE SYMMETRY ABOUT X=0
          XIN=-XP*XX1+YPT*XX2+X0
          YIN=-XP*YY1+YPT*YY2+Y0
          CALL PIGLET(XIN,YIN,MPEN)
          MPEN=2
          XIN=XP*XX1+YPT*XX2+X0
          YIN=XP*YY1+YPT*YY2+Y0
          CALL PIGLET(XIN,YIN,MPEN)
	    IF (IBMBER .NE. 0) RETURN
   5    CONTINUE
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE LOCBIT(I,J,NR,NC,ISIDE,M,N)
      SUBROUTINE LOCBIT(I,J,NR,NC,ISIDE,M,N)
C
C *** LOCBIT by JCM 24 Nov 83 ***
C
CX
CC 15C
CH A specialist routine for contour plotting, which finds the "next" bit in
CH the bit-map, removes it, and indicates where on the picture it was.
CA On entry I=which bit within a word in the bit-map,
CA          J=which word in the bit-map
CA          M,N give the size of the bit-map
CA On exit ISIDE=1,2,3 or 4 to indicate side of picture,
CA         NR,NC are set to indicate the top left of the relevant square.
CD Finds whether the indicated bit is 0 or 1, and in any case removes it.
CP The bit-map must be set up in IBIT in /BITMAP/
CP NBITS must be set up as at most the number of bits in an integer.
C
      COMMON /BITMAP/IBIT(108,4),NWORDS
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /LENINT/NBITS

C
      IF (J .GT. NWORDS) THEN
        WRITE (LPT,3000) J,NWORDS
        WRITE (ITO,3000) J,NWORDS
3000    FORMAT (' ERROR ** IN LOCBIT - INTEGER',I4,' CALLED FOR, ',
     &  ' BUT ONLY',I4,' AVAILABLE')
C>> Was STOP
        CALL BMBOUT
	  RETURN
      ENDIF
C
      ISIDE = I
      IF (I .GT. 4) ISIDE = 1
      MM=1
      IB=1
   5  IF (LOGAND(IBIT(I,J),MM) .NE. 0) GO TO 6
      MM=MM*2
C NB IF THIS GIVES INTEGER OVERFLOW, REDUCE THE VALUE OF NBITS IN COMMON
C CONTUR SO THAT THE SIGN BIT OF AN INTEGER IS NOT USED
      IB=IB+1
      GO TO 5
   6  IBIT(I,J)=IBIT(I,J)-MM
      GO TO(1,2,3,4),ISIDE
    1 NR = I
      IF (I .GT. 4) NR = I-3
      NC = (J-1)*NBITS +IB
      GO TO 100
    2 NC = N-1
      NR = (J-1)*NBITS + IB
      GO TO 100
    3 NR = M-1
      NC = N - (J-1)*NBITS - IB
      GO TO 100
    4 NC = 1
      NR = M - (J-1)*NBITS - IB
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE MAJUST
      SUBROUTINE MAJUST
C
C *** MAJUST updated by JCM May 88 ***
C
CC 5A
CH A specialist routine used in the input of the Crystal Data File needing
CH previously stored Fourier maps.
CD MAJUST is called from PREFIN, on discovering that the user has given an
CD "M GET" card.  It adjusts file IO10 so that it contains mainly cards from the
CD previously dumped run (to be found on named file), updated to include
CD any new "M" cards presented for this run.  The rule for "M" cards belonging
CD to the "old" and "new" sets is:
CD   take only new cards for PRIN, PLOT, SAVE and GET;
CD   take only old cards for NDIM, FTYP, MESH, DTYP, DELT, SCAL, SMAX and AXES.
CD   For CM/A and CONT:
CD     if the card type occurs in "old" but not "new", accept it
CD     if card type occurs in "new" but not "old", accept it
CD     if card type occurs in both, accept the "new" only.
CD Also takes a new "N" card, unless there is only an old one.
C
CN All the cards capable of being telescoped happen to occur in the "take only
CN old" category, so should not pose a problem by hiding something other than
CN in columns 3-6, but - care will be needed with any newly defined cards.
C
C
      LOGICAL NONEWN
      CHARACTER *4 MWORD,MTBL1(8),MTBL2(4),MNEW(20)
      CHARACTER *80 MCARD(20),NEWNCD
      CHARACTER *10 FILNOM
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      DATA MTBL1/'NDIM','FTYP','MESH','AXES','DELT','SCAL',
     & 'SMAX','DTYP'/
      DATA MTBL2/'PRIN','PLOT','SAVE','GET'/
C
C
C IF THERE IS A NEW 'N' CARD, SAVE IT:
      NONEWN=.TRUE.
      IF (ICDNO(14) .EQ. 0) GO TO 16
      CALL CARDIN(IABS(INREAD(14)))
      NEWNCD=ICARD
      NONEWN=.FALSE.
C
C SAVE NEW M CARDS FOR CONT, CM/A,  PRIN, PLOT, READ OR SAVE:
   16 NEWMC=ICDNO(13)
      MSTART=INREAD(13)
      J=0
      ID=IABS(MSTART)
      DO 1 I=1,NEWMC
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(MWORD,ITEMP1,3,ITEMP2,80,0,IER)
C IGNORE IF ONE OF NDIM, AXES, MESH, FTYP, DTYP, DELT, SCAL, SMAX:
      DO 10 K=1,8
      IF (MWORD .EQ. MTBL1(K)) GO TO 1
  10  CONTINUE
      J=J+1
      MCARD(J)=ICARD
      MNEW(J)=MWORD
   1  CONTINUE
C RESET NUMBER OF NEW M CARDS:
      NEWMC=J
C
C COPY CARDS FROM UNIT IDUMPG, UNFORMATTED, ADDING NEW M CARDS:
      MESSAG='File containing saved Fourier '
      NAMFIL='.SAV'
      CALL OPNFIL(IDUMPG,1111)
      INEW=1
C RESTORE OLD VALUES FOR ARRAYS OF COUNTS AND START POINTERS FOR CARDS:
      READ (IDUMPG) INREAD,ICDNO,NCDS
C ENSURE ALL POINTERS INITIALISED POSITIVE:
      DO 2 I=1,26
   2  INREAD(I)=IABS(INREAD(I))
C
C COPY CARDS ACROSS FROM IDUMPG TO IO10 NOTING WHEN M BLOCK REACHED:
      I=0
      LET=-1
   3  I=I+1
      IF (I .GT. NCDS) GO TO 101
      READ(IDUMPG) ICARD
  14  LETNEW=LETTER(ICARD(1:1))
      IF (LETNEW .EQ. LET) GO TO 5
C
C NEW BATCH - ADJUST STARTING POINTER:
      INREAD(LETNEW)=INEW
      LET=LETNEW
C NOTE WHEN ABOUT TO DEAL WITH M CARDS, AND JUMP:
      IF (I .EQ. INREAD(13)) GO TO 4
C
C WRITE OUT CARD OTHER THAN ONE STARTING "M":
   5  INEW=INEW+1
C IF ABOUT TO WRITE AN 'N' CARD, SEE IF THERE IS A NEW ONE:
      IF (ICARD(1:1) .NE. 'N') GO TO 15
      IF (NONEWN) GO TO 15
      ICARD=NEWNCD
  15  WRITE (IO10,2000) ICARD
2000  FORMAT (A80)
C COUNT AS THOUGH A "DO" LOOP OVER I (BUT ALLOWING FOR MOVING I FURTHER DOWN)
      GO TO 3
C
C HERE ON FIRST OLD "M" CARD - SCAN ALL OLD CARDS:
   4  MEND=ICDNO(13)
      DO 6 K=1,MEND
      CALL RDWORD(MWORD,ITEMP1,3,ITEMP2,80,0,IER)
C REFUSE TO COPY PRIN, PLOT, SAVE, GET:
      DO 12 II=1,4
      IF (MWORD .EQ. MTBL2(II)) GO TO 9
  12  CONTINUE
C
C INSIST ON COPYING NDIM, AXES, FTYP, MESH:
      DO 13 II=1,4
      IF (MWORD .EQ. MTBL1(II)) GO TO 8
  13  CONTINUE
C
C THIS LEAVES CONT AND CM/A;  ONLY COPY IF THEY ARE OLD BUT NOT NEW:
      DO 7 J=1,NEWMC
      IF (MWORD .EQ. MNEW(J)) GO TO 9
   7  CONTINUE
C
C OLD CARD STILL WANTED:
   8  INEW=INEW+1
      WRITE (IO10,2000) ICARD
C
C OLD CARD OCCURS AGAIN IN NEW SET - DISCARD OLD:
C COUNT INPUT OLD CARDS
   9  I=I+1
      IF (I .GT. NCDS) GO TO 101
      READ(IDUMPG) ICARD
   6  CONTINUE
C
C END OF SCANNING OLD M CARDS - NOW ADD ALL NEW ONES:
      DO 11 K=1,NEWMC
      INEW=INEW+1
  11  WRITE (IO10,2000) MCARD(K)
      ICDNO(13)=INEW-INREAD(13)
      GO TO 14
C
 101  IF (ICDNO(14) .NE. 0 .OR. NONEWN) GO TO 100
      INREAD(14) = INEW
      INEW=INEW+1
      WRITE (IO10,2000) NEWNCD
      ICDNO(14)=1
 100  WRITE (LPT,2001) FILNOM(IDUMPG)
2001  FORMAT (/' "M GET" card given;  crystal data read from ',
     & A10,' and given relevant new M cards')
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE MAKEBM(I,A,C,M,N)
      SUBROUTINE MAKEBM(I,A,C,M,N)
C
C *** MAKEBM by JCM 24 Nov 82 ***
C
CX
CC 15C
CH A specialist contour plotting routine which makes a bit map to show where
CH the contours are.
C
      LOGICAL ABOVE,ABVE,TEST
      DIMENSION A(M,N)
      IC=1
      IR=0
      NB=N-1
      NR=I-3
      NC=1
      IF (NR .GT. 1) GO TO 6
      GO TO (1,2,3,4), I
   1  NR=1
      GO TO 6
   2  NR=1
      NC=N
      IR=1
      GO TO 5
   3  NR=M
      NC=N
      IC=-1
      GO TO 6
   4  NR=M
      NC=1
      IR=-1
   5  IC=0
      NB=M-1
   6  ABOVE = A(NR,NC) .GE. C
      DO 10 IB=1,NB
      NR = NR + IR
      NC = NC + IC
      ABVE = A(NR,NC) .GE. C
      IF (ABOVE .AND. ABVE .OR. .NOT.(ABOVE .OR. ABVE)) GO TO 10
      ABOVE = ABVE
      CALL BITSET (I,IB,TEST,.TRUE.)
  10  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MAPCON(CFOUND,IC,IBMAX,IFMAX)
      SUBROUTINE MAPCON(CFOUND,IC,IBMAX,IFMAX)
C
C *** MAPCON by JCM 22 Aug 86 ***
C
CX
CC 5B
CH After a Fourier map has been plotted, sends to the plotter the list of
CH contours which were plotted, with a frame.
C
CA On entry CFOUND is a real array containing the contour values to write,
CA          IC is the number of elements in CFOUND,
CA          IBMAX and IFMAX are handed over to indicate general size of numbers.
C
CP STPLOT shuld set this up, and MPPLOT should call it, having made the list
C
      DIMENSION CFOUND(IC),PTEMP(2,3)
      CHARACTER *8 NUMBUF
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C WRITE CONTOUR LIST IF ANY FOUND:
C IF VALUES SO WIDELY DIFFERENT THAT COULD NOT ALL BE WRITTEN, EXIT:
      IF (IBMAX .GT. 8) GO TO 100
C BLACK PEN AGAIN:
      CALL PIGLET(0.,0.,-1)
C>> JCC Added
	IF (IBMBER .NE.0) RETURN
C NOW CHARACTER TYPE 3 - CONTOUR LIST PANEL - WE KNOW THIS TO BE 10 CHARS WIDE:
C WE NOW KNOW SIZE OF LIST - IC NUMBERS PLUS A TITLE:
      A=FLOAT(IC+1)*2.*CHUNIT
      CHSCAL(2,3)=(HGTMAP+5.*YWHITE+HGTTXT)/A
C DO NOT ALLOW TYPE 3 TO BECOME LARGER THAN TYPE 1:
      IF (CHSCAL(2,3) .GT. CHSCAL(2,1)) CHSCAL(2,3)=CHSCAL(2,1)
      CHSCAL(1,3)=CHSCAL(2,3)/ASPECT
C A DIGIT IS 20 PLOTTER UNITS WIDE:
      WIDCON=220.*CHSCAL(1,3)
      HGTCON=A*CHSCAL(2,3)
C
C PUT IN PLACE THE TRANSFORMATION FOR CHARACTER TYPE 3:
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,3)
      PTEMP(2,2)=CHSCAL(2,3)
      PTEMP(1,3)=WIDPIC-XMARG-WIDCON
      PTEMP(2,3)=(PMTRIX(2,3,3)+YMARG-HGTCON)/2.
      CALL PLTRIN(PTEMP,7,3)
C>> JCC Added
	IF (IBMBER .NE.0) RETURN
C
C SET CHARACTER TYPE 3 SPACE:
      CALL SPCSET(7)
C>> JCC Added
	IF (IBMBER .NE.0) RETURN
      CALL FRAME(0.,0.,220.,A)
      B=A-2.*CHUNIT
      CALL KANGA1(0.,B,3)
      CALL KANGA1(220.,B,2)
C WRITE 'CONTOURS'
      CALL KANGA2(CHUNIT,B+CHUNIT/2.,TEMP,'CONTOURS',8)
C
C SELECT FIELD WIDTH:
      IBMAX=IBMAX+IFMAX
      IF (IFMAX .EQ. 0) IBMAX=IBMAX-1
      IW=IBMAX/2 + 4
      IF (IW .GT. 8) IFMAX=IFMAX-IW+8
C
C LIST VALUES PLOTTED:
      B=B+CHUNIT/2.
      DO 5 I=1,IC
      B=B-2.*CHUNIT
      CALL NUMA1(CFOUND(I),IW,IFMAX,8,NUMBUF)
   5  CALL KANGA2(CHUNIT,B,TEMP,NUMBUF,8)
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE MAPDRW(CFOUND,IC,IBMAX,IFMAX)
      SUBROUTINE MAPDRW(CFOUND,IC,IBMAX,IFMAX)
C
C *** MAPDRW by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Draws an unframed contour map, in predetermined place.
C
CA On exit CFOUND is a real array which holds all the found contour values.
CA         IC is the number of found contours.
CA         IBMAX and IFMAX are sensible sizes for later contour list printing.
C
CP STPLOT must have set up the map contouring
C
      LOGICAL MORE,FOUND
C%
C      DIMENSION CFOUND(%CONT%)
      DIMENSION CFOUND(50)
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
C>> JCC Implement error handling
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C SET MAP SPACE:
      CALL SPCSET(4)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
C INITIALISE IC=COUNT OF FOUND CONTOURS, IBMAX AND IFMAX WHICH CONTROL THE
C DETAILS OF PRINTING THE CONTOUR LIST, AND ICON WHICH COUNTS CONTOURS SOUGHT:
      IC=0
      IBMAX=0
      IFMAX=0
      ICON=0
      MORE=.TRUE.
C
C NEXT CONTOUR:
   1  CALL NEXCON(C,ICON,MORE)
      IF (.NOT. MORE) GO TO 100
      CALL PLOTCT(C,DENS,FOUND,NX,NY)
C>> JCC Added
	IF (IBMBER .NE.0) RETURN
      IF (.NOT. FOUND) GO TO 3
C
C CONTOUR FOUND - KEEP:
      IC=IC+1
      CFOUND(IC)=C
C ADJUST IFMAX AND IBMAX SO THAT THE RESULTING LIST LOOKS NICE:
      CALL FETTLE(C,IF1,IF2)
      IB=IF1-IF2
      IF (IF2 .EQ. 0) IB=IB+1
      IF (IB .GT. IBMAX) IBMAX=IB
      IF (IF2 .GT. IFMAX) IFMAX=IF2
      WRITE (LPT,2000) C
2000  FORMAT (' Contour at',F12.4,' drawn')
      IF (NCONT .EQ. 0) WRITE(ITO,2000) C
C%
C      IF (IC .GE. %CONT%) GO TO 100
      IF (IC .GE. 50) GO TO 100
C
C JOIN IF REQUESTED CONTOUR NOT FOUND:
   3  MORE=FOUND
C BACK FOR NEXT CONTOUR VALUE:
      GO TO 1
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MAPFRA
      SUBROUTINE MAPFRA
C
C *** MAPFRA by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Draws a black frame round a potential contoured map, adding the labels
CH X Y and a 1A scale.
C
CP Needs to be set up within a whole picture by STPLOT
C
CO Causes (possibly skew) frame to be drawn via PIGLET, with labels X and
CO Y (and therefore implicit origin), and a one-angstrom scale underneath.
C
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP

C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C MOVE INTO MAP SPACE:

      CALL SPCSET(4)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
C BLACK PEN:
      CALL PIGLET(0.,0.,-1)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
C DRAW FRAME ROUND MAP:
      FX=FLOAT(NX-1)
      FY=FLOAT(NY-1)
      CALL FRAME(0.,0.,FX,FY)
C
C POSITIONS FOR 'X' AND 'Y' LABELS:
      CALL PLCONV(FX/2.,0.,4,X1,X2,5)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
      CALL PLCONV(0.,FY/2.,4,Y1,Y2,5)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
C POSITION FOR 1 ANGSTROM LINE, IN BOTH CHARACTER 1 AND PICTURE COORDS:
      CALL PLCONV(FX,FY/2.,4,C1,C2,5)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
      CALL PLCONV(FX,FY/2.,4,P1,P2,3)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
C
C BRIEF SOJURN IN PICTURE SPACE TO DRAW 1 ANGSTROM LINE:
      CALL SPCSET(3)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
      CALL KANGA1(P1-SCALMP/2.,P2-YWHITE*1.5,3)
      CALL KANGA1(P1-SCALMP/2.,P2-YWHITE*2.,2)
      CALL KANGA1(P1+SCALMP/2.,P2-YWHITE*2.,2)
      CALL KANGA1(P1+SCALMP/2.,P2-YWHITE*1.5,2)
C MOVE INTO CHARACTER TYPE 1 SPACE, WITH X1,X2 AND Y1,Y2 SET AS POSITIONS TO
C WRITE 'X' AND 'Y' AND C1,C2 MIDDLE POINT FOR '1A':
      CALL SPCSET(5)
C>> JCC Added 
	IF (IBMBER .NE. 0) RETURN
C
      CALL KANGA2(C1-CHUNIT,C2-1.8*CHUNIT,TEMP,'1A',2)
      CALL KANGA2(X1-1.5*CHUNIT,X2,TEMP,'X',1)
      CALL KANGA2(Y1-CHUNIT/2.,Y2+CHUNIT/2.,TEMP,'Y',1)
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MAPKEY(IFND,NFND,JP)
      SUBROUTINE MAPKEY(IFND,NFND,JP)
C
C *** MAPKEY updated by JCM Sep 91 ***
C
CX
CC 5B
CH Plots a key to the atoms found by ATMPLO.
C
      DIMENSION IFND(4),JP(4),PTEMP(2,3)
      COMMON /ATNAM/ATNAME(150),ATNA(150,9)
      CHARACTER *4 ATNA,ATNAME
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP

C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C
C FIT THE KEY TO NAMES OF ATOMS IN THE SPACE NORMALLY USED FOR CONTOUR VALUES
      IF (NFND.LE.0) GO TO 100
C  SET BLACK PEN
      CALL PIGLET(0.,0.,-1)
	IF (IBMBER .NE. 0) RETURN
C
C  LIST TO CONTAIN NFND ENTRIES PLUS HEADING
C A=HEIGHT OF LIST IN CHARACTER UNITS:
      A=FLOAT(NFND+1)*2.*CHUNIT
C CONVERT MIDPOINT OF RHS OF MAP FRAME INTO PICTURE COORDS:
      FX=FLOAT(NX-1)/2.
      FY=FLOAT(NY-1)
      CALL PLCONV(FX,FY,4,X,Y,3)
	IF (IBMBER .NE. 0) RETURN

C NOW CHARACTER TYPE 3 - ATOM LIST PANEL - WE SET THIS TO BE 10 CHARS WIDE:
       CHSCAL(2,3)=(HGTMAP+5.*YWHITE+HGTTXT)/A
C DO NOT ALLOW TYPE 3 TO BECOME LARGER THAN TYPE 1:
      IF (CHSCAL(2,3) .GT. CHSCAL(2,1)) CHSCAL(2,3)=CHSCAL(2,1)
      CHSCAL(1,3)=CHSCAL(2,3)/ASPECT
C A DIGIT IS 20 PLOTTER UNITS WIDE:
      WIDCON=240.*CHSCAL(1,3)
      HGTCON=A*CHSCAL(2,3)
C
C PUT IN PLACE THE TRANSFORMATION FOR CHARACTER TYPE 3:
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,3)
      PTEMP(2,2)=CHSCAL(2,3)
      PTEMP(1,3)=WIDPIC-XMARG-WIDCON
      PTEMP(2,3)=Y-HGTCON*0.5
      CALL PLTRIN(PTEMP,7,3)
C>> JCC Added
	IF (IBMBER .NE.0) RETURN
C
C  CHARACTER 3 SPACE COMPLETED - SET IT
      CALL SPCSET(7)
	IF (IBMBER .NE. 0) RETURN

      CALL FRAME(0.,0.,240.,A)
      B=A-2.*CHUNIT
      CALL KANGA1(0.,B,3)
      CALL KANGA1(240.,B,2)
C  WRITE 'KEY'
      CALL KANGA2(88.,B+CHUNIT/2.,TEMP,'KEY',3)
C  NOW LIST OF ATOMS FOUND
      B=B+CHUNIT/2.
      DO 5 I=1,NFND
      B=B-2.*CHUNIT
C  PLOT APPROPRIATE CHARACTER
      CALL KANGA3(55.,B+.5*CHUNIT,1.5*CHUNIT*CHSCAL(2,3),JP(I))
C  THEN NAME OF CORRESPONDING ATOM
      CALL KANGA2(5.*CHUNIT,B,TEMP,ATNAME(IFND(I)),4)
    5 CONTINUE
C
  100 RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE MAPTIT
      SUBROUTINE MAPTIT
C
C *** MAPTIT by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Writes a title over a plotted map, with a frame.
C
CP The picture must be initialised by a call of STPLOT, setting up in particular
CP space 6 to be "character type 2" space, measured for suitability for title.
CP The title must have been read by INPUTN.
C
      COMMON /NTITL/NTITLE,KOM14
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /TITLE/ITITLE
      CHARACTER *80 ITITLE
C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C
C MOVE TO CHARACTER TYPE 2 SPACE (TITLE CHARACTERS):
      CALL SPCSET(6)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

C WRITE TITLE, ONE CHARACTER IN AND HALF CHARACTER UP:
      CALL KANGA2(CHUNIT,CHUNIT/2.,TEMP,ITITLE,NTITLE)
C AND PUT FRAME ROUND IT:
      CALL FRAME(0.,0.,TEMP+2.*CHUNIT,2.*CHUNIT)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE NEXCON(C,ICON,MORE)
      SUBROUTINE NEXCON(C,ICON,MORE)
C
C *** NEXCON updated by JCM 22 Aug 86 ***
C
CX
CC 5A
CH Sets up the "next" contour value to plot for Fouriers.
CA On entry LOGICAL MORE is .TRUE. if there is no reason why more contours
CA                           should not be requested,
CA                       or .FALSE. if the interactive user
CA                           has requested a contour which was not found.
CA If non-interactive, on entry ICON = which contour in the list in CONT
CA we have just tried to draw.
CA On exit C = the next contour to draw, if possible.
CA         ICON has been incremented.
CA         MORE = .TRUE. if C has been found, or .FALSE. if no more contours
CA                       are to be drawn.
C
CD If NCONT (in COMMON /CONTUR/) is zero, expects to read contour values
CD interactively.  If NCONT is non-zero, expects ICON to be a count within
CD a previously read list of contours, NCONT in total in the array CONT.
C
      LOGICAL MORE,SAYS
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C
C IF NCONT IS ZERO, INTERACTIVE WORKING:
      IF (NCONT .EQ. 0) GO TO 1
C
C NEXT C FROM LIST, UNLESS FINISHED:
C MAY BE SIMPLE LIST ITEM (ICONT=0) OR STEP (ICONT=-1):
      MORE = .FALSE.
      ICON=ICON+1
      IF (ICON .GT. NCONT) GO TO 100
      C=CONT(ICON)
      GO TO 101
C
C INTERACTIVE WORKING - IF MORE CAME IN FALSE, LAST ONE REQUESTED NOT FOUND:
   1  IF (MORE) GO TO 2
      WRITE (ITO,1001)
 1001 FORMAT (' Contour at',F12.2,' not found ')
      CALL ASK('type C to continue or X to exit')
      IF (.NOT. SAYS('X')) GO TO 2
      MORE = .FALSE.
      GO TO 100
C
   2  CALL ASK('Type contour value required')
      CALL RDREAL(C,1,IPT,80,IER)
 101  MORE = .TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PICMOV
      SUBROUTINE PICMOV
C
C *** PICMOV by JCM 22 Aug 86 ***
C
CX
CC 14B
CH If plotting to Tektronix, do nothing;  if to plotter, move to next picture.
CP FROMCM in /PLODAT/ is 0 if plotting is actually to a VDU, for which
CP the scale "from cm" is irrelevant.
CP NYPIC in /PLOMAP/ is the number of pictures expected, and IYPIC is the
CP number already plotted.
CD If a large plotter is in use for several pictures plotted in sequence,
CD the matrix PMTRIX(,,2) holds the part of the transformation which
CD moves from one picture to another.  This routine deals with the moving
CD from one picture to another, advancing IYPIC and adjusting PMTRIX(,,2)
C
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
C
C USE FROMCM ALSO TO TELL WHETHER ACTUAL PLOTTER  (CALCOMP, BENSON, ZETA,
C ETC -FROMCM > 0) OR VDU (FROMCM =< 0)
      IF (FROMCM .LE. 0.) GO TO 100
C
C DEAL WITH PUTTING PICTUES NEATLY ON A LARGE PLOTTER:
      IF (IYPIC .EQ. 0) GO TO 11
      IF (IYPIC .LT. NYPIC) GO TO 12
      PMTRIX(1,3,2)=PMTRIX(1,3,2)+WIDPIC+BORDER
      PMTRIX(2,3,2)=-(HGTPIC+BORDER)
      IYPIC=0
  12  PMTRIX(2,3,2)=PMTRIX(2,3,2)+HGTPIC+BORDER
  11  IYPIC=IYPIC+1
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE PIGLET(X,Y,N)
       SUBROUTINE PIGLET(X,Y,N)
C
C *** PIGLET updated by JCM 27 Jun 86 ***
C
CX
CC 14C
CH A complete set of device-specific plotting commands.
CA On entry X and Y are plotter coordinates
CA          N indicates the function required:
CA
CA N=0  Called at very start of a plotting job, to set up physical things like
CA       plotter width in cms, plotter units (as FROMCM which converts from cms
CA       to plotter units).  Also sets up some transformation matrices and
CA       initialises quantities for transformations.
CD
CA N=2   Move the pen to the point X,Y (in the plotter's own coordinates)
CA or          N=2 moves with pen down (i.e. draws)
CA N=3         N=3 moves with pen up.
CA             There was originally an N=1 meaning move with the pen in the
CA             state it was last time.  Not every library implements this,
CA             so although CCSL uses it, it is now done by the routines which
CA             call PIGLET.
CD
CA N=-1 or -2 or -3 Changes the colour of the ink in the pen
CA             N=-1 Asks for black
CA             N=-2 Asks for red
CA             N=-3 Asks for green
CA             (These may be altered, or others added, as the user wishes)
CD
CA The remaining values of N carry out whatever special actions the local
CA plotter software needs to make when starting or finishing various stages.
CD
CD The complete plotter output produced by the whole job is called here a
CD "plot".  The plot may be made up of various "pictures" such as layers of
CD a Fourier map; or it may be just one graph. Within a "picture" there are
CD various boxes of explanatory text and the main graphic object such as a
CD "map" for fouriers or a "graph" from PLOTO
CD
CD Most plotter software libraries require that a certain routine be called to
CD start a plot, and some also require another routine to be called to finish
CD a plot (say, to move the pen clear of the plot ready for the next job).
CD There is no obvious need for any special action on an actual plotter at the
CD start and finish of one "picture", but if a Tektronix or other vdu is used,
CD there will be only one "picture" on the screen at once (remember several
CD "pictures"=1 "plot"), so special actions will be needed to start (say, clear
CD screen) and finish (say, ask user if he wants a hard copy) a picture.
CD
CD To accomplish these actions large values of n are assigned as follows:
CD N=999 Start "plot" (which will be X cms wide and Y cms high)
CD N=-999 Finish "plot" (which was X cms wide and Y cms high)
CD N=888 Start "picture" (which will be X cms wide and Y cms high)
CD N=-888 Finish "picture" (which was X cms wide and Y cms high)
C
CD Sets PMTRIX number 1: the CCSL to hardware transformation
C
CO When requested, sends output to graphical device.
CN Contains all plotting commands which are specific to whatever machine (and
CN which output device) is being used.  These are believed to be a bare
CN minimum.  Whenever a new plotter (specifically a new plotter software
CN library) is implemented on the system a specific version of this routine
CN must be made.
CN
CN There are other versions of PIGLET in CCSL for specific output devices.
C
      DIMENSION PTEMP(2,3)
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C>> JCC Implement error handling
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
      IF (N .NE. 0) GO TO 3
C INITIAL ENTRY - SET UP PLOTTER WITHOUT YET KNOWING WHAT WE WISH TO PLOT:
C
C PLOTTER CONVENTIONS - FIRST SET UP DEFAULTS COMMON TO ALL:
      CALL PINITL
	IF (IBMBER .NE. 0) RETURN
C CONVERSION MATRIX WHICH TAKES (X,Y) IN CCSL UNITS INTO (X',Y') IN YOUR
C ACTUAL PLOTTER UNITS.  SEE THE ANNOTATION FOR SUBROUTINE PLCONV FOR
C DEFINITIONS.  THE DEFAULT HERE IS THE UNIT TRANSFORMATION.
      CALL GMZER(PTEMP,2,3)
      CALL GMUNI(PTEMP,2)
C
C FROMCM POSITIVE USED TO INDICATE PLOTTER NOT VDU:
CRAL
C RUTHERFORD VAX PLOTTER WORKS IN SAME ORIENTATION AS CCSL EXPECTS,
CRAL
C  BUT IN INCHES.
CRAL
      FROMCM=1./2.54
CRAL
      PAPERW=28.
C
C3084C THE 3084 PLOTTER HAS ITS ORIGIN THE OTHER SIDE, WITH X AND Y REVERSED,
C3084C  AND IT WORKS IN MILLIMETRES.
C3084      FROMCM=10.
C3084      PAPERW=30.
C3084      PTEMP(1,1)=0.
C3084      PTEMP(2,1)=1.
C3084      PTEMP(1,2)=-1.
C3084      PTEMP(2,2)=0.
C3084      PTEMP(1,3)=PAPERW
C3084      PTEMP(2,3)=0.
C
C SET UP CCSL TO PLOTTER TRANSFORMATION:
      CALL GMSCA(PTEMP,PTEMP,ABS(FROMCM),2,3)
      CALL PLTRIN(PTEMP,2,1)
	IF (IBMBER .NE. 0) RETURN
C
      GO TO 100
C
   3  IF (IABS(N) .GT. 500) GO TO 1
      IF (N .LT. 0) GO TO 2
C
C BASIC PEN MOVING: 2=DOWN, 3=UP
CVMS
      IF ((N .EQ.2) .OR. (N .EQ. 3)) GO TO 4
C3084      IF (N .EQ. 2) GO TO 4
C3084      IF (N .EQ. 3) GO TO 5
      CALL ERRMES(-1,0,'call of PIGLET with small N not 2 or 3')
C
C3084C INSTALLATION DEPENDENT LIBRARY CALLS FOR CURVE PLOTTING ON 3084
C3084C 'DRAW TO'
C3084   4  CALL GLDT2S(X,Y)
C3084      GO TO 100
C3084C 'MOVE TO'
C3084   5  CALL GLMT2S(X,Y)
C
CVMS
C   4  CALL PLOT(X,Y,N)
4     CONTINUE
      GO TO 100
C
C PEN COLOUR CHANGE:
C3084   2  CALL GLDV2S(-N)
CVMS
C   2  CALL NEWPEN(-N)
2     CONTINUE
      GO TO 100
C
C START/FINISH ROUTINES:
C INPUT X AND Y WERE IN CCSL UNITS - PUT INTO PLOTTER:
   1  CALL PLCONV(X,Y,2,XX,YY,1)
C>> JCC added
      IF (IBMBER .NE. 0) RETURN
      IF (IABS(N) .NE. 999) GO TO 100
C ONLY "START/STOP PLOT" IS RELEVANT HERE AT PRESENT:
C3084      IF (N .EQ. -999) GO TO 9
C3084C INITIALISE PACKAGE:
C3084      CALL GLPC2S
C3084C TIE UP PLOTTING WITH JCL ITEM LABELLED 'PLOT';  ASK FOR PAPER WHICH IS
C3084C 300 MMS WIDE (MAXIMUM 30 CMS AS SET IN PAPERW IN ROUTINE FRIG AND ALREADY
C3084C CHECKED) AND MAX 6 METRES LONG (NO CHECK AT PRESENT)
C3084C
C3084C THE LAST PARAMETER IS THE RATIO OF THE LENGTH TO THE WIDTH
C3084      CALL GLPS2S('PLOT    ',300.0,20.001)
C3084C THESE NEXT 4 PROVIDED BY CS - THIS SAYS IT DEFINES DEVICE WINDOW IN
C3084C NORMALISED DEVICE SPACE WITH PREFERRED WIDTH:
C3084      CALL GLWV4S(0.0, 0.05, 0.0, 1.0, 300.0)
C3084C THIS SAYS IT DEFINES USER VIEWPORT IN NORMALISED DEVICE SPACE:
C3084      CALL GLWV3S(0.0, 0.05, 0.0, 0.05)
C3084C AND THIS SAYS IT DEFINES USER WINDOW IN WORLD COORDINATE SPACE:
C3084      CALL GLWV2S(0.0, 300.0, 0.0, 300.0)
C3084C SELECT TRANSPARENT MODE FOR SOME REASON:
C3084      CALL GLMD3S(3)
C3084      GO TO 100
C3084C
C3084C FINISH PLOT:
C3084C CLOSE OUTPUT STREAM:
C3084   9  CALL GLPS7S
C3084C CLOSE PACKAGE:
C3084      CALL GLPC4S
C
CILL      IF (N .EQ. 999) CALL PLOTS(0,XX,YY)
CILL      IF (N .EQ. -999) CALL PLOT(0.,0.,999)
C
CRAL
C      IF (N .EQ. 999) CALL PLOTS(53,0,8)
CRAL
C      IF (N .EQ. -999) CALL PLOT(XX,-0.5,999)
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE PINITL
      SUBROUTINE PINITL
C
C *** PINITL by JCM 27 Jun 86 ***
C
CX
CC 14A
CH Initialises the system in order to make graphical output.
C
CD Sets up various quantities, some of them probably machine specific, to
CD enable SUBROUTINE PIGLET to be called.  PIGLET may well alter some
CD of them.  Suitable for either the plotter version or the Tektronix
C
CD  Sets    PAPERW = width of paper in cms (or no. of pixels)
CD          PAPERH = "height" of paper in cms - this is the maximum
CD                   amount allowed in direction perpendicular to the
CD                   axis of the plotter (or no. of pixels)
CD          FROMCM = the conversion factor from centimetres to hardware
CD                   units - set to 1 for now, and adjusted in PIGLET
CD                   where necessary (<0 for VDU output)
CD          CHUNIT = number of character units of a character grid which
CD                   make the height of a character (and also the maximum
CD                   width of a character, which may not use it all)
CD          ASPECT = ratio of the height of a plotted character to its width
CD          BORDER = width of border between pictures, in cms
CD          DASH = length of the dash of a dashed line, in cms
CD  Initialises the general structure of transformations in /PLODAT;
CD  does not initialise the basic 'CCSL to hardware' transformation,
CD which must be done in individual PIGLETs.
      DIMENSION PTEMP(2,3)
      COMMON /ADASH/DASH,X1,Y1,REM,IPEN,IDSH,DTRAN(2,2)
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
C>> JCC Implement error handling
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C RATIO OF HEIGHT OF CHARACTER TO ITS WIDTH:
      ASPECT=1.0
C   PAPERW AND PAPERH = MAXIMUM VALUES FOR WIDTH (CCSL Y DIRECTION) AND
C   HEIGHT (CCSL X DIRECTION, WHICH WOULD BE "INFINITE" IF A DRUM PLOTTER
C   IS BEING USED) EXPRESSED IN CCSL UNITS WHICH ARE ** CENTIMETRES **
C INITIALISATION IS FOR GRENOBLE BENSON:
      PAPERW = 72.
      PAPERH = 500.
C FROMCM = CONVERSION FACTOR FROM CMS TO HARDWARE UNITS:
      FROMCM=1.
C BORDER = SPACE BETWEEN ONE PICTURE AND THE NEXT IN A PLOT (SEE PIGLET
C FOR EXPLANATION)
      BORDER = 0.5
C CHUNIT IS THE NUMBER OF UNITS OF CHARACTER GRID WHICH MAKE THE HEIGHT OF A
C CHARACTER, AND THE MAXIMUM WIDTH (CHARACTERS MAY TAKE FEWER UNITS ACROSS).
      CHUNIT=30.
C LENGTH OF A DASH IN NEGATIVE CONTOURS IN CMS:
      DASH=0.2
C
C SET UP PICTURE TO CCSL TRANSFORMATION (DEFAULT 1 PICTURE):
      CALL GMZER(PTEMP,2,3)
      CALL GMUNI(PTEMP,2)
      CALL PLTRIN(PTEMP,3,2)
	IF (IBMBER .NE. 0) RETURN
C INITIALISE TRANSFORMATIONS:
      NSPCE=0
      NCON1=0
      NCON2=0
      MAXSP=2
      IDSH=0
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE PLCONV(X1,Y1,NN1,X2,Y2,NN2)
      SUBROUTINE PLCONV(X1,Y1,NN1,X2,Y2,NN2)
C
C *** PLCONV updated by PJB 4 Apr 85 ***
C
CX
CC 14B
CH Performs the transformation of coordinates between different plotter spaces.
CA On entry X1, Y1 are coordinates in coordinate system number NN1
CA On exit  X2, Y2 are the same coordinates transformed into the
CA                 coordinate system number NN2
C
CP PIGLET with N=0, PLTRIN to set up the required transformation matrices.
C
CD Coordinate systems:
CD 0=Current - The current space is held in NSPCE in COMMON /PLTRAN/
CD 1=Plotter (actual coords on a particular plotter)
CD 2=CCSL (the coords in which the programs are written)
CD Coordinate sytems 3 to 7 are for user applications, for example in plotting
CD Fourier maps they are used as follows:
CD 3=Picture (one "picture" which contains one section of the map)
CD 4=Map (The crystallographically related axes of the Fourier calculation)
CD 5=Character type 1 (a mesh of 30 by 30 on which characters are defined)
CD 6=Character type 2 (a mesh of 30 by 30 on which characters are defined)
CD 7=Character type 3 (a mesh of 30 by 30 on which characters are defined)
CD
CD Conversion involves both a translation (or origin shift) and a rotation.
CD These are combined by holding the conversion matrix as 3 by 2 with
CD the translation vector as the 3rd column.
C
      DIMENSION A(2,3),B(2,3),C(2,3)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
C
      N1=NN1
      N2=NN2
      IF (N1 .EQ. 0) N1=NSPCE
      IF (N2 .EQ. 0) N2=NSPCE
C  DO WE NEED A NEW MATRIX?
      IF (N1.EQ.NCON1 .AND. N2.EQ.NCON2) GO TO 101
C MAKE IT:
      N=N1-1
      M=N2-1
      CALL GMZER(A,2,3)
      A(1,1)=1.
      A(2,2)=1.
      CALL GMEQ(A,B,2,3)
    1 IF (N-M) 4,3,2
C
C  SOURCE SPACE HIGHER
    2 IF (N .LE. 0) GO TO 6
      CALL PMTMUL(PMTRIX(1,1,N),A,C)
      CALL GMEQ(C,A,2,3)
      N=NTRAN(N)-1
      GO TO 1
C
C  DESTINATION HIGHER
    4 IF (M .LE. 0) GO TO 6
C CHECK WHICH WAY ROUND THIS SHOULD BE:
      CALL PMTMUL(PMTRIX(1,1,M),B,C)
      CALL GMEQ(C,B,2,3)
      M=NTRAN(M)-1
      GO TO 1
C
C  SOURCE AND DESTINATION NOW THE SAME, FORM MATRIX
    3 CALL PMTINV(B,C)
      CALL PMTMUL(C,A,PTRAN(1,1,2))
C  AND SET NEW VALUES IN NCON
      NCON1=N1
      NCON2=N2
C  GO AND DO TRANSFORMATION
      GO TO 101
C
    6 WRITE (LPT,3000) N1,N2
      WRITE (ITO,3000) N1,N2
3000  FORMAT (' ERROR ** PLCONV REQUIRED TO CONVERT FROM COORDS',
     & I3,' TO COORDS',I3)
C>> JCC Was STOP
      CALL BMBOUT
	RETURN
C
 101  X2=PTRAN(1,1,2)*X1+PTRAN(1,2,2)*Y1+PTRAN(1,3,2)
      Y2=PTRAN(2,1,2)*X1+PTRAN(2,2,2)*Y1+PTRAN(2,3,2)
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PLOTCT(C,A,FOUND,M,N)
      SUBROUTINE PLOTCT(C,A,FOUND,M,N)
C
C *** PLOTCT by JCM 24 Nov 83 ***
C
CX
CC 14B
CH Plots a single contour throughout a given array.
CA On entry C is the contour value required
CA          A is a M by N array of values in which the contour C is to be
CA            interpolated
CA On exit  FOUND is true if a contour was found and plotted, false otherwise.
CP PIGLET with N=0 and N=999, to set up the plotter.
CP The desired mesh on the plotter should be set up with PLTRIN and SPCSET
CO Output is to a plotter whose characteristics are defined in the version of
CO PIGLET linked.
C
      LOGICAL FOUND,MID,TEST
      DIMENSION A(M,N),T(6)
      COMMON /BITMAP/IBIT(108,4),NWORDS
C>> JCC Implemented error handling
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
      FOUND = .FALSE.
      IPEN=3
      ICC=1
      IF (C) 6,7,8
   6  ICC=2
      IPEN=2
      GO TO 8
   7  IPEN=1
      ICC=14
C
C SELECT COLOUR OF PEN:
   8  CALL PIGLET(0.,0.,-IPEN)
      M2=M+2
      DO 1 I=1,M2
      DO 5 J = 1,4
    5 IBIT(I,J) = 0
      CALL MAKEBM(I,A,C,M,N)
   1  CONTINUE
      DO 2 I=1,M2
      DO 2 J=1,4
  22  IF (IBIT(I,J) .EQ. 0) GO TO 2
      FOUND = .TRUE.
      CALL LOCBIT(I,J,NR,NC,ISIDE,M,N)
	IF (IBMBER .NE. 0) RETURN ! Bomb out on error
C        SETS NR,NC TO TOP LEFT OF SQUARE - ISIDE = 1,2,3 OR 4
      CALL GETSQ(A,T,C,NR,NC,M,N)
      XPNT = 0.
      POINT = T(ISIDE)/(T(ISIDE) - T(ISIDE+1))
      LINE=0
      CALL DOSIDE (POINT,XPNT,ISIDE,NR,NC,X,Y)
      CALL DPLOT(X,Y,LINE)
      LINE = ICC
   4  MID = T(6) .GE. 0.
      IC = 0
      IF (MID .AND. T(ISIDE) .GE. 0. .OR. .NOT. MID .AND. T(ISIDE)
     & .LT. 0.) IC = 1
      ID = ISIDE + IC
   3  POINT = 0.5 * T(ID)/(T(ID) - T(6))
      XPNT = POINT
      IF (IC .NE. 0)  XPNT = 1.-POINT
      CALL DOSIDE (XPNT,POINT,ISIDE,NR,NC,X,Y)
      CALL DPLOT(X,Y,LINE)
      LINE = ICC
      ISIDE = ISIDE - 1 + IC + IC
      IF (ISIDE .EQ. 5)  ISIDE = 1
      IF (ISIDE .EQ. 0)  ISIDE = 4
      ID = ISIDE + IC
      IF (MID .AND. T(ID) .LT. 0. .OR. .NOT. MID .AND. T(ID)
     & .GE. 0.) GO TO 3
      XPNT = 0.
      POINT = T(ISIDE)/(T(ISIDE) - T(ISIDE+1))
      CALL DOSIDE (POINT,XPNT,ISIDE,NR,NC,X,Y)
      CALL DPLOT(X,Y,LINE)
      GO TO (11,12,13,14), ISIDE
  11  ISIDE = 3
      IF (NR .GT. 1) GO TO 21
      CALL BITSET(1,NC,TEST,.FALSE.)
  17  IF (TEST)  GO TO 22
      CALL ERRMES(-1,0,'in PLOTCT')
C
  21  NR = NR-1
      CALL BITSET(NR+4,NC,TEST,.FALSE.)
      IF (.NOT. TEST) GO TO 22
      GO TO 16
  12  NC = NC+1
      ISIDE = 4
      IF (NC .LT. N) GO TO 16
      CALL BITSET (2,NR,TEST,.FALSE.)
      GO TO 17
  13  NR = NR+1
      ISIDE = 1
      IF (NR .LT. M) GO TO 15
      CALL BITSET (3,N-NC,TEST,.FALSE.)
      GO TO 17
  14  NC = NC-1
      ISIDE = 2
      IF (NC .GT. 0) GO TO 16
      CALL BITSET(4,M-NR,TEST,.FALSE.)
      GO TO 17
  15  CALL BITSET(NR+3,NC,TEST,.FALSE.)
      IF (.NOT. TEST) GO TO 22
  16  CALL GETSQ(A,T,C,NR,NC,M,N)
      GO TO 4
   2  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE PLOTIT(X,NP,SIZE)
      SUBROUTINE PLOTIT(X,NP,SIZE)
C
C *** PLOTIT by PJB Sep 87 ***
C
CX
CC 14B
CH Plots the graph of given vector y against x, with esds.
CA On entry X(3,NP) holds values to be plotted
CA    X(1,1:NP)= x values
CA    X(2,1:NP) = y values
CA    X(3,1:NP) = standard deviations of y values
CA On entry NP = number of points in graph
CA          SIZE a vector of dimension 2 holds the lengths of the x and
CA                 y axes in cms.
CD This subroutine sets up the plotter as well as drawing the graph.*
CO Output to a plotter whose characteristics are defined in the version of
CO PIGLET linked.
C
      DIMENSION X(3,NP),SIZE(2)
      DIMENSION XMAX(2),XMIN(2)
C>> JCC Trap for error in GETSCL to prevent STOP
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C  FIND MAXIMUM AND MINIMUM VALUES
      DO 3 J=1,2
      XMAX(J)=X(J,1)
      XMIN(J)=X(J,1)
      DO 2 I=2,NP
      IF (XMAX(J).LT.X(J,I)) XMAX(J)=X(J,I)
      IF (XMIN(J).GT.X(J,I)) XMIN(J)=X(J,I)
    2 CONTINUE
C  SET SCALE
    3 CALL GETSCL(XMIN(J),XMAX(J),J)
	IF (IBMBER .GT. 0) RETURN
C
C  DRAW AXES ETC
      CALL PLOTO(SIZE(1),SIZE(2),.8,0)
	IF (IBMBER .GT. 0) RETURN

C
      DO 1 I=1,NP
      CALL PLOTO(X(1,I),X(2,I),X(3,I),2)
	IF (IBMBER .GT. 0) RETURN
    1 CONTINUE
C
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PLOTO(XX,YY,ER,MODE)
      SUBROUTINE PLOTO(XX,YY,ER,MODE)
C
C *** PLOTO updated by PJB/JCM 10 Jun 88 ***
C
CX
CC 14B
CH A multi-purpose graph-drawing routine.
CA On entry XX and YY are x and y coordinates whose meaning is defined by MODE:
CA MODE=0 Set up to draw a graph in which the lengths of the axes are x, y.
CA     >0 Line drawing: move the "pen" from its current position to x, y.
CA        If MODE = -1 the "pen" is down
CA                = -2 a dashed line is drawn. The dash interval is ER.
CA                = -3 the "pen" is up
CA        If -MODE > 10 and < 21 the symbol ABS(MODE+10) is drawn at
CA                   intervals of ER.
CA MODE>0 Plot the point x,y with an error bar of length ER. The value of
CA           MODE defines the symbol to be plotted.
CA           MODE = 1 square
CA           MODE = 2 triangle, apex up
CA           MODE = 3 triangle, apex down
CA           MODE = 4 hexagon, which if small will look like a circle
CA           MODE = 5 cross like x
CA           MODE = 6 cross like +
CA           MODE = 7 cross like x with top and bottom (egg-timer)
CA           MODE = 8 cross like x with sides (butterfly)
CA           MODE = 9 diamond
CP The vector X(I,J) held in COMMON /PLTS/ defines how the graph will be drawn
CP     I=1 for x-axis, I=2 for y-axis.
CP         J=1  length of axis in user units
CP         J=2  length of axis in cms.
CP         J=3  division of axis in user units
CP         J=4  minimum value in user units
CP         J=5  position of axis to be plotted
CP GETSCL should be called for both x and y axes, to define the ranges of
CP values to plot.
C
      DIMENSION YC(2),Y(2),XO(2),IPNT(2),ICH(2),AM(2,3)
      COMMON /ADASH/DASH,X1,Y1,REM,IPEN,IDSH,DTRAN(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
      COMMON /PLTS/X(2,5),S(2),CH,XS,ISIG(2),YS,NDIVS(2,2)
      COMMON /PLOTCH/ITEXT,NTEX(2)
      CHARACTER *80 ITEXT,NTEX*15
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      EQUIVALENCE (Y(1),A),(Y(2),B)
C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
      IF (MODE) 1,2,3
C
C  MODE=0 SET UP AND DRAW AXES
C
C  GET HOLD OF PLOTTER
    2 CALL PIGLET(0.,0.,0)
C  SET DASH LENGTH
      DASH=0.5
C  IF ABLE, ACCEPT TITLE (IF NOT, IT MUST BE SET UP BEFORE ENTRY):
      CALL ASK('Give title (up to 80 characters)')
      ITEXT=ICARD
C
C  SET LENGTHS OF AXES IN CMS
      X(1,2)=XX
      X(2,2)=YY
C  DETERMINE NUMBER OF FIGURES BEFORE AND AFTER DECIMAL POINT FOR
C  LABELLING AXES
      DO 21 I=1,2
      IPNT(I)=1-ISIG(I)
      ICH(I)=2+IABS(ISIG(I))
      IF (ISIG(I).EQ.0) ICH(I)=ICH(I)+1
      IF (ISIG(I).GT.1) ICH(I)=ICH(I)-1
C  SET SCALE OF GRAPH
      S(I)=X(I,2)/X(I,1)
   21 CONTINUE
C  LIMITING CHARACTER SIZE
      CLIM=1.5
      IF (ER.NE.0) CLIM=ER
C  NORMALLY CHARACTERS LABELLING AXES SHOULD TAKE HALF THE SPACE BETWEEN
C  LABELLED DIVISIONS IN THE X DIRECTION
      CH2=S(1)*X(1,3)/(2.*FLOAT(ICH(1)))
      IF (CH2.GT.CLIM) CH2=CLIM
C  ALEN IS THE LENGTH IN USER UNITS OF THE FIGURES ON THE Y-AXIS
      ALEN=(ICH(2)+3)*CH2/S(1)
C  SET XO TO BE MINIMUM VALUE IN USER UNITS INCLUDUNG SPACE FOR NUMBERS
      DO 31 I=1,2
      XO(I)=AMIN1(X(I,5)-ALEN,X(I,4))
   31 ALEN=4.*CH2/S(2)
C
C  SPACE FOR TITLE AND CHARACTER SIZE FOR TITLE
      ITITLE=LENGT(ITEXT)
      CALL KANGA2(0.,0.,TLEN,ITEXT,-ITITLE)
      TLEN=TLEN+2.*CHUNIT
      CH1=X(1,2)*CHUNIT/TLEN
      CLIM=1.5*CH2
      IF (CH1.GT.CLIM)CH1=CLIM
C  CENTRE TITLE
      ALEN=CH1*TLEN/CHUNIT
C      ALEN=((X(1,1)-XO(1))*S(1)-ALEN)/2.
       ALEN=BORDER+(X(1,4)-XO(1))*S(1)+(X(1,2)-ALEN)/2
C  ALEN IS DISTANCE IN CMS OF START OF TITLE FROM LH EDGE
C  SET SIZES OF OTHER MARKS
C  XS FOR DASHES ON AXES
      XS=0.4*CH2
C  YS FOR TOP AND BOTTOM OF ERROR BARS
      YS=0.6*CH2/S(1)
      CH=0.5*CH2
C
C  CHARACTER 1 SPACE - FOR TITLE
      AM(1,1)=CH1/CHUNIT
      AM(2,2)=AM(1,1)*ASPECT
      AM(1,2)=0.
      AM(2,1)=0.
      AM(1,3)=BORDER+ALEN
      AM(2,3)=BORDER
      CALL PLTRIN(AM,5,3)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
C  CHARACTER 2 ROTATED BY 90 DEGREES - FOR LABEL ON Y AXIS
      A1=CH2/CHUNIT
      A2=A1*ASPECT
      AM(1,2)=-A1
      AM(2,1)=A2
      AM(1,1)=0.
      AM(2,2)=0.
      AM(1,3)=BORDER-XO(1)*S(1)
C  CHANGE HERE WHEN NO TITLE
C      AM(2,3)=BORDER-XO(2)*S(2)+5*CH1
      AM(2,3)=BORDER-XO(2)*S(2)+2.*CH1
      CALL PLTRIN(AM,6,3)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C  CHARACTER 2 SPACE - FOR NUMBERS ON AXES AND X AXIS LABEL
      AM(1,1)=A1
      AM(2,2)=A2
      AM(1,2)=0.
      AM(2,1)=0.
      CALL PLTRIN(AM,7,3)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
C  GRAPH SPACE
      AM(1,1)=S(1)
      AM(2,2)=S(2)
      CALL PLTRIN(AM,4,3)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C  SIZE OF PLOT
      PW=X(1,2)+(X(1,4)-XO(1))*S(1)+(ICH(1)+3)*CH2+3.*BORDER
      PH=X(2,2)+(X(2,4)-XO(2))*S(2)+2.*BORDER+5.*CH1
C
      CALL PIGLET(PW,PH,999)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
      CALL PIGLET(0.,0.,-1)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
C  WRITE TITLE
      CALL SPCSET(5)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      IF (ITITLE.NE.0) THEN
      CALL KANGA2(CHUNIT,0.5*CHUNIT,TLEN,ITEXT,ITITLE)
      CALL FRAME(0.,0.,TLEN+2.*CHUNIT,2*CHUNIT)
      ENDIF
C
C  LABEL AXES
      CALL SPCSET(6)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      X1=X(1,5)
      X2=X(2,1)+X(2,4)-X(2,3)
      CALL PLCONV(X1,X2,4,YC(1),YC(2),6)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
      YC(2)=YC(2)+(ICH(2)+1)*CHUNIT
      N=LENG(NTEX(2),15)
      IF (N .GT. 0) THEN
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(2),-N)
        YC(1)=YC(1)-ALEN
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(2),N)
      ENDIF
      CALL SPCSET(7)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      X1=X(1,1)+X(1,4)-X(1,3)
      X2=X(2,5)
      CALL PLCONV(X1,X2,4,YC(1),YC(2),7)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
      N=LENG(NTEX(1),15)
      IF (N .GT. 0) THEN
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(1),-N)
        YC(1)=YC(1)-ALEN
        YC(2)=YC(2)-3*CHUNIT
        CALL KANGA2(YC(1),YC(2),ALEN,NTEX(1),N)
      ENDIF
C NOW LABEL THE DIVISIONS
      L=2
      DO 22 J=1,2
      VAL0=X(J,4)
      II=NDIVS(J,1)/5+NDIVS(J,2)/5 + 1
      NLFT=IFIX((ABS(X(J,4)/X(J,3)))+.001)
      VAL=SIGN(FLOAT(NLFT),X(J,4))*X(J,3)
C CASE WHERE ALL VALUES ARE POSITIVE
      IF (VAL0-VAL .GT. .01*X(J,3)) VAL=VAL+X(J,3)
      Y(J)=VAL+X(J,3)
      Y(L)=X(L,5)
      CALL PLCONV(Y(1),Y(2),4,YC(1),YC(2),7)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
      STEP=YC(J)
      Y(J)=VAL
      CALL PLCONV(Y(1),Y(2),4,YC(1),YC(2),7)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
C
      YC(L)=YC(L)-1.5*CHUNIT
      STEP=STEP-YC(J)
C
      DO 4 I=1,II
      IF (ABS(X(J,5)-VAL).LT.10E-4) GO TO 6
      IF (ABS(VAL).LT. 10E-5) GO TO 6
      CALL FETTLE(VAL,IW,IP)
      CALL NUMA1(VAL,IW,IP,IW,ITEXT)
      IW2=IW/2
      CALL KANGA2(YC(1)-IW2*CHUNIT,YC(2),ALEN,ITEXT,IW)
    6 YC(J)=YC(J)+STEP
      VAL=VAL+X(J,3)
    4 CONTINUE
      L=1
   22 CONTINUE
C
C  DRAW AXES
      L=2
      CALL SPCSET(4)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      DO 23 J=1,2
      YO=X(L,5)
      Y2=XS/S(L)
      Y1=YO+Y2
      Y2=Y1+Y2
      II=NDIVS(J,1)+NDIVS(J,2) + 1
      STEP=X(J,3)/5.
      Y(L)=YO
      Y(J)=X(J,4)
      CALL KANGA1(A,B,3)
      Y(J)=Y(J)+AMOD(X(J,4),STEP)
C
      DO 5 I=1,II
      CALL KANGA1(A,B,2)
      Y(L)=Y1
      BIT=X(J,3)/50.
      BITTLE=BIT/10.
      TEST=ABS(AMOD(ABS(Y(J))+BITTLE,X(J,3)))
      IF (TEST.LT.BIT) Y(L)=Y2
      CALL KANGA1(A,B,1)
      Y(L)=YO
      CALL KANGA1(A,B,3)
      Y(J)=Y(J)+STEP
    5 CONTINUE
      L=1
   23 CONTINUE
C
C
C USE THIS IF WANT A FRAME:
C      CALL SPCSET(2)
C      CALL FRAME(0.,0.,PW,PH)
      GO TO 100
C
C  ENTRY TO PLOT A POINT WITH AN ERROR BAR
    3 CALL SPCSET(4)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN
      A=XX
      B=YY
      X1=A-0.5*YS
      X2=X1+YS
C MAKE THE SYMBOLS BIGGER
      SIZ=1.5*YS*S(1)
      IF (ER.EQ.0) GO TO 20
      CALL KANGA3(A,B,SIZ,MODE)
      IF (2.*ER*S(2) .LT. SIZ) GO TO 100
      B=B+ER
      CALL KANGA1(X1,B,3)
      CALL KANGA1(X2,B,2)
      CALL KANGA1(A,B,3)
      B=B-2*ER
      CALL KANGA1(A,B,2)
      CALL KANGA1(X1,B,3)
      CALL KANGA1(X2,B,2)
      GO TO 100
C
C  ENTRY TO PLOT A VECTOR
    1 CALL SPCSET(4)
C>> JCC Added
	IF (IBMBER .NE. 0) RETURN

      IF (MODE.GE.-3) GO TO 40
C  SET UP FOR DASHED LINES
      DASH=ER
   40 J=IABS(MODE)
      IF (J.EQ.3) J=0
      CALL DPLOT(XX,YY,J)
      GO TO 100
C
C  CALCULATED POINT
   20 CALL KANGA3(A,B,SIZ,MODE)
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE PLTRIN(PMAT,N,M)
      SUBROUTINE PLTRIN(PMAT,N,M)
C
C *** PLTRIN by JCM 4 Apr 85 ***
C
CX
CC 14B
CH Defines a new coordinate transformation for plotting.
CA On entry PMAT is a 2 X 3 real matrix which defines the coordinate system
CA N with respect to M.
CA          PMAT(1:2,1:2) gives the scaling and rotation
CA          PMAT(1:2,3) gives the origin of space N with respect to that of
CA                      space M, in M's cordinates.
CA M must be greater than N
C
CD PMAT and N will be written as items number N-1 in PMTRIX and NTRAN in
CD COMMON /PLTRAN/. MAXSP in /PLTRAN/ holds the largest N yet given.
C
      DIMENSION PMAT(2,3)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
      IF (M .LT. N .AND. M .GT. 0) GO TO 1
      WRITE (LPT,3000) N,M
      WRITE (ITO,3000) N,M
3000  FORMAT (/' ERROR ** TRYING TO TRANSFORM FROM SPACE',I4,
     & ' TO SPACE',I4,' IN PLTRIN')
      IBMBER =  1
	RETURN
C
   1  CALL GMEQ(PMAT,PMTRIX(1,1,N-1),2,3)
      NTRAN(N-1)=M
      IF (N .GT. MAXSP) MAXSP=N
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE PLTTXT
      SUBROUTINE PLTTXT
C
C *** PLTTXT updated by JCM 29 Apr 92 ***
C
CX
CC 5B
CH Plots a block of explanatory text under a plotted Fourier map.
C
CD Plots the block of text which lists all the necessary details for
CD identification of the map.  Does this in what is for the Fourier plotting
CD "character 1 space", space number 5.
C
CO Outputs to graphical device as set up by PIGLET
C
      CHARACTER *10 MTYP(5)
      CHARACTER *1 IXCHR(2)
      CHARACTER *52 LINE1
      CHARACTER *58 LINE2
      CHARACTER *63 LINE3
      CHARACTER *50 LINE4
      CHARACTER *45 LINE5
      CHARACTER *22 LINE6
      CHARACTER *75 LINE7
      DIMENSION ITYPE(7)
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      DATA IXCHR/'X','Y'/
      DATA MTYP/'  FCALC','   FOBS','FOBS-FCALC',' FOBS**2',
     & 'SIGMA FOBS'/
      DATA LINE1/'    FOURIER PROJECTION DOWN'/
      DATA LINE2/'  FOURIER SECTION AT           ON'/
      DATA LINE3/'   parallel to                         from         to
     & '/
      DATA LINE4/'Coefficients are            multiplied by'/
      DATA LINE5/'    and averaged over a cube of edge'/
      DATA LINE6/'No resolution function'/
      DATA LINE7/'Bounded section from          to          on'/
      DATA ITYPE/1,2,2,3,3,4,5/

C>> JCC Added error trapping
	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0
C
C WE SHOULD BE NOW WORKING IN CHAR 1 SPACE:
      CALL SPCSET(5)
	IF (IBMBER .NE. 0) RETURN
C
C BLACK PEN:
      CALL PIGLET(0.,0.,-1)
	IF (IBMBER .NE. 0) RETURN
C
C
C COLLECT LENGTH OF LONGEST LINE FOR FRAME SIZE:
      A=0.
C
C LINES OF TEXT:
      IF (NDIM.EQ.3) GO TO 3
      IF (NDIM.EQ.4) GO TO 12
      DO 4 I=1,3
      CALL FETTLE(U(I,3),IW,IF)
   4  CALL NUMA1(U(I,3),IW,IF,8,LINE1(21+8*I:28+8*I))
      CALL KANGA2(CHUNIT,8.5*CHUNIT,TEMP,LINE1,52)
      IF (TEMP .GT. A) A=TEMP
      GO TO 5
    3 DO 6 I=1,3
      CALL FETTLE(U(I,3),IW,IF)
    6 CALL NUMA1(U(I,3),IW,IF,8,LINE2(27+8*I:34+8*I))
      CALL FETTLE(OUTLIM(1,3),IW,IF)
      CALL NUMA1(OUTLIM(1,3),IW,IF,9,LINE2(22:30))
      CALL KANGA2(CHUNIT,8.5*CHUNIT,TEMP,LINE2,58)
      IF (TEMP .GT. A) A=TEMP
      GO TO 5
C
  12  DO 13 I=1,3
      CALL FETTLE(U(I,3),IW,IF)
      IP=38+8*I
   13 CALL NUMA1(U(I,3),IW,IF,8,LINE7(IP:IP+7))
      CALL FETTLE(OUTLIM(1,3),IW,IF)
      CALL NUMA1(OUTLIM(1,3),IW,IF,9,LINE7(22:30))
      CALL FETTLE(SECEND,IW,IF)
      CALL NUMA1(SECEND,IW,IF,9,LINE7(33:41))
      CALL KANGA2(CHUNIT,8.5*CHUNIT,TEMP,LINE7,64)
      IF (TEMP .GT. A) A=TEMP
C
C LINES DESCRIBING AXES:
   5  Y=6.3*CHUNIT
      DO 1 J=1,2
      DO 8 I=1,3
      CALL FETTLE(U(I,J),IW,IF)
    8 CALL NUMA1(U(I,J),IW,IF,8,LINE3(7+8*I:14+8*I))
      DO 9 I=1,2
      CALL FETTLE(OUTLIM(I,J),IW,IF)
    9 CALL NUMA1(OUTLIM(I,J),IW,IF,7,LINE3(33+11*I:39+11*I))
      LINE3(2:2)=IXCHR(J)
      CALL KANGA2(CHUNIT,Y,TEMP,LINE3,62)
      IF (TEMP .GT. A) A=TEMP
    1 Y=Y-CHUNIT*2.
C
C COEFFICIENT TYPE AND SCALE FACTOR:
      J=ITYPE(MODEF)
      CALL FETTLE(SCALF1,IW,IF)
      CALL NUMA1(SCALF1,IW,IF,9,LINE4(42:50))
      LINE4(18:27)=MTYP(J)
      CALL KANGA2(CHUNIT,2.3*CHUNIT,TEMP,LINE4,50)
      IF (TEMP .GT. A) A=TEMP
C
C DECIDE ON MESSAGE ABOUT RESOLUTI0N FUNCTION
      IF (DELTA .NE. 0.) GO TO 11
      CALL KANGA2(8.*CHUNIT,CHUNIT/2.,TEMP,LINE6,22)
      IF (TEMP .GT. A) A=TEMP
      GO TO 101
  11  TWODEL=2.*DELTA
      CALL FETTLE(TWODEL,IW,IF)
      CALL NUMA1(TWODEL,IW,IF,8,LINE5(38:45))
      CALL KANGA2(CHUNIT,0.3*CHUNIT,TEMP,LINE5,45)
      IF (TEMP .GT. A) A=TEMP
C
C DRAW BOXES TO BE ROUND EXPLANATORY TEXT:
 101  CALL FRAME(0.,0.,A+2.*CHUNIT,10.*CHUNIT)
      CALL KANGA1(0.,4.*CHUNIT,3)
      CALL KANGA1(A+2.*CHUNIT,4.*CHUNIT,2)
      CALL KANGA1(A+2.*CHUNIT,8.*CHUNIT,3)
      CALL KANGA1(0.,8.*CHUNIT,2)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PMTINV(A,B)
      SUBROUTINE PMTINV(A,B)
C
C *** PMTINV by JCM 18 May 84 ***
C
CX
CC 14B
CH Specialist routine to invert a 2x3 matrix, such as those which transform
CH plotting coordinates from one space to another.
C
CA On entry A holds a 2x3 matrix as A(2,3)
CA On exit  B(2,3) holds the matrix representing the inverse transformation.
C
      DIMENSION A(2,3),B(2,3)
      D=1./(A(1,1)*A(2,2)-A(1,2)*A(2,1))
      B(1,1)=A(2,2)*D
      B(1,2)=-A(1,2)*D
      B(1,3)=(A(1,2)*A(2,3) - A(1,3)*A(2,2))*D
      B(2,1)=-A(2,1)*D
      B(2,2)=A(1,1)*D
      B(2,3)=(A(1,3)*A(2,1)-A(1,1)*A(2,3))*D
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE PMTMUL(A,B,C)
      SUBROUTINE PMTMUL(A,B,C)
C
C *** PMTMUL by JCM 1 May 84 ***
C
CX
CC 14B
CH Specialist routine to multiply together two 2x3 matrices, such as those
CH which transform plotting coordinates from one space to another.
C
CA On entry A and B are 2x3 real arrays
CA On exit  C represents the result of performing B then A.
C
      DIMENSION A(2,3),B(2,3),C(2,3)
C
      C(1,1)=A(1,1)*B(1,1)+A(1,2)*B(2,1)
      C(2,1)=A(2,1)*B(1,1)+A(2,2)*B(2,1)
      C(1,2)=A(1,1)*B(1,2)+A(1,2)*B(2,2)
      C(2,2)=A(2,1)*B(1,2)+A(2,2)*B(2,2)
      C(1,3)=A(1,1)*B(1,3)+A(1,2)*B(2,3)+A(1,3)
      C(2,3)=A(2,1)*B(1,3)+A(2,2)*B(2,3)+A(2,3)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE PRNTMP(L21)
      SUBROUTINE PRNTMP(L21)
C
C *** PRNTMP updated by PJB 29 Apr 88 ***
C
CX
CC 5B
CH Prints out a Fourier projection or one layer of a 3D Fourier.
C
CA On entry L21 is the number of I5 integers required on a line.
CP The values of points on the map must be in array dens in COMMON /MAPDA/,
CP They are usually put there by one of FOUR1Z, FOURGP, ERRMAP, or GETMAP
CP which of these is used is usually decided by FORIER in respons to requests
CP on the M "cards"
CO The array of values is rounded to I5 integers and printed in rows of L21
CO columns on unit LPT
C
C
      LOGICAL EXACT
      DIMENSION JDENS(100),IU(3,3)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
C
      WRITE (LPT,2000) NOBSIN,NUSED
2000  FORMAT ('1Layer of Fourier calculated reading',I10,' reflections',
     & ' and using',I10)
      IF (MODET .EQ. 1) THEN
      DO 4 I=1,3
   4  CALL INDFIX(U(1,I),IU(1,I))
      IF (NDIM .EQ. 2) WRITE (LPT,2001) (IU(I,3),I=1,3),((IU(I,J),
     & I=1,3),J=1,2)
2001  FORMAT (//' Fourier projection down',3I4,' axis'/' x-axis along',
     & 3I4,'  y-axis along',3I4)
      IF (NDIM .EQ. 3) WRITE (LPT,2002) (IU(I,3),I=1,3),OUTLIM(1,3),
     & ((IU(I,J),I=1,3),J=1,2)
2002  FORMAT (//' Fourier section through',3I4,' axis at height',
     & F8.4/' x-axis parallel to',3I4,'  y-axis parallel to',3I4)
      IF (NDIM .EQ. 4) WRITE (LPT,2007) (IU(I,3),I=1,3),OUTLIM(1,3),
     & SECEND,((IU(I,J),I=1,3),J=1,2)
2007  FORMAT (//' Bounded section on ',3I4,' axis from ',F7.4,' to'
     & ,F8.4/' x-axis parallel to',3I4,'  y-axis parallel to',3I4)
      ELSE
      WRITE (LPT,2009) (U(I,3),I=1,3),OUTLIM(1,3),((U(I,J),I=1,3),
     & J=1,2)
2009  FORMAT (//' Fourier section through',3F8.4,' axis at height',
     & F8.4/' x-axis parallel to',3F8.4,'  y-axis parallel to',3F8.4)
      ENDIF
      WRITE (LPT,2003) ((OUTLIM(I,J),I=1,3),J=1,2)
2003  FORMAT (/' Rows of constant x and columns of constant y'/' x',
     & ' varies down the page from',F6.3,' to',F6.3,' in steps of',F6.3/
     & ' y varies along a row from',F6.3,' to',F6.3,' in steps of',F6.3)
      NL = NY/L21
      NR = MOD(NY,L21)
      EXACT = (NR .EQ. 0)
      IF (.NOT. EXACT) NL=NL+1
      DO 1 IX = 1,NX
      CALL MESS(LPT,1,' ')
      M = IX
      DO 2 N = 1,NL
      NEND=L21
      IF (N .EQ. NL .AND. .NOT. EXACT) NEND=NR
      DO 3 I=1,NEND
      JDENS(I) = NINT(DENS(M))
    3 M = M+NX
    2 WRITE (LPT,2004) (JDENS(I),I=1,NEND)
2004  FORMAT (1X,100(I6))
    1 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE QFOUIN(K,F,ALPHA,ENDD)
      SUBROUTINE QFOUIN(K,F,ALPHA,ENDD)
C
C *** QFOUIN DUMMY by JCM 20 Mar 84 ***
C
CX
CC 5B
CH In the library, simply a dummy routine.  If the user wishes some special
CH new input format for Fourier routines, he provides a new version of
CH QFOUIN.
C
CD Called when type 0 Fourier coefficient input is specified.  The user-
CD supplied routine must set:
CD K(1:3) = h,k,l
CD F(1:2) and PHASE according to the value of DTYP on an "M" card,
CD LOGICAL ENDD to be TRUE if there are no more items of data.
C
      LOGICAL ENDD
      DIMENSION K(3),F(2)
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE READMP
      SUBROUTINE READMP
C
C *** READMP updated by JCM 22 Aug 86 ***
C
CX
CC 5B
CH Reads into the array DENS a map previously written to file, unformatted.
C
CP Assumes simply that NX by NY numbers have been written to unit IDUMPR
C
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPRD/ZRDVAL(20),ZCRD,IRD,IZRD,IDUMPR
C
      I=0
      DO 1 IY=1,NY
      READ (IDUMPR) (DENS(I+J),J=1,NX)
   1  I=I+NX
      RETURN
      END
C
C
C
C
C LEVEL 3      FUNCTION RESOL(H,D)
      FUNCTION RESOL(H,D)
C
C *** RESOL by JCM 17 Apr 84 ***
C
CX
CC 5B
CH Calculates a resolution function for use with Fourier inversion.
CA On entry H(1:3) contains the indices h,k,l of a reflection.
CA          D is the resolution length in Angstroms.
CD The function value returned in RESOL multiplies the amplitude of the
CD term corresponding to H in the Fourier sum. The result corresponds
CD to averaging the density over a cube of edge 2D.
C
CP RECIP to set up the metric
C
      DIMENSION H(3),OH(3)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
C
      RESOL=1.
      IF (ABS(D) .LT. 0.00001) GO TO 100
      CALL ORTHO(H,OH,2)
      DO 1 I = 1,3
      A = TWOPI*OH(I)*D
      IF (ABS(A) .LT. .001) GO TO 1
      RESOL = RESOL*SIN(A)/A
    1 CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE SAVMAP
      SUBROUTINE SAVMAP
C
C *** SAVMAP updated by JCM 10 May 88 ***
C
CX
CC 5B
CH Writes 1 layer of map to given file, plus information for later retrieval.
C
CP One of FOUR1Z, FOURGP etc must have been obeyed first to produce map.
C
CO Writes on first entry a header block, plus one map;  on subsequent entries,
CO one map, and on the final entry one map and a trailer block.
C
CO The material written is the value of Z, NOBS and NUSED, and the array DENS.
C
CN The map can be later got back by GETMAP.
C
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPSV/ZSVVAL(20),ZCSV,ISV,IZSV,NDUMPS,NSAV
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)

C
C
C NSAV=HOW MANY MAPS ALREADY SENT - IF 0, SEND HEADER:
      IF (NSAV .GT. 0) GO TO 2
C
C * THERE IS A STRONG SUSPICION THAT THE USE OF NTOTAL WILL SIMPLIFY THIS
C COUNT AND CHECK NUMBER OF CARDS IN FILE IO10:
      NCDS=0
      DO 5 I=1,26
   5  NCDS=NCDS+ICDNO(I)
      WRITE (NDUMPS) INREAD,ICDNO,NCDS
      ICD=0
      ID=0
   9  ID=ID+1
      IF (ID .GT. NTOTAL(1)) GO TO 6
      READ (IO10,REC=ID,FMT=1000) ICARD
1000  FORMAT (A80)
      WRITE (NDUMPS) ICARD
      IF (ICARD(1:1) .NE. 'Y' .AND. ICARD(1:1) .NE. 'Z')ICD=ICD+1
      GO TO 9
C
   6  IF (ICD .EQ. NCDS) GO TO 2
      WRITE (LPT,3000) IO10,NCDS
      WRITE (ITO,3000) IO10,NCDS
3000  FORMAT (/' ERROR ** FILE',I3,' AND VECTOR ICDNO ARE',
     & ' OUT OF STEP - ICDNO EXPECTS',I4,' CARDS')
C>> JCC Was      STOP
	CALL BMBOUT
	RETURN
C
C WRITE INFO FOR ONE MAP:
   2  WRITE (NDUMPS) OUTLIM(1,3),NOBSIN,NUSED,NX,NY
      I=0
      DO  4 IY=1,NY
      WRITE (NDUMPS) (DENS(I+J),J=1,NX)
   4  I=I+NX
      NSAV=NSAV+1
C
 101  IF (NSAV .EQ. 1) WRITE (LPT,2003) NCDS
2003  FORMAT (/' Header record with',I4,' cards written')
      IF (NDIM .EQ. 2) WRITE (LPT,2001) NSAV
2001  FORMAT (/' Map no.',I3,' saved')
      IF (NDIM .EQ. 3) WRITE (LPT,2002) NSAV,OUTLIM(1,3)
2002  FORMAT (/' Map no.',I3,' saved for Z=',F10.4)
      IF (ZCSV .LE. 99998.) GO TO 100
C
C WRITE TRAILER:
      WRITE (NDUMPS) 99999.,0,0,0,0
      CALL MESS(LPT,1,'Trailer record written')
 100  RETURN
      END
C
C
C
C
C LEVEL 11      SUBROUTINE SETFOU
      SUBROUTINE SETFOU
C
C *** SETFOU updated by JCM 22 Aug 86  ***
C
CX
CC 5A
CH Sets up data for Fourier map calculations.
CD Reads in:  one "N" card with the title
CD            several "M" cards with map information (including that
CD            for contour plotting if required by user)
CD Sets up:   COMMON ready for calls of FORIER, which will then organise
CD            the actual calculation of (possibly several) maps, and their
CD            plotting, printing and saving as requested.
CD
CD Sets defaults of: 3 dimensions if no M NDIM card is given
CD            no resolution if no M DELT card is given
CD            a scale for Fourier coefficients of 1. if no M SCAL card is given
CD            a map scale of 2.5 cm/Angstrom if no M CM/A card is given.
CD Checks that M cards have been read for DTYP, SMAX, FTYP, MESH.
CI Causes "N" and "M" cards to be read from the copy of the Crystal
CI Data File on unit IO10.
CO Writes its findings to unit LPT.
C
      LOGICAL TESTOV
      DIMENSION KLIM(3),UU(3,3),NPOINT(100)
      COMMON /CELPAR/CELL(3,3,2),V(2),ORTH(3,3,2),CPARS(6,2),KCPARS(6),
     & CELESD(6,6,2),CELLSD(6,6),KOM4
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /FRIED/FRIEDL,KOM8
      LOGICAL FRIEDL
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
      COMMON /MAPPR/ZPRVAL(20),ZCPR,IPR,IZPR
      COMMON /MAPRD/ZRDVAL(20),ZCRD,IRD,IZRD,IDUMPR
      COMMON /MAPSV/ZSVVAL(20),ZCSV,ISV,IZSV,NDUMPS,NSAV
      COMMON /MREAD/IMREAD(15)
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP

C
C RECIP MUST BE OBEYED FIRST (AND THEREFORE SYMOP ALSO)
      IF (INREAD(3) .GT. 0) CALL RECIP
C
C COMMENT THAT FRIED CANNOT BE USED (IF FALSE) HERE:
      IF (.NOT. FRIEDL) CALL MESS(LPT,1,
     & 'Friedel''s law being assumed for Fourier')
C
C READ, STORE AND PRINT TITLE FROM AN "N" CARD:
      CALL INPUTN(LPT)
C
C NOW READ ALL "M" CARDS:
      CALL INPUTM
C
C NOW CHECK ALL INFO GIVEN, AND WRITE OUT FOR THOSE CARDS NOT GIVEN
      IF (IMREAD(11) .EQ. 0) CALL ERRMES(2,1,
     & 'M DTYP card giving data input type')
C
      IF (IMREAD(12) .LE. 0) THEN
        CALL MESS(LPT,1,'No resolution function')
        DELTA=0.
      ENDIF
C
      IF (IMREAD(15) .LE. 0) CALL ERRMES(2,1,
     & 'sin theta/lambda maximum')
C
      IF (IMREAD(13) .EQ. 0) SCALF1=1.0
C
      IF (IMREAD(1) .LE. 0) THEN
        NDIM=3
        CALL MESS(LPT,1,'No M NDIM card - assuming 3D')
      ENDIF
C
      IF (IMREAD(2) .LE. 0) CALL ERRMES(2,1,
     & 'M FTYP card giving type of Fourier required')
C
      IF (IMREAD(3) .LE. 0) CALL ERRMES(2,1,
     & 'M MESH card giving mesh for output')
C
      IF ((IMREAD(6) .NE. 0) .AND. (IMREAD(7) .LE. 0)) THEN
        SCALMP=2.5
       CALL MESS(LPT,1,
     & 'Default scale of 2.5 cm/Angstrom for plotted map')
      ENDIF
C
C SET UP SCALE ACCORDING TO NUMBER OF DIMENSIONS:
      IF (IMREAD(4) .EQ. 0) THEN
        CALL GMUNI(U,3)
        MODET=0
      ENDIF
      IF (MODET.EQ.1) THEN
        M=1
      ELSE
        M=0
      ENDIF
      CALL USYM(M)
C
C WE ARE NOW DOWN TO DECIDING WHERE THE MAP IS TO COME FROM, AND WHAT IS
C TO BE DONE WITH IT ONCE WE HAVE IT.
C
C SAVE, GET, READ, PRIN AND PLOT CARDS HAVE ALL BEEN INTERPRETED IN INPUTM.
C HERE WE NEED ONLY MAKE SURE WE HAVE SOMETHING SENSIBLE TO DO.
C
C FIRST SORT ALL LISTS INTO ASCENDING ORDER:
      IF (NCONT .GT. 0) THEN
        CALL SORTX(CONT,NPOINT,NCONT)
        CALL RESHUF(CONT,NPOINT,NCONT)
      ENDIF
      IF (IZPR .GT. 0) THEN
        CALL SORTX(ZPRVAL,NPOINT,IZPR)
        CALL RESHUF(ZPRVAL,NPOINT,IZPR)
      ENDIF
      IF (IZPL .GT. 0) THEN
        CALL SORTX(ZPLVAL,NPOINT,IZPL)
        CALL RESHUF(ZPLVAL,NPOINT,IZPL)
      ENDIF
      IF (IZSV .GT. 0) THEN
        CALL SORTX(ZSVVAL,NPOINT,IZSV)
        CALL RESHUF(ZSVVAL,NPOINT,IZSV)
      ENDIF
      IF (IZRD .GT. 0) THEN
        CALL SORTX(ZRDVAL,NPOINT,IZRD)
        CALL RESHUF(ZRDVAL,NPOINT,IZRD)
      ENDIF
      IF (IZGT .GT. 0) THEN
        CALL SORTX(ZGTVAL,NPOINT,IZGT)
        CALL RESHUF(ZGTVAL,NPOINT,IZGT)
      ENDIF
C
      IF ((IMREAD(5) .LE. 0).AND.(IMREAD(6) .LE. 0).AND.(IMREAD
     & (9) .LE. 0)) CALL ERRMES(1,1,
     & 'no M PRIN, M PLOT or M SAVE cards')
C
      SCALF2=V(2)
      IF (NDIM .EQ. 2) SCALF2=SCALF2*VCTMOD(1.,U(1,3),1)
C
C CALCULATE AND CHECK MAXIMUM VALUES OF INDICES, LIMITS ETC:
      CALL GMUNI(UU,3)
      IF (MODET .EQ.1) CALL GMEQ(U,UU,3,3)
      DO 1 I=1,2
      KLIM(I)=IFIX(VCTMOD(2.*SMAX,UU(1,I),1))
      IF (TESTOV(1.,OUTLIM(3,I))) THEN
        CALL ERRIN2(I,1,'zero step length for Fourier in direction',' ')
        GO TO 1
      ENDIF
C
      IF (OUTLIM(3,I) .LE. 0.) THEN
        WRITE (LPT,3001) OUTLIM(3,I),I
        WRITE (ITO,3001) OUTLIM(3,I),I
3001    FORMAT (' ERROR ** Negative step for Fourier',F10.4,
     & ' in direction',I2)
        IERR=IERR+1
        GO TO 1
      ENDIF
C
      NN=NINT((OUTLIM(2,I)-OUTLIM(1,I)+10.E-5)/OUTLIM(3,I)) +1
      IF (I .EQ. 1) NX=NN
      IF (I .EQ. 2) NY=NN
      IF (NN .GT. 0) GO TO 1
      WRITE (LPT,3002) NN,I
      WRITE (ITO,3002) NN,I
3002  FORMAT (' ERROR ** Negative number',I3,' of points ',
     & 'required for Fourier in direction',I2)
      IERR=IERR+1
   1  CONTINUE
C
C CHECK STORAGE LIMITS:
      NH=2*KLIM(1)+1
      NK=KLIM(2)+1
      NHK=2*NH*NK
      IF (NHK .GT. 10201) THEN
        WRITE (LPT,3010) KLIM(1),KLIM(2),NHK
        WRITE (ITO,3010) KLIM(1),KLIM(2),NHK
3010    FORMAT (/' ERROR ** Too much data for Fourier store'/
     &  ' h max=',I4,' k max=',I4, 'needing space',I7,' - only 10201',
     &  ' available')
C>> JCC WAS STOP
        CALL BMBOUT
	  RETURN
      ENDIF
C
      NXY=NX*NY
      IF (NXY .GT. 10201) THEN
        WRITE (LPT,3011) NX,NY,NXY
        WRITE (ITO,3011) NX,NY,NXY
3011    FORMAT (/' ERROR ** Too much data for Fourier store'/
     & ' No. of points in x direction =',I5/
     & ' no. of points in y direction =',I5/
     & ' requiring store',i7,' - only 10201 available')
C>> JCC WAS STOP
        CALL BMBOUT
	  RETURN
      ENDIF
C
      IF (MODET.EQ.2) THEN
C  REDEFINE NH,NK,NHK TO BE MAX VALUES OF INDICES FOR GENERAL PLANE FOURIER
        NHK=IFIX(VCTMOD(2.*SMAX,UU(1,3),1))
        NH=KLIM(1)
      ELSE
        NKX=2*NK*NX
        IF (NKX .GT. 10201) THEN
          WRITE (LPT,3012) KLIM(1),NX,NKX
          WRITE (ITO,3012) KLIM(1),NX,NKX
3012      FORMAT (/' Error ** too much data for Fourier store'/
     &    ' k max =',I4,' no. of points in x direction =',I5/
     &    ' requiring store',i7,' - only 10201 available')
          CALL BMBOUT
	    RETURN
        ENDIF
C
        CALL ERRCHK(1,KLIM(1)+1,100,0,'h values in Fourier')
        CALL ERRCHK(1,NK,100,0,'k values in Fourier')
      ENDIF
C
C NOW DISCOVER WHETHER PLOTTING
      IF (IMREAD(6) .NE. 0) CALL STPLOT
      IF (IERR .NE. 0) CALL ERRMES(1,0,'during SETFOU')
C
 100  RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE SPCSET(N)
      SUBROUTINE SPCSET(N)
C
C *** SPCSET updated by JCM 14 Nov 89 ***
C
CX
CC 14B
CH Defines the "space" in which coordinates will be given for plotting.
CA On entry N is the number of the space in which subsequent "plot"
CA            coordinates will be given.
C
CD The current space is held in NSPCE in COMMON /PLTRAN/.
CD  Coordinate systems useful in most plotting applications:
CD        1=Plotter (actual coordinates on a particular graphical output device)
CD        2=CCSL (the coordinates in which the programs are written)
CD Coordinate sytems 3 to 7 are for user applications; for example in plotting
CD Fourier maps they are used as follows:
CD        3=Picture (one "picture" which contains one section of the map)
CD        4=Map (The crystallographically related axes of the Fourier
CD               calculation).
CD        5=Character type 1 (in contouring, the text under the map)
CD        6=Character type 2 ( the title over the map)
CD        7=Character type 3 (the contour list panel)
C
CD A new conversion matrix is set up into PTRAN(,,1).
CD It should take a point expressed in current coordinates (space N) into
CD plotter coordinates (space 1).
C
CP PLTRIN  must have been used to set up matrices defining the
CP transformation from space N to "plotter" space.
C
CP For plotting FOURIERS:
CP Matrix 1 takes CCSL into plotter
CP Matrix 2 takes picture into CCSL
CP Matrix 3 takes map into picture
CP Matrix 4 takes char 1 into picture
CP Matrix 5 takes char 2 into picture (if required)
CP Matrix 6 takes char 3 into picture (if required)
CP
CP These must have been set up initially.  They are mostly unchanging,
CP but to move from one picture to the next we alter column 3 of matrix 2.
C
      DIMENSION PTEMP(2,3)
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
C
C CHECK PLAUSIBLE N:
      IF (N .LE. 0 .OR. N .GT. MAXSP) CALL ERRIN2(N,0,
     & 'cannot set space','in SPCSET')
C
   1  IF (N .GT. 1) GO TO 2
      CALL GMZER(PTRAN(1,1,1),2,3)
      CALL GMUNI(PTRAN(1,1,1),2)
      GO TO 101
C
C ANY SPACE OTHER THAN 1:
   2  M=N-1
      CALL GMEQ(PMTRIX(1,1,M),PTRAN(1,1,1),2,3)
C
C HAVE WE REACHED PLOTTER SPACE YET?
   3  M=NTRAN(M)-1
      IF (M .LT. 0) CALL ERRIN2(N,0,'Space',
     & 'in plotting not available - check setting up')
      IF (M .EQ. 0) GO TO 101
      CALL PMTMUL(PMTRIX(1,1,M),PTRAN(1,1,1),PTEMP)
      CALL GMEQ(PTEMP,PTRAN(1,1,1),2,3)
      GO TO 3
C
 101  NSPCE=N
      RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE STPLOT
      SUBROUTINE STPLOT
C
C *** STPLOT updated by JCM 26 Sep 87 ***
C
CX
CC 14A
CH Sets up the plotting of maps;  fits elements of a picture together.
C
CP Plotting of a Fourier map must be set up by SETFOU.  In particular:
CP NX=number of x values wanted for plotted points
CP NY=number of y values wanted for plotted points
CP PMAP(2,2) in /CONTUR/ holds the matrix which converts map coords
CP       to cms, set by USYM.
CP There is a title in ITITLE, of length NTITLE, read by INPUTN
C
CD Calls the special plotting routine PIGLET to do whatever is necessary
CD locally to start using graphical output.
CD
CD Decides the scales of various sizes of characters which will be
CD written on a picture.  Sets up all conversion matrices needed in
CD subsequent map plotting, by calculating the layout of the various
CD elements of a picture (map, title, expanatory text, etc) within its
CD frame.
CD
CD Finally calls PIGLET to do whatever is required locally to start the
CD whole plot, now we know how big it will be.
C
      DIMENSION PTEMP(2,3)
      COMMON /BITMAP/IBIT(108,4),NWORDS
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /LENINT/NBITS
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NTITL/NTITLE,KOM14
      COMMON /PLODAT/PAPERW,PAPERH,ASPECT,BORDER,CHUNIT,FROMCM
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
      COMMON /TITLE/ITITLE
      CHARACTER *80 ITITLE
C>> JCC Implement error tracking rather than stopping

	INTEGER IBMBER
      COMMON / CCSLER / IBMBER
	IBMBER = 0

C
C INITIALISE ANY SPECIAL HARDWARE QUANTITIES FOR PLOTTER:
      CALL PIGLET(0.,0.,0)
	IF (IBMBER .NE. 0) RETURN
C
C SET UP NWORDS=NUMBER OF CONSECUTIVE INTEGERS OF LENGTH NBITS NEEDED TO
C TAKE 108 BITS (OR WHATEVER IS SET UP):
C%
C      NWORDS=IFIX(%CBIT%./FLOAT(NBITS))+1
      NWORDS=IFIX(108./FLOAT(NBITS))+1
C
C WE MUST CHECK THAT THERE IS ROOM FOR NX ROWS + 2 EDGES IN THE LONG
C DIMENSION OF IBIT, AND THAT BOTH THE NUMBER OF ROWS AND THE NUMBER OF COLUMNS
C WILL FIT IN THE "BITS ALLOWED PER ROW", WHICH IS THE SHORTER DIMENSION
C OF IBIT TIMES THE WORD LENGTH IN NBITS.
C
C NBITS IS ACTUALLY THE WORD LENGTH MINUS ONE, TO AVOID THE SIGN BIT.
C
C%
C      M1DIM=%CBIT%
      M1DIM=108
      M2=NX+2
      MSIZE=NBITS*NWORDS
      M1DIM2=M1DIM-2
      IF (M1DIM2 .LT. NX) THEN
        WRITE (LPT,3000) M1DIM2,NX
        WRITE (ITO,3000) M1DIM2,NX
3000    FORMAT (' ERROR ** Too many x values to plot -',I5,
     &  ' allowed by parameter CM1-2,',I5,' given')
C>> JCC Was STOP
        CALL BMBOUT
	  RETURN
      ENDIF
C
      IF (NX .GT. MSIZE) THEN
        WRITE (LPT,3001) NX,NBITS,NWORDS
        WRITE (ITO,3001) NX,NBITS,NWORDS
3001    FORMAT (' ERROR ** Too many x values to plot -',I5,
     &  ' requested - NBITS,NWORDS in STPLOT=',2I5)
C>> JCC Was STOP
        CALL BMBOUT
	  RETURN
      ENDIF
C
      IF (NY .GT. MSIZE) THEN
        CALL ERRIN2(NY,-1,'too many y values to plot -','requested')
        WRITE (LPT,3003) MSIZE,NWORDS,NBITS
        WRITE (ITO,3003) MSIZE,NWORDS,NBITS
3003    FORMAT (' but only space for',I5,' arising from',I5,' words',
     &  ' using',I5,' bits in each')
C>> JCC Was STOP
        CALL BMBOUT
	  RETURN	  
      ENDIF
C
      FX=FLOAT(NX-1)
      FY=FLOAT(NY-1)
C
C PMAP HAS BEEN SET UP IN USYM FOR MAP TO CMS CONVERSION:
      HGTMAP=-PMAP(2,1)*FX
C WIDTH OF PROJECTING PIECE OF MAP:
      WIDPRO=ABS(PMAP(1,1)*FX)
      WIDMAP=WIDPRO+PMAP(1,2)*FY
C
C DECIDE CHARACTER SCALES - FIRST TYPE 1, THE TEXT BLOCK:
C FIRST TRY TO MAKE THE TEXT BLOCK THE SAME WIDTH AS THE MAP:
      CHSCAL(1,1)=WIDMAP/1050.
C 1050 IS A GUESS, BEING  AN ARBITRARY AMOUNT TO BE THE WIDTH OF A LINE
C OF TEXT, THE WHOLE THING BEING IN CHARACTER COORDINATES.  THE BEST SIZE FOR
C THE FRAME IS CALCULATED IN PLTTXT.
      CHSCAL(2,1)=ASPECT*CHSCAL(1,1)
C IF CHARS TYPE 1 ARE MORE THAN 1 CM OR LESS THAN 0.2 CMS, ADJUST SO THAT THEY
C HIT THE LIMIT:
      CLIM1=1./CHUNIT
      CLIM2=0.2/CHUNIT
      IF (CHSCAL(2,1) .GT. CLIM1) CHSCAL(2,1)=CLIM1
      IF (CHSCAL(2,1) .LT. CLIM2) CHSCAL(2,1)=CLIM2
      CHSCAL(1,1)=CHSCAL(2,1)/ASPECT
C ALL WIDTHS OF ITEMS IN PICTURE ARE WANTED IN CMS:
      WIDTXT=CHSCAL(1,1)*1050.
      HGTTXT=10.*CHSCAL(2,1)*CHUNIT
C THE 10 COVERS 5 LINES OF TEXT AND 5 BLANKS IN BETWEEN
C
C CHAR TYPE 1 IS DEFINITIVE FOR ALL THE WHITE SPACE AND INTERNAL BORDERS:
      XWHITE=CHSCAL(1,1)*CHUNIT
      YWHITE=CHSCAL(2,1)*CHUNIT
      XMARG=4.*XWHITE
      YMARG=4.*YWHITE
C
C NOW CHARACTER TYPE 2, THE TITLE.  WE MAKE THIS MATCH THE TEXT BLOCK BY
C TRYING TO MAKE THEIR WIDTHS THE SAME, BUT IF THIS GIVES CHAR TYPE 2 OF
C MORE THAN 1.5 CMS HIGH, WE ALLOW IT TO BE SMALLER:
C
C FIRST MEASURE LENGTH OF TITLE IN CHARACTER UNITS:
      CALL KANGA2(0.,0.,TLEN,ITITLE,-NTITLE)
      TLEN=TLEN+2.*CHUNIT
      CHSCAL(1,2)=WIDTXT/TLEN
      CLIM1=1.5/CHUNIT
      IF (CHSCAL(1,2) .GT. CLIM1) CHSCAL(1,2)=CLIM1
      CHSCAL(2,2)=CHSCAL(1,2)*ASPECT
      WIDTTL=TLEN*CHSCAL(1,2)
      HGTTTL=2.*CHSCAL(2,2)*CHUNIT
C
C DO NOTHING ABOUT CHARACTER TYPE 3 - CONTOUR LIST PANEL YET:
C A DIGIT IS 20 PLOTTER UNITS WIDE - PRETEND USING TYPE 1 FOR NOW:
      WIDCON=220.*CHSCAL(1,1)
      WIDMAX=WIDMAP
      IF (WIDTXT .GT. WIDMAP) WIDMAX=WIDTXT
      WIDPIC=3.*XMARG+WIDMAX+WIDCON
      HGTPIC=4.*YMARG+HGTMAP+HGTTXT+HGTTTL+2.*YWHITE
C
C NOW SET UP THE VARIOUS MATRICES WHICH MOVE FROM ONE SPACE TO ANOTHER:
C
C A TRANSFORMATION TAKES THE FORM:
C        A B C    OLD X = NEW X
C        D E F    OLD Y   NEW Y
C                  1
C SO A,B,D,E ROTATES OLD X,OLD Y AND C,F GIVES A TRANSLATION.  THUS C AND
C F ARE IN THE SAME UNITS AS NEW X, NEW Y.
C
C PMTRIX 1 MOVES FROM CCSL TO PLOTTER - IT HAS BEEN SET UP IN PINTIL
C
C PMTRIX 2 MOVES FROM PICTURE TO CCSL - WE HAVE NO REASON TO ALTER THE SCALE OR
C ORIENTATION OF A PICTURE IN CCSL SPACE.  (IF, LATER, WE WANT TO DO THIS, HERE
C IS THE PLACE TO DO IT.)
C
C THIS MATRIX IS THE ONLY ONE WHICH CHANGES ONCE SET UP - ITS THIRD COLUMN IS
C THE ONE WHICH MOVES FROM PICTURE TO PICTURE, POSSIBLY PUTTING SEVERAL
C SIDE BY SIDE ON WIDE PAPER.
C
C FIRST CALCULATE HOW SEVERAL PICTURES CAN FIT ON THE PLOTTER:
      IF (HGTPIC .GE. PAPERW) THEN
        WRITE (LPT,3004) HGTPIC,PAPERW
        WRITE (ITO,3004) HGTPIC,PAPERW
3004    FORMAT (' ERROR ** picture of height',F10.2,'cms requested',
     &  ' but plotter paper given as only',F10.2,'cms')
C>> Was STOP
        CALL BMBOUT
	  RETURN        
      ENDIF
C
      NYPIC=IFIX(PAPERW/(HGTPIC+BORDER))
      N1=(IZPL-1)/NYPIC + 1
      N2=NYPIC
      IF (N1 .EQ. 1) N2=IZPL
C
C TOTAL SIZE OF PLOT IN CMS:
      WIDTOT=(WIDPIC+BORDER)*FLOAT(N1)
      HGTTOT=(HGTPIC+BORDER)*FLOAT(N2)
C
C INITIALISE COUNT ACROSS PAGE:
      IYPIC=0
C
C USE PLTRIN TO PUT MATRICES 3 4 5 AND 6 IN PLACE:
C
C PMTRIX 3 TAKES MAP COORDINATES INTO PICTURE COORDINATES.  THE ROTATION
C PART HAS BEEN SET UP BY USYM AND IS IN PMAP IN /CONTUR/
C
      CALL GMEQ(PMAP,PTEMP,2,2)
C MAP ORIGIN IN PICTURE COORDS:
      XO=XMARG
      DIFF=(WIDTXT-WIDMAP)/2.
      IF (DIFF .GT. 0.) XO=XO+DIFF
      IF (WIDPRO .GT. 0.) XO=XO+WIDPRO
      PTEMP(1,3)=XO
C
      PTEMP(2,3)=2.*YMARG+HGTTXT+3.*YWHITE+HGTMAP
      CALL PLTRIN(PTEMP,4,3)
	IF (IBMBER .NE. 0) RETURN
C
C NOW THE CHARACTERS INTO PICTURE MATRICES.  ALL THE ROTATIONS ARE AT
C PRESENT SIMPLE SCALES, NOT ACTUAL ROTATIONS.
C
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,1)
      PTEMP(2,2)=CHSCAL(2,1)
C
C PMTRIX 4 TAKES CHARACTERS OF TYPE 1 INTO PICTURE COORDS.  THE ORIGIN HERE
C IS THE BOTTOM LEFT HAND CORNER OF THE TEXT BLOCK:
      XO=XMARG
      IF (DIFF .LT. 0.) XO=XO-DIFF
      PTEMP(1,3)=XO
      PTEMP(2,3)=YMARG
      CALL PLTRIN(PTEMP,5,3)
	IF (IBMBER .NE. 0) RETURN
C
C PMTRIX 5 IS FOR CHARACTER TYPE 2, THE TITLE CHARACTERS.  THE ORIGIN IS THE
C BOTTOM LEFT HAND CORNER OF THE TITLE BLOCK:
C
      CALL GMZER(PTEMP,2,2)
      PTEMP(1,1)=CHSCAL(1,2)
      PTEMP(2,2)=CHSCAL(2,2)
      DIFF1=(WIDMAP-WIDTTL)/2.
      IF (DIFF .GT. 0.) DIFF1=DIFF1+DIFF
      IF (DIFF1 .LT. 0.) DIFF1=0.
      PTEMP(1,3)=DIFF1+XMARG
      PTEMP(2,3)=HGTPIC-YMARG-HGTTTL
      CALL PLTRIN(PTEMP,6,3)
	IF (IBMBER .NE. 0) RETURN
C
C PMTRIX 6 IS FOR CHARACTER TYPE 3, THE CONTOUR LIST.  THE ORIGIN IS NOT
C YET DETERMINED AS WE DO NOT KNOW HOW MANY CONTOURS WILL BE FOUND
C
C
C WE ARE NOW IN A POSITION TO CALL WHATEVER SPECIAL ROUTINE IS NEEDED TO START
C A PLOT, REQUESTING A PIECE OF PAPER HGTTOT WIDE (ACROSS PLOTTER) AND WIDTOT
C LONG (ALONG LENGTH OF PLOTTER, OFTEN APPROACHING INFINITY IF REALLY A PLOTTER)
C
C WHEN WE START TO APPLY THIS TO VDUS, OUR REQUIRED SCREEN (IN CMS) IS
C WIDTOT WIDE AND HGTTOT HIGH.  BUT WE WOULD IN PRACTICE ASK FOR WIDPIC TIMES
C HGTPIC BECAUSE OF DRAWING ONE AT A TIME.  LEAVE THIS FOR NOW.
C
      IF (FROMCM .GT. 0)   CALL PIGLET(WIDTOT,HGTTOT,999)	
      IF (FROMCM .LE. 0)   CALL PIGLET(WIDPIC,HGTPIC,999)
	IF (IBMBER .NE. 0) RETURN
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE SYMEQU(HI,H,K,N,MI,UU,BETA)
      SUBROUTINE SYMEQU(HI,H,K,N,MI,UU,BETA)
C
C *** SYMEQU updated by PJB 29 Apr 88 ***
C
CX
CC 5B
CH Generates new indices and a phase, in Fourier calculations.
C
CA On entry HI is a 1x3 vector containg h,k,l
CA          N is the number of a symmetry operator
CA          H is an array of indices already found for this HI
CA          MI is the number of entries in H.
CA On exit  EH holds the new h,k,l
CA          UU=0. if these indices have occurred before in the array H
CA             or, if NDIM=2 or 3, =-1 if the (-h,-k,-l) operator was
CA                 necessary to put EH into the correct half of reciprocal
CA                  space with l >=0,
CA                                  +1 if (-h,-k,-l) was not used.
CA            or, if NDIM=2, the transformed l is non-zero;
CA            or, if NDIM=4 for a bounded section, UU= the coefficient
CA                needed for this EH in the sum.
CA          BETA is the phase for this h,k,l.
C
CP Fourier calculations should be set up by SETFOU.
C
      DIMENSION HI(3),EH(3),K(3),H(1)
      COMPLEX BOUND
      LOGICAL TESTOV
C
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
      UU=1.
      CALL ROTSYM(HI,EH,N,2)
      CALL INDFIX(EH,K)
      IF (K(2)) 4,3,2
   3  IF (K(1)) 4,5,2
   5  IF (K(3)) 4,2,2
   4  DO 6 I=1,3
      K(I)=-K(I)
      EH(I)=-EH(I)
   6  CONTINUE
C TO ENSURE FRIEDEL EXACT HALF
      UU=-UU
   2  CALL EQVEC(H,EH,MI,M,NOP)
C DO NOT USE IF EXACTLY THIS HKL HAS ALREADY OCCURRED FROM THIS CYCLE:
      IF (M .LE. MI) GO TO 101
      MI = M
C ONLY TEST L IF 2D:
      IF ((NDIM .EQ. 2) .AND. (K(3) .NE. 0)) GO TO 101
      TRA = 0.
      DO 31 I = 1,3
      Q = -SECZER(I)
      IF (NDIM.NE.3 .AND. I.EQ.3) Q=0
      IF (MODEF .NE. 6) Q=Q+TRANS(I,N)
      TRA = TRA+EH(I)*Q
  31  CONTINUE
      BETA = TWOPI*TRA
      IF (NDIM.NE.4) GO TO 100
      IF (TESTOV(1.,EH(3))) GO TO 100
      ARG=TWOPI*EH(3)
      BOUND=CEXP(CMPLX(0.,-ARG*SECEND))
     & -CEXP(CMPLX(0.,-ARG*SECZER(3)))
      BOUND=BOUND*CMPLX(0.,1./ARG)
      ABOUND=CABS(BOUND)
      UU=UU*ABOUND/(SECEND-SECZER(3))
      IF (ABOUND.GT.10E-5)
     &  BETA=BETA+ATAN2(AIMAG(BOUND),REAL(BOUND))
      GO TO 100
C
 101  UU=0.
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE TBOUND(IFOUND)
      SUBROUTINE TBOUND(IFOUND)
C
C *** TBOUND by PJB Aug 86 ***
C
CX
CC 5B
CH A specialist routine used duing the plotting of atomic positions
CH in main program ATMPLO.
C
      DIMENSION Y(3)
C%
C      COMMON/SCRAT/AA(3,3),TRXX(3,%SY*2%),TLAT(3,4),BOUNDS(2,6),XX(3,3),
      COMMON/SCRAT/AA(3,3),TRXX(3,48),TLAT(3,4),BOUNDS(2,6),XX(3,3),
     & TMPV1(3),TMPV2(3),TMPV3(3),TTXX(3,50),NT
      EQUIVALENCE(Y,TMPV1)
C
C  FIRST GET JUST INSIDE THE LOWER BOUND
      IFOUND=0
      CALL GMEQ(Y,XX(1,NT),1,3)
      DO 3 I=1,NT
    1 DIFF=XX(I,NT)-BOUNDS(1,I)
      IF (DIFF.GT. -.001) GO TO 2
      XX(I,NT)=XX(I,NT)+1.
      GO TO 1
C
C  HERE IF INSIDE LOWER BOUND, SEE IF LOWEST POSSIBLE
    2 IF (DIFF.LT.1.) GO TO 3
      XX(I,NT)=XX(I,NT)-1.
      DIFF=DIFF-1.
      GO TO 2
    3 CONTINUE
C
C  NOW TEST UPPER BOUND
      J=NT
   12 IF (BOUNDS(2,J)-XX(J,J).LT.-.001) GO TO 10
      IF (J.EQ.1) THEN
C  TEST IF STRICLY INSIDE BOX
      CALL GMPRD(XX(1,1),AA,TMPV2,1,3,3)
      DO 21 I=1,3
      IF (TMPV2(I).LT.BOUNDS(1,3+I) .OR. TMPV2(I).GT.BOUNDS(2,3+I))
     &  GO TO 10
   21 CONTINUE
      IFOUND=IFOUND+1
      CALL GMEQ(TMPV2,TTXX(1,IFOUND),1,3)
      XX(1,1)=XX(1,1)+1.
      ELSE
      CALL GMEQ(XX(1,J),XX(1,J-1),1,3)
      J=J-1
      ENDIF
      GO TO 12
C
C  HERE IF TESTED POINT OUTSIDE
   10 IF(J.EQ.NT) GO TO 100
      J=J+1
      XX(J,J)=XX(J,J)+1.
      GO TO 12
C
C  HERE WHEN NO MORE POSSIBILITIES
 100  RETURN
C
      END
C
C
C
C
C LEVEL 3      SUBROUTINE USYM(N)
      SUBROUTINE USYM(N)
C
C *** USYM by JCM 19 Mar 83 ***
C
CX
CC 5A
CH Transforms all the symmetry operators by pre- and post-multiplying
CH them by U, the orientation matrix for a Fourier map.
C
CA On entry N=0 if no matrix U has in fact been read.
C
CP Fourier calculations should be set up by SETFOU;  in particular the
CP number of dimensions, NDIM, is needed.
C
CD Each symmetry matrix R except the first is replaced by:
CD         (U)**-1 * R * U
CD and each translation operator T by (U)**-1 * T
C
CD The routine also fills in the matrix PMAP(2,2), using the matrix
CD U expressed on the standard orthogonal axes.  This matrix is
CD then used in a "map to picture" conversion during plotting.
C
CN If the original symmetry matrices are ever needed we can recover the
CN transformations from the first element.
C
      COMMON /CONTUR/ZPLVAL(20),ZCPL,IPL,IZPL,CONT(50),
     & NCONT,PMAP(2,2)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPDA/U(3,3),OUTLIM(3,3),NX,NY,NXY,NH,NK,NHK,NKX,NDIM,
     & DENS(10201),MODEF,NOBSIN,NUSED,SCALF1,SCALF2,DELTA,MODED,SMAX,
     & MODET,SECZER(3),SECEND
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /PLOMAP/WIDTOT,HGTTOT,WIDPIC,HGTPIC,WIDMAP,HGTMAP,WIDTTL,
     & HGTTTL,WIDTXT,HGTTXT,WIDCON,HGTCON,XMARG,YMARG,XWHITE,YWHITE,
     & NYPIC,IYPIC,CHSCAL(2,3),SCALMP
C%
C      COMMON /SCRAT/B(3,3,%SYMO%),A(3,3),C(3,3),TT(3)
      COMMON /SCRAT/B(3,3,24),A(3,3),C(3,3),TT(3)
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
C
      CALL GMEQ(U,A,3,3)
C
C IF UNIT MATRIX, SKIP INVERSION:
      IF (N .EQ. 0) GO TO 10
      CALL TRINV3(A,D)
      WRITE (LPT,2000) D
2000  FORMAT (/' Unit cell transformed for Fourier is ',F6.2,' times',
     & ' original cell')
      IF (ABS(D) .GT. 0.0001) GO TO 2
      CALL ERRMES(1,1,'3 axes of transformed map are coplanar')
      GO TO 100
C
C INTO A PUT INVERSE OF U (NOT TRANSPOSED)
   2  CALL TRANSQ(A,3)
      DO 1 N=2,NOPC
      CALL GMPRD(SYM(1,1,N),U,B(1,1,N),3,3,3)
      CALL GMPRD(A,TRANS(1,N),TT,3,3,1)
      CALL GMEQ(TT,TRANS(1,N),1,3)
   1  CONTINUE
C
C COPY MATRICES BACK:
      DO 3 N=2,NOPC
      CALL GMPRD(A,B(1,1,N),SYM(1,1,N),3,3,3)
   3  CONTINUE
C
  10  DO 4 I=1,3
   4  CALL ORTHO(U(1,I),A(1,I),1)
      GO TO (100,5,6), NDIM
C 2-D PROJECTION:
    5 CALL UNIVEC(A(1,3),TT(3))
      DO 7 I=1,2
      CALL VECPRD(A(1,I),A(1,3),C(1,I))
      CALL UNIVEC(C(1,I),TT(I))
   7  CONTINUE
      COSPHI=SCALPR(C(1,1),C(1,2))
      GO TO 8
C
C 3-D:
   6  DO 9 I=1,2
   9  CALL UNIVEC(A(1,I),TT(I))
      COSPHI=SCALPR(A(1,1),A(1,2))
C
   8  CALL SINCOS(COSPHI,SINPHI,'USYM')
      TEMP=TT(1)*OUTLIM(3,1)*SCALMP
      PMAP(1,1)=TEMP*COSPHI
      PMAP(2,1)=-TEMP*SINPHI
      PMAP(1,2)=TT(2)*OUTLIM(3,2)*SCALMP
      PMAP(2,2)=0.0
 100  RETURN
      END
C
C

!
!*****************************************************************************
!
! Originally in PCDruid_Main.f90
!
! This doesnt work for chm files, only hlp files - I think we have to upgrade the compiler for it to work with chm files
!     SUBROUTINE LaunchWinHelp()
!       USE VARIABLES
!       USE dfwin
!     CHARACTER*100 lpszHelpFileName, lpszContents
!       integer hWnd
!       logical ret

!       lpszHelpFileName ="G:\\ConQuest.chm"C
!      lpszContents = "CONTENTS"C

!      ret = WinHelp (hWnd, lpszHelpFileName, HELP_KEY, LOC(lpszContents) )
!       END SUBROUTINE LaunchWinHelp
!
!*****************************************************************************
!
!      SUBROUTINE TIC_file_Open()
!
!   This subroutine processes Open TIC file selection
!
!      USE WINTERACTER
!      USE VARIABLES
!
!      IMPLICIT NONE
!
!      CHARACTER(LEN=256) :: FILTER
!      INTEGER            :: IFLAGS
!      CHARACTER(LEN=80) STATBARSTR
!      COMMON /STATBAR/ STATBARSTR(10)
!C>> JCC Declaration for trapping tic file return
!      INTEGER TicRead
!      INTEGER Load_TIC_File
!      INTEGER IPTYPE
!      COMMON /PLTYPE/ IPTYPE

!   Check if file needs saving
!      IF (SAVEF) THEN
!        CALL WMessageBox(YesNo,QuestionIcon,CommonOK,'Program contains an'//&
!        ' unsaved project.'//CHAR(13)//'Do you wish to '// &
!        'continue?','Open Project')
!   If answer 'No', return
!        IF (WInfoDialog(4) .EQ. 2) RETURN
!      END IF
!   If answer 'Yes'
!      SAVEF = .FALSE.
!      CALL FieldUpdate()
!      IFLAGS = LoadDialog + DirChange + PromptOn
!      FILTER = 'Peak position files (*.tic)|*.tic|'
!      FNAME=' '
!      CALL WSelectFile(FILTER,IFLAGS,FNAME,'Open peak position file')
!   Place your file load code here
!C>> JCC Trap return, and if successful replot the data
!      TicRead = Load_TIC_File(LEN_TRIM(FNAME),FNAME)
!      IF (TicRead .EQ. 1) CALL Profile_Plot(iptype)
!C>> Was
!     CALL Load_TIC_File(LEN_TRIM(FNAME),FNAME)
!      STATBARSTR(1)=FNAME
!      CALL WindowOutStatusBar(1,STATBARSTR(1))
!      RETURN
!
!      END SUBROUTINE TIC_file_Open
!
!*****************************************************************************
!
      SUBROUTINE CCL_file_Open()

!   This subroutine processes Open CCL file selection

      USE WINTERACTER
      USE VARIABLES

      IMPLICIT NONE

      CHARACTER(LEN=256) :: FILTER
      INTEGER            :: IFLAGS

      INCLUDE 'GLBVAR.INC'

      LOGICAL Confirm ! Function

!   Check if file needs saving
      IF (SAVEF) THEN
        IF (.NOT. Confirm('Program contains an unsaved project.'//CHAR(13)//'Do you wish to continue?')) RETURN
      END IF
      SAVEF  = .FALSE.
      CALL FieldUpdate()
      IFLAGS = LoadDialog + DirChange + PromptOn
      FILTER = 'CCL crystal data files (*.ccl)|*.ccl|'
      FNAME=' '
      CALL WSelectFile(FILTER,IFLAGS,FNAME,'Open CCL file')
!   Place your file load code here
      CALL Load_CCL_File(LEN_TRIM(FNAME),FNAME)
      STATBARSTR(1)=FNAME
      CALL WindowOutStatusBar(1,STATBARSTR(1))
      RETURN

      END SUBROUTINE CCL_file_Open
!
!*****************************************************************************
!
!      SUBROUTINE Save(IDENT)
!
!   This subroutine processes Save/As selection
!
!      USE WINTERACTER
!      USE VARIABLES
!
!      IMPLICIT NONE
!
!      INTEGER, INTENT (IN) :: IDENT
!
!      CHARACTER(LEN=256)   :: FILTER
!      INTEGER              :: IFLAGS
!
!      IF ((FNAME .EQ. ' ') .OR. (IDENT .EQ. 1)) THEN
!        IFLAGS = SaveDialog + DirChange + PromptOn
!        FILTER = 'All files (*.*)|*.*|'
!        FNAME=' '
!        CALL WSelectFile(FILTER,IFLAGS,FNAME,'Save File')
!      END IF
!      IF (WInfoDialog(4) .EQ. 1) THEN
!   Place save code here
!        SAVEF = .FALSE.
!        CALL FieldUpdate()
!      END IF
!      RETURN

!      END SUBROUTINE Save
!
!*****************************************************************************
!
!      SUBROUTINE Edit()
!
!   This subroutine processes Edit selection
!
!      USE WINTERACTER
!      USE VARIABLES
!      USE druid_header
!
!      IMPLICIT NONE
!
!   Load and show edit dialog
!
!!!      CALL WDialogLoad(IDD_EDITDIAG)
!!!      CALL WDialogShow(-1,-1,0,Modal)
!
!      IF (WInfoDialog(1) .EQ. 1) THEN
!        SAVEF = .TRUE.
!        CALL FieldUpdate()
!      END IF
!
!      RETURN
!      END SUBROUTINE Edit
!
!*****************************************************************************
!
! Originally in Abcalc.for
!
C LEVEL 3      SUBROUTINE ABCALC(IR,AFCAL,BFCAL)
      SUBROUTINE ABCALC(IR,AFCAL,BFCAL)
C
C *** FCALC by JCM 19 Jul 83 ***
C
CX
CC 4B
CH Calculates the COMPLEX nuclear structure factor for the reflection H.
CA On entry H is a 1x3 read vector holding h,k,l.
CA On exit FCALC holds the COMPLEX nuclear structure factor
CP PREFIN, RECIP, SYMOP, SETFOR, ATOPOS and SETANI must be called before the
CP first call to FCALC.  (All these except PREFIN are all in SETFC)
CD Forms sin theta/lambda and leaves it in STHL in /BRAGG
CD Cycles over atomic positions, then over symmetry operators, forming
CD COMPLEX FCALC by the usual formula.
CD
CD Applies scattering factor, site occupation factor, multiplicity of atom and
CD individual isotropic or anisotropic temperature factors.
C
      INCLUDE 'params.inc'
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /FCSTOR/ MAXK,FOB(150,MFCSTO)
      LOGICAL LOGREF
      COMMON /FCSPEC/ NLGREF,IREFH(3,MFCSPE),LOGREF(8,MFCSPE)
      COMMON /CSQSTO/ COSQS(-20:20,3,150),SINQS(-20:20,3,150)
C
      INCLUDE 'FFCALC.INC'
C
      RETURN
      END
!
!*****************************************************************************
!
! Originally in SplineFit.f90
!
      SUBROUTINE Spline_Background

! Algorithm:
!
! 1. Define all points on the profile by using user defined positions. Initially these are defined
! from the unit cell reflection positions using a fitness equation (as yet undefined) or from user-given 
! points in the profile
!
! 2. Fit a cubic spline to these points and use this for background correction
!
! Notes:
!
! This algorithm uses the information from the indexing. If your indexing is bad, then
! it has no chance!

      USE WINTERACTER
      USE DRUID_HEADER
      USE VARIABLES

      INCLUDE 'POLY_COLOURS.INC'
      INCLUDE 'PARAMS.INC'
      COMMON /PROFTIC/ NTIC,IH(3,MTIC),ARGK(MTIC),DSTAR(MTIC)

      COMMON /PROFRAN/ XPMIN,XPMAX,YPMIN,YPMAX,XPGMIN,XPGMAX,&
        YPGMIN,YPGMAX,XPGMINOLD,XPGMAXOLD,YPGMINOLD,YPGMAXOLD, &
        XGGMIN,XGGMAX,YGGMIN,YGGMAX

      COMMON /PROFOBS/ NOBS,XOBS(MOBS),YOBS(MOBS),YCAL(MOBS),YBAK(MOBS),EOBS(MOBS)
      COMMON /PROFBIN/ NBIN,LBIN,XBIN(MOBS),YOBIN(MOBS),YCBIN(MOBS),YBBIN(MOBS),EBIN(MOBS)

      REAL TicVal(Mtic),XSpline(Mtic),YSpline(Mtic),DSpline(Mtic),NSpline,Xtem,Ytem
      INTEGER Npos,Count,Nstep
      REAL Del

      Npos = 0
! Calculate the mean intensity over the profile and the mean intensity 
! over the reflection positions
      DO I = 1, MTIC
! Modify the position 
        IF (I .GT. 1) THEN
          Del =  ARGK(I) - ARGK(I-1)
        ELSE
          Del =  ARGK(I) - XOBS(1)
        ENDIF
! we want points between the peaks that are well separated
        IF (Del .GT. 0.25 ) THEN  ! This is selection is hard coded here but really should be
                              ! dependant on the estimated peak width at this position
           Npos = Npos + 1
           TicVal(Npos) = ARGK(I) - (Del/2.0)
        END IF
      END DO
      Count = 1
      DO I = 1, NOBS-1
        IF (XOBS(I).LE.TicVal(Count) .AND. XOBS(I+1).GE.TicVal(Count)) THEN
          XSpline(Count) = XOBS(I)
          YSpline(Count) = YOBS(I)
          Count = Count + 1
          IF (Count .GT. Npos) GOTO 99
        END IF
      END DO
 99   CONTINUE
      CALL IGrColourN(KolNumObs)
! JvdS IPgNewGraph is now obsolete and should be replaced by IPgNewPlot
! I don't know the equivalent of 'S'
!      CALL IPgNewPlot(PgPolyLine,1,NBIN,??)
      CALL IPgNewGraph(1,Npos,' ','S','X')
      CALL IPgStyle(1,0,0,0,KolNumDif,0)
      CALL IPgXYPairs(XSpline,YSpline)
      CALL IGrColourN(KolNumMain)

      END SUBROUTINE Spline_Background

!
!*****************************************************************************
!
! Originally in subplxopt.for
!
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE SUBPLXOPT(X,DX,COVAR,N,CCHI)
C     ----------------------------------
C
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C Purpose
C     A SUBPLEX-based routine which optimises the values of the N 
C parameters pertaining to the components of the vector X; it also 
C estimates the related covariance matrix. The SUBPLEX work-engine 
C is due to Dr. Tom Rowan (Ph.D., 1990), which he developed while 
C a Research student at University of Texas, Austin, USA.
C
C Parameters
C   ARGUMENT  TYPE  I/O  DIMENSION  DESCRIPTION
C    N        I*4    I       -      No. of parameters to be optimised.
C    X        R*4    I       N      Initial guess.
C    X        R*4    O       N      The optimal answer.
C    DX       R*4    I       N      Initial step-lengths for X.
C    COVAR    R*4    O     N x N    The covariance matrix.
C
C Other Requirements
C     The user must provide a FUNCTION CCHI(X) which evalutes 
C Chi-squared (un-normalised) given the vector X.
C
C History
C     D. S. Sivia   22 Jun 1999  Initial release.
C-----------------------------------------------------------------------
C
      REAL     X(N),DX(N),COVAR(N,N)
      REAL     HESS(9801),DELTA(99),C0,C1(2,99),C2(9801)
      INTEGER  IWORK(150)
      REAL*8   SUBCHI,TOL,DV(99),V(99),CHIV,WORK(250)
      EXTERNAL CCHI,SUBCHI
      DATA     NMAX,TOL /99,1.0D-2/
C
      IF (N.GT.NMAX) STOP' Sorry, too many parameters !'
      CHIMIN=CCHI(N,X)
C 100  FORMAT(' Chi-squared = ',1PE12.4)
      MODE=0
      NCHMAX=N*1000
      CALL VDBLE(X,V,N)
      CALL VDBLE(DX,DV,N)
   1  CALL SUBPLX(SUBCHI,CCHI,N,TOL,NCHMAX,MODE,DV,V,CHIV,NCHI,
     *            WORK,IWORK,IFLAG)
      CALL VSNGL(V,X,N)
      CALL VCOPY(X,WORK,N)
      CALL CHINIT(WORK,N,DELTA,C0,C1,C2,CCHI)
      CALL HSINT1(C0,C1,DELTA,N,HESS)
      CALL HSINT2(C0,C1,C2,DELTA,N,HESS)
      CALL INVERT(HESS,COVAR,N,INDX)
      END
C

C***<subplex interface>*************************************************
C
      REAL*8 FUNCTION SUBCHI(N,X,CCHI)
C     ---------------------------
C
      REAL*8   X(*)
      REAL     XS(99)
      EXTERNAL CCHI
C
      CALL VSNGL(X,XS,N)
      SUBCHI=DBLE(CCHI(N,XS))
      END
C
C***<utilities>*********************************************************
C
      SUBROUTINE VDBLE(X,Y,N)
C     -----------------------
C
      REAL   X(*)
      REAL*8 Y(*)
C
      DO 10 I=1,N
  10    Y(I)=DBLE(X(I))
      END
C
      SUBROUTINE VSNGL(X,Y,N)
C     -----------------------
C
      REAL*8 X(*)
      REAL   Y(*)
C
      DO 10 I=1,N
  10    Y(I)=SNGL(X(I))
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C            Dr. Tom Rowan's SUBPLEX code follows below.               C
C            -------------------------------------------               C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      subroutine calcc (ns,s,ih,inew,updatc,c)
c
      integer ns,ih,inew
      double precision s(ns,ns+3),c(ns)
      logical updatc
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c calcc calculates the centroid of the simplex without the
c vertex with highest function value.
c
c input
c
c   ns     - subspace dimension
c
c   s      - double precision work space of dimension .ge.
c            ns*(ns+3) used to store simplex
c
c   ih     - index to vertex with highest function value
c
c   inew   - index to new point
c
c   updatc - logical switch
c            = .true.  : update centroid
c            = .false. : calculate centroid from scratch
c
c   c      - centroid of the simplex without vertex with
c            highest function value
c
c output
c
c   c      - new centroid
c
c local variables
c
      integer i,j
c
c subroutines and functions
c
c   blas
      external daxpy,dcopy,dscal
c
c-----------------------------------------------------------
c
      if (updatc) then
        if (ih .eq. inew) return
        do 10 i = 1,ns
          c(i) = c(i)+(s(i,inew)-s(i,ih))/ns
   10   continue
      else
        call dcopy (ns,0.d0,0,c,1)
        do 20 j = 1,ns+1
          if (j .ne. ih) call daxpy (ns,1.d0,s(1,j),1,c,1)
   20   continue
        call dscal (ns,1.d0/ns,c,1)
      end if
      return
      end
C
      double precision function dist (n,x,y)
c
      integer n
      double precision x(n),y(n)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c dist calculates the distance between the points x,y.
c
c input
c
c   n      - number of components
c
c   x      - point in n-space
c
c   y      - point in n-space
c
c local variables
c
      integer i
      double precision absxmy,scale,sum
c
c subroutines and functions
c
c   fortran
      intrinsic abs,sqrt
c
c-----------------------------------------------------------
c
      absxmy = abs(x(1)-y(1))
      if (absxmy .le. 1.d0) then
        sum = absxmy*absxmy
        scale = 1.d0
      else
        sum = 1.d0
        scale = absxmy
      end if
      do 10 i = 2,n
        absxmy = abs(x(i)-y(i))
        if (absxmy .le. scale) then
          sum = sum+(absxmy/scale)**2
        else
          sum = 1.d0+sum*(scale/absxmy)**2
          scale = absxmy
        end if
   10 continue
      dist = scale*sqrt(sum)
      return
      end
C
      subroutine evalf (f,cchi,ns,ips,xs,n,x,sfx,nfe)
c
      integer ns,n,nfe
      integer ips(*)
      double precision f,xs(*),x(n),sfx
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c evalf evaluates the function f at a point defined by x
c with ns of its components replaced by those in xs.
c
c input
c
c   f      - user supplied function f(n,x) to be optimized
c
c   ns     - subspace dimension
c
c   ips    - permutation vector
c
c   xs     - double precision ns-vector to be mapped to x
c
c   n      - problem dimension
c
c   x      - double precision n-vector
c
c   nfe    - number of function evaluations
c
c output
c
c   sfx    - signed value of f evaluated at x
c
c   nfe    - incremented number of function evaluations
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
      double precision fbonus,sfstop,sfbest
      logical new
c
      common /isubc/ fbonus,sfstop,sfbest,new
c
c local variables
c
      integer i
      double precision fx
      logical newbst
c
      save
c
c subroutines and functions
c
      external f,fstats
      external cchi
c
c-----------------------------------------------------------
c
      do 10 i = 1,ns
        x(ips(i)) = xs(i)
   10 continue
      newx = new .or. irepl .ne. 2
      fx = f(n,x,cchi)
      if (irepl .eq. 0) then
        if (minf) then
          sfx = fx
        else
          sfx = -fx
        end if
      else if (new) then
        if (minf) then
          sfx = fx
          newbst = fx .lt. ftest
        else
          sfx = -fx
          newbst = fx .gt. ftest
        end if
        if (initx .or. newbst) then
          if (irepl .eq. 1) call fstats (fx,1,.true.)
          ftest = fx
          sfbest = sfx
        end if
      else
        if (irepl .eq. 1) then
          call fstats (fx,1,.false.)
          fx = fxstat(ifxsw)
        end if
        ftest = fx+fbonus*fxstat(4)
        if (minf) then
          sfx = ftest
          sfbest = fx
        else
          sfx = -ftest
          sfbest = -fx
        end if
      end if
      nfe = nfe+1
      return
      end
C
      subroutine fstats (fx,ifxwt,reset)
c
      integer ifxwt
      double precision fx
      logical reset
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c fstats modifies the common /usubc/ variables nfxe,fxstat.
c
c input
c
c   fx     - most recent evaluation of f at best x
c
c   ifxwt  - integer weight for fx
c
c   reset  - logical switch
c            = .true.  : initialize nfxe,fxstat
c            = .false. : update nfxe,fxstat
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
c local variables
c
      integer nsv
      double precision fscale,f1sv
c
      save
c
c subroutines and functions
c
c   fortran
      intrinsic abs,max,min,sqrt
c
c-----------------------------------------------------------
c
      if (reset) then
        nfxe = ifxwt
        fxstat(1) = fx
        fxstat(2) = fx
        fxstat(3) = fx
        fxstat(4) = 0.d0
      else
        nsv = nfxe
        f1sv = fxstat(1)
        nfxe = nfxe+ifxwt
        fxstat(1) = fxstat(1)+ifxwt*(fx-fxstat(1))/nfxe
        fxstat(2) = max(fxstat(2),fx)
        fxstat(3) = min(fxstat(3),fx)
        fscale = max(abs(fxstat(2)),abs(fxstat(3)),1.d0)
        fxstat(4) = fscale*sqrt((
     *              (nsv-1)*(fxstat(4)/fscale)**2+
     *              nsv*((fxstat(1)-f1sv)/fscale)**2+
     *              ifxwt*((fx-fxstat(1))/fscale)**2)
     *              /(nfxe-1))
      end if
      return
      end
C
      subroutine newpt (ns,coef,xbase,xold,new,xnew,small)
c
      integer ns
      double precision coef,xbase(ns),xold(ns),xnew(*)
      logical new,small
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c newpt performs reflections, expansions, contractions, and
c shrinkages (massive contractions) by computing:
c
c xbase + coef * (xbase - xold)
c
c The result is stored in xnew if new .eq. .true.,
c in xold otherwise.
c
c use :  coef .gt. 0 to reflect
c        coef .lt. 0 to expand, contract, or shrink
c
c input
c
c   ns     - number of components (subspace dimension)
c
c   coef   - one of four simplex method coefficients
c
c   xbase  - double precision ns-vector representing base
c            point
c
c   xold   - double precision ns-vector representing old
c            point
c
c   new    - logical switch
c            = .true.  : store result in xnew
c            = .false. : store result in xold, xnew is not
c                        referenced
c
c output
c
c   xold   - unchanged if new .eq. .true., contains new
c            point otherwise
c
c   xnew   - double precision ns-vector representing new
c            point if  new .eq. .true., not referenced
c            otherwise
c
c   small  - logical flag
c            = .true.  : coincident points
c            = .false. : otherwise
c
c local variables
c
      integer i
      double precision xoldi
      logical eqbase,eqold
c
c subroutines and functions
c
c   fortran
      intrinsic dble
c
c-----------------------------------------------------------
c
      eqbase = .true.
      eqold = .true.
      if (new) then
        do 10 i = 1,ns
          xnew(i) = xbase(i)+coef*(xbase(i)-xold(i))
          eqbase = eqbase .and.
     *             (dble(xnew(i)) .eq. dble(xbase(i)))
          eqold = eqold .and.
     *            (dble(xnew(i)) .eq. dble(xold(i)))
   10   continue
      else
        do 20 i = 1,ns
          xoldi = xold(i)
          xold(i) = xbase(i)+coef*(xbase(i)-xold(i))
          eqbase = eqbase .and.
     *             (dble(xold(i)) .eq. dble(xbase(i)))
          eqold = eqold .and.
     *            (dble(xold(i)) .eq. dble(xoldi))
   20   continue
      end if
      small = eqbase .or. eqold
      return
      end
C
      subroutine order (npts,fs,il,is,ih)
c
      integer npts,il,is,ih
      double precision fs(npts)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c order determines the indices of the vertices with the
c lowest, second highest, and highest function values.
c
c input
c
c   npts   - number of points in simplex
c
c   fs     - double precision vector of function values of
c            simplex
c
c   il     - index to vertex with lowest function value
c
c output
c
c   il     - new index to vertex with lowest function value
c
c   is     - new index to vertex with second highest
c            function value
c
c   ih     - new index to vertex with highest function value
c
c local variables
c
      integer i,il0,j
c
c subroutines and functions
c
c   fortran
      intrinsic mod
c
c-----------------------------------------------------------
c
      il0 = il
      j = mod(il0,npts)+1
      if (fs(j) .ge. fs(il)) then
        ih = j
        is = il0
      else
        ih = il0
        is = j
        il = j
      end if
      do 10 i = il0+1,il0+npts-2
        j = mod(i,npts)+1
        if (fs(j) .ge. fs(ih)) then
          is = ih
          ih = j
        else if (fs(j) .gt. fs(is)) then
          is = j
        else if (fs(j) .lt. fs(il)) then
          il = j
        end if
   10 continue
      return
      end
C
      subroutine partx (n,ip,absdx,nsubs,nsvals)
c
      integer n,nsubs,nsvals(*)
      integer ip(n)
      double precision absdx(n)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c partx partitions the vector x by grouping components of
c similar magnitude of change.
c
c input
c
c   n      - number of components (problem dimension)
c
c   ip     - permutation vector
c
c   absdx  - vector of magnitude of change in x
c
c   nsvals - integer array dimensioned .ge. int(n/nsmin)
c
c output
c
c   nsubs  - number of subspaces
c
c   nsvals - integer array of subspace dimensions
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
c local variables
c
      integer i,nleft,ns1,ns2,nused
      double precision asleft,as1,as1max,as2,gap,gapmax
c
      save
c
c subroutines and functions
c
c   fortran
      intrinsic min
c
c-----------------------------------------------------------
c
      nsubs = 0
      nused = 0
      nleft = n
      asleft = absdx(1)
      do 10 i = 2,n
        asleft = asleft+absdx(i)
   10 continue
   20 continue
      if (nused .lt. n) then
        nsubs = nsubs+1
        as1 = 0.d0
        do 30 i = 1,nsmin-1
          as1 = as1+absdx(ip(nused+i))
   30   continue
        gapmax = -1.d0
        do 40 ns1 = nsmin,min(nsmax,nleft)
          as1 = as1+absdx(ip(nused+ns1))
          ns2 = nleft-ns1
          if (ns2 .gt. 0) then
            if (ns2 .ge. ((ns2-1)/nsmax+1)*nsmin) then
              as2 = asleft-as1
              gap = as1/ns1-as2/ns2
              if (gap .gt. gapmax) then
                gapmax = gap
                nsvals(nsubs) = ns1
                as1max = as1
              end if
            end if
          else
            if (as1/ns1 .gt. gapmax) then
              nsvals(nsubs) = ns1
              return
            end if
          end if
   40   continue
        nused = nused+nsvals(nsubs)
        nleft = n-nused
        asleft = asleft-as1max
        go to 20
      end if
      return
      end
C
      subroutine setstp (nsubs,n,deltax,step)
c
      integer nsubs,n
      double precision deltax(n),step(n)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c setstp sets the stepsizes for the corresponding components
c of the solution vector.
c
c input
c
c   nsubs  - number of subspaces
c
c   n      - number of components (problem dimension)
c
c   deltax - vector of change in solution vector
c
c   step   - stepsizes for corresponding components of
c            solution vector
c
c output
c
c   step   - new stepsizes
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
c local variables
c
      integer i
      double precision dasum,stpfac
c
      save
c
c subroutines and functions
c
c   blas
      external dasum,dscal
c   fortran
      intrinsic max,min,sign
c
c-----------------------------------------------------------
c
c     set new step
c
      if (nsubs .gt. 1) then
        stpfac = min(max(dasum(n,deltax,1)/dasum(n,step,1),
     *           omega),1.d0/omega)
      else
        stpfac = psi
      end if
      call dscal (n,stpfac,step,1)
c
c     reorient simplex
c
      do 10 i = 1,n
        if (deltax(i) .ne. 0.) then
          step(i) = sign(step(i),deltax(i))
        else
          step(i) = -step(i)
        end if
   10 continue
      return
      end
C
      subroutine simplx (f,cchi,n,step,ns,ips,maxnfe,cmode,x,fx,
     *                   nfe,s,fs,iflag)
c
      integer n,ns,maxnfe,nfe,iflag
      integer ips(ns)
      double precision f,step(n),x(n),fx,s(ns,ns+3),fs(ns+1)
      logical cmode
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c simplx uses the Nelder-Mead simplex method to minimize the
c function f on a subspace.
c
c input
c
c   f      - function to be minimized, declared external in
c            calling routine
c
c   n      - problem dimension
c
c   step   - stepsizes for corresponding components of x
c
c   ns     - subspace dimension
c
c   ips    - permutation vector
c
c   maxnfe - maximum number of function evaluations
c
c   cmode  - logical switch
c            = .true.  : continuation of previous call
c            = .false. : first call
c
c   x      - starting guess for minimum
c
c   fx     - value of f at x
c
c   nfe    - number of function evaluations
c
c   s      - double precision work array of dimension .ge.
c            ns*(ns+3) used to store simplex
c
c   fs     - double precision work array of dimension .ge.
c            ns+1 used to store function values of simplex
c            vertices
c
c output
c
c   x      - computed minimum
c
c   fx     - value of f at x
c
c   nfe    - incremented number of function evaluations
c
c   iflag  - error flag
c            = -1 : maxnfe exceeded
c            =  0 : simplex reduced by factor of psi
c            =  1 : limit of machine precision
c            =  2 : reached fstop
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
      double precision fbonus,sfstop,sfbest
      logical new
c
      common /isubc/ fbonus,sfstop,sfbest,new
c
c local variables
c
      integer i,icent,ih,il,inew,is,itemp,j,npts
      double precision dist,dum,fc,fe,fr,tol
      logical small,updatc
c
      save
c
c subroutines and functions
c
      external f,calcc,dist,evalf,newpt,order,start
      external cchi
c   blas
      external dcopy
c   fortran
      intrinsic min
c
c-----------------------------------------------------------
c
      if (cmode) go to 50
      npts = ns+1
      icent = ns+2
      itemp = ns+3
      updatc = .false.
      call start (n,x,step,ns,ips,s,small)
      if (small) then
        iflag = 1
        return
      end if
      if (irepl .gt. 0) then
        new = .false.
        call evalf (f,cchi,ns,ips,s(1,1),n,x,fs(1),nfe)
      else
        fs(1) = fx
      end if
      new = .true.
      do 10 j = 2,npts
        call evalf (f,cchi,ns,ips,s(1,j),n,x,fs(j),nfe)
   10 continue
      il = 1
      call order (npts,fs,il,is,ih)
      tol = psi*dist(ns,s(1,ih),s(1,il))
c
c     main loop
c
   20 continue
        call calcc (ns,s,ih,inew,updatc,s(1,icent))
        updatc = .true.
        inew = ih
c
c       reflect
c
        call newpt (ns,alpha,s(1,icent),s(1,ih),.true.,
     *              s(1,itemp),small)
        if (small) go to 40
        call evalf (f,cchi,ns,ips,s(1,itemp),n,x,fr,nfe)
        if (fr .lt. fs(il)) then
c
c         expand
c
          call newpt (ns,-gamma,s(1,icent),s(1,itemp),
     *                .true.,s(1,ih),small)
          if (small) go to 40
          call evalf (f,cchi,ns,ips,s(1,ih),n,x,fe,nfe)
          if (fe .lt. fr) then
            fs(ih) = fe
          else
            call dcopy (ns,s(1,itemp),1,s(1,ih),1)
            fs(ih) = fr
          end if
        else if (fr .lt. fs(is)) then
c
c         accept reflected point
c
          call dcopy (ns,s(1,itemp),1,s(1,ih),1)
          fs(ih) = fr
        else
c
c         contract
c
          if (fr .gt. fs(ih)) then
            call newpt (ns,-beta,s(1,icent),s(1,ih),.true.,
     *                  s(1,itemp),small)
          else
            call newpt (ns,-beta,s(1,icent),s(1,itemp),
     *                  .false.,dum,small)
          end if
          if (small) go to 40
          call evalf (f,cchi,ns,ips,s(1,itemp),n,x,fc,nfe)
          if (fc .lt. min(fr,fs(ih))) then
            call dcopy (ns,s(1,itemp),1,s(1,ih),1)
            fs(ih) = fc
          else
c
c           shrink simplex
c
            do 30 j = 1,npts
              if (j .ne. il) then
                call newpt (ns,-delta,s(1,il),s(1,j),
     *                      .false.,dum,small)
                if (small) go to 40
                call evalf (f,cchi,ns,ips,s(1,j),n,x,fs(j),nfe)
              end if
   30       continue
          end if
          updatc = .false.
        end if
        call order (npts,fs,il,is,ih)
c
c       check termination
c
   40   continue
        if (irepl .eq. 0) then
          fx = fs(il)
        else
          fx = sfbest
        end if
   50   continue
        if (nfstop .gt. 0 .and. fx .le. sfstop .and.
     *      nfxe .ge. nfstop) then
          iflag = 2
        else if (nfe .ge. maxnfe) then
          iflag = -1
        else if (dist(ns,s(1,ih),s(1,il)) .le. tol .or.
     *           small) then
          iflag = 0
        else
          go to 20
        end if
c
c     end main loop, return best point
c
      do 60 i = 1,ns
        x(ips(i)) = s(i,il)
   60 continue
      return
      end
C
      subroutine sortd (n,xkey,ix)
c
      integer n
      integer ix(n)
      double precision xkey(n)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c sortd uses the shakersort method to sort an array of keys
c in decreasing order. The sort is performed implicitly by
c modifying a vector of indices.
c
c For nearly sorted arrays, sortd requires O(n) comparisons.
c for completely unsorted arrays, sortd requires O(n**2)
c comparisons and will be inefficient unless n is small.
c
c input
c
c   n      - number of components
c
c   xkey   - double precision vector of keys
c
c   ix     - integer vector of indices
c
c output
c
c   ix     - indices satisfy xkey(ix(i)) .ge. xkey(ix(i+1))
c            for i = 1,...,n-1
c
c local variables
c
      integer i,ifirst,ilast,iswap,ixi,ixip1
c
c-----------------------------------------------------------
c
      ifirst = 1
      iswap = 1
      ilast = n-1
   10 continue
      if (ifirst .le. ilast) then
        do 20 i = ifirst,ilast
          ixi = ix(i)
          ixip1 = ix(i+1)
          if (xkey(ixi) .lt. xkey(ixip1)) then
            ix(i) = ixip1
            ix(i+1) = ixi
            iswap = i
          end if
   20   continue
        ilast = iswap-1
        do 30 i = ilast,ifirst,-1
          ixi = ix(i)
          ixip1 = ix(i+1)
          if (xkey(ixi) .lt. xkey(ixip1)) then
            ix(i) = ixip1
            ix(i+1) = ixi
            iswap = i
          end if
   30   continue
        ifirst = iswap+1
        go to 10
      end if
      return
      end
C
      subroutine start (n,x,step,ns,ips,s,small)
c
      integer n,ns
      integer ips(n)
      double precision x(n),step(n),s(ns,ns+3)
      logical small
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c start creates the initial simplex for simplx minimization.
c
c input
c
c   n      - problem dimension
c
c   x      - current best point
c
c   step   - stepsizes for corresponding components of x
c
c   ns     - subspace dimension
c
c   ips    - permutation vector
c
c
c output
c
c   s      - first ns+1 columns contain initial simplex
c
c   small  - logical flag
c            = .true.  : coincident points
c            = .false. : otherwise
c
c local variables
c
      integer i,j
c
c subroutines and functions
c
c   blas
      external dcopy
c   fortran
      intrinsic dble
c
c-----------------------------------------------------------
c
      do 10 i = 1,ns
        s(i,1) = x(ips(i))
   10 continue
      do 20 j = 2,ns+1
        call dcopy (ns,s(1,1),1,s(1,j),1)
        s(j-1,j) = s(j-1,1)+step(ips(j-1))
   20 continue
c
c check for coincident points
c
      do 30 j = 2,ns+1
        if (dble(s(j-1,j)) .eq. dble(s(j-1,1))) go to 40
   30 continue
      small = .false.
      return
c
c coincident points
c
   40 continue
      small = .true.
      return
      end
C
      subroutine subopt (n)
c
      integer n
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c subopt sets options for subplx.
c
c input
c
c   n      - problem dimension
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
      save
c
c subroutines and functions
c
c   fortran
      intrinsic min
c
c-----------------------------------------------------------
c
c***********************************************************
c simplex method strategy parameters
c***********************************************************
c
c alpha  - reflection coefficient
c          alpha .gt. 0
c
      alpha = 1.d0
c
c beta   - contraction coefficient
c          0 .lt. beta .lt. 1
c
      beta = .5d0
c
c gamma  - expansion coefficient
c          gamma .gt. 1
c
      gamma = 2.d0
c
c delta  - shrinkage (massive contraction) coefficient
c          0 .lt. delta .lt. 1
c
      delta = .5d0
c
c***********************************************************
c subplex method strategy parameters
c***********************************************************
c
c psi    - simplex reduction coefficient
c          0 .lt. psi .lt. 1
c
      psi = .25d0
c
c omega  - step reduction coefficient
c          0 .lt. omega .lt. 1
c
      omega = .1d0
c
c nsmin and nsmax specify a range of subspace dimensions.
c In addition to satisfying  1 .le. nsmin .le. nsmax .le. n,
c nsmin and nsmax must be chosen so that n can be expressed
c as a sum of positive integers where each of these integers
c ns(i) satisfies   nsmin .le. ns(i) .ge. nsmax.
c Specifically,
c     nsmin*ceil(n/nsmax) .le. n   must be true.
c
c nsmin  - subspace dimension minimum
c
      nsmin = min(2,n)
c
c nsmax  - subspace dimension maximum
c
      nsmax = min(5,n)
c
c***********************************************************
c subplex method special cases
c***********************************************************
c nelder-mead simplex method with periodic restarts
c   nsmin = nsmax = n
c***********************************************************
c nelder-mead simplex method
c   nsmin = nsmax = n, psi = small positive
c***********************************************************
c
c irepl, ifxsw, and bonus deal with measurement replication.
c Objective functions subject to large amounts of noise can
c cause an optimization method to halt at a false optimum.
c An expensive solution to this problem is to evaluate f
c several times at each point and return the average (or max
c or min) of these trials as the function value.  subplx
c performs measurement replication only at the current best
c point. The longer a point is retained as best, the more
c accurate its function value becomes.
c
c The common variable nfxe contains the number of function
c evaluations at the current best point. fxstat contains the
c mean, max, min, and standard deviation of these trials.
c
c irepl  - measurement replication switch
c irepl  = 0, 1, or 2
c        = 0 : no measurement replication
c        = 1 : subplx performs measurement replication
c        = 2 : user performs measurement replication
c              (This is useful when optimizing on the mean,
c              max, or min of trials is insufficient. Common
c              variable initx is true for first function
c              evaluation. newx is true for first trial at
c              this point. The user uses subroutine fstats
c              within his objective function to maintain
c              fxstat. By monitoring newx, the user can tell
c              whether to return the function evaluation
c              (newx = .true.) or to use the new function
c              evaluation to refine the function evaluation
c              of the current best point (newx = .false.).
c              The common variable ftest gives the function
c              value that a new point must beat to be
c              considered the new best point.)
c
      irepl = 0
c
c ifxsw  - measurement replication optimization switch
c ifxsw  = 1, 2, or 3
c        = 1 : retain mean of trials as best function value
c        = 2 : retain max
c        = 3 : retain min
c
      ifxsw = 1
c
c Since the current best point will also be the most
c accurately evaluated point whenever irepl .gt. 0, a bonus
c should be added to the function value of the best point
c so that the best point is not replaced by a new point
c that only appears better because of noise.
c subplx uses bonus to determine how many multiples of
c fxstat(4) should be added as a bonus to the function
c evaluation. (The bonus is adjusted automatically by
c subplx when ifxsw or minf is changed.)
c
c bonus  - measurement replication bonus coefficient
c          bonus .ge. 0 (normally, bonus = 0 or 1)
c        = 0 : bonus not used
c        = 1 : bonus used
c
      bonus = 1.d0
c
c nfstop = 0 : f(x) is not tested against fstop
c        = 1 : if f(x) has reached fstop, subplx returns
c              iflag = 2
c        = 2 : (only valid when irepl .gt. 0)
c              if f(x) has reached fstop and
c              nfxe .gt. nfstop, subplx returns iflag = 2
c
      nfstop = 0
c
c fstop  - f target value
c          Its usage is determined by the value of nfstop.
c
c minf   - logical switch
c        = .true.  : subplx performs minimization
c        = .false. : subplx performs maximization
c
      minf = .true.
      return
      end
C
      subroutine subplx (f,cchi,n,tol,maxnfe,mode,scale,x,fx,nfe,
     *                   work,iwork,iflag)
c
      integer n,maxnfe,mode,nfe,iwork(*),iflag
      double precision f,tol,scale(*),x(n),fx,work(*)
c
c                                         Coded by Tom Rowan
c                            Department of Computer Sciences
c                              University of Texas at Austin
c
c subplx uses the subplex method to solve unconstrained
c optimization problems.  The method is well suited for
c optimizing objective functions that are noisy or are
c discontinuous at the solution.
c
c subplx sets default optimization options by calling the
c subroutine subopt.  The user can override these defaults
c by calling subopt prior to calling subplx, changing the
c appropriate common variables, and setting the value of
c mode as indicated below.
c
c By default, subplx performs minimization.
c
c input
c
c   f      - user supplied function f(n,x) to be optimized,
c            declared external in calling routine
c
c   n      - problem dimension
c
c   tol    - relative error tolerance for x (tol .ge. 0.)
c
c   maxnfe - maximum number of function evaluations
c
c   mode   - integer mode switch with binary expansion
c            (bit 1) (bit 0) :
c            bit 0 = 0 : first call to subplx
c                  = 1 : continuation of previous call
c            bit 1 = 0 : use default options
c                  = 1 : user set options
c
c   scale  - scale and initial stepsizes for corresponding
c            components of x
c            (If scale(1) .lt. 0.,
c            abs(scale(1)) is used for all components of x,
c            and scale(2),...,scale(n) are not referenced.)
c
c   x      - starting guess for optimum
c
c   work   - double precision work array of dimension .ge.
c            2*n + nsmax*(nsmax+4) + 1
c            (nsmax is set in subroutine subopt.
c            default: nsmax = min(5,n))
c
c   iwork  - integer work array of dimension .ge.
c            n + int(n/nsmin)
c            (nsmin is set in subroutine subopt.
c            default: nsmin = min(2,n))
c
c output
c
c   x      - computed optimum
c
c   fx     - value of f at x
c
c   nfe    - number of function evaluations
c
c   iflag  - error flag
c            = -2 : invalid input
c            = -1 : maxnfe exceeded
c            =  0 : tol satisfied
c            =  1 : limit of machine precision
c            =  2 : fstop reached (fstop usage is determined
c                   by values of options minf, nfstop, and
c                   irepl. default: f(x) not tested against
c                   fstop)
c            iflag should not be reset between calls to
c            subplx.
c
c common
c
      integer nsmin,nsmax,irepl,ifxsw,nfstop,nfxe
      double precision alpha,beta,gamma,delta,psi,omega,
     *     bonus,fstop,fxstat,ftest
      logical minf,initx,newx
c
      common /usubc/ alpha,beta,gamma,delta,psi,omega,nsmin,
     *               nsmax,irepl,ifxsw,bonus,fstop,nfstop,
     *               nfxe,fxstat(4),ftest,minf,initx,newx
c
      double precision fbonus,sfstop,sfbest
      logical new
c
      common /isubc/ fbonus,sfstop,sfbest,new
c
c local variables
c
      integer i,j,ifsptr,ins,insfnl,insptr,ipptr,isptr,
     *        istep,istptr,ns,nsubs
      double precision bnsfac(3,2),dum,scl,sfx,xpscl
      logical cmode
c
      save
c
c subroutines and functions
c
      external f,sortd,evalf,partx,setstp,simplx,subopt
      real*4 cchi
      external cchi
c   blas
      external dcopy
c   fortran
      intrinsic abs,mod
c
c data
c
      data ((bnsfac(i,j),i=1,3),j=1,2) /-1.d0,-2.d0,0.d0,
     *      1.d0,0.d0,2.d0/
c-----------------------------------------------------------
c
      if (mod(mode,2) .eq. 0) then
c
c       first call, check input
c
        if (n .lt. 1) go to 120
        if (tol .lt. 0.d0) go to 120
        if (maxnfe .lt. 1) go to 120
        if (scale(1) .ge. 0.d0) then
          do 10 i = 1,n
            xpscl = x(i)+scale(i)
            if (xpscl .eq. x(i)) go to 120
   10     continue
        else
          scl = abs(scale(1))
          do 20 i = 1,n
            xpscl = x(i)+scl
            if (xpscl .eq. x(i)) go to 120
   20     continue
        end if
        if (mod(mode/2,2) .eq. 0) then
          call subopt (n)
        else
          if (alpha .le. 0.d0) go to 120
          if (beta .le. 0.d0 .or. beta .ge. 1.d0) go to 120
          if (gamma .le. 1.d0) go to 120
          if (delta .le. 0.d0 .or. delta .ge. 1.d0)
     *        go to 120
          if (psi .le. 0.d0 .or. psi .ge. 1.d0) go to 120
          if (omega .le. 0.d0 .or. omega .ge. 1.d0)
     *        go to 120
          if (nsmin .lt. 1 .or. nsmax .lt. nsmin .or.
     *        n .lt. nsmax) go to 120
          if (n .lt. ((n-1)/nsmax+1)*nsmin) go to 120
          if (irepl .lt. 0 .or. irepl .gt. 2) go to 120
          if (ifxsw .lt. 1 .or. ifxsw .gt. 3) go to 120
          if (bonus .lt. 0.d0) go to 120
          if (nfstop .lt. 0) go to 120
        end if
c
c       initialization
c
        istptr = n+1
        isptr = istptr+n
        ifsptr = isptr+nsmax*(nsmax+3)
        insptr = n+1
        if (scale(1) .gt. 0.d0) then
          call dcopy (n,scale,1,work,1)
          call dcopy (n,scale,1,work(istptr),1)
        else
          call dcopy (n,scl,0,work,1)
          call dcopy (n,scl,0,work(istptr),1)
        end if
        do 30 i = 1,n
          iwork(i) = i
   30   continue
        nfe = 0
        nfxe = 1
        if (irepl .eq. 0) then
          fbonus = 0.d0
        else if (minf) then
          fbonus = bnsfac(ifxsw,1)*bonus
        else
          fbonus = bnsfac(ifxsw,2)*bonus
        end if
        if (nfstop .eq. 0) then
          sfstop = 0.d0
        else if (minf) then
          sfstop = fstop
        else
          sfstop = -fstop
        end if
        ftest = 0.d0
        cmode = .false.
        new = .true.
        initx = .true.
        call evalf (f,cchi,0,iwork,dum,n,x,sfx,nfe)
        initx = .false.
      else
c
c       continuation of previous call
c
        if (iflag .eq. 2) then
          if (minf) then
            sfstop = fstop
          else
            sfstop = -fstop
          end if
          cmode = .true.
          go to 70
        else if (iflag .eq. -1) then
          cmode = .true.
          go to 70
        else if (iflag .eq. 0) then
          cmode = .false.
          go to 90
        else
          return
        end if
      end if
c
c     subplex loop
c
   40 continue
        do 50 i = 1,n
          work(i) = abs(work(i))
   50   continue
        call sortd (n,work,iwork)
        call partx (n,iwork,work,nsubs,iwork(insptr))
        call dcopy (n,x,1,work,1)
        ins = insptr
        insfnl = insptr+nsubs-1
        ipptr = 1
c
c       simplex loop
c
   60   continue
          ns = iwork(ins)
   70     continue
          call simplx (f,cchi,n,work(istptr),ns,iwork(ipptr),
     *                 maxnfe,cmode,x,sfx,nfe,work(isptr),
     *                 work(ifsptr),iflag)
          cmode = .false.
          if (iflag .ne. 0) go to 110
          if (ins .lt. insfnl) then
            ins = ins+1
            ipptr = ipptr+ns
            go to 60
          end if
c
c       end simplex loop
c
        do 80 i = 1,n
          work(i) = x(i)-work(i)
   80   continue
c
c       check termination
c
   90   continue
        istep = istptr
        do 100 i = 1,n
          if (max(abs(work(i)),abs(work(istep))*psi)/
     *        max(abs(x(i)),1.d0) .gt. tol) then
            call setstp (nsubs,n,work,work(istptr))
            go to 40
          end if
          istep = istep+1
  100   continue
c
c     end subplex loop
c
      iflag = 0
  110 continue
      if (minf) then
        fx = sfx
      else
        fx = -sfx
      end if
      return
c
c     invalid input
c
  120 continue
      iflag = -2
      return
      end
C
      double precision function dasum(n,dx,incx)
c
c     takes the sum of the absolute values.
c     uses unrolled loops for increment equal to one.
c     jack dongarra, linpack, 3/11/78.
c     modified to correct problem with negative increment, 8/21/90.
c
      double precision dx(1),dtemp
      integer i,incx,ix,m,mp1,n
c
      dasum = 0.0d0
      dtemp = 0.0d0
      if(n.le.0)return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      ix = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      do 10 i = 1,n
        dtemp = dtemp + dabs(dx(ix))
        ix = ix + incx
   10 continue
      dasum = dtemp
      return
c
c        code for increment equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,6)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dtemp + dabs(dx(i))
   30 continue
      if( n .lt. 6 ) go to 60
   40 mp1 = m + 1
      do 50 i = mp1,n,6
        dtemp = dtemp + dabs(dx(i)) + dabs(dx(i + 1)) + dabs(dx(i + 2))
     *  + dabs(dx(i + 3)) + dabs(dx(i + 4)) + dabs(dx(i + 5))
   50 continue
   60 dasum = dtemp
      return
      end
C
      subroutine daxpy(n,da,dx,incx,dy,incy)
c
c     constant times a vector plus a vector.
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c
      double precision dx(1),dy(1),da
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if (da .eq. 0.0d0) return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dy(iy) = dy(iy) + da*dx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,4)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dy(i) = dy(i) + da*dx(i)
   30 continue
      if( n .lt. 4 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,4
        dy(i) = dy(i) + da*dx(i)
        dy(i + 1) = dy(i + 1) + da*dx(i + 1)
        dy(i + 2) = dy(i + 2) + da*dx(i + 2)
        dy(i + 3) = dy(i + 3) + da*dx(i + 3)
   50 continue
      return
      end
C
      subroutine  dcopy(n,dx,incx,dy,incy)
c
c     copies a vector, x, to a vector, y.
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c
      double precision dx(1),dy(1)
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dy(iy) = dx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,7)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dy(i) = dx(i)
   30 continue
      if( n .lt. 7 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,7
        dy(i) = dx(i)
        dy(i + 1) = dx(i + 1)
        dy(i + 2) = dx(i + 2)
        dy(i + 3) = dx(i + 3)
        dy(i + 4) = dx(i + 4)
        dy(i + 5) = dx(i + 5)
        dy(i + 6) = dx(i + 6)
   50 continue
      return
      end
C
      subroutine  dscal(n,da,dx,incx)
c
c     scales a vector by a constant.
c     uses unrolled loops for increment equal to one.
c     jack dongarra, linpack, 3/11/78.
c     modified to correct problem with negative increment, 8/21/90.
c
      double precision da,dx(1)
      integer i,incx,ix,m,mp1,n
c
      if(n.le.0)return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      ix = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      do 10 i = 1,n
        dx(ix) = da*dx(ix)
        ix = ix + incx
   10 continue
      return
c
c        code for increment equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dx(i) = da*dx(i)
   30 continue
      if( n .lt. 5 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        dx(i) = da*dx(i)
        dx(i + 1) = da*dx(i + 1)
        dx(i + 2) = da*dx(i + 2)
        dx(i + 3) = da*dx(i + 3)
        dx(i + 4) = da*dx(i + 4)
   50 continue
      return
      end
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!*****************************************************************************
!
! Originally in SA_INPUT.FOR
!
      subroutine sa_input(sa_file,nsa,IER)
      character*132 line
      character*80  sa_file
      logical   log_inf_file,log_nvar,log_bounds,log_reduce,
     &log_eps,log_ns,log_nt,log_neps,log_maxevl,log_iprint,
     &log_iseed1,log_iseed2,log_T0,log_target_value,
     &log_frag_file
      double precision cen,sig
      logical gaussb
      character*80  inf_file,zm_file
      double precision x,lb,ub,vm,xpreset
      double precision T0,rt,eps,target_value
      common /inffil/ lfinf,lfzm,inf_file,zm_file
      parameter (maxfrg=20)
      common /frgcom/ nfrag,lfrag(maxfrg)
      character*80 frag_file
      common /frgcha/ frag_file(maxfrg)
      parameter (mvar=100)
      common /gaubou/ cen(mvar),sig(mvar)
      common /gaulog/ gaussb(mvar)
      character*80  torfile
      logical ltorfil
      common /torfcm/ torfile(mvar)
      common /torlog/ ltorfil(mvar)
      common /jitter/ rjittr
      common /values/ x(mvar),lb(mvar),ub(mvar),vm(mvar)
      common /presetr/ xpreset(mvar)
      logical log_preset
      common /presetl/ log_preset
      logical log_hydrogens
      common /hydrogen/ log_hydrogens
c
      common /saparl/ T0,rt,eps,target_value
      common /sapars/ nvar,ns,nt,neps,maxevl,iprint,iseed1,iseed2
      common /shadl/ log_shad(mvar)
      common /shadi/ kshad(mvar)
c
      open(10,file=sa_file(:nsa),status='old')!,err=2)
c
      IER=0
      inf_file=' '
      do ifrg=1,maxfrg
         frag_file(ifrg)=' '
      end do
      nfrag=0
      do i=1,mvar
        log_shad(i)=.false.
      end do
      log_inf_file=.false.
      log_frag_file=.false.
      log_nvar=.false.
      log_bounds=.false.
      log_preset=.false.
      log_T0=.false.
      log_target_value=.false.
      log_reduce=.false.
      log_eps=.false.
      log_ns=.false.
      log_nt=.false.
      log_neps=.false.
      log_maxevl=.false.
      log_iprint=.false.
      log_iseed1=.false.
      log_iseed2=.false.
      log_hydrogens=.false.
c
 10   line=' '
      read(10,1010,end=100,ERR=998) line
 1010 format(a)
      i=132
      do i=132,1,-1
        if (line(i:i).ne.' ') then
          ie=i
          goto 12
        end if
      end do
c.. blank line 
      goto 10
 12   ix=index(line,'!')-1
      if (ix.eq.-1) ix=ie
      if (index(line(1:ix),'NVAR').ne.0) then
        ii=index(line(1:ix),'NVAR')
        read(line(ii+4:ix),*,err=10) nvar
        log_nvar=.true.
      else if (index(line(1:ix),'SHADOWS').ne.0) then
        ii=index(line(1:ix),'SHADOWS')
        read(line(1:ii-1),*,err=10) ishad
        read(line(ii+7:ix),*,err=10) ktem
        kshad(ishad)=ktem
        log_shad(ishad)=.true.
      else if (index(line(1:ix),'BOUNDS').ne.0) then
        ii=index(line(1:ix),'BOUNDS')
        if (log_nvar) then
          do iv=1,nvar
c            read(10,*,err=999) lb(iv),ub(iv),vm(iv)
c          end do
c          log_bounds=.true.
            line=' '
            read(10,1010,end=100) line
            ig=index(line(1:132),'G')
            itorf=index(line(1:132),'Torsion file')
            gaussb(iv)=(ig.ne.0)
            ltorfil(iv)=(itorf.ne.0)
            if (ltorfil(iv)) gaussb(iv)=.false.
            if (ltorfil(iv)) then
              read(line(1:itorf-1),*,err=999) lb(iv),ub(iv),vm(iv)
              torfile(iv)=' '
              read(line(itorf+12:132),5020,err=999) torfile(iv)
 5020         format(a)
            else if (gaussb(iv)) then
              read(line(1:ig-1),*,err=999) lb(iv),ub(iv),vm(iv)
              read(line(ig+1:132),*,err=999) cen(iv),sig(iv)
            else
              read(line(1:132),*,err=999) lb(iv),ub(iv),vm(iv)
            end if
          end do
          log_bounds=.true.
        else
c.. we need to know the number of variables before we can read the bounds
          goto 999
        end if
      else if (index(line(1:ix),'PRESET').ne.0) then
        ii=index(line(1:ix),'PRESET')
        if (log_nvar) then
          do iv=1,nvar
            read(10,*,err=999) xpreset(iv)
          end do
          log_preset=.true.
        else
c.. we need to know the number of variables before we can read the preset values
          goto 999
        end if
      else if (index(line(1:ix),'INF').ne.0) then
        ii=index(line(1:ix),'INF')
        do jj=ii+3,ix
          if (line(jj:jj).ne.' ') then
            kk=1
            inf_file(kk:kk)=line(jj:jj)
            do k=jj+1,ix
              if (line(k:k).ne.' ') then
                kk=kk+1
                inf_file(kk:kk)=line(k:k)
                lfinf=kk
              else
                goto 14
              end if
            end do
            goto 14
          end if
        end do
 14     log_inf_file=.true.
        inf_file(lfinf+1:lfinf+4)='.inf'
        lfinf=lfinf+4
c        zm_file(:lfinf)=inf_file(:lfinf)
c        zm_file(lfinf+1:lfinf+8)='.zmatrix'
c        lfzm=lfinf+8
      else if (index(line(1:ix),'FRAG').ne.0) then
        nfrag=nfrag+1
        ii=index(line(1:ix),'FRAG')
        do jj=ii+4,ix
          if (line(jj:jj).ne.' ') then
            kk=1
            frag_file(nfrag)(kk:kk)=line(jj:jj)
            do k=jj+1,ix
              if (line(k:k).ne.' ') then
                kk=kk+1
                frag_file(nfrag)(kk:kk)=line(k:k)
                lfrag(nfrag)=kk
              else
                goto 141
              end if
            end do
            goto 141
          end if
        end do
 141    log_frag_file=.true.
        ltem=lfrag(nfrag)+1
        frag_file(nfrag)(ltem:ltem+7)='.zmatrix'
        lfrag(nfrag)=lfrag(nfrag)+8
      else if (index(line(1:ix),'T0').ne.0) then
        ii=index(line(1:ix),'T0')
        read(line(ii+2:ix),*,err=10) T0
        log_T0=.true.
      else if (index(line(1:ix),'TARGET').ne.0) then
        ii=index(line(1:ix),'TARGET')
        read(line(ii+6:ix),*,err=10) target_value
        log_target_value=.true.
      else if (index(line(1:ix),'REDUCE').ne.0) then
        ii=index(line(1:ix),'REDUCE')
        read(line(ii+6:ix),*,err=10) rt
        log_reduce=.true.
c.. hydrogens
      else if (index(line(1:ix),'HYDROGENS').ne.0) then
        log_hydrogens=.true.
      else if (index(line(1:ix),'EPSI').ne.0) then
        ii=index(line(1:ix),'EPSI')
        read(line(ii+4:ix),*,err=10) eps
        log_eps=.true.
      else if (index(line(1:ix),'#NS').ne.0) then
        ii=index(line(1:ix),'#NS')
        read(line(ii+3:ix),*,err=10) ns
        log_ns=.true.
      else if (index(line(1:ix),'#NT').ne.0) then
        ii=index(line(1:ix),'#NT')
        read(line(ii+3:ix),*,err=10) nt
        log_nt=.true.
      else if (index(line(1:ix),'NEPS').ne.0) then
        ii=index(line(1:ix),'NEPS')
        read(line(ii+4:ix),*,err=10) neps
        log_neps=.true.
      else if (index(line(1:ix),'MAXEVL').ne.0) then
        ii=index(line(1:ix),'MAXEVL')
        read(line(ii+6:ix),*,err=10) maxevl
        log_maxevl=.true.
      else if (index(line(1:ix),'IPRINT').ne.0) then
        ii=index(line(1:ix),'IPRINT')
        read(line(ii+6:ix),*,err=10) iprint
        log_iprint=.true.
      else if (index(line(1:ix),'ISEED1').ne.0) then
        ii=index(line(1:ix),'ISEED1')
        read(line(ii+6:ix),*,err=10) iseed1
        log_iseed1=.true.
      else if (index(line(1:ix),'ISEED2').ne.0) then
        ii=index(line(1:ix),'ISEED2')
        read(line(ii+6:ix),*,err=10) iseed2
        log_iseed2=.true.
      end if
      goto 10
c
c.. check if parameters have been specified - if not use defaults.
 100  if (.not.log_inf_file) goto 999
      if (.not.log_frag_file) goto 999
      if (.not.log_nvar) goto 999
      if (.not.log_bounds) goto 999
      if (.not.log_T0) T0=200.0
      if (.not.log_target_value) target_value=20.0
      if (.not.log_reduce) rt=0.1
      if (.not.log_eps) eps=0.1
      if (.not.log_ns) ns=20
      if (.not.log_nt) nt=min(100,5*nvar)
      if (.not.log_neps) neps=4
      if (.not.log_maxevl) maxevl=1000000
      if (.not.log_iprint) iprint=0
      if (.not.log_iseed1) iseed1=401
      if (.not.log_iseed2) iseed2=101
c
      GOTO 999
 998  IER=1
      CALL ERROR_MESSAGE(2)
 999  close(10)
      end
!
!*****************************************************************************
!
! Originally in zm_upload.f90
!
      subroutine zm_upload()
!
!
  USE WINTERACTER
  USE DRUID_HEADER
!
      character*80 line
      parameter (maxatm=100)
      parameter (maxfrg=20)
      double precision a,b,c,al,be,ga
      double precision tiso,occ
      double precision blen,alph,bet,f2cmat
      character*3 asym
      integer ioptb,iopta,ioptt,iz1,iz2,iz3
      common /zmcomi/ ntatm,natoms(maxfrg),&
     ioptb(maxatm,maxfrg),iopta(maxatm,maxfrg),ioptt(maxatm,maxfrg),&
     iz1(maxatm,maxfrg),iz2(maxatm,maxfrg),iz3(maxatm,maxfrg)
      common /zmcomr/ blen(maxatm,maxfrg),alph(maxatm,maxfrg),&
     bet(maxatm,maxfrg),f2cmat(3,3)
      common /zmcomc/ asym(maxatm,maxfrg)
      common /zmcomo/ a(maxfrg),b(maxfrg),c(maxfrg),&
      al(maxfrg),be(maxfrg),ga(maxfrg),tiso(maxatm,maxfrg),&
      occ(maxatm,maxfrg)              
!
      common /frgcom/ nfrag,lfrag(maxfrg)
      character*80 frag_file
      common /frgcha/ frag_file(maxfrg)
      common /zmcomg/ icomflg(maxfrg)
!
            CALL WDialogSelect(IDD_zmatrix_files)
            CALL WDialogPutInteger(IDF_nfrag,NFRAG)
            CALL WGridRows(IDF_zmatrixfile_grid,nfrag)
            DO i=1,nFRAG
              CALL WGridPutCellString(IDF_zmatrixfile_grid,1,i,frag_file(i)(:lfrag(i)))
            END DO
!
!
      end
!
!*****************************************************************************
!
! Originally in Ccslmain.for
!

C
C LEVEL 2      SUBROUTINE AINOUT(K,FBUF,N,N1,MODE)
      SUBROUTINE AINOUT(K,FBUF,N,N1,MODE)
C
C *** AINOUT by PJB June 92 ***
C
CX
CC 2B
CH Multiple function routine called by ARRNGE type programs to
CH process sort items.
CA The function is chosen by MODE:
CA   MODE = 0 Initialise: vector K of length N holds the limits for the
CA            sorting keys. Sets N1 items to be associated with the sorted
CA            quantity.
CA   MODE = 1 Enter the items in FBUF creating the sort key from K
CA   MODE = 2 Sort all items read
CA   MODE = 3 Return the next item from the sorted list in FBUF together with
CA            the unpacked key in K and the number of identically labelled
CA            items in N. N1 is set to indicate the most significant K that
CA            changes after the Nth item.
CA   MODE = 4 Simply return the next item in the sorted list in FBUF and
CA            the number remaining from the same group in N
C
C
      DIMENSION K(6),FBUF(1)
      COMMON /ARSORT/NREFS,KEYS,ITEMS,LRPACK(10,3),
     & MS,KP,JPOINT,ICOUNT,KOLD(6)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C%
C      COMMON /SCRAT/MSORT(%NOBS%),VALUES(%NO*5%),IPOINT(%NOBS%)
      COMMON /SCRAT/MSORT(4000),VALUES(20000),IPOINT(4000)
C%
C      DATA NOBS,NVALS/%NOBS%,%NO*5%/
      DATA NOBS,NVALS/4000,20000/
C
      GO TO (1,11,21,31,41) MODE+1
C
    1 CALL NPACK(I,K,N,0,LRPACK)
      KEYS=N
      ITEMS=N1
      JPOINT=1
      NREFS=0
      GO TO 100
C
   11 CALL ERRCHK(2,NREFS,NOBS,0,'reflections to sort')
      CALL ERRCHK(1,JPOINT+ITEMS,NVALS,0,'values to store for sorting')
      CALL GMEQ(FBUF,VALUES(JPOINT),ITEMS,1)
      JPOINT=JPOINT+ITEMS
      CALL NPACK(MSORT(NREFS),K,KEYS,1,LRPACK)
      GO TO 100
C
   21 IF (NREFS.EQ.0) CALL ERRMES(1,0,'No reflections to sort')
      CALL MESS(ITO,0,'Sort started . . . ')
      CALL SORTN(MSORT,IPOINT,NREFS)
      WRITE (ITO,2001)NREFS
 2001 FORMAT ('+Sort started . . sorted',I4,' records ')
      MS=MSORT(IPOINT(1))
      CALL NPACK(MS,KOLD,KEYS,2,LRPACK)
      KP=1
      N=NREFS
      GO TO 100
C
   31 CALL JGMEQ(KOLD,K,KEYS,1)
      I=1+(IPOINT(KP)-1)*ITEMS
      CALL GMEQ(VALUES(I),FBUF,ITEMS,1)
      N=1
   32 KP=KP+1
      ICOUNT=N
      IF (KP.GT.NREFS) THEN
        N1=0
        GO TO 100
      ENDIF
      IF (MSORT(IPOINT(KP)).NE.MS) THEN
        MS=MSORT(IPOINT(KP))
        CALL NPACK(MS,KOLD,KEYS,2,LRPACK)
        DO 33 I=1,KEYS
        IF (KOLD(I).NE.K(I)) THEN
          N1=I
          GO TO 100
        ENDIF
   33   CONTINUE
      ENDIF
      N=N+1
      GO TO 32
C
   41 ICOUNT=ICOUNT-1
      I=1+(IPOINT(KP-ICOUNT)-1)*ITEMS
      CALL GMEQ(VALUES(I),FBUF,ITEMS,1)
      N=ICOUNT
      GO TO 100
C
  100 RETURN
      END
C
C

C
C LEVEL 3      SUBROUTINE ALRPOL(H,ALR,POL,MODE)
      SUBROUTINE ALRPOL(H,ALR,POL,MODE)
C
C *** ALRPOL by JCM 24 Sep 85 ***
C
CX
CC 2B
CH Calculates the reciprocals of Lorentz and polarisation factors.
C
CA H is a 3-size real array holding h,k,l on entry
CA ALR on exit will hold the Lorentz factor
CA POL on exit will hold the polarisation factor
CA MODE on entry =1 if wavelength is already in WLGTH (or ALAMBD)
CA               =2 if wavelength is not set, but SINTH holds sin theta,
CA                  and the wavelength will not be required.
C
CP SETDC must have been obeyed to read necessary D cards to COMMON /DGEOM
C
CP SETLP calls SETDC; it also checks that if a monochromator angle is
CP needed it has been supplied, and ANGLIN(2) holds cos sqrd 2 theta
CP monochromator. POL will be modified appropriately.
CP
CP SETDC has set the geometry type into IGEOM;  possible types are:
CP       IGEOM = 1 Normal beam
CP       IGEOM = 2 Normal beam equatorial
CP       IGEOM = 3 Equi-inclination Weissenberg
CP       IGEOM = 6 4 circle bisecting
CP       IGEOM = 7 4 circle angles given
CP       IGEOM = 8 D3
CP       IGEOM = 9 Powder data, no polarisation
CP       IGEOM = 10 Powder data, X ray
CP       IGEOM = 11 4 circle high chi
CP       IGEOM = 12 SXD geometry
C
      DIMENSION H(3),OH(3),UL(3)
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(5,5),
     & NLAMB,ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C
C REFER H TO STANDARD ORTHOGONAL AXES IN OH, AND MAKE IT A UNIT VECTOR:
      CALL ORTHO(H,OH,2)
      CALL UNIVEC(OH,AK)
C MODE 2 ALLOWS FOR SINTH ALREADY SET ON INPUT (USEFUL IF NO SPECIFIC WLGTH)
      IF (MODE .NE. 2) SINTH = WLGTH*AK*0.5
      CALL SINCOS(SINTH,COSTH,'LP 1')
C THE CORE OF THE LORENTZ CORRECTION IS SIN 2 THETA:
      SIN2TH = 2.*SINTH*COSTH
      ALR=SIN2TH
C NOW ADJUST FOR PARTICULAR IGEOM:
      GO TO (1,2,3,4,4,2,2,8,9,9) , IGEOM
C
   4  CALL ERRIN2(IGEOM,0,'Geometry type','not avaiable in ALRPOL')
C
C NORMAL BEAM:
   1  CALL GMEQ(UM(1),UL,1,3)
      GO TO 6
C
C EQUI-INCLINATION WEISSENBERG:
   3  CALL GMEQ(UM(1),UL,1,3)
      CSPHI=SCALPR(OH,UL)
      CALL SINCOS(CSPHI,SNPHI,'LP 3')
      ALR=ALR*SNPHI
      GO TO 2
C
C D3:
   8  DO 11 I=1,3
  11  UL(I)=UM(I*3)
   6  CSPHI=SCALPR(OH,UL)
      SNRHO=CSPHI/COSTH
      IF (ABS(SNRHO-1.) .LT.  10.E-4) GO TO 5
      ALR=0.
      POL=0.
      WRITE (LPT,3001) H
      WRITE (ITO,3001) H
3001  FORMAT (' WARNING ** REFLEXION',3F4.0,' SHOULD NOT OCCUR')
      GO TO 100
C
   5  CALL SINCOS(SNRHO,CSRHO,'LP 2')
      ALR=ALR*CSRHO
      GO TO 2
C
C  POWDER DATA:
   9  ALR=ALR*SINTH
      GO TO 2
C
C POLARISATION CORRECTION:
   2  GO TO (21,22,22,4,4,22,22,21,29,22), IGEOM
C
C NO POLARISATION:
  29  POL=1.
      GO TO 100
C
C RHO = 0:
  22  CSQRHO=1.
      SSQRHO=0.
      GO TO 20
C
C RHO ALREADY SET UP IN LORENTZ CALCULATION:
  21  CSQRHO=CSRHO*CSRHO
      SSQRHO=SNRHO*SNRHO
C
C SET COS2TH = COS 2 THETA
  20  CALL SINCOS(SIN2TH,COS2TH,'LP 5')
      POL = (1. +ANGLIN(2))/((SSQRHO+ANGLIN(2)*CSQRHO)*COS2TH*COS2TH +
     & CSQRHO + ANGLIN(2)*SSQRHO)
 100  RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE ABSCOR(IS)
      SUBROUTINE ABSCOR(IS)
C
C *** ABSCOR updated by PJB 24-Apr-1995 ***
C
CX
CC 2B
CH Applies absorption corrections to groups of equivalent reflections.
C
CA On entry IS =0 for the initial seting up, or 1 for the calculation
C
CP SYMOP, RECIP, SETABS should be obeyed first to set up calls of ABSOR
CP A group of reflections should be present in /REFS/
C
CO If IOUT is > 9 on entry IS=0, creates output unit LP2
CO (Note that this is a non-standard use of IOUT & better change)
CO For entries IS=1, writes to that unit
C
CN A PJB speciality called from ABSMSF
C
      EXTERNAL ABSHED
      DIMENSION ANG(4),KK(3),W1(5),W2(5)
      LOGICAL NEW
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(5,5),
     & NLAMB,ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /HEDABS/HEDAB
      CHARACTER*104 HEDAB
      COMMON /HEDAB2/LP2,LINB,IANG
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /REFS/K(3,2),JJ(48,2),LL(48,2),R(500,2),SCALE(2),INC,II,NR,
     &FF(3,2),ITEMS
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C
C INITIAL ENTRY:
      IF (IS.NE.0) GO TO 5
      IF (IOUT.LT.10) GO TO 100
      GO TO (100,100,100,100,100,1,1,1,100,100,1) ,IGEOM
      GO TO 100
C
    1 IANG=3
      MESSAG(1:10)='ABSCOR.LIS'
      CALL UPONE(MESSAG,3)
      LP2=NOPFIL(2022)
      IF (INC.EQ.0) GO TO 20
      HEDAB(2:2)='6'
      HEDAB(9:9)='7'
      HEDAB(16:16)='7'
      HEDAB(23:23)='7'
   20 IF (IGEOM .EQ. 8)GO TO 21
      HEDAB(87:)='Chi       Phi''/)'
      IANG=4
   21 WRITE (LP2,HEDAB)
      LINB=3
      GO TO 100
C
C FURTHER ENTRIES:
    5 IR=1
      II=0
    2 L=LL(IR,IS)
      IF (L.EQ.3) GO TO 100
C   SET BEGINNING AND END OF DATA
      IE=II+L
      IB=II+4
      IF (IGEOM.NE.7 .AND. IGEOM.NE.12) THEN
        TRFAC=ABSOR(R(II+1,IS))
        ABSC=1./TRFAC
      ELSE
        NEW=.TRUE.
      ENDIF
C   INITIALIZE
      CALL WTMEAN(X1,Y1,0,W1)
      CALL WTMEAN(X2,Y2,0,W2)
      DO 6 I=IB,IE,ITEMS
      IF (IGEOM.EQ.7) THEN
        IF (.NOT. NEW) THEN
C CHECK FOR EXACT SAME MEASUREMENT
          CALL EQVEC(DIFANG,R(I+2,IS),1,M,0)
          IF (M.EQ.1) GO TO 23
        ENDIF
        CALL GMEQ(R(I+2,IS),ANG,4,1)
        CALL GMSCA(ANG,DIFANG,RAD,4,1)
        TRFAC=ABSOR(R(II+1,IS))
        ABSC=1./TRFAC
      ENDIF
C   ADD IN REPEATED MEASUREMENTS OF THE SAME REFLECTION
   23 CALL WTMEAN(R(I,IS),R(I+1,IS),1,W1)
      R(I,IS)=R(I,IS)*ABSC
      R(I+1,IS)=R(I+1,IS)*ABSC
C   AND ITS INTENSITY AFTER SCALING BY ABSORPTION CORRECTION
      CALL WTMEAN(R(I,IS),R(I+1,IS),1,W2)
    6 CONTINUE
C   FIND MEAN OF REPEATED MEASUREMENTS
      CALL WTMEAN(X1,Y1,-1,W1)
      CALL WTMEAN(X2,Y2,-1,W2)
      IF (IOUT.GT.10) THEN
        IF (IGEOM.NE.7) THEN
C   CALCULATE SETTING ANGLES AS A CHECK
          CALL ANGDIR(R(II+1,IS),ANG)
          DO 4 I=1,IANG
    4     ANG(I)=DEGREE(ANG(I))
        ENDIF
        CALL TESTP(LP2,LINB,1,HEDAB,2)
        IF (INC.EQ.0) THEN
          CALL INDFIX(R(II+1,IS),KK)
          WRITE (LP2,2000) KK,X1,X2,TRFAC,(ANG(I),I=1,IANG)
 2000     FORMAT (2X,3I5,2(2X,F10.2),2X,F10.4,2X,4F10.2)
        ELSE
          WRITE (LP2,2001) (R(II+I,IS),I=1,3),X1,X2,TRFAC,
     &    (ANG(I),I=1,IANG)
 2001     FORMAT (1X,3F8.3,2(2X,F10.2),2X,F10.4,2X,4F10.2)
        ENDIF
      ENDIF
C   ADVANCE POINTER TO NEXT PIECE OF DATA IN ARRAY R(II,IS)
      II=IE+2
      IR=IR+1
      GO TO 2
C
 100  RETURN
      END
C
C
C
C
C LEVEL 4      FUNCTION ABSOR(H)
      FUNCTION ABSOR(H)
C
C *** ABSOR by JCM 24 Sep 85 ***
C
CX
CC 2B
CH Forms a transmission (=1/absorption) factor or related integrals.
C
CA On entry H is a 3-size real array holding h,k,l
C
CP On entry, SETABS (or a MAIN program) has placed in COMMON /ABSDAT
CP         AMU = mu, the coefficient of absorption
CP         MODEA = which integral is required -
CP         MODEA = 1 usual exp(-mu(in+out)) transmission factor to ABSC(1)
CP         MODEA = 2 path in exp(-mu(in)) depolarisation to ABSC(2)
CP         MODEA = 3 derivative (in+out)*exp(-mu(in+out)) extinction to ABSC(3)
CP
CP SETABS has set up (via SETGAU) the Gaussian 3D integration in COMMON /GAUSS
CP
CP SETABS has set up the equations of the plane faces in COMMON /CPLANE.
C
CD Uses 3D Gaussian integration over the crystal as defined by its plane faces
CN There also exists SUBROUTINE ABMULT, which is capable of calcuating more
CN than one type of integral at one entry.  If, e.g., absorption and
CN depolarisation were both required, one call of ABMULT would be more
CN efficient than 2 calls of ABSOR
C
      LOGICAL TESTOV
      DIMENSION H(3),DIREC(3,2)
      COMMON /ABSDAT/AMU,MODEA
      COMMON /CPLANE/AA(15),BB(15),CC(15),DD(15),NP
      COMMON /GAUSS/XX(1000),YY(1000),ZZ(1000),WW(1000),NL,NM,NN,NQ
C
      CALL GETDC(H,DIREC)
      ABSC = 0.
      DO 1 J = 1,NQ
      D = 6000.
      E = 6000.
      DO 2 I = 1,NP
      A = DD(I) - AA(I)*XX(J) - BB(I)*YY(J) - CC(I)*ZZ(J)
      B=AA(I)*DIREC(1,1)+BB(I)*DIREC(2,1)+CC(I)*DIREC(3,1)
      IF (TESTOV(A,B)) GO TO 3
      C = A/B
      IF (C) 3,4,4
   4  IF (C-D) 5,5,3
   5  D = C
   3  B=AA(I)*DIREC(1,2)+BB(I)*DIREC(2,2)+CC(I)*DIREC(3,2)
      IF (TESTOV(A,B)) GO TO 2
      C = A/B
      IF (C) 2,6,6
   6  IF (C-E) 7,7,2
   7  E = C
   2  CONTINUE
      IF (MODEA .GT. 3) CALL ERRIN2(MODEA,0,'for FUNCTION ABSOR MODE',
     & 'not allowed - only 1-3')
      GO TO (8,9,10) , MODEA
   8  ABSC = ABSC + EXP(-AMU*(D+E))*WW(J)
      GO TO 1
   9  ABSC = ABSC + EXP(-AMU*D)*WW(J)
      GO TO 1
  10  ABSC = ABSC + (D+E)*EXP(-AMU*(D+E))*WW(J)
   1  ABSOR=ABSC
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE XYZREL
      SUBROUTINE XYZREL
C
C *** XYZREL by JCM 28 Nov 91 ***
C
CX
CC 6B
CH Collects all position parameter constraints implied by the symmetry.
CD Space group symmetry generated constraints are each between 2 parameters.
CD Some of the relations found may lead to fixings rather than constraints.
CD
CD On exit in /POSREL/ for each atom I the integer array NXYZ(I,1:3) and
CD real array XYZ(I,1:3) hold the constraints.
C
C
      DIMENSION RMAT(3,3)
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /POSREL/NXYZ(3,150),XYZ(3,150)
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
C SCAN ALL ATOMS, PICKING UP RELATIONS BETWEEN POSITION PARAMETERS:
      DO 3 IR=1,NATOM
C CLEAR OUT ALL FIX/RELA INFO FOR THIS ATOM:
      DO 2 K=1,3
      NXYZ(K,IR)=9999
   2  CONTINUE
C
C JUMP IF NOT SPECIAL:
      IF (ISGEN(1,IR) .EQ. 1) GO TO 3
C JUMP IF NOT SPECIAL BECAUSE OF A CENTRE OF SYMMETRY AT THE ORIGIN:
      IF (ISGEN(1,IR) .LE. 0) THEN
C FIX ALL POSITION:
        CALL GMZER(NXYZ(1,IR),1,3)
        GO TO 3
      ENDIF
C
C TAKE FIRST (OF POSSIBLE 2) SYMMETRY ELEMENTS MAKING THIS POSITION SPECIAL:
      DO 1 I=2,3
      K=IABS(ISGEN(I,IR))
      CALL GMEQ(SYM(1,1,K),RMAT,3,3)
      IF (ISGEN(I,IR) .LT. 0) CALL GMREV(RMAT,RMAT,3,3)
      CALL RELSM3(RMAT,NXYZ(1,IR),XYZ(1,IR))
C
C IS THERE A SECOND GENERATOR OF THE SUB-GROUP WHICH MAKES THIS ATOM SPECIAL?
      IF (ISGEN(3,IR) .EQ. 0) GO TO 3
   1  CONTINUE
   3  CONTINUE
 100  RETURN
      END

C
C LEVEL 1      FUNCTION WIYPOS(Y)
C
      FUNCTION WIYPOS(Y)
C
C *** WIYPOS by WIFD 6-JUNE-84 ***
C
CH      GIVES      EXP(Y*Y)ERFNC(Y) FOR +VE Y ONLY
C
      IMPLICIT DOUBLE PRECISION            (A-H,O-V)
      DOUBLE PRECISION LAMBDA
      LOGICAL B
      VY=DBLE(Y)
      IF (VY .LT. 4.29 ) GO TO 1
      H= 0.
      NC= 0
      N= 9
      LAMBDA= 0.
      B= .TRUE.
      GO TO 2
 1      S=(1.0-VY/4.29)
      H=1.6*S
      H2=2.0*H
      NC=6+IDINT(23.0*S)
      N=10+IDINT(21.0*S)
      LAMBDA=H2**NC
      B= .FALSE.
      IF (LAMBDA .EQ. 0.) B= .TRUE.
 2      R1=0.
      S1=0.
 3      N=N-1
      FN=N+1
      T1=VY+H+FN*R1
      R1=0.5/T1
      IF (H .LE. 0.0 .OR. N .GT. NC) GO TO 4
      S1=R1*(LAMBDA+S1)
      LAMBDA=LAMBDA/H2
 4      IF (N .GT. 0) GO TO 3
      IF (B) GO TO 6
      VR= S1
      GO TO 7
 6      VR= R1
 7      VR= 1.12837916709551*VR
      IF (VY .EQ. 0.0) VR= 1.
      WIYPOS= VR
      RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE WGHTSF(H)
      SUBROUTINE WGHTSF(H)
C
C *** WGHTSF updated by JCM 29 Jun 87 ***
C
CX
CC 6C
CH Deals with weights of LSQ observations for single crystal.
CA On entry H is a real 1x3 vector containg h,k,l
CD Puts weight of observation at H into WT, its square root into SQRTWT,
CD and WDIFF = SQRTWT times difference, all according to IWGHT.
C
      LOGICAL TESTOV
      DIMENSION H(3)
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
      GO TO (1,2) ,IWGHT
C
C  NO WEIGHTS
   1  WT=1.
      SQRTWT=1.
      GO TO 101
C
C GOES WITH MODER=2 OR 3 - IF 2, EXPECT WT TO BE ALREADY THERE,
C PROBABLY READ AT SAME TIME AS REFLECTION DATA.   IF 3, EXPECT
C SIGMA, THE STANDARD DEVIATION OF THE OBSERVATION, TO BE ALREADY
C THERE IN DOBS
   2  GO TO (1,21,22,22,22,22,22,22) , MODER
  21  SQRTWT=SQRT(WT)
      GO TO 101
C
  22  SQRTWT=0.
      IF (.NOT. TESTOV(1.,DOBS)) SQRTWT=ABS(1./DOBS)
      WT=SQRTWT*SQRTWT
 101  WDIFF=DIFF*SQRTWT
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE VARST2
      SUBROUTINE VARST2
C
C *** VARST2 by JCM 17 Aug 92 ***
C
CX
CC 7B
CH Makes variables for zero and cell for T2 type LSQ
CP Only useful if called from T2LSQ or similar.  Expects suitable type
CP of Least Squares to be set up.
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans all variables as made by VARMAK, identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /ZEROPT/ZERO,KZERO
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      CALL CELVAR(0,0)
      KZERO=0
C
C COUNT ALL VARIABLES:
      DO 1 I=1,LVARV
C J=WHICH BASIC VARIABLE:
      J=LVRBS(I)
C KPACK=WHICH PACKED PARAMETER SPEC:
      KPACK=LVRPR(I)
C
C AND ITS FAMILY, GENUS AND SPECIES:
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C FAMILY 1, GENUS 1 - CELL PARAMETERS:
      IF (IGEN .EQ. 1) THEN
        IF (ISPC .EQ. 7) THEN
          KZERO=I
        ELSE
          CALL CELVAR(ISPC,I)
        ENDIF
      ENDIF
C
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE VARSSF
      SUBROUTINE VARSSF
C
C *** VARSSF by JCM 16 Nov 90 ***
C
CX
CC 7A
CH Records variable pointers for all variables in structure-factor LSQ.
CP VARMAK has set up the variables
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans variables as made by VARMAK.  Identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      CALL LTFAC9
      CALL CELVAR(0,0)
      CALL EXTIN9
      CALL LSCAL9
      CALL F2VAR9
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
      KPACK=LVRPR(I)
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C
C BRANCH ON FAMILY:
      GO TO (11,12), IFAM
C
  11  GO TO (21,22) , IGEN
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SPECIES (TFAC,A*,B* . . F*,DOMR,MOSC):
  21  GO TO (31,32,32,32,32,32,32,33,33) , ISPC
C
C TFAC:
  31  CALL LTFAC8(I)
      GO TO 1
C
C DOMR OR MOSC (EXTINCTION CORRECTION PARAMETERS)
  33  CALL EXTIN8(ISPC-7,I)
      GO TO 1
C
C CELL PARAMETERS:
  32  CALL CELVAR(ISPC-1,I)
      GO TO 1
C
C FAMILY 1, GENUS 2 - IN SF THIS IS 'SCAL':
  22  CALL LSCAL8(ISPC,I)
      GO TO 1
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .LE. 12) CALL F2VAR8(IGEN,ISPC,I)
   1  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE VARSDS
      SUBROUTINE VARSDS
C
C *** VARSDS updated by PJB 29-Sept-93  ***
C
CX
CC 7A
CH Makes variables for cell parameters and propagation vector for d-spacing LSQ.
CP Only useful if called from DSLSQ or similar.  Expects suitable type
CP of Least Squares to be set up.
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans all variables as made by VARMAK, identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
C SET ALL VARIABLES FIXED:
      CALL CELVAR(0,0)
      CALL PROPAG(0,0)
C
C COUNT ALL VARIABLES:
      DO 1 I=1,LVARV
C J=WHICH BASIC VARIABLE:
      J=LVRBS(I)
C KPACK=WHICH PACKED PARAMETER SPEC:
      KPACK=LVRPR(I)
C
C AND ITS FAMILY, GENUS AND SPECIES:
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C FAMILY 1, GENUS 1 - CELL PARAMETERS:
      IF (IFAM .EQ. 1 .AND. IGEN .EQ. 1) THEN
        IF (ISPC.LE.6) THEN
          CALL CELVAR(ISPC,I)
        ELSE
          CALL PROPAG(-ISPC+6,I)
        ENDIF
      ELSE
        CALL ERRMES(-1,0,' parameter in DSLSQ not of family 1 genus 1')
      ENDIF
C
   1  CONTINUE
 100  RETURN
      END
C
C
C
C LEVEL 13      SUBROUTINE VARSMP
      SUBROUTINE VARSMP
C
C *** VARSMP by JCM 8 Feb 91 ***
C
CX
CC 7A
CH Records pointers for all variables in multipole LSQ.
CP VARMAK has set up the variables
C
CD First clears all possible parameters for this application to be fixed.
CD Then scans variables as made by VARMAK.  Identifies each variable as a
CD type of parameter, and calls individual routines to record the information.
C
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
      IF (SIMUL) GO TO 100
C SET ALL VARIABLES FIXED:
      CALL LTFAC9
      CALL CELVAR(0,0)
      CALL MAGVAR(0,0,0)
      CALL EXTIN9
      CALL LSCAL9
      CALL F2VAR9
      CALL MPOVAR(0,0)
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
      KPACK=LVRPR(I)
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
C
C BRANCH ON FAMILY:
      GO TO (11,12,1,1,15), IFAM
C
  11  GO TO (21,22) , IGEN
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SPECIES (TFAC,A*,B* . . F*,DOMR,MOSC):
  21  GO TO (31,32,32,32,32,32,32,33,33) , ISPC
C
C TFAC:
  31  CALL LTFAC8(I)
      GO TO 1
C
C DOMR OR MOSC (EXTINCTION CORRECTION PARAMETERS)
  33  CALL EXTIN8(ISPC-7,I)
      GO TO 1
C
C CELL PARAMETERS:
  32  CALL CELVAR(ISPC-1,I)
      GO TO 1
C
C FAMILY 1, GENUS 2 - IN SF THIS IS 'SCAL':
  22  CALL LSCAL8(ISPC,I)
      GO TO 1
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .LE. 12) CALL F2VAR8(IGEN,ISPC,I)
      IF (ISPC .GT. 12) CALL MAGVAR(IGEN,ISPC,I)
      GO TO 1
C
C MULTIPOLES:
  15  CALL MPOVAR(ISPC,I)
   1  CONTINUE
 100  RETURN
      END
C
C

C
C
C LEVEL 2      SUBROUTINE SHUFLE(JORD,IORD)
      SUBROUTINE SHUFLE(JORD,IORD)
C
C *** SHUFLE by PJB Jan 86 ***
C
CX
CC 1A
CH Reorders the symmetry operators for various specialist applications.
C
      LOGICAL BINDIG
C%
C      DIMENSION IORD(%SYMO%),JORD(%SYMO%),L(%SYMO%)
      DIMENSION IORD(24),JORD(24),L(24)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
      COMMON /SYMREP/REP(9,25),AKVEC(3),LREP(25),NREP,IVEC,ANORM,
     & NOPS,NOPP,NCSTAR,TREP(25,2,2)
      COMPLEX REP,TREP
      COMMON /SYMTAB/MULTAB(24,24),INVERS(24),
     & NORD(24),IGEN(3),KOM22
C
      IF (BINDIG(IOUT,16)) THEN
        WRITE (ITO,4000) (JORD(I),I=1,NOPC)
        WRITE (LPT,4000) (JORD(I),I=1,NOPC)
        WRITE (ITO,4000) (IORD(I),I=1,NOPC)
        WRITE (LPT,4000) (IORD(I),I=1,NOPC)
4000    FORMAT (/' ',2(12I4))
      ENDIF
      CALL JGMZER(L,1,NOPC)
C
C  NOW SHUFFLE TABLE
      DO 3 NN=2,NOPC
      NNN=NN
      IF (L(NN).EQ.1) GO TO 3
      INN=JORD(NN)
      IF (INN.EQ.NN) INN=1
C
C  SAVE A ROW IN PLACE OF ROW 1
C REPLACES CALL GMEQ(MULTAB(1,NN),MULTAB(1,1),NOPC,1)
      DO 88 IJ=1,NOPC
  88  MULTAB(IJ,1)=MULTAB(IJ,NN)
C  AND A SYMMETRY OPERATOR
      CALL GMEQ(SYM(1,1,NN),SYM(1,1,1),3,3)
      CALL GMEQ(TRANS(1,NN),TRANS(1,1),3,1)
      CALL CGMEQ(REP(1,NN),REP(1,1),NREP,NREP)
      INVERS(1)=INVERS(NN)
      NORD(1)=NORD(NN)
      LREP(1)=LREP(NN)
C
C  NOW SHUFFLE ROW INN INTO ROW NN
    6 DO 5 N=1,NOPC
      M=MULTAB(JORD(N),INN)
    5 MULTAB(N,NNN)=IORD(M)
C  AND REPLACE THE NNN TH SYMMMTRY OPERATOR
      CALL GMEQ(TRANS(1,INN),TRANS(1,NNN),3,1)
      CALL GMEQ(SYM(1,1,INN),SYM(1,1,NNN),3,3)
      CALL CGMEQ(REP(1,INN),REP(1,NNN),NREP,NREP)
      INVERS(NNN)=IORD(INVERS(INN))
      NORD(NNN)=NORD(INN)
      LREP(NNN)=LREP(INN)
C
C  NOW FIND OU WHAT TO DO NEXT
      IF (INN.EQ.1) GO TO 3
C  MARK INN 'DONE'
      L(INN)=1
      NNN=INN
      IF (JORD(INN).EQ.0) GO TO 9
      INN=JORD(INN)
      IF (L(INN).EQ.0) GO TO 8
      GO TO 3
    8 IF (INN.EQ.NN) INN=1
      GO TO 6
    9 INN=1
      GO TO 6
C
    3 CONTINUE
C
C  NOW REWRITE ROW 1
       DO 7 N=1,NOPC
    7 MULTAB(N,1)=N
C  AND SYMMETRY ELEMENT NUMBER 1, THE IDENTITY ELEMENT
      DO 4 I=1,3
      TRANS(I,1)=0.
      SYM(I,I,1)=1.
      DO 4 J=1,3
      IF (I.EQ.J) GO TO 4
      SYM(I,J,1)=0.
    4 CONTINUE
C
      IJ=0
      DO 20 I=1,NREP
      DO 20 J=1,NREP
      IJ=IJ+1
   20 REP(IJ,1)=CMPLX(SYM(I,J,1),0.)
      NORD(1)=1
      LREP(1)=1
      INVERS(1)=1
C
      IF (BINDIG(IOUT,16)) THEN
        WRITE (ITO,4000)
        WRITE (LPT,4000)
        DO 50 I=1,NOPC
        WRITE (ITO,4000) (MULTAB(J,I),J=1,NOPC)
   50   CONTINUE
      ENDIF
C
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ABMULT(H,ABSC)
      SUBROUTINE ABMULT(H,ABSC)
C
C *** ABMULT by JCM 24 Sep 85 ***
C
CX
CC 2B
CH Forms transmission (=1/absorption) factors or related integrals.
C
CA On entry:
CA    H is a 3-size real array holding h,k,l on entry
CA    ABSC is a 3-size real array to hold the requested integrals on exit
C
CP On entry, SETABS (or a MAIN program) has placed in COMMON /ABSDAT
CP         AMU = mu, the coefficient of absorption
CP         MODEA = which integral is required -
CP         MODEA = 1 usual exp(-mu(in+out)) transmission factor to ABSC(1)
CP         MODEA = 2 path in exp(-mu(in)) depolarisation to ABSC(2)
CP         MODEA = 3 derivative (in+out)*exp(-mu(in+out)) extinction to ABSC(3)
CP         MODEA = 4 means do 1 and 2
CP         MODEA = 5 means do 1 and 3
CP         MODEA = 6 means do 2 and 3
CP         MODEA = 7 means do all three integrals
CP
CP SETABS has set up (via SETGAU) the Gaussian 3D integration in COMMON /GAUSS
CP
CP SETABS has set up the equations of the plane faces in COMMON /CPLANE.
C
CD Uses 3D Gaussian integration
C
CN There exists also the FUNCTION ABSOR(H), which is similar to ABMULT but will
CN only do one answer at once.
C
      LOGICAL TESTOV
      DIMENSION H(3),DIREC(3,2),ABSC(3)
      COMMON /ABSDAT/AMU,MODEA
      COMMON /CPLANE/AA(15),BB(15),CC(15),DD(15),NP
      COMMON /GAUSS/XX(1000),YY(1000),ZZ(1000),WW(1000),NL,NM,NN,NQ
C
      CALL GETDC(H,DIREC)
      DO 11 I=1,3
  11  ABSC(I)=0.
      DO 1 J = 1,NQ
      D = 6000.
      E = 6000.
      DO 2 I = 1,NP
      A = DD(I) - AA(I)*XX(J) - BB(I)*YY(J) - CC(I)*ZZ(J)
      B=AA(I)*DIREC(1,1)+BB(I)*DIREC(2,1)+CC(I)*DIREC(3,1)
      IF (TESTOV(A,B)) GO TO 3
      C = A/B
      IF (C) 3,4,4
   4  IF (C-D) 5,5,3
   5  D = C
   3  B=AA(I)*DIREC(1,2)+BB(I)*DIREC(2,2)+CC(I)*DIREC(3,2)
      IF (TESTOV(A,B)) GO TO 2
      C = A/B
      IF (C) 2,6,6
   6  IF (C-E) 7,7,2
   7  E = C
   2  CONTINUE
      IF (MODEA .GT. 7) CALL ERRIN2(MODEA,0,'for ABMULT MODE',
     & 'not allowed - only 1-7')
C
      GO TO (20,21,20,20,20,20,20) , MODEA
  20  TERM=EXP(-AMU*(D+E))*WW(J)
  21  GO TO (8,9,10,8,8,9,8) , MODEA
   8  ABSC(1)=ABSC(1)+TERM
      GO TO (1,1,1,9,10,1,9) , MODEA
   9  ABSC(2)=ABSC(2)+EXP(-AMU*D)*WW(J)
      GO TO (1,1,1,1,1,10,10) , MODEA
  10  ABSC(3)=ABSC(3) + (D+E)*TERM
   1  CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE ABMULT(H,ABSC)
      SUBROUTINE ABMULT(H,ABSC)
C
C *** ABMULT by JCM 24 Sep 85 ***
C
CX
CC 2B
CH Forms transmission (=1/absorption) factors or related integrals.
C
CA On entry:
CA    H is a 3-size real array holding h,k,l on entry
CA    ABSC is a 3-size real array to hold the requested integrals on exit
C
CP On entry, SETABS (or a MAIN program) has placed in COMMON /ABSDAT
CP         AMU = mu, the coefficient of absorption
CP         MODEA = which integral is required -
CP         MODEA = 1 usual exp(-mu(in+out)) transmission factor to ABSC(1)
CP         MODEA = 2 path in exp(-mu(in)) depolarisation to ABSC(2)
CP         MODEA = 3 derivative (in+out)*exp(-mu(in+out)) extinction to ABSC(3)
CP         MODEA = 4 means do 1 and 2
CP         MODEA = 5 means do 1 and 3
CP         MODEA = 6 means do 2 and 3
CP         MODEA = 7 means do all three integrals
CP
CP SETABS has set up (via SETGAU) the Gaussian 3D integration in COMMON /GAUSS
CP
CP SETABS has set up the equations of the plane faces in COMMON /CPLANE.
C
CD Uses 3D Gaussian integration
C
CN There exists also the FUNCTION ABSOR(H), which is similar to ABMULT but will
CN only do one answer at once.
C
      LOGICAL TESTOV
      DIMENSION H(3),DIREC(3,2),ABSC(3)
      COMMON /ABSDAT/AMU,MODEA
      COMMON /CPLANE/AA(15),BB(15),CC(15),DD(15),NP
      COMMON /GAUSS/XX(1000),YY(1000),ZZ(1000),WW(1000),NL,NM,NN,NQ
C
      CALL GETDC(H,DIREC)
      DO 11 I=1,3
  11  ABSC(I)=0.
      DO 1 J = 1,NQ
      D = 6000.
      E = 6000.
      DO 2 I = 1,NP
      A = DD(I) - AA(I)*XX(J) - BB(I)*YY(J) - CC(I)*ZZ(J)
      B=AA(I)*DIREC(1,1)+BB(I)*DIREC(2,1)+CC(I)*DIREC(3,1)
      IF (TESTOV(A,B)) GO TO 3
      C = A/B
      IF (C) 3,4,4
   4  IF (C-D) 5,5,3
   5  D = C
   3  B=AA(I)*DIREC(1,2)+BB(I)*DIREC(2,2)+CC(I)*DIREC(3,2)
      IF (TESTOV(A,B)) GO TO 2
      C = A/B
      IF (C) 2,6,6
   6  IF (C-E) 7,7,2
   7  E = C
   2  CONTINUE
      IF (MODEA .GT. 7) CALL ERRIN2(MODEA,0,'for ABMULT MODE',
     & 'not allowed - only 1-7')
C
      GO TO (20,21,20,20,20,20,20) , MODEA
  20  TERM=EXP(-AMU*(D+E))*WW(J)
  21  GO TO (8,9,10,8,8,9,8) , MODEA
   8  ABSC(1)=ABSC(1)+TERM
      GO TO (1,1,1,9,10,1,9) , MODEA
   9  ABSC(2)=ABSC(2)+EXP(-AMU*D)*WW(J)
      GO TO (1,1,1,1,1,10,10) , MODEA
  10  ABSC(3)=ABSC(3) + (D+E)*TERM
   1  CONTINUE
      RETURN
      END
C
C

C
C
C
C LEVEL 8      SUBROUTINE GAMEX(R,G,FC,QQ,IERR)
      SUBROUTINE GAMEX(R,G,FC,QQ,IERR)
C
C *** GAMEX updated by JCM 23 Sep 91 ***
C
CX
CC 2B
CH Calculates an extinction corrected gamma from a flipping ratio.
CA On entry R is a 1x2 real array holding the flipping ratio and its
CA            standard deviation
CA          FC is the value of the nuclear structure factor
CA          QQ is sin(alpha) the angle between Q and k
CA On exit  G(1)  holds the extinction corrected gamma
CA          IERR=0 if no error
CA               1 if no zero found in range
CA               2 if no convergence after 50 iterations
C
      DIMENSION R(2),G(2),F(2),PP(4)
      COMMON /EXTN/IEXTYP,DOMR,KDOMR,AMOSC,KMOSC,EXTCOR,CEXT(4),
     & DEXDFQ,DEXDRQ,DEXDGQ,LOREN,GAUSS
      LOGICAL LOREN,GAUSS
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POLDA/P,DP,E,DE,MODE,POLND(3)
      DATA ITER,PREC/100,10./
C
      IERR=0
C IF IN FACT NO EXTINCTION, SET RS TO BE GAMMAS AND EXIT:
      IF (IEXTYP .EQ. 0) THEN
        CALL GMEQ(G,R,1,2)
        GO TO 100
      ENDIF
C
C  SET LIMITS
      GLIM=SIGN(1.,G(1))
      A=AMIN1(GLIM,G(1))
      B=AMAX1(GLIM,G(1))
      ERR=G(2)/PREC
      K=0
    5 CALL NB01A(K,A,B,ERR,X,Y,ITER)
      GO TO (1,2,3,4) ,K
C
    3 WRITE (LPT,3000) A,B
3000  FORMAT (' No zero found in the range from',F8.4,' to',F8.4)
      IERR=1
      GO TO 100
C
   4  CALL ERRIN2(ITER,1,
     & 'Gamma value not converged after','iterations')
      IERR=2
      GO TO 100
C
C  CALCULATE R FOM GAMMA
    1 FF=1.+(QQ*X)**2
      F2=2.*QQ*X
      F(1)=FF+F2
      F(2)=FF-F2
      PP(1)=0.5*(1.+P)
      PP(2)=0.5*(1.-P)
      PE=P*E
      PP(3)=0.5*(1.-PE)
      PP(4)=0.5*(1.+PE)
      ANUM=0.
      DEN=0.
      DO 20 I=1,2
      FMOD=SQRT(F(I))*FC
      CALL EXTINC(2,FMOD)
      YY=EXTCOR**2
      ANUM=ANUM+YY*F(I)*PP(I)
      DEN=DEN+YY*F(I)*PP(2+I)
   20 CONTINUE
      Y=R(1)-ANUM/DEN
      GO TO 5
C
C  HERE AFTER CONVERGENCE
    2 G(1)=X
C
  100 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE ESDFMT(X,DX,BUFF,IW)
      SUBROUTINE ESDFMT(X,DX,BUFF,IW)
C
C *** ESDFMT new by PJB 9 Mar 1994 ***
C
CH Writes X and its esd DX in the form X(DX)
C
CD A value X and its its ESD DX are written into the buffer BUFF in the form
CD X(DX) as often used in published tables.
CA X is the value and DX its standard deviation
CA BUFF is a character buffer to receive the result
CA IW is the maximum number of characters in BUFF to be used
C
      CHARACTER *(*) BUFF
      CHARACTER *40 VFMT
      LOGICAL TWOFIG
C
      DEL=DX
      IF (DEL.LT.10E-10) THEN
        WRITE (VFMT,13) IW
   13 FORMAT ('(E',I2,'.4)')
        WRITE (BUFF,VFMT) X
        GO TO 100
      ENDIF
      ISIG=NINT(DEL)
      IF (ISIG.EQ.0) THEN
        IS=0
    1   IS=IS+1
        DEL=10.*DEL
        ISIG=NINT(DEL)
        IF (ISIG.EQ.0) GO TO 1
        JW=IW-3
        IF (JW.LT.3) GO TO 99
        WRITE (VFMT,10) JW,IS
   10 FORMAT ('(F',I2,'.',I1,',''('',I1,'')'')')
        WRITE (BUFF,VFMT) X,ISIG
      ELSE
        IS=1
    2   TWOFIG=(ISIG.GE.10)
        IS=IS+1
        IF (ISIG.GT.15) THEN
          DEL=DEL/10.
          ISIG=NINT(DEL)
          GO TO 2
        ENDIF
        IS=IS-1
        MUL=10**(IS-1)
        IF (TWOFIG) IS=IS+1
        IX=(NINT(X/FLOAT(MUL)))*MUL
        ISIG=ISIG*MUL
        JW=IW-2-IS
        IF (JW.LT.IS) GO TO 99
        WRITE (VFMT,11) JW,IS
   11 FORMAT ('(I',I2,',''('',I',I1,','')'')')
        WRITE (BUFF,VFMT) IX,ISIG
      ENDIF
      GO TO 100
   99 WRITE (BUFF,12) ('*',I=1,IW)
   12 FORMAT (80A1)
  100 RETURN
      END
C
C
C
C
C LEVEL 1      LOGICAL FUNCTION DFTRUE(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFTRUE(IFAM,IGEN,ISPC)
C
C *** DFTRUE by JCM 3 Dec 90 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of VARMAK in main programs, to vary
CH an otherwise unspecified parameter.
CA DFTRUE on exit is .TRUE. if parameter is by default varied, .FALSE. if fixed
CA      - in this case it is always TRUE
CA IFAM on entry = family
CA IGEN on entry = genus
CA ISPC on entry = species (in this case, all irrelevant)
C
CD Varies all by default:
C TO KEEP COMPILERS HAPPY:
      I=IFAM
      I=IGEN
      I=ISPC
      DFTRUE=.TRUE.
      RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION DFLTSF(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFLTSF(IFAM,IGEN,ISPC)
C
C *** DFLTSF updated by JCM 10 May 90 ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of SUBROUTINE VARMAK, giving
CH default fix/vary information for structure parameters.
CA On entry IFAM, IGEN, ISPC specify the parameter.
CD On exit DFLTSF is .TRUE. if parameter IFAM,IGEN,ISPC is by default varied
CD         and .FALSE. if fixed.
C
CD In general varies, but fixes scattering factor, and only varies an itf
CD if there is no corresponding atf. Only allows A*-F* to vary if there
CD are slack constraints.
C
      COMMON /ANISO/ATF(6,50),KATF(6,50),IAPT(150),
     & IATYP(50),KOM1
      COMMON /SLAKDA/NSLAK(4),SLKSWD(4),SLAKWT(4),
     & CHISQD(4),ISLKTP,NSKTOT,KOM24
C
      DFLTSF=.TRUE.
      GO TO (1,2) , IFAM
      GO TO 100
C
C
C TRAP NON-EXISTENT CELL PARAMETERS:
   1  IF (IGEN .NE. 1) GO TO 100
      IF (NSLAK(1).EQ.0 .AND. (ISPC.GE.2 .AND. ISPC.LE.7)) GO TO 101
      GO TO 100
C
   2  IF (ISPC .LT. 10) GO TO 100
      IF (ISPC .LT. 12) GO TO 101
C IF VARYING ITF BY DEFAULT, CHECK NOT ALSO ATF:
      IF (IAPT(IGEN) .EQ. 0) GO TO 100
C
C FIX:
 101  DFLTSF=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 2      LOGICAL FUNCTION DFLTMP(IFAM,IGEN,ISPC)
      LOGICAL FUNCTION DFLTMP(IFAM,IGEN,ISPC)
C
C *** DFLTMP by PJB Oct 88  ***
C
CX
CC 7A
CH Called as a substitute for DEFALT out of VARMAK, giving defaults fix/vary
CH for otherwise unspecified parameters of multipole refinements.
CA On entry, IFAM,ISPC,IGEN hold family, genus and species of a parameter
CA for which there exists no other information as to whether to fix or
CA vary it.
CD Varies all multipoles and fixes the rest.
C
      I=IGEN + ISPC
      DFLTMP=(IFAM.EQ.5)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE CIRCLE(XX,YY,R,M)
      SUBROUTINE CIRCLE(XX,YY,R,M)
C
C *** CIRCLE by PJB 25 May 90 ***
C
CX
CC 14C
CH Draws a circle of given radius and centre, with various options.
CA On entry XX,YY give the centre of the circle in the current space.
CA          R is the required radius, in cms.
CA          M lists the required options:
CA If M=0 the circle is open
CA If M=+/- 1 a plus or minus is inscribed
CA If M>1 the circle is hatched at intervals of M*.25 mm.
C
      COMPLEX ARG,PHASE,POS
      DIMENSION A(2),PTS(2,12),FPTS(2,12),IPT(4)
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /PLTRAN/PMTRIX(2,3,10),PTRAN(2,3,2),NSPCE,NCON1,NCON2,MPEN,
     & NTRAN(10),MAXSP
      EQUIVALENCE (A,POS),(A(1),X),(A(2),Y)
      DATA FPTS/3.5,1.,1.,1.,1.,3.5,-1.,3.5,-1.,1.,
     & -3.5,1.,-3.5,-1.,-1.,-1.,-1.,-3.5,1.,-3.5,1.,-1.,3.5,-1./
      DATA IPT/1,6,7,12/
      DATA GRID/.025/
C>> JCC Implement error tracking rather than stopping

      INTEGER IBMBER
      COMMON / CCSLER / IBMBER
      IBMBER = 0
C
C  SAVE CURRENT SPACE
      MSPCE=NSPCE
      CALL PLCONV(XX,YY,NSPCE,A1,B1,3)
C>> JCC Added
      IF (IBMBER .NE. 0) RETURN
      CALL SPCSET(3)
C>> JCC Added
      IF (IBMBER .NE. 0) RETURN
C
C  DRAW CIRCLE
      CALL KANGA1(A1+R,B1,3)
      PHASE=CMPLX(1.,0.)
      ARG=CEXP(CMPLX(0.,TWOPI/200.))
      DO 1 I=1,200
      PHASE=PHASE*ARG
      POS=PHASE*R
      CALL KANGA1(A1+X,B1+Y,2)
    1 CONTINUE
C
      IF (M.EQ.0) GO TO 101
      IF (IABS(M).EQ.1) THEN
C  SCALE SIGNS
        CALL GMSCA(FPTS,PTS,R*.2,2,12)
        CALL GMEQ(PTS(1,12),A,2,1)
        CALL KANGA1(A1+X,B1+Y,3)
        IF (M.LT.0) THEN
          NPTS=4
        ELSE
          NPTS=12
        ENDIF
        DO 2 I=1,NPTS
        J=I
        IF (M.LT.0) J=IPT(I)
        CALL GMEQ(PTS(1,J),A,2,1)
        CALL KANGA1(A1+X,B1+Y,2)
    2   CONTINUE
C
C  SHADE SIGN
        STEP=.05
        IF (M.GT.0) THEN
          CALL KANGA1(A1+PTS(1,5),B1+PTS(2,5),3)
          DO 20 W=PTS(2,5),PTS(2,4),STEP
          CALL KANGA1(A1+PTS(1,4),B1+W,2)
          CALL KANGA1(A1+PTS(1,3),B1+W,2)
   20     CONTINUE
        ENDIF
        CALL KANGA1(A1+PTS(1,7),B1+PTS(2,7),3)
        DO 21 W=PTS(2,7),PTS(2,6),STEP
        CALL KANGA1(A1+PTS(1,7),B1+W,2)
        CALL KANGA1(A1+PTS(1,12),B1+W,2)
   21   CONTINUE
        IF (M.GT.0) THEN
          CALL KANGA1(A1+PTS(1,9),B1+PTS(2,9),3)
          DO 22 W=PTS(2,9),PTS(2,8),STEP
          CALL KANGA1(A1+PTS(1,9),B1+W,2)
          CALL KANGA1(A1+PTS(1,10),B1+W,2)
   22     CONTINUE
        ENDIF
      ELSE
        IF (M.LT.2) GO TO 101
      ENDIF
C
C  SHADE CIRCLES
      CALL KANGA1(A1+R,B1,3)
      STEP=GRID*FLOAT(M)
      DO 23 W=R,-R,-STEP
      V=(R*R-W*W)
      IF (V.LT.0) GO TO 23
      V=SQRT(V)
      CALL KANGA1(A1+W,B1-V,2)
      CALL KANGA1(A1+W,B1+V,2)
   23 CONTINUE
C
C  RESTORE ORIGINAL SPACE
  101 CALL SPCSET(MSPCE)
  100 RETURN
      END
C
C
C
C
C LEVEL 5      SUBROUTINE CALPOL(H,NEW,ICOMP,SFCALC,MGCALC)
      SUBROUTINE CALPOL(H,NEW,ICOMP,SFCALC,MGCALC)
C
C *** CALPOL corrected by PJB 31-May-1994 ***
C
CX
CC 7B
CH Calculates scattered polarisations and their derivatives for structures
CH which may have mixed magnetic and nuclear reflections.
C
CA On entry H is the 1x3 array holding h,k,l
CA          NEW is TRUE if this hkl differs from the previous one
CA                   FALSE if it is the same
CA          ICOMP is the component of polarisation required
CA          SFCALC is the name of the routine to get nuclear structure factors
CA                 and their derivatives.  This is usually LFCALC.
CA          MGCALC is the name of the routine to get magnetic structure factors
CA                and their derivatives.  This is now LMCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC to the ICOMPth component of the scattered polarisation.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      If NEW calculate the nuclear and magnetic structure factors and
CD      their derivatives.
CD      If ICOMP=1 (ie 1st component for this input polarisation)
CD      calculate the output polarisation, summing over all domains
CD      and its differential wrt all parameters.
CD      Otherwise just set GCALC to previously calculated component
CD      of polarisation and scale the appropriate component of the
CD      differentials.
CD On exit in /OBSCAL/ GCALC = calculated function to compare with observed
CD         in /DERVAR/ DERIVV is an array holding all derivatives of GCALC
CD                            wrt all variables.
C
      EXTERNAL SFCALC,MGCALC
      COMPLEX CVEC(3),QSTAR(3),CPRD,CRSCLP,QCROSP(3)
      COMPLEX DPOLDP(3),TENS(3,3)
      LOGICAL NEW
      DIMENSION H(3),VEC(3),VEC1(3),POLI(3),DIFFER(3,10),QCROSQ(3)
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /FCAL/FC,FCMOD,COSAL,SINAL,FCDERS(300),DERIVT(300)
      COMPLEX FC,DERIVT
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /QCAL/Q(3,12)
      COMPLEX Q
      COMMON /QCALD/FQCDER(3,12,100)
      COMPLEX FQCDER
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /OVER/ITFAC,OTFAC(10),KOTFAC(10),NTFAC,JTFAC,KOM15
      EQUIVALENCE (TFAC,OTFAC(1)),(KTFAC,KOTFAC(1))
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /POLDAT/POLIT(3,3),POLM(6),POLO(3,12),QSQR(12),
     & POLD(3),QSQRM,DXSDN,DXSDQ(3,12),DPOLDN(3),DPOLDQ(3,3,12),
     & NDOMN,ND180
      COMPLEX DXSDN,DXSDQ,DPOLDN,DPOLDQ
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(20),KSCALE(20),
     & NSCL,LSCD(10)
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C  CALCULATE STRUCTURE FACTORS ON FIRST ENTRY
      IF (NEW) THEN
        CALL SFCALC(H)
        CALL MGCALC(H)
      ENDIF
      IF (ICOMP.EQ.1) THEN
C  CLEAR SUMS
        CALL GMZER(POLD,1,3)
        CALL CGMZER(DPOLDQ,3,3)
        CALL CGMZER(DPOLDN,3,1)
        CALL CGMZER(DXSDQ,3,1)
        QSQRM=0.
        DXSDN=CMPLX(0.,0.)
C  SET POLARISATION
        CALL GMEQ(POLM,POLI,3,1)
C  LOOP OVER DOMAINS
        NND=0
        DO 22 N180=1,ND180
        DO 20 ND=1,NDOMN/ND180
        NND=NND+1
C  CALCULATION OF POLARISATION DIRECTIONS
        CALL CMCONJ(Q(1,ND),QSTAR,3,1)
        CALL CGMSCA(Q(1,ND),CVEC,CONJG(FC),3,1)
        CALL CMREAL(CVEC,POLO(1,NND),3,1)
C  QXQ* TERM
        CALL CMREAL(QSTAR,VEC,3,1)
        CALL CMIMAG(QSTAR,VEC1,3,1)
        CALL VECPRD(VEC,VEC1,QCROSQ)
        CALL GMADD(POLO(1,NND),QCROSQ,POLO(1,NND),3,1)
C  POLARISATION DEPENDENT PART OF CROSS-SECTION
        POLPRD=2.*SCALPR(POLO(1,NND),POLI)
C  N*PXQ PART OF POLARISATION
        CALL CMIMAG(CVEC,VEC,3,1)
        CALL VECPRD(POLI,VEC,VEC1)
        CALL GMADD(POLO(1,NND),VEC1,POLO(1,NND),3,1)
C  Q(P.Q*) PART OF POLARISATION
        CPRD=CRSCLP(QSTAR,POLI)
        CALL CGMSCA(Q(1,ND),CVEC,CPRD,3,1)
        CALL CMREAL(CVEC,VEC,3,1)
        CALL GMADD(POLO(1,NND),VEC,POLO(1,NND),3,1)
C  DOUBLE ALL THIS FOR TWICE REAL AND IMAG PARTS
        CALL GMSCA(POLO(1,NND),POLO(1,NND),2.,3,1)
C  PART PARALLEL TO INCIDENT POLN
        FNSQR=REAL(FC)*CONJG(FC)
        QMOD=RSCALP(Q(1,ND),Q(1,ND))
        CALL GMSCA(POLI,VEC,FNSQR-QMOD,3,1)
        CALL GMADD(POLO(1,NND),VEC,POLO(1,NND),3,1)
C
C DERIVATIVES WITH RESPECT TO FC AND Q
C FIRST DIFFERENTIATE THE CROSSECTION
        DXSDN=DXSDN+(CONJG(FC)+CPRD)*SCALE(NND)
        CALL CMCONJ(Q(1,ND),DXSDQ(1,NND),3,1)
        CALL C1MSCA(POLI,CVEC,CONJG(FC),3,1)
        CALL CGMADD(CVEC,DXSDQ(1,NND),DXSDQ(1,NND),3,1)
C FIDDLE THE QXQ TERM  -idQ{Q*xP}
        CALL CMREAL(QSTAR,VEC,3,1)
        CALL VECPRD(VEC,POLI,VEC1)
        CALL C1MSCA(VEC1,QCROSP,CMPLX(0.,-1.),3,1)
        CALL CMIMAG(QSTAR,VEC,3,1)
        CALL VECPRD(VEC,POLI,VEC1)
        CALL C1MSCA(VEC1,CVEC,CMPLX(1.,0.),3,1)
        CALL CGMADD(CVEC,QCROSP,QCROSP,3,1)
        CALL CGMADD(QCROSP,DXSDQ(1,NND),DXSDQ(1,NND),3,1)
C THE DIFFERENTIALS OF THE SCATTERED POLARISATION
C  FIRST WITH RESPECT TO NUCLEAR PART
        CALL C1MSCA(POLI,CVEC,CONJG(FC),3,1)
        CALL CGMADD(QSTAR,CVEC,CVEC,3,1)
        CALL CGMADD(QCROSP,CVEC,CVEC,3,1)
        CALL CMRSCA(CVEC,CVEC,SCALE(NND),3,1)
C SUM UP WEIGHTING WITH DOMAIN POPULATION
        CALL CGMADD(CVEC,DPOLDN,DPOLDN,3,1)
C THEN THE TENSOR FOR THE MAGNETIC DERIVATIVES
        DO 25 J=1,3
        DO 25 I=1,3
        DPOLDQ(I,J,NND)=QSTAR(I)*POLI(J)-POLI(I)*QSTAR(J)
        IF (I.EQ.J) THEN
          DPOLDQ(I,I,NND)=DPOLDQ(I,I,NND)+CONJG(FC)+CPRD
        ELSE
          DO 26 K=1,3
          IF (K.EQ.I .OR. K.EQ.J) GO TO 26
          IF (ABS(J-I).EQ.1) THEN
            SIG=FLOAT(ISIGN(1,J-I))
          ELSE
            SIG=FLOAT(ISIGN(1,I-J))
          ENDIF
          DPOLDQ(I,J,NND)=DPOLDQ(I,J,NND)+
     &    SIG*CMPLX(0.,1.)*(CONJG(FC)*POLI(K)+QSTAR(K))
   26     CONTINUE
        ENDIF
   25   CONTINUE
C
C  SCALE BY DOMAIN FRACTIONS ADD INTO SUMS FOR MEAN POLARISATION
        CALL GMEQ(POLO(1,NND),VEC,3,1)
C  CROSSSECTION FOR THIS INPUT POLARISATION
        QSQR(NND)=POLPRD+FNSQR+QMOD
        CALL GMSCA(POLO(1,NND),VEC,SCALE(NND),3,1)
        CALL GMADD(VEC,POLD,POLD,3,1)
        QSQRM=QSQRM+QSQR(NND)*SCALE(NND)
C  SUMS FOR DERIVATIVES
        CALL CMRSCA(DXSDQ(1,NND),DXSDQ(1,NND),SCALE(NND),3,1)
        CALL CMRSCA(DPOLDQ(1,1,NND),DPOLDQ(1,1,NND),SCALE(NND),3,3)
        IF (ND180.EQ.2) THEN
          DO 23 II=1,3
          Q(II,ND)=-Q(II,ND)
   23     CONTINUE
        ENDIF
   20   CONTINUE
   22   CONTINUE
C  CONVERT POLD WHICH IS AN INTENSITY TO POLARISATION
        CALL GMSCA(POLD,POLD,1./QSQRM,3,1)
C      WRITE (LPT,4004) (JJ,(Q(II,JJ),II=1,3),
C     1(FQCDER(II,JJ,1),II=1,3),JJ=1,NDOM)
C 4004 FORMAT (' Q and dQ/dmu for each domain: ',3(I4,2(6F6.3,2X)/38X))
C      WRITE (LPT,4000) POLI,POLD,FC
C 4000 FORMAT (' Input and Output polarisations:'  2(3F8.4,2X)/
C     1'  Nuclear SF : '2F8.4)
      ENDIF
C
C  DERIVATIVES WITH RESPECT TO SCALE FACTORS
      DO 24 ND=1,NDOMN
C  THE SCALES ARE THE DOMAIN POPULATIONS
      L=KSCALE(ND)
      IF (L .NE.0) DERIVV(L)=(POLO(ICOMP,ND)-POLD(ICOMP)*QSQR(ND))/QSQRM
   24 CONTINUE
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, TO DERIVATIVES OF POLARISATION
      DO 4 I=1,NVARF(2,JPHASE,1)
      SUM=0.
C FIRST NUCLEAR DERIVATIVES: THEY DONT DEPEND ON WHICH DOMAIN
      ANBIT=2.*REAL((DPOLDN(ICOMP)-DXSDN*POLD(ICOMP))*DERIVT(I))
C SUM OVER DOMAINS FOR MAGNETIC BIT
      DO 30 ND=1,NDOMN
      IF (ND180.EQ.2 .AND. ND .GT.NDOMN/2) THEN
        CALL CMRSCA(FQCDER(1,ND-NDOMN/2,I),CVEC,-1.,3,1)
      ELSE
        CALL CGMEQ(FQCDER(1,ND,I),CVEC,3,1)
      ENDIF
      DO 31 L=1,3
      DO 31 J=1,3
   31 TENS(L,J)=POLD(L)*DXSDQ(J,ND)
      CALL CMRSCA(TENS,TENS,-1.,3,3)
      CALL CGMADD(DPOLDQ(1,1,ND),TENS,TENS,3,3)
      CALL CGMPRD(TENS,CVEC,DPOLDP,3,3,1)
      SUM=SUM+2.*REAL(DPOLDP(ICOMP))
C      IF (ICOMP.EQ.1) WRITE (LPT,4001) ND,(POLO(IX,ND),IX=1,3),DPOLDP
C 4001 FORMAT (' Domain poln and diff.: ',I4,2X,3(3F8.4,2X))
   30 CONTINUE
      DERIVV(LVFST1(2,JPHASE,1)+I)=(ANBIT+SUM)/QSQRM
C  TEST OUTPUT
      IF (IOUT.GE.100) THEN
        DIFFER(ICOMP,I)=DERIVV(LVFST1(2,JPHASE,1)+I)
        IF (ICOMP.EQ.3) THEN
          IF (I.EQ.1) THEN
            WRITE (LPT,4002)I, (DIFFER(L,I),L=1,3)
        ELSE
            WRITE (LPT,4003)I, (DIFFER(L,I),L=1,3)
        ENDIF
 4002     FORMAT (/' Calculated Differentials Var no.',I3,2X,3F8.4)
 4003     FORMAT (26X,'Var no.',I3,2X,3F8.4)
        ENDIF
      ENDIF
    4 CONTINUE
C
   7  GCALC = POLD(ICOMP)
 100  RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE CALDSM(H,ISAT)
      SUBROUTINE CALDSM(H,ISAT)
C
C *** CALDSM to include PROPAGATION VECTOR by PJB 21-Sept-93 ***
C
CX
CC 17B
CH Calculates  d star squared, and its derivatives wrt reciprocal
CH cell quadratic products and components of propagation vector.
CA On entry H is a 1x3 vector holding h,k,l
CP In /CELPAR/ CPARS(1:6,2) should hold the 6 reciprocal quadratic products
CP             A* = a* squared
CP             D* =  b* c* cos alpha* etc
CP             KCPARS(1:6) should hold fix/vary information for each of the 6
CP             reciprocal cell quadratic products.
CP If magnetic /SATELL/ should have been set up with a call to PROPER
CP             and the corresponding symmetry constraints with PROPSM
CD Sets GCALC in /OBSCAL/ to be d star squared, the d spacing squared,
CD and DERIVV in /DERVAR/ to be the derivative, where relevant
C
      DIMENSION H(3),DER(3)
      COMMON /CELPAR/CELL(3,3,2),V(2),ORTH(3,3,2),CPARS(6,2),KCPARS(6),
     & CELESD(6,6,2),CELLSD(6,6),KOM4
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SATELL/PROP(3),KPROP(3),KSTAB(24),NKSTAR,IPROP,FKSTAR,
     & NKC,KCENT,INCOM,KOM21
      LOGICAL INCOM
C
      GCALC=0.
      J=2
      K=3
      DO 1 I=1,3
      C1=H(I)*H(I)
      C2=2.*H(J)*H(K)
      GCALC=GCALC+C1*CPARS(I,2)+C2*CPARS(I+3,2)
      L1=KCPARS(I)
      L2=KCPARS(I+3)
      IF (L1 .GT. 0) DERIVV(L1)=C1
      IF (L2 .GT. 0) DERIVV(L2)=C2
      J=K
   1  K=I
C
      IF (MAG .AND. ISAT .NE.0) THEN
        CALL PROPDR(H,ISAT,DER)
        DO 2 I=1,3
        L=KPROP(I)
        IF (L.GT.0) DERIVV(L)=DER(I)
    2   CONTINUE
      ENDIF
      RETURN
      END
C
C
C
C LEVEL 2      SUBROUTINE CALCT2(H)
      SUBROUTINE CALCT2(H)
C
C *** CALCT2 by JCM 25 Nov 86 ***
C
CX
CC 7B
CH Calculates a function to match an observation for 2theta-type refinement
CH of reciprocal cell parameters and a zero point.
CA On entry H holds a real 1x3 array of h,k,l
CD On exit in /OBSCAL/ GCALC holds calculated 2 theta degrees + zeropoint
CD         in /DERVAR/ DERIVV holds its derivatives wrt 6 cell parameters and
CD         the zeropoint.
C
      DIMENSION H(3)
      DIMENSION DERS(6)
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /CELPAR/CELL(3,3,2),V(2),ORTH(3,3,2),CPARS(6,2),KCPARS(6),
     & CELESD(6,6,2),CELLSD(6,6),KOM4
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(5,5),
     & NLAMB,ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /ZEROPT/ZERO,KZERO
C
C SET DSTAR2 TO BE D STAR SQUARED, AND KEEP H SQRD, K SQRD ETC IN DERS:
      CALL CELDER(H,DERS)
C CALCULATED FN IS 2THETA DEGREES + ZERO POINT:
      STH=0.5*WLGTH*SQRT(DSTAR2)
      CALL SINCOS(STH,CTH,'CALCT2')
      GCALC=2.*DEGREE(ASIN(STH)) + ZERO
      FAC=2.*DEGREE(WLGTH*WLGTH/(8.*STH*CTH))
      DO 1 I=1,6
      L=KCPARS(I)
      IF (L .GT. 0) DERIVV(L)=FAC*DERS(I)
   1  CONTINUE
      IF (KZERO .GT. 0) DERIVV(KZERO)=1.
      RETURN
      END
C
C
C
C LEVEL 8      SUBROUTINE CALCSF(H,SFCALC)
      SUBROUTINE CALCSF(H,SFCALC)
C
C *** CALCSF updated by PJB 31-May-1994 ***
C
CX
CC 7B
CH Makes the calculated function and derivatives for single crystal LSQ.
CA On entry H is a 3-sized array containing h,k,l
CA   SFCALC is a subroutine name used for the actual structure factor
CA   calculation, like LFCALC
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables
CD      Convert derivatives to be of P2, not just mod FCALC
CD      Form P3: convert derivatives
CD      Form GCALC and make all derivatives so that they are of GCALC
CD      Adjust for GCALC squared if necessary
C
      EXTERNAL SFCALC
      LOGICAL TESTOV
      DIMENSION H(3)
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /EXTN/IEXTYP,DOMR,KDOMR,AMOSC,KMOSC,EXTCOR,CEXT(4),
     & DEXDFQ,DEXDRQ,DEXDGQ,LOREN,GAUSS
      LOGICAL LOREN,GAUSS
      COMMON /FCAL/FC,FCMOD,COSAL,SINAL,FCDERS(300),DERIVT(300)
      COMPLEX FC,DERIVT
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /OVER/ITFAC,OTFAC(10),KOTFAC(10),NTFAC,JTFAC,KOM15
      EQUIVALENCE (TFAC,OTFAC(1)),(KTFAC,KOTFAC(1))
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(20),KSCALE(20),
     & NSCL,LSCD(10)
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      P1=SCALE(ISCALE)*EXP(-TFAC*SSQRD)
      IF (KTFAC .NE. 0) DERIVV(KTFAC)=-SSQRD
      L=KSCALE(ISCALE)
      IF (L .NE. 0) DERIVV(L)=1./SCALE(ISCALE)
C NEXT DO P2:
      CALL SFCALC(H)
      P2=FCMOD
      IF (IREF .EQ. 4) P2=REAL(FC)
      DP2DFQ=0.
      IF (.NOT. TESTOV(1.,FCMOD)) DP2DFQ=1./FCMOD
C
C P3:
      CALL EXTINC(3,FCMOD)
      P3=EXTCOR
      IF (KDOMR .NE. 0) DERIVV(KDOMR)=DEXDRQ
      IF (KMOSC .NE. 0) DERIVV(KMOSC)=DEXDGQ
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
      DO 4 I=1,NVARF(2,1,1)
   4  DERIVV(LVFST1(2,1,1)+I)=FCDERS(I)*(DP2DFQ+DEXDFQ)
C
      GCALC = P1*P2*P3
C ADJUST IF NECESSARY FOR GCALC SQUARED:
      FAC=GCALC
      IF (IREF .EQ. 2) THEN
        GCALC=GCALC*GCALC
        FAC=2.*GCALC
      ENDIF
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*FAC
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALCMP(H)
      SUBROUTINE CALCMP(H)
C
C *** CALCMP by PJB Oct 88 ***
C
CX
CC 7B
CH Makes the calculated function and derivatives for single crystal LSQ
CH with multipoles.
CA On input H is a 3-sized array containing h,k,l
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables
CD               This includes the multipoles.
CD      Convert derivatives to be of P2, not just mod FCALC.
CD      Form P3: convert derivatives.
CD      Form GCALC and make all derivatives so that they are of GCALC.
CD      Adjust for GCALC squared if necessary.
C
      LOGICAL TESTOV
      DIMENSION H(3)
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /EXTN/IEXTYP,DOMR,KDOMR,AMOSC,KMOSC,EXTCOR,CEXT(4),
     & DEXDFQ,DEXDRQ,DEXDGQ,LOREN,GAUSS
      LOGICAL LOREN,GAUSS
      COMMON /FCAL/FC,FCMOD,COSAL,SINAL,FCDERS(300),DERIVT(300)
      COMPLEX FC,DERIVT
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /OVER/ITFAC,OTFAC(10),KOTFAC(10),NTFAC,JTFAC,KOM15
      EQUIVALENCE (TFAC,OTFAC(1)),(KTFAC,KOTFAC(1))
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(20),KSCALE(20),
     & NSCL,LSCD(10)
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      DO 2  I=1,LVARV
   2  DERIVV(I)=0.
C
C FORM P1 AND THE FAMILY 1 DERIVATIVES:
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      P1=SCALE(ISCALE)*EXP(-TFAC*SSQRD)
      IF (KTFAC .GT. 0) DERIVV(KTFAC)=-SSQRD
      L=KSCALE(ISCALE)
      IF (L .GT. 0) DERIVV(L)=1./SCALE(ISCALE)
C NEXT DO P2:
      CALL LMPCAL(H)
      P2=FCMOD
      IF (IREF .EQ. 4) P2=REAL(FC)
      DP2DFQ=0.
      IF (.NOT. TESTOV(1.,FCMOD)) DP2DFQ=1./FCMOD
C
C P3:
      CALL EXTINC(3,FCMOD)
      P3=EXTCOR
      IF (KDOMR .NE. 0) DERIVV(KDOMR)=DEXDRQ
      IF (KMOSC .NE. 0) DERIVV(KMOSC)=DEXDGQ
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
      L25ST=LVFST1(2,1,1)
      IF (L25ST .EQ. -1) L25ST=LVFST1(5,1,1)
      DO 4 I=1,NVARF(5,1,1)+NVARF(2,1,1)
   4  DERIVV(L25ST+I)=FCDERS(I)*(DP2DFQ+DEXDFQ)
C
      GCALC = P1*P2*P3
C ADJUST IF NECESSARY FOR GCALC SQUARED:
      FAC=GCALC
      IF (IREF .EQ. 2) THEN
        GCALC=GCALC*GCALC
        FAC=2.*GCALC
      ENDIF
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*FAC
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE CALCMG(H,SFCALC,MGCALC)
      SUBROUTINE CALCMG(H,SFCALC,MGCALC)
C
C *** CALCMG updated by PJB 31-May-1994 ***
C
CX
CC 7B
CH Calculates GCALC and its derivatives for structures which may have
CH mixed magnetic and nuclear reflections.
C
CA On entry H is the 1x3 array holding h,k,l
CA       SFCALC is the name of the routine to get nuclear structure factors
CA              and their derivatives.  This is usually LFCALC.
CA       MGCALC is the name of the routine to get magnetic structure factors
CA              and their derivatives.  This is usually LMCALC.
CP Structure factor data must have been set up in various COMMON blocks
CP by SYMOP RECIP ATOPOS, SETFOR, SETANI
CP LSETUP, PARSSF, VARMAK must have set up the Least Squares.
CP STLSSF must have read the L cards:
C
CD Sets GCALC, the calculated function corresponding to an OBS just read
CD Applies an extinction correction if there was an E card.
CD Also produces the vector DERIVV (LVARV long) of derivatives of this
CD function wrt each variable in turn.
C
CD The function GCALC is made up of three functions multiplied together.
CD We write G=P1*P2*P3 where P2 is a simple function of FCALC, P1 is
CD independent of FCALC (being Scale * overall itf), and P3 is the extinction
CD correction.(They are written in this way for ease of differentiation.)
C
CD If IREF=2, we are in fact comparing OBS squared with GCALC squared.  This is
CD dealt with right at the end, after proceeding as though we were not.
CD
CD The sequence of operations is:
CD      Get STHL= sin theta/lambda, SSQRD= STHL squared.
CD      Clear derivatives to zero.
CD      Form P1 and its derivatives.
CD      Form P2: get FCALC and derivatives of mod FCALC wrt family 2 variables,
CD               using both nuclear and magnetic structure factors
CD      The scattering factors are calculated using PFORMF with multipoles.
CD      Convert derivatives to be of P2, not just mod FCALC
CD      Form P3: convert derivatives
CD      Form GCALC and make all derivatives so that they are of GCALC
CD      Adjust for GCALC squared if necessary
CD On exit in /OBSCAL/ GCALC = calculated function to compare with observed
CD On exit in /DERVAR/ DERIVV is an array holding all derivatives of GCALC
CD wrt all variables
CD
CN If L REFI=5 the GOBS and GCALC are polarised neutron flipping ratios
C
      EXTERNAL SFCALC,MGCALC
      DIMENSION H(3)
      COMPLEX FND,FN,PHASE,PN(3),PND(3)
      LOGICAL TESTOV
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /EXTN/IEXTYP,DOMR,KDOMR,AMOSC,KMOSC,EXTCOR,CEXT(4),
     & DEXDFQ,DEXDRQ,DEXDGQ,LOREN,GAUSS
      LOGICAL LOREN,GAUSS
      COMMON /FCAL/FC,FCMOD,COSAL,SINAL,FCDERS(300),DERIVT(300)
      COMPLEX FC,DERIVT
      COMMON /MCAL/FMCMOD,FMCSQR,FMCDER(300)
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /OVER/ITFAC,OTFAC(10),KOTFAC(10),NTFAC,JTFAC,KOM15
      EQUIVALENCE (TFAC,OTFAC(1)),(KTFAC,KOTFAC(1))
      COMMON /PHASE/NPHASE,IPHASE,JPHASE,KPHASE,NPHUNI(9),
     & SCALEP(9),KSCALP(9),PHMAG(9)
      LOGICAL PHMAG
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /POLDA/P,DP,E,DE,MODE,POLND(3)
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /QCAL/Q(3,12)
      COMPLEX Q
      COMMON /QCALD/FQCDER(3,12,100)
      COMPLEX FQCDER
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(20),KSCALE(20),
     & NSCL,LSCD(10)
C
      STHL = VCTMOD(0.5,H,2)
C STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
C
C CLEAR DERIVATIVES WRT VARIABLES - THERE MAY NOT BE AN ENTRY FOR EVERY ONE FOR
C THIS INPUT VALUE OF H:
      IF (LVARV .GT. 0) CALL GMZER(DERIVV,1,LVARV)
C
C FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      IF (IREF.EQ.5) THEN
        P1=1.
      ELSE
        P1=SCALE(ISCALE)*EXP(-TFAC*SSQRD)
        IF (KTFAC .NE. 0) DERIVV(KTFAC)=-SSQRD
        L=KSCALE(ISCALE)
        IF (L .NE. 0) DERIVV(L)=1./SCALE(ISCALE)
      ENDIF
C
C NEXT DO P2:
      CALL SFCALC(H)
      CALL MGCALC(H)
      P2S=FCMOD**2+FMCSQR
      IF (IREF.EQ.5) THEN
        PHASE=CMPLX(COSAL,SINAL)
        FN=FCMOD*PHASE
        CALL C1MSCA(POLND,PN,FN,3,1)
        XST=2.*RSCALP(FMC,PN)
        RNUM=(P2S+P*XST)
        RDEN=P2S-P*E*XST
        P2=RNUM/RDEN
C P3:
        X1=SQRT(P2S+XST)
        CALL EXTINC(3,X1)
        P3=EXTCOR
        DEX1=DEXDFQ
        IF (KDOMR .NE. 0) DERIVV(KDOMR)=DEXDRQ
        IF (KMOSC .NE. 0) DERIVV(KMOSC)=DEXDGQ
        X2=SQRT(P2S-XST)
        CALL EXTINC(3,X2)
        P3=P3/EXTCOR
        DEX2=DEXDFQ
        IF (KDOMR .NE. 0) DERIVV(KDOMR)=DERIVV(KDOMR)-DEXDRQ
        IF (KMOSC .NE. 0) DERIVV(KMOSC)=DERIVV(KMOSC)-DEXDGQ
      ELSE
        P2=SQRT(P2S)
C  CHECK THAT P2 IS NOT ZERO
        IF (TESTOV(1.,P2)) GO TO 7
        DFTDFQ=1./P2
C P3:
        CALL EXTINC(3,P2)
        P3=EXTCOR
        IF (KDOMR .NE. 0) DERIVV(KDOMR)=DEXDRQ
        IF (KMOSC .NE. 0) DERIVV(KMOSC)=DEXDGQ
      ENDIF
      YCALC=P2
C
C CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
C LFCALC, USING:
C DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
C DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
C GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
      DO 4 I=1,NVARF(2,JPHASE,1)
        IF (IREF .EQ.5) THEN
        FND=FCDERS(I)*PHASE
        CALL C1MSCA(POLND,PND,FND,3,1)
        XSTD=RSCALP(PN,FQCDER(1,1,I)) + RSCALP(PND,FMC)
        YSTD=FCDERS(I)*FCMOD + FMCDER(I)
C NOTE THAT MAGNETIC DERIVATIVES COME OUT MULTIPLIED BY FMCMOD **
        DERIVV(LVFST1(2,JPHASE,1)+I)=2.*((YSTD+P*XSTD)/RNUM)-
     &  ((YSTD-P*E*XSTD)/RDEN) + ((YSTD+XSTD)*DEX1)/X1 -
     &  ((YSTD-XSTD)*DEX2)/X2
      ELSE
        DERIVV(LVFST1(2,JPHASE,1)+I)=((FCDERS(I)*FCMOD)+FMCDER(I))*
     &  (DEXDFQ+DFTDFQ)*DFTDFQ
      ENDIF
    4 CONTINUE
C
   7  GCALC = P1*P2*P3
C ADJUST IF NECESSARY FOR GCALC SQUARED:
      FAC=GCALC
      IF (IREF .EQ. 2) THEN
        GCALC=GCALC*GCALC
        FAC=2.*GCALC
      ENDIF
      DO 6 I=1,LVARV
   6  DERIVV(I)=DERIVV(I)*FAC
 100  RETURN
      END
C
C
C
C LEVEL 1      SUBROUTINE ARREAD(H,FBUF,IEND)
      SUBROUTINE ARREAD(H,FBUF,IEND)
C
C *** ARREAD updated by PJB 22-Jun-1995 ***
C
CX
CC 2A
CH Multiple entry routine to deal with reading items for ARRNGE type programs.
CD Expects IICD3 to have been obeyed to read the data type DTYP. The following
CD formats are defined:
CD         = 0 user supplied subroutine QUARRIN to read the data
CD         = 1 D3 polarised neutron ratios as given by D3OP90 or D3OP94
CD         = 2 COLL5  1 card output
CD         = 3 COLL5  2 card output
CD         = 4 ADVANCE floating format output
CD         = 5 SXD format output including wave-length and path length
CD         = 6 LLB format (floating indices)
CD         = 7 D3 Integrated intensities (ext .ROC)
CD         = 8 COLL5 floating format (1 card ext .COL)
C
C
      DIMENSION H(3),K(3),FBUF(10),ANG(4)
      LOGICAL IEND,JEND,ANGLES
      CHARACTER *40 QUERY(2)
      CHARACTER *4 EXT(8)
      CHARACTER*10 FILNOM
C
      COMMON /ARRDAT/IFOR(6),INC,LINO,NREF,INLBUF,NBUF,IBUF,INFBUF,
     & INDLEN,NUMVAL,IPOS,ISTORE,ICHNGE,NEW,LPRINT,ICD,IS,NREF1,NREFL
      LOGICAL INC,NEW,LPRINT
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C
      DATA QUERY/'File with reflections to be arranged',
     &'Next reflection file (or c/r to end)'/
      DATA EXT/'.FLI','.DAT','.DAT','.COL','.SXD','.LLB','.ROC','.COL'/
C
      ANGLES=(IFOR(6).NE.0)
      ISTART=2
      IF (IEND) THEN
        ISTART=1
        WRITE (LPT,2010) IFOR(1)
 2010 FORMAT (/' Input type',I2,' - ')
        IF ((IFOR(1) .LT. 0) .OR. (IFOR(1) .GE.9)) GO TO 1
        GO TO (10,11,12,13,14,15,16,17,18) , IFOR(1)+1
C
  10    CALL MESS(LPT,0,'User to supply own routine QARRIN')
        GO TO 3
C
  11    CALL MESS(LPT,0,'D3 polarised neutron ratios 4I5,24X,2F1.6')
        GO TO 3
C
  12    CALL MESS(LPT,0,'College 5 input, 1 card, I6,3I4,2F10.2')
        GO TO 3
C
  13    CALL MESS(LPT,0,'College 5 input, 2 cards, I6,3I4,2F10.2/')
        GO TO 3
C
  14    CALL MESS(LPT,0,'"ADVANCE" floating indices, I6,3F6.2,I8,I4/')
        GO TO 3
C
  15    CALL MESS(LPT,0,'SXD intensities,wavelengths and pathlength'//
     &   ' from "SXDABS", I8,3F8.3,4F10.4/')
        GO TO 3
C
  16    CALL MESS(LPT,0,'LLB data: floating indices,' //
     &   'I4,3F6.2,2F10.4,4F8.2')
        GO TO 3
C
  17    CALL MESS(LPT,0,'D3 integrated intensities (2 cards),' //
     &   'I6,3F6.2,2F10.2,4F8.2')
        GO TO 3

  18    CALL MESS(LPT,0,'COLL5 1 card format with floating indices,'//
     &  ' I6,3F7.2,2F10.4,4F8.3')
        GO TO 3
C
  98    WRITE (ITO,2010)
        CALL MESS(ITO,0,'NOT YET IMPLEMENTED')
        CALL MESS(LPT,0,'NOT YET IMPLEMENTED')
        IERR=IERR+1
        GO TO 99
      ENDIF
C
   1  GO TO (51,52,53,54,55,56,57,58) , IFOR(1)
C
C READ DATA ITEM UNDER USER'S OWN FORMAT:
  50  CALL QARRIN(N,K,DUMMY,FBUF,JEND)
      IF (JEND) GO TO 2
      GO TO 60
C
C D3 POLARISED NEUTRON RATIOS:
  51  READ (LUNI,1001,END=2) N,K,(ANG(I),I=1,3),FBUF(2),FBUF(3)
1001  FORMAT (4I5,3F8.2,2F10.6)
      IF (ANGLES) THEN
C ON D3 OMEGA IS THE FIRST ANGLE
        FBUF(4)=ANG(2)
        FBUF(5)=ANG(1)
        FBUF(6)=ANG(3)
      ENDIF
      GO TO 60
C
C COLLEGE 5 INTEGRATED INTENSITIES - 1 CARD:
  52  READ (LUNI,1002,END=2) N,K,FBUF(2),FBUF(3),ANG
1002  FORMAT (I6,3I4,2F10.2,3F8.2)
C COLL5 PUTS OUT THETA NOT 2THETA
      ANG(1)=2.*ANG(1)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
      GO TO 60
C
C COLLEGE 5 INTEGRATED INTENSITIES - 2 CARDS:
  53  READ (LUNI,1003,END=2) N,K,FBUF(2),FBUF(3),ANG
1003  FORMAT (I6,3I4,2F10.2,3F8.2/)
C COLL5 PUTS OUT THETA NOT 2THETA
      ANG(1)=2.*ANG(1)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
      GO TO 60
C
C ADVANCE INTEGRATED INTENSITIES - FLOATING FORMAT:
  54  READ (LUNI,1030,END=2) N,H,LFIN,LDFIN,ANG
1030  FORMAT (I6,3F6.2,I8,I4,3F8.2)
      FBUF(2)=FLOAT(LFIN)
      FBUF(3)=FLOAT(LDFIN)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
C IGNORE BLANK CARDS:
      IF (N+LFIN+LDFIN.EQ.0) GO TO 1
      GO TO 61
C
C SXD INTENSITIES FROM SXDABS:
  55  READ (LUNI,1031,END=2) N,H,(FBUF(I),I=2,5)
1031  FORMAT (I8,3F8.2,4F10.4)
      IF (N.NE.0) GO TO 61
      GO TO 1
C
C LLB FORMAT:
  56  READ (LUNI,1032,END=2) N,H,FBUF(2),FBUF(3),ANG
1032  FORMAT (I4,3F6.2,2F10.4,4F8.3)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
      IF (N.NE.0) GO TO 61
      GO TO 1
C
C D3 Integrated intensities 2 card .ROC FORMAT:
  57  READ (LUNI,1033,END=2) N,H,FBUF(2),FBUF(3),ANG,FIELD,TEMP
1033  FORMAT (I6,3F6.2,2F10.2,4F8.2,F8.2,F7.2)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
C SKIP SECOND CARD
      READ (LUNI,1032)
      IF (N.NE.0) GO TO 61
      GO TO 1
c
C Floating COLL5 format:
  58  READ (LUNI,1034,END=2) N,H,FBUF(2),FBUF(3),ANG
1034  FORMAT (I6,3F7.2,2F10.4,4F8.3)
      IF (ANGLES) CALL GMEQ(ANG,FBUF(4),4,1)
      IF (N.NE.0) GO TO 61
      GO TO 1
C
C IGNORE BLANK CARDS:
  60  IF (IABS(K(1))+IABS(K(2))+IABS(K(3)) .EQ. 0) GO TO 1
      CALL INDFLO(H,K)
  61  IF (NREF1 .EQ.-1) NREF1=N
      FBUF(1)=FLOAT(N)
      NREFL=N
      GO TO 100
C
C START READING (NEXT) INPUT DATA FILE:
   2  WRITE (LPT,2005) NREF1,NREFL,FILNOM(LUNI)
2005  FORMAT (/' Reflection numbers ',I8,' to ',I8,' read from file ',
     &A10)
      CLOSE(LUNI)
   3  MESSAG=' '
      NREF1=-1
      NAMFIL=EXT(IFOR(1))
      WRITE (MESSAG,2000) QUERY(ISTART)
2000  FORMAT (A40)
      LUNI=NOPFIL(111)
      IF (LUNI .NE. 0) THEN
        IEND=.FALSE.
        GO TO 1
      ENDIF
C
  99  IEND=.TRUE.
 100  RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE BIGGAM(K,IQ,CSMAX)
      SUBROUTINE BIGGAM(K,IQ,CSMAX)
C
C *** BIGGAM updated by PJB Nov 89 ***
C
CX
CC 2B
CH Deals with gammas whose value is greater than one, in SORGAM.
CH There is also the entry SETGAM to set up the calculation.
CA On entry K is a set of reflection indices to be tested
CA IQ is returned as 1 if gamma for this reflection is greater than 1
CA       returned as 0 otherwise
CA CSMAX is the maximum value of cos(rho) for which the effective gamma
CA       is >1
CA Entry SETGAM SOME is a logical which is set true if a GAMA 1 is found
CA                   on an I card.  It is false otherwise.
C
      DIMENSION K(3)
      LOGICAL ENDG,SOME,ONCARD
      CHARACTER *10 FILNOM
      COMMON /BIGAM/KG(3),CSRED,ENDG
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C
      IQ=0
      IF (ENDG) GO TO 100
C
      DO 1 I=3,1,-1
      IF (KG(I)-K(I)) 2,1,100
    1 CONTINUE
C MATCH:
      IF (CSRED.NE.0.) THEN
        WRITE (ITO,16)KG,CSRED
      ELSE
        WRITE (ITO,17)KG
      ENDIF
   16 FORMAT (' Gamma > 1 for ',3I3,' and Cos(rho) >',F7.4)
   17 FORMAT (' Gamma > 1 for ',3I3)
      IQ=1
      CSMAX=CSRED
      GO TO 5
C
C  INDICES OUT OF ORDER
    2 WRITE (ITO,12) K,KG
   12 FORMAT (' Error in order of indices matching',3I3,' with',3I3/
     & ' Gamma < 1 assumed from here on')
    4 ENDG =.TRUE.
      GO TO 100
C
C  SETUP ENTRY
      ENTRY SETGAM(SOME)
      ENDG=.FALSE.
      SOME=.FALSE.
C  SEARCH FOR GAMA ON ICARD = IF NOT FOUND ASSUME ALL GAMMA < 1
      IF (.NOT. ONCARD('I','GAMA',A)) GO TO 100
C
      IGAM=NINT(A)
      IF (IGAM.EQ.0) GO TO 100
      CALL ASK('File of labelling indices for gamma > 1 reflections ?')
      LBIG=NOPFIL(21)
      CALL MESS(LPT,1,'Reflections with abs(gamma) > 1 from file '//
     & FILNOM(LBIG)//' these marked ** on the output list')
      SOME = .TRUE.
    5 READ (LBIG,11,END=4) KG,CSRED
   11 FORMAT (3I5,F10.4)
  100 RETURN
      END
C
C
C LEVEL 2      SUBROUTINE BIGCHA(BWORD)
      SUBROUTINE BIGCHA(BWORD)
C
C *** BIGCHA corrected by PJB 31-May-1994 ***
C
CX
CC 13C
CH Writes on unit LPT up to 9 characters in large letters.
CA On entry, BWORD is the required word
CO Writes (up to 9) characters of BWORD to output LPT in letters/digits
CO 12 characters wide by 12 lines high, composed of the relevant character
CO and finishes with 2 blank lines
CN Turns lower case into upper
C
      CHARACTER *(*) BWORD
      DIMENSION NSTART(10)
      COMMON /BIGONE/ X(504)
      CHARACTER*12 X
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C
      MAXLEN=9
      LENGTH=LENGT(BWORD)
      NCHARS=90
C
      DO 1 J=1,MAXLEN
C DEFAULT SPACE:
      I=40
      IF (J .GT. LENGTH) GO TO 1
      IF (BWORD(J:J) .EQ. ' ') GO TO 1
      I=LETTER(BWORD(J:J))
      IF (I .GT. 0) GO TO 1
      I=NDIGIT(BWORD(J:J))+29
      IF (I .GE. 29) GO TO 1
      I=40
      IF (BWORD(J:J) .EQ. '.') I=27
      IF (BWORD(J:J) .EQ. '+') I=28
      IF (BWORD(J:J) .EQ. '/') I=39
   1  NSTART(J)=(I-1)*12
      DO 2 K=1,12
   2  WRITE(LPT,2000) (X(NSTART(I)+K),I=1,MAXLEN)
2000  FORMAT(10(1X,A12,1X))
      WRITE (LPT,2001)
2001  FORMAT(//)
      RETURN
      END
C
C
C
C
C
      BLOCK DATA BIGLET
      COMMON /BIGONE/ X
      CHARACTER*12 X(504),A(72),B(72),C(72),D(72),E(72),F(72),G(72)
      EQUIVALENCE (X(1),A(1)),(X(73),B(1)),(X(145),C(1)),
     & (X(217),D(1)),(X(289),E(1)),(X(361),F(1)),(X(433),G(1))
      DATA A/
     &   ' AAAAAAAAAA ','AAAAAAAAAAAA','AA        AA','AA        AA',
     &   'AA        AA','AAAAAAAAAAAA','AAAAAAAAAAAA','AA        AA',
     &   'AA        AA','AA        AA','AA        AA','AA        AA',
     &   'BBBBBBBBBBB ','BBBBBBBBBBBB','BB        BB','BB        BB',
     &   'BB       BB ','BBBBBBBBBB  ','BBBBBBBBBB  ','BB       BB ',
     &   'BB        BB','BB        BB','BBBBBBBBBBBB','BBBBBBBBBBB ',
     &   ' CCCCCCCCCC ','CCCCCCCCCCCC','CC        CC','CC          ',
     &   'CC          ','CC          ','CC          ','CC          ',
     &   'CC          ','CC        CC','CCCCCCCCCCCC',' CCCCCCCCCC ',
     &   'DDDDDDDDD   ','DDDDDDDDDD  ','DD       DD ','DD        DD',
     &   'DD        DD','DD        DD','DD        DD','DD        DD',
     &   'DD        DD','DD       DD ','DDDDDDDDDD  ','DDDDDDDDD   ',
     &   'EEEEEEEEEEEE','EEEEEEEEEEEE','EE          ','EE          ',
     &   'EE          ','EEEEEEEE    ','EEEEEEEE    ','EE          ',
     &   'EE          ','EE          ','EEEEEEEEEEEE','EEEEEEEEEEEE',
     &   'FFFFFFFFFFFF','FFFFFFFFFFFF','FF          ','FF          ',
     &   'FF          ','FFFFFFFF    ','FFFFFFFF    ','FF          ',
     &   'FF          ','FF          ','FF          ','FF          '/
      DATA B/
     &   ' GGGGGGGGGG ','GGGGGGGGGGGG','GG        GG','GG          ',
     &   'GG          ','GG          ','GG     GGGGG','GG     GGGGG',
     &   'GG        GG','GG        GG','GGGGGGGGGGGG',' GGGGGGGGGG ',
     &   'HH        HH','HH        HH','HH        HH','HH        HH',
     &   'HH        HH','HHHHHHHHHHHH','HHHHHHHHHHHH','HH        HH',
     &   'HH        HH','HH        HH','HH        HH','HH        HH',
     &   ' IIIIIIIIII ',' IIIIIIIIII ','     II     ','     II     ',
     &   '     II     ','     II     ','     II     ','     II     ',
     &   '     II     ','     II     ',' IIIIIIIIII ',' IIIIIIIIII ',
     &   '  JJJJJJJJJJ','  JJJJJJJJJJ','      JJ    ','      JJ    ',
     &   '      JJ    ','      JJ    ','      JJ    ','      JJ    ',
     &   'JJ    JJ    ','JJ    JJ    ','JJJJJJJJ    ',' JJJJJJ     ',
     &   'KK        KK','KK       KK ','KK      KK  ','KK     KK   ',
     &   'KK    KK    ','KKKKKKK     ','KKKKKKK     ','KK    KK    ',
     &   'KK     KK   ','KK      KK  ','KK       KK ','KK        KK',
     &   'LL          ','LL          ','LL          ','LL          ',
     &   'LL          ','LL          ','LL          ','LL          ',
     &   'LL          ','LL          ','LLLLLLLLLLLL','LLLLLLLLLLLL'/
      DATA C/
     &   'MM        MM','MMM      MMM','MMMM    MMMM','MM MM  MM MM',
     &   'MM  MMMM  MM','MM   MM   MM','MM        MM','MM        MM',
     &   'MM        MM','MM        MM','MM        MM','MM        MM',
     &   'NN        NN','NNN       NN','NNNN      NN','NN NN     NN',
     &   'NN  NN    NN','NN   NN   NN','NN    NN  NN','NN     NN NN',
     &   'NN      NNNN','NN       NNN','NN        NN','NN         N',
     &   'OOOOOOOOOOOO','OOOOOOOOOOOO','OO        OO','OO        OO',
     &   'OO        OO','OO        OO','OO        OO','OO        OO',
     &   'OO        OO','OO        OO','OOOOOOOOOOOO','OOOOOOOOOOOO',
     &   'PPPPPPPPPPP ','PPPPPPPPPPPP','PP        PP','PP        PP',
     &   'PP        PP','PPPPPPPPPPPP','PPPPPPPPPPP ','PP          ',
     &   'PP          ','PP          ','PP          ','PP          ',
     &   ' QQQQQQQQQQ ','QQQQQQQQQQQQ','QQ        QQ','QQ        QQ',
     &   'QQ        QQ','QQ        QQ','QQ        QQ','QQ    QQ  QQ',
     &   'QQ     QQ QQ','QQ      QQQQ','QQQQQQQQQQQ ',' QQQQQQQQ QQ',
     &   'RRRRRRRRRRR ','RRRRRRRRRRRR','RR        RR','RR        RR',
     &   'RR        RR','RRRRRRRRRRRR','RRRRRRRRRRR ','RR    RR    ',
     &   'RR     RR   ','RR      RR  ','RR       RR ','RR        RR'/
      DATA D/
     &   ' SSSSSSSSSS ','SSSSSSSSSSSS','SS        SS','SS          ',
     &   'SSS         ',' SSSSSSSSS  ','  SSSSSSSSS ','         SSS',
     &   '          SS','SS        SS','SSSSSSSSSSSS',' SSSSSSSSSS ',
     &   'TTTTTTTTTTTT','TTTTTTTTTTTT','     TT     ','     TT     ',
     &   '     TT     ','     TT     ','     TT     ','     TT     ',
     &   '     TT     ','     TT     ','     TT     ','     TT     ',
     &   'UU        UU','UU        UU','UU        UU','UU        UU',
     &   'UU        UU','UU        UU','UU        UU','UU        UU',
     &   'UU        UU','UU        UU','UUUUUUUUUUUU',' UUUUUUUUUU ',
     &   'VV        VV','VV        VV','VV        VV','VV        VV',
     &   'VV        VV','VV        VV','VV        VV',' VV      VV ',
     &   '  VV    VV  ','   VV  VV   ','    VVVV    ','     VV     ',
     &   'WW        WW','WW        WW','WW        WW','WW        WW',
     &   'WW        WW','WW        WW','WW   WW   WW','WW  WWWW  WW',
     &   'WW WW  WW WW','WWWW    WWWW','WWW      WWW','WW        WW',
     &   'XX        XX','XX        XX',' XX      XX ','  XX    XX  ',
     &   '   XX  XX   ','    XXXX    ','    XXXX    ','   XX  XX   ',
     &   '  XX    XX  ',' XX      XX ','XX        XX','XX        XX'/
      DATA E/
     &   'YY        YY','YY        YY',' YY      YY ','  YY    YY  ',
     &   '   YY  YY   ','    YYYY    ','     YY     ','     YY     ',
     &   '     YY     ','     YY     ','     YY     ','     YY     ',
     &   'ZZZZZZZZZZZZ','ZZZZZZZZZZZZ','         ZZ ','        ZZ  ',
     &   '       ZZ   ','      ZZ    ','     ZZ     ','    ZZ      ',
     &   '   ZZ       ','  ZZ        ',' ZZZZZZZZZZZ','ZZZZZZZZZZZZ',
     &   '            ','            ','            ','            ',
     &   '            ','            ','            ','            ',
     &   '     ..     ','    ....    ','    ....    ','     ..     ',
     &   '            ','     ++     ','     ++     ','     ++     ',
     &   '     ++     ',' ++++++++++ ',' ++++++++++ ','     ++     ',
     &   '     ++     ','     ++     ','     ++     ','            ',
     &   '  00000000  ',' 0000000000 ','00        00','00        00',
     &   '00        00','00        00','00        00','00        00',
     &   '00        00','00        00',' 0000000000 ','  00000000  ',
     &   '     11     ','    111     ','   1111     ','     11     ',
     &   '     11     ','     11     ','     11     ','     11     ',
     &   '     11     ','     11     ',' 1111111111 ',' 1111111111 '/
      DATA F/
     &   ' 2222222222 ','222222222222','22        22','          22',
     &   '          22','         22 ','       22   ','     22     ',
     &   '   22       ',' 22         ','222222222222','222222222222',
     &   ' 3333333333 ','333333333333','33        33','          33',
     &   '          33','       3333 ','       3333 ','          33',
     &   '          33','33        33','333333333333',' 3333333333 ',
     &   '      444   ','     4444   ','    44 44   ','   44  44   ',
     &   '  44   44   ',' 44444444444','444444444444','       44   ',
     &   '       44   ','       44   ','       44   ','       44   ',
     &   '555555555555','555555555555','55          ','55          ',
     &   '55          ','555555555   ','5555555555  ','         55 ',
     &   '          55','          55','555555555555','55555555555 ',
     &   ' 6666666666 ','666666666666','66        66','66          ',
     &   '66          ','66666666666 ','666666666666','66        66',
     &   '66        66','66        66','666666666666',' 6666666666 ',
     &   '777777777777','77777777777 ','77      77  ','       77   ',
     &   '      77    ','     77     ','     77     ','     77     ',
     &   '     77     ','     77     ','     77     ','     77     '/
      DATA G/
     &   ' 8888888888 ','888888888888','88        88','88        88',
     &   ' 88      88 ','  88888888  ','  88888888  ',' 88      88 ',
     &   '88        88','88        88','888888888888',' 8888888888 ',
     &   ' 9999999999 ','999999999999','99        99','99        99',
     &   '99        99','999999999999','999999999999','          99',
     &   '          99','99        99','999999999999',' 9999999999 ',
     &   '          //','         // ','        //  ','       //   ',
     &   '      //    ','     //     ','    //      ','   //       ',
     &   '  //        ',' //         ','//          ','            ',
     &               36*'            '/
      END
C
C
C
C LEVEL 1      SUBROUTINE BATCH
      SUBROUTINE BATCH
C
C *** BATCH by JCM 27 Jun 86 ***
C
CX
CC 16C
CH Signals batch running, not interactive.
C
CO Sets NBATCH in COMMON /GLOBAL to be the distinctive value 42
C
CN BATCH should be called AFTER INITIL, but before anything else.
CN The relevant input/output unit numbers should also be set up
CN in MAIN, AFTER BATCH, if they differ from the following settings:
C
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /GLOBAL/NINIT,NBATCH,NSYSTM,MULFAS,MULSOU,MULONE
      LOGICAL MULFAS,MULSOU,MULONE
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MAPGT/ZGTVAL(20),ZCGT,IGT,IZGT,IDUMPG
      COMMON /MAPRD/ZRDVAL(20),ZCRD,IRD,IZRD,IDUMPR
      COMMON /MAPSV/ZSVVAL(20),ZCSV,ISV,IZSV,NDUMPS,NSAV
      COMMON /NEWOLD/SHIFT,XOLD,XNEW,ESD,IFAM,IGEN,ISPC,
     & NEWIN,KPACK,LKH,SHESD,ISHFT,AVSHFT,AMAXSH
      COMMON /PRSTAT/SMYC,SMYD,SMYO,SMIO,SMID,SMWYOS,IZCT,
     & P5,IOP1,IOP2,KMI(9),KMA(9)
C
      NBATCH=42
      ICRYDA=11
      LUNI=2
      NEWIN=9
      NDUMPS=3
      IDUMPG=4
      IDUMPR=4
      IOP1=2
      IOP2=1
      CALL MESS(LPT,2,'            Batch running - no interaction')
      RETURN
      END
C
C
C
C LEVEL 5      SUBROUTINE BNDLST(NAME1,NAME2)
      SUBROUTINE BNDLST(NAME1,NAME2)
C
C *** BNDLST updated by JCM 11 Sep 92 ***
C
CX
CC 8B
CH Writes out and saves a list of bonds from one atomic position.
CA On entry NAME1 is the name of source atom in list in /POSNS/,
CA                   NOT a general atom name (i.e. all letters) because that
CA                   would not group together bonds from a single atom, to
CA                   be used in angles.
CA          NAME2  is EITHER the name of one destination atom,
CA                    OR a general atom name.
CP In /BONDLA/ BMAX and BMIN give the limits of bonds to consider.
C
CD To find both NAME1 and NAME2, scans the list in ATNAME.  Accepts a complete
CD match;  also for NAME2 accepts a match of a general atom name with ALL the
CD starting letters of a name in the list.
C
CD So, e.g. for NAME2, Si2 matches with ONLY Si2 (not Si23)
CD                     Si matches with Si, Si1, Si2 etc (not SiA)
C
CD Makes from atom 2 all useful destination atoms related by symmetry to it.
CD Because bonds are also used as slack constraints in LSQ, the destination atom
CD formed by a particular symmetry operation, which may well fall outside the
CD original unit cell (i.e. have coordinates < 0 or > 1) is NOT now put
CD back into the original cell.  Previously it was, and the resulting
CD 3x3x3 cube of cells was scanned.  This makes a terrible mess of refined
CD coordinates which themselves hop over a cell edge.
CD So now a symmetry related position is formed, and the surrounding 5x5x5
CD cube of unit cells is scanned.
CD
CD A list of found bonds (and related information) is held in /BONDLA/ for
CD use when rejecting duplicate bonds, and perhaps later if angles are
CD required.
C
CO Writes found bonds to unit LPT
CO Writes generated cards to unit LSK
C
      CHARACTER *16 CH
      CHARACTER *4 NAME1,NAME2,GENNAM,TONAME
      LOGICAL DONT,HEAD,MIDD
      DIMENSION DX(3),CEL(3),XD(3),X1(3),X2(3),XD1(3),XD2(3),K(6),ODX(3)
      DIMENSION ZER(3),CELXYZ(3)
      COMMON /ATNAM/ATNAME(150),ATNA(150,9)
      CHARACTER *4 ATNA,ATNAME
      COMMON /ATNMPK/ATPACK(10,3)
      INTEGER ATPACK
      COMMON /BONDLA/NB,BSAVE(100),DXSAVE(3,100),NBSAVE(100),
     & N2SAVE(100),N3SAVE(100),I1LAST,BMAX,BMIN,BBMAX,SDMAX,
     & ANG1,ANG2,BON2,SD1,SD2,BONOUT,LSK,SLK
      LOGICAL SLK,BONOUT
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /SLKGEC/ATTNAM(500),BONNAM(500),ANGNAM(100),
     & TORNAM(100)
      CHARACTER *4 ATTNAM,BONNAM,ANGNAM,TORNAM
      COMMON /SLKGEO/NSTYP,BOBS(500),EOBS(500),IATM(500,2),
     & ISYM(500),ILAT(500),CELLTR(3,500),XSLAK(3,500),
     & COSIN(3,3),IABASE(500),NST1,SLONLY,TOSTAR(6,6),BCALC(500),
     & DERCEL(6,500),DERPOS(3,500,2),ITYPSK(500),INVBON(10,
     & 500),NINVB(500),INANG(100,3),INTOR(100,6),
     & DERBON(10),NVB(10),NUMBON,NTARNM,NUMANG,NUMTOR,KOM25
      LOGICAL SLONLY
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
      DATA ZER/0.,0.,0./
C
C
C IDENTIFY SOURCE:
      I1=IATOM(NAME1)
      IF (I1 .LE. 0) GO TO 100
C
C ADD TO LIST:
      CALL ADDATM(NAME1,I1,X(1,I1),1,1,ZER,N1)
C
C CLEAR COUNT OF SAVED BONDS IF NEW SOURCE:
      IF (I1 .NE. I1LAST) THEN
        NB=0
        HEAD=.TRUE.
      ENDIF
      I1LAST=I1
C
C IDENTIFY DESTINATION:
      DO 42 I2=1,NATOM
      IF (NAME2 .NE. ATNAME(I2) .AND. GENNAM(ATNAME(I2))
     & .NE. NAME2) GO TO 42
C
C SET START OF BOND COUNT FOR THIS DESTINATION
      DO 14 I=1,3
      X1(I)=X(I,I1)
C DO NOT NOW PUT SOURCE ATOM INTO CENTRAL CELL:
C      CALL FRACT(X1(I),Y,N)
      X2(I)=X(I,I2)
   14  CONTINUE
C
C OUTER CYCLE OVER CENTRE OF SYMMETRY IF PRESENT:
      DO 1 IC=1,NCENT
C NEXT CYCLE OVER SYMMETRY OPERATORS FOR SPACE GROUP
      DO 2 IS=1,NOPC
      CALL ROTSYM(X2,XD1,IS,1)
      CALL GMADD(XD1,TRANS(1,IS),XD1,1,3)
      IF (IC .EQ. 2) CALL GMREV(XD1,XD1,1,3)
C
C MIDDLE CYCLE OVER LATTICE SYMMETRY
      DO 3 IL=1,NLAT
      CALL GMADD(XD1,ALAT(1,IL),XD2,1,3)
C
C DO NOT NOW PUT DESTINATION ATOM INTO CENTRAL CELL
C      CALL FRAC3(XD2)
C
C INNER CYCLES OVER 5x5x5 UNIT CELLS, WHICH IS OVERKILL & SLOW BUT WON'T MISS
C MUCH:
      DO 4 NCELZ=1,5
      CEL(3)=FLOAT(NCELZ-3)
      DO 5 NCELY=1,5
      CEL(2)=FLOAT(NCELY-3)
      DO 6 NCELX=1,5
      CEL(1)=FLOAT(NCELX-3)
C
      CALL GMADD(XD2,CEL,XD,1,3)
      CALL GMSUB(X1,XD,DX,1,3)
C REJECT IF ONE LENGTH IS > MAX BOND:
      DO 38 I=1,3
      IF (DX(I) .GT. BMAX) GO TO 6
  38  CONTINUE
C
      B = VCTMOD(1.,DX,1)
      IF (B .GT. BMAX) GO TO 6
      IF (B .LT. BMIN) GO TO 6
      IF (B .LT. 0.00001) GO TO 6
C
C SAVE BOND:
      DO 12 I=1,NB
      DO 13 J=1,3
      IF (ABS(DXSAVE(J,I)-DX(J)) .GT. 0.00001) GO TO 12
  13  CONTINUE
C TO 6 IF LATEST BOND HAS OCCURRED PREVIOUSLY AND IS NOT WANTED AGAIN
      GO TO 6
  12  CONTINUE
C%
C   8  CALL ERRCHK(2,NB,%BSAV%,0,'bonds from 1 atom')
   8  CALL ERRCHK(2,NB,100,0,'bonds from 1 atom')
      BSAVE(NB)=B
      DXSAVE(1,NB)=DX(1)
      DXSAVE(2,NB)=DX(2)
      DXSAVE(3,NB)=DX(3)
      N2SAVE(NB)=I2
C
C FORM THETA, PHI ANGLES AND REPORT THEM WITH DELTAS(X,Y,Z)
      CALL ORTHO(DX,ODX,1)
      CALL GMREV(ODX,ODX,1,3)
      CALL UNIVEC(ODX,C)
      ANGT1=DEGREE(ACOS(ODX(3)))
      DONT = (ABS(ODX(3)) .GT. 0.9999)
      IF (.NOT. DONT) ANGT2=DEGREE(ATAN2(ODX(2),ODX(1)))
      MIDD = ((IL.EQ.1) .AND. (IS.EQ.1) .AND. (NCELX.EQ.3) .AND.
     & (NCELY.EQ.3) .AND. (NCELZ.EQ.3) .AND. (IC .EQ. 1))
      IF (HEAD) THEN
        CALL MESS(LPT,2,'    SOURCE ATOM: '//NAME1)
        CALL MESS(LPT,0,'Atom1-Atom2     Bond        Atom 2'//
     & '               Position                Atom 1 - Atom 2'//
     & '       Bond Angles')
        CALL MESS(LPT,0,'                       (if not original)   '//
     & '   x       y       z      delta x delta y delta z   theta phi')
      ENDIF
      HEAD=.FALSE.
C
C IF MAKING CARDS FOR SLACK CONSTRAINTS:
      IF (SLK) THEN
        IF (.NOT. MIDD) THEN
C INVENT NEW NAME INTO TONAME:
          CELXYZ(1)=FLOAT(NCELX-3)
          CELXYZ(2)=FLOAT(NCELY-3)
          CELXYZ(3)=FLOAT(NCELZ-3)
          ISC=IS*(3-2*IC)
          NOLD=NTARNM
          CALL ADDATM('    ',I2,XD,ISC,IL,CELXYZ,N2)
          IF (NOLD .LT. NTARNM) THEN
            TONAME=ATTNAM(NTARNM)
            WRITE (LSK,2005) TONAME,ATNAME(I2),ISC,IL,NCELX-3,
     &      NCELY-3,NCELZ-3
2005        FORMAT ('L ATOM ',A4,2X,A4,2X,I3,2X,I3,2X,3I3)
          ELSE
            TONAME=ATTNAM(N2)
            GO TO 43
          ENDIF
        ELSE
          TONAME=ATNAME(I2)
C ADD TO LIST:
          CALL ADDATM(TONAME,I2,X(1,I2),1,1,ZER,N2)
        ENDIF
  43    NOLD=NUMBON
        CALL ADDBON('    ',N1,N2,NN)
        NBSAVE(NB)=NN
        N3SAVE(NB)=N2
        IF (NOLD .EQ. NUMBON) GO TO 6
        IF (.NOT. BONOUT) THEN
          WRITE (LSK,2051) BONNAM(NN),NAME1,TONAME,BON2,SD2
2051      FORMAT ('L BOND ',A4,2X,A4,2X,A4,2F10.5)
        ELSE
          WRITE (LSK,2051) BONNAM(NN),NAME1,TONAME
        ENDIF
      ENDIF
      IF (MIDD) GO TO 10
C
      K(1)=I2
      K(2)=(3-2*IC)*IS
      K(3)=IL
      K(4)=NCELX-3
      K(5)=NCELY-3
      K(6)=NCELZ-3
      CALL NPACK(I3,K,6,1,ATPACK)
      N2SAVE(NB)=-I3
      CALL ATSPEC(I3,K,CH)
      IF (DONT) WRITE (LPT,2000) ATNAME(I1),ATNAME(I2),B,CH,XD,DX,ANGT1
      IF (.NOT. DONT) WRITE (LPT,2000) ATNAME(I1),ATNAME(I2),
     & B,CH,XD,DX,ANGT1,ANGT2
2000  FORMAT (1X,A4,' - ',A4,F10.4,2X,A16,2X,3F8.4,2X,3F8.4,2F8.2)
      GO TO 6
  10  IF (DONT) WRITE (LPT,2001) ATNAME(I1),ATNAME(I2),B,DX,ANGT1
      IF (.NOT. DONT) WRITE (LPT,2001) ATNAME(I1),ATNAME(I2),
     & B,DX,ANGT1,ANGT2
2001  FORMAT (1X,A4,' - ',A4,F10.4,46X,3F8.4,2F8.2)
   6  CONTINUE
   5  CONTINUE
   4  CONTINUE
   3  CONTINUE
   2  CONTINUE
   1  CONTINUE
  42  CONTINUE
 100  RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE APSHSF(MAGSHF)
      SUBROUTINE APSHSF(MAGSHF)
C
C *** APSHSF updated by PJB 31-May-1994 ***
C
CX
CC 7B
CH Applies shifts to all variables in single crystal structure factor based
CH LSQ, and prints the results.
CA On entry MAGSHF is the name of a routine which applies shifts to magnetic
CA parameters.  It is DUMMY for non-magnetic applications.
CP Shifts are in array BLSQ, and ESDs in DERIVB (to save space)
C
CD Identifies each variable as a type of parameter, and call individual
CD routines to apply shift (possibly fudged).
C
CD For redundant variables, calculates shift from constituent parts of
CD relevant constraint.
C
CO Prints old and new values, shift and esd, with parameter name
CO If family 2 (structure parameter), does printing in blocks
C
      EXTERNAL MAGSHF
      CHARACTER *4 LNAM1,LNAM2
      CHARACTER *80 VFMT
      LOGICAL HEAD,SHFCEL
      COMMON /ATBLOC/NAME,IPNAME(12)
      CHARACTER *4 NAME,IPNAME
      COMMON /ATBLOK/IBUFF,PNEW(12),PESD(12),PSHIFT(12),POLD(12),
     & PSESD(12)
      COMMON /DERBAS/DERIVB(400),LVARB
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MATDAT/MATPNT(401),BLSQ(400)
      COMMON /NEWOLD/SHIFT,XOLD,XNEW,ESD,IFAM,IGEN,ISPC,
     & NEWIN,KPACK,LKH,SHESD,ISHFT,AVSHFT,AMAXSH
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
      DATA VFMT/'(1X,2(1X,A4),4F14.5,F14.4)'/
C
      IF (SIMUL) GO TO 100
      WRITE (LPT,2000) ICYC
2000  FORMAT (/////'1Shifts in variables for cycle',I3)
C
C SET UP QUANTITIES TO USE WITH DIFFERENT STYLES OF OUTPUT:
      IG=0
      IBUFF=0
      HEAD=.FALSE.
C SET NO CELL SHIFTS:
      SHFCEL=.FALSE.
C CLEAR SHIFT AVERAGING:
      CALL FETSHF(1,0.,0.)
C
C SCAN ALL VARIABLES:
      DO 1 I=1,LVARV
      J=LVRBS(I)
      KPACK=LVRPR(I)
C IF VARIABLE IS BASIC:
      IF (J .GT. 0) THEN
        SHIFT=BLSQ(J)
        ESD=DERIVB(J)
C OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
      ELSE
        CALL SHFESD(-J)
      ENDIF
C
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
      IF (J .LT. 0 .AND. IFAM .EQ. 2 .AND. ISPC .EQ. 10) GO TO 1
C
C BRANCH ON FAMILY:
      GO TO (11,12), IFAM
C
  11  GO TO (21,22) , IGEN
C
C FAMILY 1, GENUS 1 - MISCELLANEOUS SPECIES (TFAC,A*,B* . . F*,DOMR,MOSC):
  21  GO TO (31,32,32,32,32,32,32,33,33,33,33,33) , ISPC
C
C TFAC:
  31  CALL LLTFAC(3)
      GO TO 40
C
C DOMR OR MOSC OR FOVLP (EXTINCTION CORRECTION PARAMETERS)
  33  CALL EXTIN3(ISPC-7)
      GO TO 40
C
C CELL PARAMETERS:
  32  CALL CELSHF(ISPC-1)
      SHFCEL=.TRUE.
      GO TO 40
C
C FAMILY 1, GENUS 2 - IN SF THIS IS 'SCAL':
  22  CALL LLSCAL(3)
      GO TO 40
C
C FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
  12  IF (ISPC .LE. 12) CALL F2SHFT
      IF (ISPC .GT. 12) CALL MAGSHF(3)
      GO TO 40
C
C
C COMMON EXIT TO PRINT SHIFTS:
  40  CALL FETSHF(2,SHIFT,ESD)
      CALL PARNAM(LNAM1,LNAM2,3,KPACK)
      IF (IFAM .NE. 2) GO TO 6
C DETECT CHANGE OF GENUS (ATOM)
      IF (IG .EQ. IGEN) GO TO 7
      HEAD=.FALSE.
      CALL PRBLOK
C PUT FIRST ENTRY FOR NEW ATOM INTO BUFFERS:
      NAME=LNAM1
      IG=IGEN
   7  IF (IBUFF .GE. 12) CALL PRBLOK
      IBUFF=IBUFF+1
      IPNAME(IBUFF)=LNAM2
      PNEW(IBUFF)=XNEW
      PESD(IBUFF)=ESD
      PSHIFT(IBUFF)=SHIFT
      POLD(IBUFF)=XOLD
      PSESD(IBUFF)=SHESD
      GO TO 1
C
C HERE TO PRINT TYPE 1 SHIFT AS BEFORE:
   6  IF (.NOT. HEAD) CALL MESS(LPT,1,'  Variable         New'//
     & '           Esd          Shift          Old           Shift/Esd')
      HEAD=.TRUE.
      WRITE (VFMT(19:19),2006) NSIGFG(ESD)
 2006 FORMAT (I1)
      WRITE (LPT,VFMT) LNAM1,LNAM2,XNEW,ESD,SHIFT,XOLD,SHESD
   1  CONTINUE
C
C PRINT ANY REMNANTS FROM BUFFER:
      CALL PRBLOK
      CALL FETSHF(3,0.,0.)
C IF ANY SLACK CONSTRAINTS, UPDATE THEIR BOND ENDS:
      CALL GEOMCO(2)
C IF ANY CELL PARAMETERS CHANGED, UPDATE ALL:
      IF (SHFCEL) CALL RECELL(1,1)
 100  RETURN
      END
C
C
C
C LEVEL 8      SUBROUTINE APSHT2
      SUBROUTINE APSHT2
C
C *** APSHT2 updated by JCM 10 Feb 87 ***
C
CX
CC 7B
CH Applies shifts for reciprocal cell quadratic products and zero
CH during 2theta refinement.
C
CP Only of use from MAIN program T2LSQ, or similar;  only expects one family
CP of parameters, being the 6 reciprocal cell quadratic products
CP and a zero point.
CP Expects shifts (one for each basic variable) in array BLSQ, with
CP corresponding ESDs in array DERIVB.
C
CD Applies shifts as given to the parameters, dealing with constraints
CD if necessary.  Recalculates all cell quantities.
C
CO Writes to unit LPT the old and new values, the shift and its esd.
C
      CHARACTER *4 LNAM1,LNAM2
      COMMON /CELPAR/CELL(3,3,2),V(2),ORTH(3,3,2),CPARS(6,2),KCPARS(6),
     & CELESD(6,6,2),CELLSD(6,6),KOM4
      COMMON /DERBAS/DERIVB(400),LVARB
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /MATDAT/MATPNT(401),BLSQ(400)
      COMMON /NEWOLD/SHIFT,XOLD,XNEW,ESD,IFAM,IGEN,ISPC,
     & NEWIN,KPACK,LKH,SHESD,ISHFT,AVSHFT,AMAXSH
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /ZEROPT/ZERO,KZERO
C
      WRITE (LPT,2000) ICYC
2000  FORMAT (/////'1Shifts in variables for cycle',I3/
     & '   Variable       New           Esd          Shift        ',
     & '  Old    ')
      DO 1 I=1,LVARV
      J=LVRBS(I)
      KPACK=LVRPR(I)
C IF VARIABLE IS BASIC:
      IF (J .GT. 0) THEN
        SHIFT=BLSQ(J)
        ESD=DERIVB(J)
C OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
      ELSE
        CALL SHFESD(-J)
      ENDIF
C
      CALL PARNAM(LNAM1,LNAM2,3,KPACK)
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
      IF (ISPC .GT. 6) GO TO 11
      CALL ADJUST(CPARS(ISPC,2))
      GO TO 12
C
C SHIFT IN ZERO POINT:
  11  CALL ADJUST(ZERO)
  12  WRITE (LPT,2001) LNAM1,LNAM2,XOLD,ESD,SHIFT,XNEW
2001  FORMAT (' ',1X,A4,1X,A4,4G14.5)
   1  CONTINUE
      CALL RECELL(1,1)
      RETURN
      END
C
C
C
C LEVEL 1      SUBROUTINE ARPRIN(H,FBUF,MODE)
      SUBROUTINE ARPRIN(H,FBUF,MODE)
C
C *** ARPRIN updated by PJB 24-Apr-1995 ***
C
CX
CC 2A
CH A multi-mode routine to produce the output in ARRNGE type main programs.
CA On entry H contains a set of floating indices
CA          FBUF is as set up in the main program. FBUF(1) is the record
CA               number and normally FBUF(2:3) the observation and its
CA               standard deviation.
CA MODE selects what is printed out
CA MODE = 0 Sets up the variable formats in accordance with IFOR
CA MODE = 1 Reject output
CA MODE = 2 Initial heading
CA MODE = 3 1st entry for a reflection (rec no indices and values)
CA MODE = 4 Add values to output file buffer
CA MODE = 5 Entry for repeated reflections (recno and values)
CA MODE = 6 End of sub-group
CA MODE = 7 End of group
CA MODE = 8 Average of configuration domains
C
      EXTERNAL ARRBLK
      DIMENSION H(3),FBUF(10),K(3)
      COMMON /ARRFMT/FILBUF,LPTBUF,HKLFMT,VALFMT,REJFMT,VFMT1,VFMT2,
     &VFMT3,VFMT4
      CHARACTER *80 FILBUF,LPTBUF*132,HKLFMT*7,VALFMT*16,REJFMT*30
      CHARACTER *30 VFMT1,VFMT2,VFMT3,VFMT4*45
      COMMON /ARRDAT/IFOR(6),INC,LINO,NREF,INLBUF,NBUF,IBUF,INFBUF,
     & INDLEN,NUMVAL,IPOS,ISTORE,ICHNGE,NEW,LPRINT,ICD,IS,NREF1,NREFL
      LOGICAL INC,NEW,LPRINT
      COMMON /HEDIN/HEADNG
      CHARACTER *300 HEADNG
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /WHEN/DAT,TIM(2),MAIN
      CHARACTER *5 TIM
      CHARACTER *10 DAT
      CHARACTER *6 MAIN
C
      N=NINT(FBUF(1))
      IF (.NOT.INC .AND. MODE.NE.2) CALL INDFIX(H,K)
      GO TO (1,10,20,30,40,50,60,70,80), MODE+1
C
C  FIDDLE THE FORMATS
    1 NUMVAL=3
C NUMVAL IS THE NUMBER OF ENTRIES IN FBUF
      IF (IFOR(1).EQ.1) THEN
        IF (IFOR(6) .EQ.0) THEN
          VALFMT='(2F10.6)'
        ELSE
          VALFMT='(2F10.6,3F10.2)'
          NUMVAL=6
        ENDIF
      ELSE IF (IFOR(1).EQ.5) THEN
        VALFMT='(2F10.2,2F10.5)'
        NUMVAL=5
      ELSE
        IF (IFOR(6) .EQ .0) THEN
          VALFMT='(2F10.2)'
        ELSE
         VALFMT='(2F10.2,4F10.2)'
         NUMVAL=7
       ENDIF
      ENDIF
C IPOS IS THE STARTING POSITION IN FBUF TO STORE
      IPOS=2-IFOR(3)
C ISTORE IS THE NUMBER OF CHARACTERS NEEDED PER MEASUREMENT
      ISTORE=(NUMVAL+1-IPOS)*10
C NBUF IS THE NUMBER OF MEASUREMENTS WHICH WILL FIT IN FILBUF
      NBUF=74/ISTORE
C FORCE NBUF TO 1 TO ENSURE THAT INPUAR WORKS PROPERLY
C THIS NEEDS TO BE CLEANED UP SOMETIME
      NBUF=1
C
      IF (INC) THEN
        HKLFMT='(3F8.3)'
        INDLEN=24
        HEADNG(14:15)='11'
        HEADNG(28:29)='12'
        HEADNG(69:70)=' 9'
        HEADNG(85:86)='11'
        HEADNG(122:123)='53'
        HEADNG(141:142)='13'
        HEADNG(153:154)='16'
        HEADNG(171:194)='16X,''h'',7X,''k'',7X,''l'',7X'
        HEADNG(236:258)='6X,''h'',7X,''k'',7X,''l'',9X'
      ELSE
C SET IS TO ZERO FOR ARRNGE (NO SATELLITES)
        IS=0
        HKLFMT='(3I5  )'
        INDLEN=15
      ENDIF
C
      IF (IFOR(5).NE.0) THEN
        REJFMT='('' Reject '',I9,'//HKLFMT(2:6)//','//VALFMT(2:)
      ENDIF
      VFMT1='(I9,2X,'//HKLFMT(2:6)//','//VALFMT(2:)
      VFMT2='(I5,'//HKLFMT(2:6)//',2I5)'
      VFMT3=HKLFMT(1:6)//','//VALFMT(2:)
      VFMT4='(53X,''Domain average  '','//VFMT3(2:)
      IF (INC) VFMT4(2:3)='62'
      INFBUF=0
C
      GO TO 100
C
C REPORT REJECTIONS
   10 IF (INC) THEN
        WRITE (LPT,REJFMT) N,H,(FBUF(I),I=2,NUMVAL)
      ELSE
        WRITE (LPT,REJFMT) N,K,(FBUF(I),I=2,NUMVAL)
      ENDIF
      GO TO 100
C
   20 WRITE (LPT,HEADNG)
      LINO=6
      INLBUF=1
      NEW=.TRUE.
      GO TO 100
C
C PRINTOUT DATA FOR INDIVIDUAL MEASUREMENTS
   30 J=NREF
      CALL TESTP(LPT,LINO,J,HEADNG,3)
      LINO=LINO-1
C CHECK WHETHER REFLECTIONS OCCURRING SINGLY ARE TO BE PRINTED
      IF (NEW) THEN
        LPRINT=((IFOR(2).GE.0) .OR. (NREF.GT.1) .OR. (ICHNGE.EQ.4))
        NEW=.FALSE.
      ENDIF
      IF (LPRINT) THEN
        IF (INLBUF.GT.1) THEN
          WRITE (LPT,3000) LPTBUF
 3000     FORMAT (A80)
          LINO=LINO+1
        ENDIF
        IF (INC) THEN
          WRITE (LPTBUF,VFMT1)  N,H,FBUF(2),FBUF(3)
        ELSE
          WRITE (LPTBUF,VFMT1) N,K,FBUF(2),FBUF(3)
        ENDIF
        INLBUF=31+INDLEN
      ENDIF
C
C  WRITE HEADER LINE TO OUTPUT FILE
        L=(NUMVAL-IPOS+1)*NREF+3
        IF (INFBUF.EQ.0. 0) WRITE (FILBUF(INDLEN:),2001) DAT,TIM(1)
2001    FORMAT (30X,A10,A5)
        INFBUF=INDLEN+44
        IF (INC) THEN
          WRITE (FILBUF(1:21+INDLEN),VFMT2) ICD,H,J,L
        ELSE
          WRITE  (FILBUF(1:21+INDLEN),VFMT2) ICD,K,J,L
        ENDIF
        WRITE (LUNI,3002) (FILBUF(I:I),I=1,INFBUF)
        ICD=ICD+1
        WRITE (FILBUF,3001) ICD
        INFBUF=6
        IBUF=0
        GO TO 100
C

C PUT VALUES INTO A BUFFER TO ACCUMULATE A LINE OF OUTPUT
   40 WRITE (FILBUF(INFBUF:),VALFMT) (FBUF(I),I=IPOS,NUMVAL)
      IBUF=IBUF
      INFBUF=INFBUF+ISTORE
      IBUF=IBUF+1
      IF (IBUF.GE.NBUF) THEN
        WRITE (LUNI,3002) (FILBUF(I:I),I=1,INFBUF-1)
 3002   FORMAT (80A1)
        ICD=ICD+1
        IBUF=0
        WRITE (FILBUF,3001) ICD
 3001   FORMAT (I5)
        INFBUF=6
      ENDIF
      GO TO 100
C
C REPEATED MEASUREMENT
   50 IF (LPRINT) THEN
C PRINT LINE JUST TERMINATED
        CALL TESTP(LPT,LINO,1,HEADNG,3)
        WRITE (LPT,2000) LPTBUF
 2000   FORMAT (A132)
        LINO=LINO+1
      ENDIF
      WRITE (LPTBUF,VFMT1) N
      WRITE (LPTBUF(12+INDLEN:),VALFMT) FBUF(2),FBUF(3)
      GO TO 100
C
C CHANGE OF SUBGROUP
C EMPTY BUFFER
   60 IF (IBUF.GT.0) THEN
        WRITE (LUNI,3002) (FILBUF(I:I),I=1,INFBUF-1)
        ICD=ICD+1
      ENDIF
      IF (LPRINT) THEN
        INLBUF=33+INDLEN
        WRITE (LPTBUF(INLBUF:),VALFMT) FBUF(2),FBUF(3)
      ENDIF
      GO TO 100
C
C END OF GROUP
   70 L=3
      INLBUF=INLBUF+22
      IF (INC) THEN
        J=100*IS+ICHNGE
        IF (LPRINT) WRITE (LPTBUF(INLBUF:),VFMT3) H,FBUF(2),FBUF(3)
        WRITE (LUNI,VFMT2) ICD,H,J,L
      ELSE
        IF (LPRINT) WRITE (LPTBUF(INLBUF:),VFMT3) K,FBUF(2),FBUF(3)
        WRITE (LUNI,VFMT2) ICD,K,J,L
      ENDIF
      ICD=ICD+1
      IF (LPRINT) THEN
        CALL TESTP(LPT,LINO,2,HEADNG,3)
        WRITE (LPT,2000) LPTBUF
        CALL NEWLIN(LPT)
        LINO=LINO+1
      ENDIF
      INLBUF=1
      NEW=.TRUE.
      GO TO 100
C
C AVERAGE OVER CONFIGURATION DOMAINS
   80 CALL TESTP(LPT,LINO,2,HEADNG,3)
       L=3
       J=0
      IF (INC) THEN
        WRITE (LPT,VFMT4)H,FBUF(2),FBUF(3)
        WRITE (LUNI,VFMT2) ICD,H,J,L
      ELSE
        WRITE (LPT,VFMT4)H,FBUF(2),FBUF(3)
        WRITE (LUNI,VFMT2) ICD,K,J,L
      ENDIF
      ICD=ICD+1
      CALL NEWLIN(LPT)
      LINO=LINO+1
      GO TO 100
C
  100 RETURN
      END
C
C
C LEVEL 1      SUBROUTINE TESTP(LUN,LINO,I,HEADNG,NL)
      SUBROUTINE TESTP(LUN,LINO,I,HEADNG,NL)
C
C *** TESTP by JCM 16 Oct 85 ***
C
CX
CC 13C
CH Puts a given heading at top of every printer page, counting lines.
CA On entry LUN is the required output unit number
CA          LINO is the number of lines already output on the current page
CA          I is the number of lines required to be output on this call
CA          HEADNG is the character variable holding the heading
CA          NL is the number of lines in HEADNG
CA On exit  LINO has been updated.
CD Tests the potential output against a page size of NLINES
CO If necessary, throws a page and puts out the heading on unit LUN
C
      CHARACTER*(*) HEADNG
C%
C      DATA NLINES/%LNPP%/
      DATA NLINES/115/
C
      LINO=LINO+1
      IF (LINO+I .LT. NLINES) GO TO 100
      IF (LINO .LT. NLINES-4) GO TO 100
      CALL NEWPAG(LUN)
      WRITE (LUN,FMT=HEADNG)
      LINO=NL+1
 100  RETURN
      END
C
C
C
C
      BLOCK DATA ARRBLK
C
C *** ARRBLK corrected by PJB Sept 94  ***
C
      COMMON /HEDIN/HEADNG
      CHARACTER *300 HEADNG
      DATA HEADNG/'(4X,''Record'', 6X,''Indices'', 6X,''Observations'',9
     &X,''Mean of repeated'', 5X,''Labelling'', 6X,''Mean of equivalent'
     &'/4X,''Number'',44X,''Observations'', 9X,''Index'',11X,''Reflectio
     &ns''/14X,''h'',4X,''k'',4X,''l'',6X,''Value'',5X,''SDevn'',7X,''Me
     &an'',5X,''SDevn'',4X,''h'',4X,''k'',4X,''l'',8X,''Mean'',5X,''SDev
     &n''/)'/
      END
C
C
C
C LEVEL 7      LOGICAL FUNCTION SYMFIX(KK)
      LOGICAL FUNCTION SYMFIX(KK)
C
C *** SYMFIX by JCM 7 Jun 88 ***
C
CX
CC 6C
CH Says whether a LSQ parameter is fixed by symmetry or not.
CA On entry KK holds packed parameter spec
CA On exit SYMFIX is TRUE if KK is fixed by symmetry (not just by user)
C
      LOGICAL KSAME
      COMMON /LINKAG/NUMFV,NUMPAK,KKFV(200),KTYPFV(200),KSTFV(200),
     & KTIME(200),KUNPFV(5,30),NTIME,NUMCON,KKCON(500),AMCON(500),
     & KPTCON(201),KSTCON(200),KTPCON(200)
C
      SYMFIX=.TRUE.
C
C SCAN ALL FIXING AND VARYING:
      DO 1 I=1,NUMFV
C IF ENTRY IS NOT KK ITSELF, AND DOES NOT ENCOMPASS KK, JUMP:
      IF (.NOT. KSAME(KK,KKFV(I)))  GO TO 1
C OTHERWISE, IF STATUS IS + (="FIX") 5 (="BY PROGRAM"), TRUE:
      IF (KSTFV(I) .EQ. 5) GO TO 100
   1  CONTINUE
      SYMFIX=.FALSE.
 100  RETURN
      END
C
C
C
C
C LEVEL 9      SUBROUTINE STLSSF
      SUBROUTINE STLSSF
C
C *** STLSSF updated by JCM 20 Jul 88 ***
C
CX
CC 7A
CH Sets up any main program which does single crystal structure factor LSQ.
C
CI Reads and interprets:
CI An I card giving general instructions (including NCYC, CYC1, MCOR,
CI             and PRIN items, if required).
CI All L cards except FIX, VARY and RELA.
C
CD Reads in I and L cards.  If the refinement is actually a simple
CD application of geometric slack constraints, with no other observations,
CD sets this up (by recording "no. of scale factors=0" in LF1SP(2)),
CD deals with a possible absence of fudge factors, and exits.
CD
CD Otherwise deals with defaults for:
CD L TFAC: set TFAC=0 and fixed
CD L SCAL: set SCAL(1)=0, variable, and NSCALE=1
CD L REFI: assumes refinement type 1, "on mod Fc"
CD L MODE: assumes mode 3, data input as h,k,l, obs, sigma(obs), possible
CD         scale zone, possible code.
CD L WGHT: assumes weighting type 2, "use 1/sigma sqrd".
CD L FUDG: assumes no fudge factors.
C
CO Writes its findings to unit LPT.
C
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /LREAD/ILREA(22,5),KOM18
      DIMENSION ILREAD(22)
      EQUIVALENCE (ILREAD(1),ILREA(1,1))
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(20),KSCALE(20),
     & NSCL,LSCD(10)
      COMMON /SLAKDA/NSLAK(4),SLKSWD(4),SLAKWT(4),
     & CHISQD(4),ISLKTP,NSKTOT,KOM24
      COMMON /SLKGEO/NSTYP,BOBS(500),EOBS(500),IATM(500,2),
     & ISYM(500),ILAT(500),CELLTR(3,500),XSLAK(3,500),
     & COSIN(3,3),IABASE(500),NST1,SLONLY,TOSTAR(6,6),BCALC(500),
     & DERCEL(6,500),DERPOS(3,500,2),ITYPSK(500),INVBON(10,
     & 500),NINVB(500),INANG(100,3),INTOR(100,6),
     & DERBON(10),NVB(10),NUMBON,NTARNM,NUMANG,NUMTOR,KOM25
      LOGICAL SLONLY
C
      IF (INREAD(9) .GT. 0) CALL INPUTI
      CALL IICD1
C NOW ALL L CARDS EXCEPT FIX,RELA, VARY:
      CALL INPLSF
C AND INTERPRET THEM HAVING READ ALL:
C
C IF ONLY SLAK CONSTRAINTS & NO OBS, ONLY DEFAULT TO CONSIDER
C IS FUDG, AND WE NEED TO SET NO SCALES:
      IF (NSLAK(1) .LE. 0 .OR. .NOT. SLONLY) THEN
C DEFAULT IF NO L TFAC:
        IF (ILREAD(1) .EQ. 0) CALL LLTFAC(5)
C DEFAULT IF NO L SCAL:
        IF (ILREAD(2) .EQ. 0) CALL LLSCAL(0)
C SET ACTUAL NUMBER OF SCALE ZONES AS NUMBER OF PARAMETERS OF FAMILY 1, GENUS 2:
        LF1SP(2)=-NSCALE
C
C DEFAULT IF NO REFI - ASSUME REFINING ON MOD FC TO BE MOST USUAL:
        IF (ILREAD(3) .EQ. 0) THEN
          IREF=1
          CALL MESS(LPT,1,
     &    'No L REFI card - assuming refining on mod(Fc), type 1')
        ENDIF
C
C DEFAULT IF NO MODE CARD - TYPE 3:
        IF (ILREAD(4) .EQ. 0) THEN
          MODER=3
          CALL MESS(LPT,1,
     &    'No L MODE card - assuming mode 3, data input as h,k,l'//
     &    ' Gobs, sigma, (Scale), (Code)')
        ENDIF
C
C DEFAULT WEIGHTING IS TYPE 2 - ALSO SORT OUT INTERACTION BETWEEN IWGHT & MODER:
        IF (ILREAD(5) .EQ. 0) THEN
          IWGHT=2
          CALL MESS(LPT,1,'No L WGHT card given - assuming type 2')
        ENDIF
C
C IF WEIGHTING SCHEME 2, EXACT FORM OF INPUT FOR WEIGHTS DEPENDS ON MODER:
        IF (IWGHT .EQ. 2) THEN
C
C CANNOT HAVE MODER=1:
          IF (MODER .EQ. 1) THEN
            WRITE (LPT,3000) IWGHT,MODER
            WRITE (ITO,3000) IWGHT,MODER
3000        FORMAT (/' ERROR ** Weighting scheme=',I4,
     &      ' and input mode =',I4,' incompatible')
            IERR=IERR+1
          ELSE IF (MODER .EQ. 2) THEN
C
C WEIGHT TO BE USED AS READ:
            CALL MESS(LPT,1,
     &      'Weights to be used as read from reflection data')
          ELSE
C
C SIGMA READ, WEIGHT IS 1/SIGMA SQUARED:
            CALL MESS(LPT,1,
     &      'Sigma read from reflection data - weight is '//
     &      '1/sigma squared')
          ENDIF
        ENDIF
      ELSE
        LF1SP(2)=0
      ENDIF
C
      CALL ERRMES(0,0,'for structure factor LSQ')
C
      CALL GEOMIN(1)
 100  RETURN
      END
C
C
C
C
C LEVEL 7      SUBROUTINE STLSFW
      SUBROUTINE STLSFW
C
C *** STLSFW by JCM 17 Nov 84 ***
C
CX
CC 7A
CH Sets up the main program FWLSQ to perform LSQ on Forsyth & Wells
CH scattering factor coefficients.
C
CI Reads in and interprets an I card and an L VALS card giving
CI the 5, 7 or 9 initial values.
CO Writes its findings to unit LPT.
C
      COMMON /FWVALS/NVALS,COEFFS(9)
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
C
C SET 'FORSYTH & WELLS SCATTERING FACTOR TYPE LSQ':
      IREF=-1
C WRITE TITLE IN CASE USER HAS INVOKED WRONG SUB-LIBRARY:
      CALL CENTRE(LPT,3,'Least Squares Refinement',80)
      CALL CENTRE(LPT,0,'Forsyth and Wells Scattering Factors',80)
      IF (INREAD(9) .GT. 0) CALL INPUTI
      CALL IICD1
C
C READ L CARDS:   L VALS HAS 5, 7 OR 9 STARTING VALUES
      ILCD=ICDNO(12)
      IF (ILCD .LE. 0) CALL ERRMES(1,0,'No L cards')
C
      K=0
      NVLS=0
  1   CALL FINDCD('L','VALS',4,K,LCD)
      IF (LCD .GT. 0) THEN
        K=LCD
        NV=NVLS+1
        CALL RDNUMS(COEFFS(NV),7,9,NVLS,IER)
        NVLS=NVLS+NV-1
        GO TO 1
      ENDIF
C
      NVALS=NVLS
      WRITE (LPT,2010) NVALS,(COEFFS(I),I=1,NVALS)
2010  FORMAT (/1X,I4,' coefficients in approximation'/' Initial values',
     & 9F12.5)
      RETURN
      END
C
C
C
C
C LEVEL 3      SUBROUTINE STATIS(MODE)
      SUBROUTINE STATIS(MODE)
C
C *** STATIS updated by PJB 22 Jun 92 ***
C
CX
CC 2B
CH Calculates means and other statistics for a set of measurements of a
CH single quantity.
CA MODE is an integer indicating which of the two sets of data held in
CA /REFS/ is to be used
CA  MODE=0 read and average both sets
CA  MODE=1 read and average the first block of data in REFS
CA  MODE=2 read and average the second block
CP INPUAR to fill in the data in /REFS/
CP The vector SUMS in COMMON /STATS/ is used to accumulate quantities
CA needed for statistical output. It should be cleared before the first call
CP to STATIS
CP   SUMS(1) holds the sum of the observations
CP   SUMS(2)       the sum of the standard deviations
CP   SUMS(3)       the sum of the means of repeated measurements
CP   SUMS(4)       the sum of the standard deviations of repeated measurements
CP   SUMS(5)       the sum for repeated observations of their weighted squares
CP                 minus the weighted square of the mean
CP   SUMS(6)       the number of repeated observations
CP   SUMS(7)       the sum of the means of equivalent observations
CP   SUMS(8)       the sum of the standard deviations of equivalent observations
CP   SUMS(9) as SUM(5) for equivalent observations
CP   SUMS(10) holds the number of equivalent observations
CP   SUMS(11)       the sum of all weighted observations
CP   SUMS(12)       the sum of the means for all observations
C
      COMMON /REFS/K(3,2),JJ(48,2),LL(48,2),R(500,2),SCALE(2),INC,II,NR,
     &FF(3,2),ITEMS
      COMMON /STATS/WRK1(5),WRK2(5),WRK3(5),AMEAN(2),DEV(2),SUMS(12),
     & X,DX,RAT,DRAT
C
      IF (MODE.NE.0) THEN
        MS=MODE
        ME=MS
      ELSE
        MS=1
        ME=2
      ENDIF
C
      DO 4 IS=MS,ME
      CALL WTMEAN(X,DX,0,WRK3)
      CALL WTMEAN(X,DX,0,WRK1)
      IR=1
      II=0
    2 L=LL(IR,IS)
      IF (L.EQ.3) GO TO 3
      IE=II+L
      IB=II+4
      CALL WTMEAN(X,DX,0,WRK2)
      DO 1 I=IB,IE,ITEMS
C WRK1 IS THE WORKING SPACE FOR STATISTICS OF ALL MEASUREMENTS TAKEN
C INDIVIDUALLY
      CALL WTMEAN(R(I,IS),R(I+1,IS),2,WRK1)
C WRK2 IS THE WORKING SPACE FOR STATISTICS OF REPEATED MEASUREMENTS
      CALL WTMEAN(R(I,IS),R(I+1,IS),2,WRK2)
      SUMS(1)=SUMS(1)+R(I,IS)
      SUMS(2)=SUMS(2)+R(I+1,IS)
    1 CONTINUE
      II=II+L
      CALL WTMEAN(R(II+1,IS),R(II+2,IS),-1,WRK2)
C WRK3 IS THE WORKING SPACE FOR STATISTICS OF EQUIVALENTS AFTER AVERAGING
C REPEATED MEASUREMENTS
      CALL WTMEAN(R(II+1,IS),R(II+2,IS),2,WRK3)
      IF (WRK2(4).GT.1.01) THEN
        SUMS(3)=SUMS(3)+R(II+1,IS)
        SUMS(4)=SUMS(4)+R(II+2,IS)
        SUMS(5)=SUMS(5)+WRK2(2)-R(II+1,IS)*WRK2(1)
        SUMS(6)=SUMS(6)+WRK2(4)
      ENDIF
        SUMS(11)=SUMS(11)+1.
        SUMS(12)=SUMS(12)+R(II+1,IS)
C  LEAVE SPACE FOR MEANS
      II=II+2
      IR=IR+1
      GO TO 2
C
C  FINISH ONE INDEPENDENT MEASUREMENT
    3 CALL WTMEAN(AMEAN(IS),DEV(IS),-1,WRK1)
      CALL WTMEAN(AMN,DEVN,-1,WRK3)
      IF (WRK1(4).GT.1.01) THEN
        SUMS(7)=SUMS(7)+AMEAN(IS)
        SUMS(8)=SUMS(8)+DEV(IS)
        SUMS(9)=SUMS(9)+WRK3(2)-AMN*WRK3(1)
        SUMS(10)=SUMS(10)+WRK3(4)
      ENDIF
    4 CONTINUE
C
      IF (MODE .EQ. 0) THEN
        RAT=AMEAN(2)/AMEAN(1)
        DRAT=SQRT((DEV(1)/AMEAN(1))**2+(DEV(2)/AMEAN(2))**2)
        CALL WTMEAN(RAT,DRAT,2,WRK1)
        CALL WTMEAN(X,DX,0,WRK2)
        DO 5 I=1,2
        CALL WTMEAN(AMEAN(I),DEV(I),2,WRK2)
    5   CONTINUE
        CALL WTMEAN(X,DX,-1,WRK2)
      ENDIF
      RETURN
      END
C
C
C
C
C LEVEL 12      SUBROUTINE SETPOL
      SUBROUTINE SETPOL
C
C *** SETPOL by PJB 17 Jan 85 ***
C
CX
CC 2A
CH Reads the polarisation and flipping efficiencies (for polarised neutrons).
CD Reads the "P" card giving the polarisation and flipping efficiency
CD both with their standard deviations. Stores the data in COMMON /POLDA/.
C
CI Reads the "P" card from the copy of the Crystal Data File on unit IO10.
CO Writes its findings to unit LPT
C
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /POLDA/P,DP,E,DE,MODE,POLND(3)
C
      INREAD(16)=-IABS(INREAD(16))
      IF (ICDNO(16) .LE. 0) CALL ERRMES(1,0,
     & 'no polarisation data have been given')
C
      CALL CARDIN(IABS(INREAD(16)))
      CALL RDREAL(P,3,IPT,80,IER)
      CALL RDREAL(DP,IPT,IPT,80,IER)
      CALL RDREAL(E,IPT,IPT,80,IER)
      CALL RDREAL(DE,IPT,IPT,80,IER)
      CALL RDINTG(MODE,IPT,IPT,80,IER)
      WRITE (LPT,2000) P,DP,E,DE
2000  FORMAT (/' Polarisation of beam is',F10.5,' +or-',F10.5,
     & '.  Flipping efficiency is',F10.5,' +or-',F10.5)
      IMODE = MODE+1
      IF (IMODE .EQ. 3) THEN
        CALL MESS(LPT,1,
     &   'Depolarisation to be calculated as a volume effect')
        IF (INREAD(7) .GT. 0) CALL INPUTG
        CALL SETDC
        CALL SETGAU
      ENDIF
 100  RETURN
      END
C
C
C
C
C LEVEL 12      SUBROUTINE SETLP
      SUBROUTINE SETLP
C
C *** SETLP by JCM 8 Oct 85 ***
C
CX
CC 2A
CH Prepares to calculate (X-ray) Lorentz and polarisation corrections.
CP RECIP should have read the cell parameters.
CD Reads and checks the D cards necessary for LP corrections and puts
CD required data into COMMON /DGEOM/
CD Checks the presence of D WVLN and D TH2M (for type 10 IGEOM) cards.
CO Writes a title to unit LPT.
C
      COMMON /DGEOM/IGEOM,UM(9),NLR,ANGLIN(3),ALAMBD(5,5),
     & NLAMB,ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /DREAD/IDREAD(8)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
C
      CALL MESS(LPT,2,'Lp corrections')
      CALL SETDC
      IF (IDREAD(2) .LE. 0) THEN
        CALL ERRMES(2,1,'D WVLN card for LP')
        GO TO 100
      ENDIF
C
      IF (IGEOM .NE. 10) THEN
        IF (IDREAD(4) .LE. 0) CALL ERRMES(2,1,
     &  'D TH2M card for monochrometer 2theta')
      ENDIF
C
 100  RETURN
      END
C
C
C
C LEVEL 1      SUBROUTINE SERROR(M,N,F,X,W,S,H,SD)
      SUBROUTINE SERROR(M,N,F,X,W,S,H,SD)
C
C *** SERROR from PJB by R M Richardson 22 Sep 80 ***
C
CX
CC 6C
CH Called after VA05A to give the standard deviations of the parameters.
C
CP  Minimisation procedure VA05A from the Harwell library
CA  Input arguments:-
CA     M,N,F,X,W as defined in VA05A description
CA  Output arguments:-
CA     S=Sum of squares
CA     H=Fractional variance covariance matrix
CA     SD=Fractional standard error of parameter (provided that the
CA     covariance is negligible)
C
      DIMENSION F(M),X(N),W(1),H(1),SD(N)
      NWI=M*N
      S=0.0
      DO 2 J=1,M
    2 S=S+F(J)*F(J)
      DO 10 I=1,N
      DO 6 J=1,N
      HH=0.0
      K=NWI+I
      KK=NWI+J
      DO 5 L=1,M
      HH=HH+W(K)*W(KK)
      K=K+N
      KK=KK+N
    5 CONTINUE
      IJ=(J-1)*N+I
      H(IJ)=HH/(X(I)*X(J))
    6 CONTINUE
      I2=(I-1)*N+I
      SD(I)=SQRT(H(I2)*S/(M-N))
   10 CONTINUE
      RETURN
      END
C
C
C
C
C LEVEL 1      FUNCTION MATCHF(F)
      FUNCTION MATCHF(F)
C
C *** MATCHF by JBF 19 Jun 87 ***
C
CX
CC 3C
CH Checks to see whether two sets of floating point reflection indices match.
CA On entry F(3,2) holds the two sets of indices, hkl1 hkl2.
CD The function is set to zero if the indices match
CD                     to 1 if hkl1 comes before hkl2 in the standard order
CD                          of reflection indices in which h varies fastest
CD                          then k then l
CD                     to 2 if hkl2 comes before hkl1
CN See MATCH for fixed point indices
C
      DIMENSION F(3,2)
C
      DO 1 I=3,1,-1
      IF (F(I,1)-F(I,2).GT.0.001) GO TO 2
      IF (F(I,1)-F(I,2).LT.-0.001) GO TO 3
    1 CONTINUE
C
C  INDICES MATCH
      MATCHF=0
      GO TO 100
C  POSITIVE DIFFERENCE STREAM 1 AHEAD
    2 MATCHF=2
      GO TO 100
C  NEGATIVE DIFFERENCE STREAM 2 AHEAD
    3 MATCHF=1
C
  100 RETURN
      END
C
C
C
C
C
C LEVEL 1      FUNCTION MATCH(K)
      FUNCTION MATCH(K)
C
C *** MATCH by PJB 1 Jul 86 ***
C
CX
CC 3C
CH Checks to see whether two sets of reflection indices match.
CA On entry K(3,2) holds the two sets of indices, hkl1 hkl2.
CD The function is set to zero if the indices match
CD                     to 1 if hkl1 comes before hkl2 in the standard order
CD                          of reflection indices in which h varies fastest
CD                          then k then l
CD                     to 2 if hkl2 comes before hkl1
CN See also MATCHF for floating indices
C
      DIMENSION K(3,2)
C
      DO 1 I=3,1,-1
      IF (K(I,1)-K(I,2)) 3,1,2
    1 CONTINUE
C
C  INDICES MATCH
      MATCH=0
      GO TO 100
C  POSITIVE DIFFERENCE STREAM 1 AHEAD
    2 MATCH=2
      GO TO 100
C  NEGATIVE DIFFERENCE STREAM 2 AHEAD
    3 MATCH=1
C
  100 RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE LSETUP(NW,LSPEC,LWORDS)
      SUBROUTINE LSETUP(NW,LSPEC,LWORDS)
C
C *** LSETUP updated by JCM 26 Jun 89 ***
C
CX
CC 6A
CH Sets up specific LSQ problem - copies the vocabulary to standard COMMON.
CA NW on entry is the number of words in this problem's vocabulary
CA LSPEC on entry is an array specifying the meaning of the words
CA       with 3 integers per word - family, genus, species
CA LWORDS on entry is an A4 array of words in this problem's vocabulary
CP The problem must have already been specified to the extent of:
CP    NFAM=number of families
CP    NGENS(I)=number of genera in family I
CP    NSPC(I)=number of species in each genus of family I
CD Packs the LSPEC integers to 1 word
CD Copies both arrays LSPEC and LWORDS into standard arrays IWDSPC  and
CD LSQWD in /WDSPEC/ and /WORDS/.
CD Sets up the packing of IFAM, IGEN, ISPC into one integer
C
      CHARACTER *4 LWORDS(NW)
      DIMENSION LSPEC(3,NW),LPAK(3)
      COMMON /LINKAG/NUMFV,NUMPAK,KKFV(200),KTYPFV(200),KSTFV(200),
     & KTIME(200),KUNPFV(5,30),NTIME,NUMCON,KKCON(500),AMCON(500),
     & KPTCON(201),KSTCON(200),KTPCON(200)
      COMMON /LSQPAK/KKPACK(10,3)
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /WDSPC/IWDNUM,IWDSPC(60)
      COMMON /WORDS/LSQWD(60)
      CHARACTER *4 LSQWD
C
C CHECK NFAM:
C%
C  20  CALL ERRCHK(1,NFAM,%FAMS%,0,'LSQ families of parameters')
  20  CALL ERRCHK(1,NFAM,6,0,'LSQ families of parameters')
C
      MGEN=0
      MSPC=0
      DO 1 I=1,NFAM
      IF (NGENS(I) .GT. MGEN) MGEN=NGENS(I)
      IF (NSPC(I) .GT. MSPC) MSPC=NSPC(I)
   1  CONTINUE
C
C SET UP PACKING OF IFAM,IGEN,ISPC:
      IWDNUM=NW
C CHECK ARRAY SIZES:
C%
C   4  CALL ERRCHK(1,NW,%WORD%,0,'words specifying LSQ problem')
   4  CALL ERRCHK(1,NW,60,0,'words specifying LSQ problem')
      IF (MGEN .LE. 0) CALL ERRMES(1,0,
     & 'maximum genera in any family is 0')
      IF (MSPC .LE. 0) CALL ERRMES(1,0,
     & 'maximum species in any genus is 0')
C
      LPAK(1)=NFAM
      LPAK(2)=MGEN
      LPAK(3)=MSPC
      CALL NPACK(N,LPAK,3,0,KKPACK)
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMM0N:
      DO 2 I=1,IWDNUM
      DO 7 J=1,3
   7  LPAK(J)=LSPEC(J,I)
      IF (LPAK(1) .LT. 0) IWDSPC(I)=LPAK(1)
      IF (LPAK(1) .GE. 0) CALL NPACK(IWDSPC(I),LPAK,3,1,KKPACK)
   2  LSQWD(I)=LWORDS(I)
C
C PREPARE FIX LIST AND CONSTRAINT LIST FOR CALLS OF ADDFIX, ADDCON
      NUMFV=0
      NUMPAK=0
      NUMCON=0
      KPTCON(1)=1
 100  RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE LSETSF(NW,LSPEC,LWORDS)
      SUBROUTINE LSETSF(NW,LSPEC,LWORDS)
C
C *** LSETSF by JCM 14 Jun 92 ***
C
CX
CC 6A
CH Sets up vocabulary for a specific LSQ problem involving structure factors.
CA NW on entry is the number of words in this problem's specific vocabulary
CA LSPEC on entry is an array specifying the meaning of the words
CA       with 3 integers per word - family, genus, species
CA LWORDS on entry is an A4 array of words in this problem's vocabulary
CP The problem must have already been specified to the extent of:
CP    NFAM=number of families
CP    NGENS(I)=number of genera in family I
CP    NSPC(I)=number of species in each genus of family I
CD Sets up the packing of IFAM, IGEN, ISPC into one integer
CD Packs the LSPEC integers to 1 word
CD First sets up the standard Structure Factor LSQ vocabulary for family 2
CD parameters (and cell from family 1).
CD Copies both arrays LSPEC and LWORDS into standard arrays IWDSPC  and
CD LSQWD in /WDSPEC/ and /WORDS/.
C
CN Because of its use of the standard family 2 names and numbers, it determines
CN these to be the same in every application (e.g. B11 is always species 4).
CN If this is not what is wanted, use LSETUP and give it the entire vocabulary.
C
      EXTERNAL F2PARS
      CHARACTER *4 LWORDS(NW)
      DIMENSION LSPEC(3,NW),LPAK(3)
      COMMON /F2NAMS/F2NAME(40)
      CHARACTER *4 F2NAME
      COMMON /F2NUMS/NF2NUM(3,40)
      COMMON /LINKAG/NUMFV,NUMPAK,KKFV(200),KTYPFV(200),KSTFV(200),
     & KTIME(200),KUNPFV(5,30),NTIME,NUMCON,KKCON(500),AMCON(500),
     & KPTCON(201),KSTCON(200),KTPCON(200)
      COMMON /LSQPAK/KKPACK(10,3)
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /WDSPC/IWDNUM,IWDSPC(60)
      COMMON /WORDS/LSQWD(60)
      CHARACTER *4 LSQWD
C
C CHECK NFAM:
C%
C  20  CALL ERRCHK(1,NFAM,%FAMS%,0,'LSQ families of parameters')
  20  CALL ERRCHK(1,NFAM,6,0,'LSQ families of parameters')
C
      MGEN=0
      MSPC=0
      DO 1 I=1,NFAM
      IF (NGENS(I) .GT. MGEN) MGEN=NGENS(I)
      IF (NSPC(I) .GT. MSPC) MSPC=NSPC(I)
   1  CONTINUE
      IF (MGEN .LE. 0) CALL ERRMES(1,0,
     & 'maximum genera in any family is 0')
      IF (MSPC .LE. 0) CALL ERRMES(1,0,
     & 'maximum species in any genus is 0')
C
C SET UP PACKING OF IFAM,IGEN,ISPC:
      LPAK(1)=NFAM
      LPAK(2)=MGEN
      LPAK(3)=MSPC
      CALL NPACK(N,LPAK,3,0,KKPACK)
C
C WORDS RELEVANT TO THIS PROBLEM FROM DATA INTO COMM0N:
C
      IWDNUM=0
C FIRST PUT IN STANDARD FAMILY 2 PARAMETERS, AND CELL:
C%
C      CALL VOCAB(F2NAME,NF2NUM,%F2PR%)
      CALL VOCAB(F2NAME,NF2NUM,40)
C NOW THE SPECIAL ADDITIONAL VOCABULARY:
      CALL VOCAB(LWORDS,LSPEC,NW)
C
C PREPARE FIX LIST AND CONSTRAINT LIST FOR CALLS OF ADDFIX, ADDCON
      NUMFV=0
      NUMPAK=0
      NUMCON=0
      KPTCON(1)=1
 100  RETURN
      END
C
C
C
C LEVEL 7      SUBROUTINE LMPCAL(H)
      SUBROUTINE LMPCAL(H)
C
C *** LMPCAL updated by JCM 9 Feb 91 ***
C
CX
CC 7B
CH Calculates a structure factor and its derivatives using a multipole
CH description of the form factors.
CA On entry H is a 1x3 array containing h,k,l
CD On exit in /FCAL/
CD    FC is the complex structure factor
CD    FCMOD is its modulus
CD    COSAL is the cosine of its phase
CD    SINAL is the sine of its phase
CD    FCDERS is an array of derivatives of FCMOD wrt all family 2 (structure
CD           parameters and family 5 (multipole).  These are NOT multiplied
CD           or divided by anything else;  compare LMCALC
CD The above will all be zero if h,k,l gives a lattice absence;  note that
CD such would not be true of FCALC
C
      COMPLEX SUM1,TERM,HR,CRS,PSUM,PFACS(50)
      LOGICAL TESTOV,LATABS
      DIMENSION RH(3),H(3)
      COMMON /ANISO/ATF(6,50),KATF(6,50),IAPT(150),
     & IATYP(50),KOM1
      COMMON /BRAGG/STHMXX(5),STHL,SINTH,COSTH,SSQRD,TWSNTH(5),
     & DSTAR2,TWOTHD(5),DIFANG(6)
      EQUIVALENCE(STHLMX,STHMXX(1))
      COMMON /CONSTA/PI,RAD,DEG,TWOPI,FOURPI,PIBY2,ALOG2,SQL2X8,VALMUB
      COMMON /DERVAR/DERIVV(500),LVARV
      COMMON /FCAL/FC,FCMOD,COSAL,SINAL,FCDERS(300),DERIVT(300)
      COMPLEX FC,DERIVT
      COMMON /FORMDA/NFORMF(150),MODE(20),NT(20),F(40,20),
     & S(40,20),CMULT(20),KCMULT(150),NBAKF(20),
     & NUMFNM,KOM7
      COMMON /MPODA/NMPAT,NMPOL,MPATAB(20),MPNMTB(150),
     & NCLUMP,KCLUMP(100),MPTAB(21),POLAMP(200,6),KPOLMP(200),
     & NCMAT,CONMAT(600,2)
      COMMON /MPODAC/MPNAM(200)
      CHARACTER *4 MPNAM
      COMMON /NSYM/NOP,NCENT,NOPC,NLAT,NGEN,CENTRC,KOM13
      LOGICAL CENTRC
      COMMON /POINTS/LVRBS(500),LVRPR(500),LBSVR(400),LRDVR(300)
      COMMON /POSNS/NATOM,X(3,150),KX(3,150),AMULT(150),
     & TF(150),KTF(150),SITE(150),KSITE(150),
     & ISGEN(3,150),SDX(3,150),SDTF(150),SDSITE(150),KOM17
      COMMON /PRBLEM/NFAM,NGENPS(6,9),NSPCPS(6,9),
     & LF1SP(5),LF3SP(10,9,5),LVFST1(6,9,5),
     & LBFST1(6,9,5),NVARF(6,9,5),
     & NBARF(6,9,5),LF6SP(3,5)
      DIMENSION NGENS(6),NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1)),(NSPC(1),NSPCPS(1,1))
      COMMON /SYMDA/SYM(3,3,24),TRANS(3,24),ALAT(3,4),
     & ORIGIN(3),KOM26
C
C CLEAR ANSWERS IN CASE ABSENT:
C
C  FC COLLECTS THE CONVENTIONAL STRUCTURE FACTOR, COMPLEX:
      FC=CMPLX(0.,0.)
C CLEAR MODULUS AND ANGLES:
      FCMOD=0.
      COSAL=0.
      SINAL=0.
C
C STHL HOLDS SIN THETA/LAMBDA:
      STHL=VCTMOD(0.5,H,2)
      SSQRD=STHL*STHL
C
      L2=NVARF(2,1,1)
      L25=L2+NVARF(5,1,1)
      LO=LVFST1(2,1,1)
      IF (LO .EQ. -1) LO=LVFST1(5,1,1)
      LO5=LO+L2
C CLEAR DERIVATIVES:
      IF (L25.GT.0) THEN
        CALL GMZER(FCDERS,1,L25)
        CALL CGMZER(DERIVT,1,L25)
      ENDIF
C
C OUT IF ABSENT:
      IF (LATABS(H)) GO TO 100
C
C CYCLE OVER INDEPENDENT ATOMS:
      DO 1 IR=1,NATOM
C
C  SET MP TO THE MULTIPOLE ATOM AND NMP1, NMP2 TO SCAN ITS MULTIPOLES:
      MP=MPNMTB(IR)
      IF (MP.EQ.0) THEN
        NMP1=0
        NMP2=-1
      ELSE
        NMP1=MPTAB(MP)
        NMP2=MPTAB(MP+1)-1
      ENDIF
C
      SUM1=CMPLX(0.,0.)
C  CALCULATE RADIAL FORM-FACTORS
      CALL PFORMF(H,MP,PSUM,PFACS,0)
C
C INNER LOOP OVER SYMMETRY EQUIVALENTS:
      DO 3 IS=1,NOPC
      CALL ROTSYM(H,RH,IS,-1)
C CALCULATE NON-SPHERICAL FORM FACTORS
      CALL PFORMF(RH,MP,PSUM,PFACS,1)
      F1=TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IS),H))
      ERS=ANITF(RH,IR)
C ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
      CRS=CEXP(CMPLX(0.,F1))*ERS
      TERM=CRS*PSUM
      ARS=REAL(TERM)
      BRS=AIMAG(TERM)
      SUM1=SUM1+TERM
C
C  NOW WE DO THE INNERMOST SUMS FOR THE DERIVATIVES OF MODFC WRT
C VARIABLES XYZ AND ALL BIJ.  WE USE THE
C COMPLEX VECTOR DERIVT FOR THE DERIVATIVES OF THE REAL & IMAGINARY PARTS
C OF THE COMPLEX FMC WRT EACH VARIABLE IN TURN.
C
      DO 7 I=1,3
      L=KX(I,IR)
      IF (L .NE. 0) DERIVT(L-LO)=RH(I)*CMPLX(-BRS,ARS) + DERIVT(L-LO)
   7  CONTINUE
C
C IF ANY ATF (NOT A LOOP, FOR SPEED):
      IA=IAPT(IR)
      IF (IA .NE. 0) THEN
        L=KATF(1,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(1)*TERM + DERIVT(L-LO)
        L=KATF(2,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(2)*RH(2)*TERM + DERIVT(L-LO)
        L=KATF(3,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(3)*RH(3)*TERM + DERIVT(L-LO)
        L=KATF(4,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(3)*RH(2)*TERM + DERIVT(L-LO)
        L=KATF(5,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(3)*TERM + DERIVT(L-LO)
        L=KATF(6,IA)
        IF (L.NE.0) DERIVT(L-LO)=RH(1)*RH(2)*TERM + DERIVT(L-LO)
      ENDIF
C
C DERIVATIVES OF FORM ("SCAT"):
      L=KCMULT(IR)
      IF (L.GT.0) DERIVT(L-LO)=CRS+DERIVT(L-LO)
C
C  DERIVATIVES OF MULTIPOLES:
      DO 21 I=NMP1,NMP2
      L=KPOLMP(I)
      IF (L.GT.0) DERIVT(L-LO5)=PFACS(I-NMP1+1)*CRS +DERIVT(L-LO5)
   21 CONTINUE
   3  CONTINUE
C END OF INNERMOST CYCLE OVER SYMMETRY
C
C IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
      IF (CENTRC) SUM1=SUM1+CONJG(SUM1)
      FAC=AMULT(IR)*EXP(-TF(IR)*SSQRD)
      HR=FAC*SITE(IR)
C HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS (BUT NOTE
C FORM ABSENT FROM USUAL EXPRESSION AS PSUM HAS BEEN MULTIPLIED IN EARLIER)
      FC=FC + HR*SUM1
C
C  NOW WE TIDY UP THE XYZ BIJ AND MP DERIVATIVES, ALLOWING FOR CENTRE:
      DO 8 I=1,3
      L=KX(I,IR)
      IF (L.GT.0) THEN
        DERIVT(L-LO)=TWOPI*HR*DERIVT(L-LO)
        IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
      ENDIF
      IF (IA .NE. 0) THEN
        L=KATF(I,IA)
        IF (L.GT.0) THEN
          DERIVT(L-LO)=-HR*DERIVT(L-LO)
          IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
        ENDIF
        L=KATF(I+3,IA)
        IF (L.GT.0) THEN
          DERIVT(L-LO)=-HR*2.*DERIVT(L-LO)
          IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
        ENDIF
      ENDIF
   8  CONTINUE
C
C FORM FACTOR (PARTLY FORMED WITHIN THE SYMMETRY LOOP):
      L=KCMULT(IR)
      IF (L.GT.0) THEN
        DERIVT(L-LO)=HR*DERIVT(L-LO)
        IF (CENTRC) DERIVT(L-LO)=DERIVT(L-LO)+CONJG(DERIVT(L-LO))
      ENDIF
C SITE OCCUPATION FACTOR:
      L=KSITE(IR)
      IF (L.GT.0) DERIVT(L-LO)=FAC*SUM1
C ISOTROPIC TEMPERATURE FACTOR:
      L=KTF(IR)
      IF (L.GT.0) DERIVT(L-LO)=-SSQRD*HR*SUM1
C MULTIPOLE PARAMETERS (PARTLY FORMED WITHIN THE SYMMETRY LOOP):
      DO 24 I=NMP1,NMP2
      L=KPOLMP(I)
      IF (L.GT.0) THEN
        DERIVT(L-LO5)=HR*DERIVT(L-LO5)
        IF (CENTRC) DERIVT(L-LO5)=DERIVT(L-LO5)+CONJG(DERIVT(L-LO5))
      ENDIF
  24  CONTINUE
   1  CONTINUE
C END OF CYCLE OVER ATOMIC POSITIONS
C
C  TIDY FCALC AND COLLECT TRUE D(MODFC)/D(VARIABLE)
      A = REAL(FC)
      B = AIMAG(FC)
      FCMOD = SQRT(A*A+B*B)
      IF (.NOT. TESTOV(A,FCMOD)) THEN
        COSAL=A/FCMOD
        SINAL=B/FCMOD
      ENDIF
      DO 6 I=1,L25
C NO SUMMING - THESE ARE THE ACTUAL DERIVATIVES NOT DIVIDED BY ANYTHING, AS
C THEY ARE SUBJECT TO THE CHAIN RULE NEXT, NOT LOGARITHMIC DIFFERENTIATION:
      FCDERS(I)=REAL(DERIVT(I))*COSAL + AIMAG(DERIVT(I))*SINAL
   6  CONTINUE
 100  RETURN
      END
C
C
C
C LEVEL 1      SUBROUTINE LATGEN(KI,K,KLIM,DONE,ISW,ISWO)
      SUBROUTINE LATGEN(KI,K,KLIM,DONE,ISW,ISWO)
C
C *** LATGEN by PJB 23 Apr 92 ***
C
CX
CC 1B
CH Generates points on a lattice.
CA On entry: KI(3) is the previous point generated
CA           KLIM(3,2) gives the limits over which points should be generated
CA           ISW is a switch indicating for which axes the a point on the upper
CA               limit is required. The point is required for the nth axis if t
CA               nth bit is set in ISW.
CA On exit: K  contains the next point generated.
CA          DONE is .TRUE. if there are no more points
CA          ISWO indicates whether the point generated is at any of the limits.
CA               The nth bit is set if the point is at the limit for the nth
CA               axis.
CN Use KLIM(1:3,1) for the first point, set KI(1:3)=KLIM(1:3,1) for the
CN first call to LATGEN, for subsequent calls set KI=K and continue until
CN DONE is .TRUE.
C
      DIMENSION KI(3),K(3),KLIM(3,2)
      LOGICAL DONE
C
      DONE=.FALSE.
      CALL JGMEQ(KI,K,3,1)
      IS=ISW
      ISWO=0
      J=1
C
      DO 1 I=1,3
      K(I)=K(I)+1
      IB=MOD(IS,2)
      IS=IS-IB
      IF (K(I).LT.KLIM(I,2)) THEN
        GO TO 100
      ELSE IF (IB.NE.0 .AND. K(I).EQ.KLIM(I,2)) THEN
        ISWO=ISWO+J
        GO TO 100
      ENDIF
      IF (I.EQ.3) DONE=.TRUE.
      K(I)=KLIM(I,1)
      IS=IS/2
      J=J*2
    1 CONTINUE
C
  100 RETURN
      END
C
C
C
C
C LEVEL 3      FUNCTION INPUAR(M,LUN)
      FUNCTION INPUAR(M,LUN)
C
C *** INPUAR corrected by PJB 22-June-95  ***
C
CX
CC 2C
CH Reads the data from files made by ARRNGE and other similar programs.
CA On entry M is 1 or 2 indicating the unit from which to read
CA          LUN is a 1x2 integer array holding the logical unit numbers
CA              of two data streams
CA On exit INPUAR indicates whether end of either file has been reached
CD The call reads one set of equivalent reflections into the COMMON /REFS/
CD from the file on UNIT number LUN(M)
C
      DIMENSION LUN(2)
      COMMON /REFS/K(3,2),JJ(48,2),LL(48,2),R(500,2),SCALE(2),INC,II,NR,
     &FF(3,2),ITEMS
      COMMON/VARFOR/RLINE1,RLINE2
      CHARACTER*24 RLINE2
      CHARACTER*16 RLINE1
C
      IEND=0
      IF (M.EQ.0) THEN
      MS=1
      ME=2
      ELSE
      MS=M
      ME=M
      ENDIF
      DO 1 IS=MS,ME
C COUNT HKLS WHICH FORM A RELATED GROUP:
      NR=1
      II=0
C
C READ IN EITHER 'I5' (F5.0) OR F8.3:
    2 READ (LUN(IS),RLINE1,END=4)(R(II+I,IS),I=1,3),JJ(NR,IS),L
      LL(NR,IS)=L
C IF ONLY 3 READ, THESE ARE THE DEFINITIVE INDICES FOR THE GROUP:
      IF (L.EQ.3) GO TO 3
C IF > 3, PAIRS OF X, DX FOR THIS PARTICULAR H,K,L:
      J=4
   42 READ (LUN(IS),RLINE2)(R(II+I,IS),I=J,J+ITEMS-1)
      J=J+ITEMS
      IF (J.LT.L) GO TO 42
C
C IF MERGING, SCALE - IF COMPARING, SCALE() SET TO 1.0
      DO 6 I=4,L,ITEMS
      R(II+I,IS)=SCALE(IS)*R(II+I,IS)
    6 R(II+I+1,IS)=SCALE(IS)*R(II+I+1,IS)
C
C  LEAVE ROOM FOR STORAGE OF MEANS
      II=II+L+2
      NR=NR+1
      GO TO 2
C
C END OF A GROUP OF EQUIVALENTS - COPY DEFINITIVE HKL BOTH FIXED & FLOATING
    3 CALL INDFIX(R(II+1,IS),K(1,IS))
      CALL GMEQ(R(II+1,IS),FF(1,IS),1,3)
      GO TO 1
C
C END OF DATA ON EITHER STREAM:
    4 IEND=IEND+IS
C
    1 CONTINUE
      INPUAR=IEND
      RETURN
      END
C
C
C
C
C LEVEL 8      SUBROUTINE INPLSF
       SUBROUTINE INPLSF
C
C *** INPLSF updated by JCM 12 Nov 87 ***
C
CX
CC 7A
CH Reads in (nearly) all L cards for the particular LSQ type 'SF', for
CH single crystal work.
C
CD Is not concerned with L FIX, LRELA, L VARY, L SLAK, L ATOM, L BOND
CD cards, so ignores them.
CD
CD Otherwise, records information off the following L cards:
CD    TFAC   An overall temperature factor
CD    SCAL   Scale factors, one per zone
CD    REFI   Function 'on which to refine'
CD    MODE   Mode of presentation of input reflection data
CD    WGHT   Weighting scheme.
C
CI Reads all L cards.
CO Writes its findings to unit LPT.
C
CN For Profile LSQ the equivalent routine is INPLPR.
C
C%
C      CHARACTER *4 LWD,LTABLE(%LCRD%)
      CHARACTER *4 LWD,LTABLE(22)
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /LREAD/ILREA(22,5),KOM18
      DIMENSION ILREAD(22)
      EQUIVALENCE (ILREAD(1),ILREA(1,1))
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCLDAT/ISCALE,NSCALE,SCALE(20),KSCALE(20),
     & NSCL,LSCD(10)
      COMMON /SLAKDA/NSLAK(4),SLKSWD(4),SLAKWT(4),
     & CHISQD(4),ISLKTP,NSKTOT,KOM24
      COMMON /SLKGEO/NSTYP,BOBS(500),EOBS(500),IATM(500,2),
     & ISYM(500),ILAT(500),CELLTR(3,500),XSLAK(3,500),
     & COSIN(3,3),IABASE(500),NST1,SLONLY,TOSTAR(6,6),BCALC(500),
     & DERCEL(6,500),DERPOS(3,500,2),ITYPSK(500),INVBON(10,
     & 500),NINVB(500),INANG(100,3),INTOR(100,6),
     & DERBON(10),NVB(10),NUMBON,NTARNM,NUMANG,NUMTOR,KOM25
      LOGICAL SLONLY
      DATA LTABLE/'TFAC','SCAL','REFI','MODE','WGHT',' ',' ',
     & ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
     & ' '/
C
C SET 'NO L CARDS READ':
C%
C      CALL JGMZER(ILREAD,1,%LCRD%)
      CALL JGMZER(ILREAD,1,22)
C
C INITIALISE COUNTS OF ITEMS WHICH MAY COME ON MORE THAN 1 CARD:
      NSCALE=0
      NSLAK(1)=0
      NUMBON=0
      NSKTOT=0
C%
C        CALL JGMZER(NSLAK,1,%SKTP%)
        CALL JGMZER(NSLAK,1,4)
C
C READ ALL 'L' CARDS:
      INREAD(12)=-IABS(INREAD(12))
      ID=IABS(INREAD(12))
      NCARD=ICDNO(12)
      IF (NCARD .LE. 0) THEN
        CALL MESS(LPT,1,'No "L" cards given')
        GO TO 100
      ENDIF
C
      DO 3 ICD=1,NCARD
      CALL CARDIN(ID)
      ID=ID+NYZ
      CALL RDWORD(LWD,LEN,3,IPT,80,0,IER)
  42  L=NCFIND(LWD,LTABLE,5)
C IGNORE L CARD IF NOT ONE OF THE 5 WE WANT:
      IF (L .LE. 0) GO TO 3
C
      ILREAD(L)=ILREAD(L)+1
      GO TO (11,12,13,14,15) , L
C
C L TFAC:
C SHORTLY TO BE ABLE TO READ SEVERAL TFACS
  11  CALL LLTFAC(1)
      GO TO 3
C
C L SCAL - MAY BE SEVERAL:
  12  CALL LLSCAL(1)
      GO TO 3
C
C L REFI:
  13  CALL RDINTG(IREF,IPT,IPT,80,IER)
      IF (IREF .GT. 5) GO TO 6
      GO TO (21,22,6,24,25) ,IREF
   6  CALL ERRIN2(IREF,2,'Refining mode','not allowed')
      GO TO 43
  21  CALL MESS(LPT,1,'Refining on mod(Fc)')
      GO TO 43
  22  CALL MESS(LPT,1,'Refining on Fc squared')
      GO TO 43
  24  CALL MESS(LPT,1,'Refining on signed Fc')
      GO TO 43
C
  25  CALL MESS(LPT,1,'Refining on polarised neutron Flipping Ratios')
      GO TO 43
C
C L MODE:
  14  CALL RDINTG(MODER,IPT,IPT,80,IER)
      IF (MODER .GT. 8) GO TO 7
      GO TO (31,32,33,34,35,36,33,35) , MODER
   7  CALL ERRIN2(MODER,2,'Reflection input format type',
     & 'not allowed')
      GO TO 43
C
C
  31  CALL MESS(LPT,1,'Data input as h,k,l, Gobs, (Scale), (Code)')
      GO TO 43
C
  32  CALL MESS(LPT,1,'Data input as h,k,l Gobs, Weight, '//
     & '(Scale), (Code)')
      GO TO 43
C
  33  CALL MESS(LPT,1,'Data input as h,k,l Gobs, Sigma, '//
     & '(Scale), (Code)')
      IF (MODER .EQ. 7) CALL MESS(LPT,0,'h,k,l floating')
      GO TO 43
C
  34  CALL MESS(LPT,1,'Data input as h,k,l Gcalc, Gobs, Sigma '//
     & '- output from MEANGM')
      GO TO 43
C
  35  CALL MESS(LPT,1,'Data input as h,k,l,Gobs,Sigma,4 coeffs,(Scale)')
      IF (MODER .EQ. 8) CALL MESS(LPT,0,'h,k,l floating')
      GO TO 43
C
  36  CALL MESS(LPT,1,'Data input as h,k,l A, B, Gobs, '//
     & 'Sigma (Scale), (Code) - ignoring A,B')
      GO TO 43
C
C L WGHT:
  15  CALL RDINTG(IWGHT,IPT,IPT,80,IER)
      GO TO (41,40) , IWGHT
C
      WRITE (LPT,3002) IWGHT
      WRITE (ITO,3002) IWGHT
3002  FORMAT (/' ** WARNING * WEIGHTING SCHEME',I4,
     & ' NOT ALLOWED IN SFLSQ - TYPE 2 SUBSTITUTED')
      IWGHT=2
      GO TO 40
C
  41  CALL MESS(LPT,1,'Unit weights')
      GO TO 43
C
  40  CALL MESS(LPT,1,'Weights to be read with reflection data')
      GO TO 43
C
C AFTER READING <WORD> <NUMBER> PAIR:
  43  CALL RDWORD(LWD,LEN,IPT,IPT,80,0,IER)
      IF (IER .EQ. 100) GO TO 3
      GO TO 42
   3  CONTINUE
C
 100  RETURN
      END
C
C
C
C LEVEL 5      SUBROUTINE INOBGR(ISCR)
      SUBROUTINE INOBGR(ISCR)
C
C *** INOBGR by JCM 15 Feb 85 ***
C
CX
CC 7A
CH Performs a preliminary pass of observations for GRLSQ,
CH (group refinement, integrated intensity LSQ).
CA On entry ISCR is the number of a unit set up as a scratch file.
CD Accepts user's input on unit LUNI, collects together groups of h,k,l and
CD counts them, forms multiplicity and D, and sends out this information
CD on unit ISCR ready for repeated reinput to the cycling LSQ.
CD
CD Expects each observation to be preceded by sets of relevant h,k,l.  Reads
CD until an OBS containing a decimal point, then takes remainder of that line
CD to be the observation, allowing various "MODER" formats, as in SFLSQ.
C
      DIMENSION K(3,100),H(3),H1(3)
      DIMENSION CEXT(4)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /REFINE/IREF,NCYC,NCYC1,LASTCY,ICYC,MODERR(5),
     & MODEOB(5),IPRNT(20),MAXCOR,IONLY(9),SIMUL,MAG,MPL,
     & FIXED,DONE,CONV
      LOGICAL SIMUL,MAG,MPL,FIXED,DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCRACH/MESSAG,NAMFIL
      CHARACTER *80 ICARD,MESSAG*100,NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
C
C OPEN UNIT LUNI TO READ USER'S REFLECTION DATA:
      MESSAG='Reflection data'
      CALL OPNFIL(LUNI,11)
C
C OPEN SCRATCH UNIT ON WHICH TO HAND OVER PREPROCESSED REFLECTION DATA:
      ISCR=NOPFIL(1005)
C IP COUNTS SETS OF INDICES FOR THIS ONE OBSERVATION:
   5  IP=0
C IPT MOVES ALONG ONE CARD:
   2  IPT=1
      READ(LUNI,1000,END=100) ICARD
1000  FORMAT (A80)
   6  IPKEEP=IPT
      CALL RDINTG(K(1,IP+1),IPT,IPT,80,IER)
C IS IT CARD END?
      IF (IER .EQ. 100) GO TO 2
C WAS IT ACTUALLY OBS?
      IF (IER .NE. 0) GO TO 4
C
C READ K AND L:
C%
C   3  CALL ERRCHK(2,IP,100,0,'sets of indices')
   3  CALL ERRCHK(2,IP,100,0,'sets of indices')
      CALL RDINTG(K(2,IP),IPT,IPT,80,IER)
      CALL RDINTG(K(3,IP),IPT,IPT,80,IER)
C NEXT SET OF INDICES:
      GO TO 6
C
   4  IPT=IPKEEP
      ISCALE=0
      ICODE=1
      IF (MODER.EQ.4 .OR. MODER.EQ.6) CALL RDREAL(GCAL,IPT,IPT,80,IER)
      IF (MODER.EQ.6) CALL RDREAL(BCAL,IPT,IPT,80,IER)
      CALL RDREAL(OBS,IPT,IPT,80,IER)
      IF (MODER .NE. 1) CALL RDREAL(DOBS,IPT,IPT,80,IER)
      IF (MODER .NE. 5) GO TO 9
      DO 8 I=1,4
   8  CALL RDREAL(CEXT(I),IPT,IPT,80,IER)
      GO TO 10
   9  CALL RDINTG(ISCALE,IPT,IPT,80,IER)
      CALL RDINTG(ICODE,IPT,IPT,80,IER)
  10  IF (ISCALE .EQ. 0) ISCALE=1
      IF (ICODE .EQ. 0) ICODE=1
      WRITE (ISCR) IP,OBS,DOBS,ISCALE,ICODE
      IF (MODER .EQ. 5) WRITE (ISCR) CEXT
      DO 7 I=1,IP
      CALL INDFLO(H,K(1,I))
C DISCOVER MULTIPLICITY, ALLOWING FOR REFLECTION NOT BEING IN DEFINED UNIT:
      CALL ASUNIT(H,H1,N,M)
      S=VCTMOD(1.,H,2)
      D4=1./(S*S*S*S)
      FMD=FLOAT(M)*D4
   7  WRITE (ISCR) (K(J,I),J=1,3),FMD
C NEXT OBSERVATION - BACK TO RESTART COUNT OF INDICES:
      GO TO 5
C
 100  RETURN
      END
C
C
C
C
C LEVEL 2      SUBROUTINE INCREM(IFNS,IFNL)
      SUBROUTINE INCREM(IFNS,IFNL)
C
C *** INCREM updated for UNIX PJB 15-Nov-1994 ***
C
CX
CC 13C
CH Increments a file name.
CA On entry IFNS is an A10 short file name
CA          IFNL is an A60 full file name expected to contain IFNS
CA On exit  both file names have been incremented;  that is, the character
CA          before the . has been advanced by 1, counting 1-9, A-Z
C
      CHARACTER*10 IFNS
      CHARACTER*60 IFNL
      CHARACTER*1 CH(6)
      COMMON /GLOBAL/NINIT,NBATCH,NSYSTM,MULFAS,MULSOU,MULONE
      LOGICAL MULFAS,MULSOU,MULONE
C
      DATA CH/'9','A','Z','0','z','0'/
C
C CHOOSE UPPER OR LOWER CASE LETTERS ACCORDING TO SYSTEM
      CALL UPONE(CH(2),NSYSTM)
C  POSITION SHORT NAME IN LONG NAME
C
      NP=INDEX(IFNL,IFNS)
      IF (NP.EQ.0) GO TO 100
C
C  CHECK FOR EXTN
      L=INDEX(IFNS,'.')-1
      IF (L.LE.0) L=LENG(IFNS,10)
C
      DO 1 I=L,1,-1
      DO 2 J=1,5,2
      IF (IFNS(I:I).NE.CH(J)) GO TO 2
      IFNS(I:I)=CH(J+1)
      IF (J.GE.2) GO TO 1
      GO TO 3
    2 CONTINUE
      IFNS(I:I)=CHAR(ICHAR(IFNS(I:I))+1)
      GO TO 3
    1 CONTINUE
    3 IFNL(NP:NP+L)=IFNS
  100 RETURN
      END
C
C
C
C
C LEVEL 4      SUBROUTINE INCELL(X,P)
      SUBROUTINE INCELL(X,P)
C
C *** INCELL by PJB/JCM 10 Apr 87 ***
C
CX
CC 8B
CH Sets P to be the position in the central cell equivalent to X.
CA On entry X is a 1x3 array which holds fractional coordinates of a point in
CA            a unit cell (not necessarily in the "central" cell)
CA On exit  P is a 1x3 array which holds the fractional coordinates of an
CA            equivalent point all in range 0=<  x < 1
C
      DIMENSION X(3),P(3)
C
      CALL GMEQ(X,P,1,3)
      CALL FRAC3(P)
      RETURN
      END
C
C
C
C
C LEVEL 6      SUBROUTINE IICD3
      SUBROUTINE IICD3
C
C *** IICD3 updated by PJB 23-June-1995 ***
C
CX
CC 2A
CH Interprets I cards for ARRNGE-type MAIN programs, and sets them up.
C
CD Sets up the array IFOR in /ARRDAT/ to hold input switches
CD as may be read from I card:
CD    IFOR(1) gives the input format; see ARREAD for the various
CD            possibilities.
CD
CD    IFOR(2) is -ve for 'do not print unique reflections', +ve for 'print
CD             all reflections'.  This does not affect the filed output.
CD
CD    IFOR(3) is 0 for 'do not output record numbers to file' or 1 for
CD            'output record numbers both to file and printer'.
CD
CD    IFOR(4) gives the weighting scheme requested:
CD        IFOR(4) = 0 - unit weights for individual measurements, and
CD                  mean of equivalents weighted according to their
CD                  esds.
CD        IFOR(4) = 1 - statistical weights used for the means of individual
CD                   measurements, and esds used in weighting for mean of
CD                   equivalents.
CD        IFOR(4) = 2 - unit weights throughout.
CD
CD        IFOR(5) = whether or not a rejection list is to be given, 0 or 1.
CD
CD        IFOR(6) >= 1 if angles are to be read and stored
C
CI Reads an I card if necessary.
C
CO Writes its findings on unit LPT.
C
      CHARACTER *4 INEED(6)
      LOGICAL ONCARD
      COMMON /ARRDAT/IFOR(6),INC,LINO,NREF,INLBUF,NBUF,IBUF,INFBUF,
     & INDLEN,NUMVAL,IPOS,ISTORE,ICHNGE,NEW,LPRINT,ICD,IS,NREF1,NREFL
      LOGICAL INC,NEW,LPRINT
      COMMON /CARDRC/ICRYDA,NTOTAL(9),NYZ,NTOTL,INREA(26,9),
     & ICDN(26,9),IERR,IO10,SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26),ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      DATA INEED/'DTYP','PRIN','RNUM','WGHT','REJ','ANGL'/
C
  20  DO 21 I=1,6
      IF (ONCARD('I',INEED(I),A)) GO TO 23
C
C WORD NOT PRESENT - BRANCH FOR DEFAULTS:
      GO TO (41,42,43,44,45,46) , I
C
C NO DTYP:
  41  CALL ERRMES(2,1,'DTYP on I card')
      GO TO 21
C
C DEFAULT NO PRIN:
  42  IFOR(2)=1
      GO TO 52
C
C DEFAULT NO RNUM:
  43  IFOR(3)=0
      GO TO 53
C
C DEFAULT NO WGHT:
  44  IFOR(4)=0
      GO TO 54
C
C DEFAULT NO REJ:
  45  IFOR(5)=0
      GO TO 55
C
C DEFAULT DONT STORE ANGLES
  46  IFOR(6)=0
      GO TO 21
C
C WORD RECOGNISED:
  23  GO TO (31,32,33,34,35,36) , I
C
C DTYP:
C IFOR(1) - INPUT FORMAT
  31  IFOR(1)=NINT(A)
      GO TO 21
C
C PRIN:
C IFOR(2) - CONTROL OF OUTPUT FORMAT
  32  IFOR(2)=NINT(A)
      IF (IFOR(2) .EQ. 0) IFOR(2)=-1
      IF (IFOR(2) .LT. 0) CALL MESS(LPT,1,
     & 'Unique reflections omitted from printed output')
  52  IF (IFOR(2) .GT. 0) CALL MESS(LPT,1,'All reflections printed')
      GO TO 21
C
C RNUM:
C IFOR(3) -     RECORD NUMBERS
  33  IFOR(3) = NINT(A)
  53  IF (IFOR(3) .EQ. 0) CALL MESS(LPT,1,
     & 'Record numbers as read written to printer only')
      IF (IFOR(3) .EQ. 1) CALL MESS(LPT,1,
     & 'Record numbers as read writen to printer and file')
      GO TO 21
C
C WGHT:
C IFOR(4) = 0,1 OR 2 FOR WEIGHTING REQUIRED
  34  IFOR(4)=NINT(A)
  54  IF (IFOR(4) .EQ. 0) THEN
        CALL MESS(LPT,1,'Unit weights for individual measurements')
        CALL MESS(LPT,0,
     & 'Mean of equivalents weighted according to their ESDs')
      ELSE IF (IFOR(4) .EQ. 1) THEN
        CALL MESS(LPT,1,'Statistical weights used for '//
     &  'the means of individual measurements')
        CALL MESS(LPT,0,'ESDs used in weighting for mean of'//
     &  ' equivalents')
      ELSE IF (IFOR(4) .EQ. 2) THEN
        CALL MESS(LPT,1,'Unit weights')
      ENDIF
      GO TO 21
C
C REJ:
C IFOR(5) HOLDS WHETHER OR NOT REJECTIONS ARE ON FILE ITEM7:
  35  IFOR(5)=NINT(A)
  55  IF (IFOR(5) .EQ. 0) CALL MESS(LPT,1,
     & 'No reflections to be rejected')
C IF THERE IS A FILE ITEM7, WAIT TILL IT IS NAMED TO SAY SO:
      GO TO 21
C
C ANGL:
  36  IFOR(6)=NINT(A)
      IF (IFOR(6) .EQ. 0) GO TO 21
C
      WRITE (LPT,2061)
2061  FORMAT (' Diffractometer angles to be read and stored ')
      GO TO 21
C
  21  CONTINUE
C
C
      RETURN
      END
C
C
C
C LEVEL 6      SUBROUTINE ICDFMT(INC,ITEMS)
      SUBROUTINE ICDFMT(INC,ITEMS)
C
C *** ICDFMT modified by PJB 24-Apr-1995 ***
C
CX
CC 2A
CH Interprets I and Q PROP cards for programs reading ARRNGE type data".
CA Returns ICD=0 for integer and 1 for non-integer indices,
CA and the number of items stored per reflection  in ITEMS.
C
      DIMENSION APROP(3)
      CHARACTER*12 ALTLIN
      CHARACTER *4 INEED(3)
      LOGICAL ONCARD
      EXTERNAL VARFMT
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /SATELL/PROP(3),KPROP(3),KSTAB(24),NKSTAR,IPROP,FKSTAR,
     & NKC,KCENT,INCOM,KOM21
      LOGICAL INCOM
      COMMON/VARFOR/RLINE1,RLINE2
      CHARACTER*24 RLINE2
      CHARACTER*16 RLINE1
C
      DATA ALTLIN/'(5X,6F10.5)'/
      DATA INEED/'RNUM','DTYP','ANGL'/
C
      DO 1 J=1,3
      IF (ONCARD('I',INEED(J),A)) GO TO 3
C
C  WORD NOT PRESENT
      GO TO (4,6,20) ,J
C
    3 IICD=NINT(A)
      GO TO (5,8,21),J
C  NO RECORD NUMBERS WRITTEN
    4 RLINE2=' '
      RLINE2(1:12)=ALTLIN
      CALL MESS(LPT,1,'No record numbers on input file')
      GO TO 1
C
    5 IF (IICD.LT.2) GO TO 4
      CALL MESS(LPT,1,'Record numbers skipped on input file')
      GO TO 1
C
    8 NDTYP=IICD
      IF (IICD.EQ.5) THEN
        ITEMS=4
        RLINE2(5:5)='4'
        WRITE (LPT,2001) IICD
 2001 FORMAT (' DTYP =',I3,' SXD:'/' records contain Fsqrsd, DFsqrd,',
     & 'wavelength and pathlength'/)
      ENDIF
      GO TO 1
C
C ARE ANGLES RECORDED
   20 IF (NDTYP.NE.5) THEN
        WRITE (LPT,2000) NDTYP
 2000 FORMAT (' DTYP =',I3,' records contain Fsqrsd and DFsqrd only'/)
        ITEMS=2
        GO TO 1
      ENDIF
  21  IF (IICD.EQ.0) GO TO 20
      IF (NDTYP.NE.5) THEN
        WRITE (LPT,2002) NDTYP
 2002 FORMAT (' DTYP =',I3,' records contain Fsqrsd, DFsqrd,',
     &'2theta omega chi and phi'/)
        RLINE2(5:5)='6'
        ITEMS=6
      ELSE IF (NDTYP.EQ.1) THEN
        WRITE (LPT,2004) NDTYP
 2004 FORMAT (' DTYP =',I3,' records contain Fsqrsd, DFsqrd,',
     &'2theta omega and nu'/)
        RLINE2(5:5)='5'
        ITEMS=5
      ENDIF
    1 CONTINUE
C
C  COMMENSURATE OR INCOMMENSURATE?
    7 CALL FINDCD('Q','PROP',4,0,LCD)
      IF (LCD .LE.0) GO TO 6
      CALL RDNUMS(APROP,7,3,N,IER)
      IF (N.EQ.3) THEN
        CALL PROPER(APROP)
        IF (IPROP.GT.0) GO TO 9
      ENDIF
    6 CALL MESS(LPT,1,'Propagation vector not given or integer:'//
     & 'expect integer indices')
      INC=0
      GO TO 10
    9 WRITE (LPT,2003) PROP
2003  FORMAT (/'Propagation vector',3F8.3/' Expect floating '//
     & '(incommensurate) indices'/)
      INC=1
      RLINE1(7:9)='8.3'
C
   10 RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE GETSQ(A,T,X,I,J,MM,NN)
      SUBROUTINE GETSQ(A,T,X,I,J,MM,NN)
C
C *** GETSQ by JCM 24 Nov 83 ***
C
CX
CC 15C
CH Works out where a contour crosses the sides of a square of function
CH values.
CA On entry array A holds the rectangular array of function values.
CA    MM,NN are the dimensions of A.
CA    I,J specify the point under consideration.
CA On exit array T has been set up to indicate where in the square
CA the  contour will go.
C
      DIMENSION A(MM,NN),T(6)
C
      T(1) = A(I,J) - X
      T(2) = A(I,J+1) - X
      T(3) = A(I+1,J+1) - X
      T(4) = A(I+1,J) - X
      T(5) = T(1)
      BIG = T(1)
      SMALL = T(1)
      SUM = T(1)
      DO 1 K=2,4
      IF (T(K) .GT. BIG)  BIG=T(K)
      IF (T(K) .LT. SMALL)  SMALL = T(K)
   1  SUM = SUM + T(K)
      T(6) = (SUM - BIG - SMALL)*0.5
      RETURN
      END
C
C
C
C
C LEVEL 1      SUBROUTINE QLSQIN(K,IEND)
      SUBROUTINE QLSQIN(K,IEND)
C
C *** QLSQIN DUMMY by JCM 17 Nov 84 ***
C
CX
CC 6B
CH In the library, simply a dummy routine.  If the user wishes some special
CH new input format for Least Squares routines, he provides a new version
CH QLSQIN.
C
CD Called if data input type 0 is specified.  The user's routine must set:
CD   K(1:3) = h,k,l
CD   LOGICAL IEND = TRUE if there are no more data,
CD  and in /OBSCAL/, OBS=the observation, DOBS=its esd.
C
      LOGICAL IEND
      DIMENSION K(3)
      COMMON /IOUNIT/LPT,ITI,ITO,IPLO,LUNI,IOUT
      COMMON /OBSCAL/OBS,DOBS,GCALC,YCALC,DIFF,ICODE,SUMWD,NOBS,
     & IWGH(5),WTC(4),WT,SQRTWT,WDIFF,YBACK,YPEAK,YMAX,CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
C
      RETURN
      END
C
C
C
C LEVEL 1      SUBROUTINE QARRIN(N,K,F,DF,IEND)
      SUBROUTINE QARRIN(N,K,F,DF,IEND)
C
C *** QARRIN DUMMY by JCM 17 Oct 85 ***
C
CX
CC 2B
CH In the library, simply a dummy routine.  If the user wishes some special
CH new input format for "ARRNGE" type main programs, he provides a new
CH version of QUARRIN.
CA A replacement routine should set:
CA N=serial number of next reflection
CA K= h,k,l for next reflection
CA F=observation
CA DF=standard deviation
CA IEND is a logical, set TRUE if there are no more reflections.
C
CD In ARRNGE and similar main programs, if in /ARRDAT/ IFOR(1)=0, it is
CD expected that the user has included his own version of QUARRIN.
C
      LOGICAL IEND
      RETURN
      END
C
C
!*==REJECT.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE REJECT(N,NEXT,LREJ,USE)
      SUBROUTINE REJECT(N,NEXT,LREJ,USE)
!
! *** REJECT corrected by PJB 22-June-95 ***
!
!X
!C 11C
!H Decides for ARRNGE-type main programs whether the record number of
!H a reflection occurs in a list of those to be rejected.
!A On entry N is normally the number of the reflection to be tested.
!A            but if negative indicates the setting up entry which
!A            opens the rejection list and reads the first entry.
!A          NEXT should initially be set to zero;  it should then be
!A               preserved between entries.
!A          LREJ is the number of the unit from which to read rejection
!A               numbers.
!
!A On exit LOGICAL USE is TRUE if reflection number N is to be used.
!
!D Reads one integer at a time from unit LREJ.  Takes a -ve integer
!D to imply "all the numbers between the previous number and this one".
!
!N N must be monotonic increasing.
!
      LOGICAL USE
      COMMON /ARRDAT/ IFOR(6), INC, LINO, NREF, INLBUF, NBUF, IBUF,     &
     &                INFBUF, INDLEN, NUMVAL, IPOS, ISTORE, ICHNGE, NEW,&
     &                LPRINT, ICD, IS, NREF1, NREFL
      LOGICAL INC, NEW, LPRINT
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      EQUIVALENCE (ICARD(1:1),MESSAG)
!
      IF (N.GE.0) GOTO 1
!
      MESSAG = 'File containing rejection list?'
      NAMFIL = '.REJ'
      LREJ = NOPFIL(111)
   31 READ (LREJ,1000,END=30) ICARD
      CALL RDINTG(NEXT,1,IPT,80,IER)
      IF (IER.NE.0) GOTO 31
      IF (NEXT.GE.0) GOTO 100
      WRITE (LPT,2000) NEXT
 2000 FORMAT (/' No rejections - ',I6,' read')
   30 NEXT = 99999999
      GOTO 100
!
    1 IF (N.LT.NEXT) GOTO 101
!
      USE = .FALSE.
      IF (N.LE.-NEXT) GOTO 100
!
! NEED NEXT NUMBER FROM LIST
      LAST = NEXT
      READ (LREJ,1000,END=2) ICARD
      CALL RDINTG(NEXT,1,IPT,80,IER)
      IF (IER.NE.0) GOTO 31
!
! CHECK CORRECT SEQUENCE
      IF ((LAST.LT.0.AND.NEXT+LAST.GT.0) .OR. IABS(NEXT).GT.LAST)       &
     &    GOTO 100
      WRITE (LPT,3000) LAST, NEXT
 3000 FORMAT (/' ERROR ** in sequence of rejection list',2I10)
!>>JCC HAndle through extra function
! Was      STOP
! Now
      CALL BMBOUT
      RETURN
!
!
! AT END, SET NO MORE REJECTIONS
    2 NEXT = 99999999
      GOTO 100
  101 USE = .TRUE.
  100 RETURN
 1000 FORMAT (A80)
      END SUBROUTINE REJECT

!*==SETABS.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
!
! LEVEL 12      SUBROUTINE SETABS
      SUBROUTINE SETABS
!
! *** SETABS by JCM 4 Oct 85 ***
!
!X
!C 2A
!H Sets up data for the calculation of absorption (or related) integrals.
!D Calls SETDC and SETG to set up the COMMON blocks /DGEOM/ and /GAUSS/
!D Checks that all necessary quantities have been given and are acceptable.
!D Checks that at least 3 plane faces have been given on G FACE cards.
!D Checks that D L/R card has been given.
!D If no G MODE card has been given, assumes mode 1, simple absorption
!D correction.
!D If no G PNTS card has been given assumes 5 x 5 x 5
!D  If no G MU card has been given assumes that mu will be set by a
!D main program
!P RECIP must have read in the cell parameters.
!I Causes D and "G" cards to be read from the copy of the Crystal Data
!I File on unit IO10.
!O Writes its findings to unit LPT.
!
      COMMON /ABSDAT/ AMU, MODEA
      COMMON /CPLANE/ AA(15), BB(15), CC(15), DD(15), NP
      COMMON /DREAD / IDREAD(8)
      COMMON /GAUSS / XX(1000), YY(1000), ZZ(1000), WW(1000), NL, NM,   &
     &                NN, NQ
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /GREAD / IGREAD(4)
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
!
      CALL MESS(LPT,2,                                                  &
     &          'Absorption Corrections using Gaussian integration')
      IF (INREAD(4).GT.0) CALL SETDC
      IF (INREAD(7).GT.0) CALL INPUTG
!
! NOW CHECK SPECIFIC ITEMS NEEDED FOR ABSORPTION TYPE INTEGRALS:
      IF (NP.LE.2) THEN
        CALL ERRMES(2,1,'equations of plane faces')
        GOTO 100
      ENDIF
!
      IF (IGREAD(2).LE.0) THEN
        NL = 5
        NM = 5
        NN = 5
        CALL MESS(LPT,1,'No G PNTS card read - assuming 5 x 5 x 5')
      ENDIF
!
      IF (IGREAD(3).LE.0) CALL MESS(LPT,1,'No G MU card read - '//      &
     &                       'assuming AMU put in place by MAIN program'&
     &                       )
!
      IF (IGREAD(4).LE.0) THEN
        MODEA = 1
        CALL MESS(LPT,1,'No G MODE card read - assuming 1')
      ENDIF
!
      IF (IDREAD(3).LE.0) THEN
        CALL ERRMES(2,1,'D L/R card for abs cor')
        GOTO 100
      ENDIF
!
      CALL SETGAU
  100 RETURN
      END SUBROUTINE SETABS
!*==SETGAU.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 5      SUBROUTINE SETGAU
      SUBROUTINE SETGAU
!
! *** SETGAU BY JCM ***
!
!X
!C 2A
!H Sets up the COMMON /GAUSS/ for Gaussian integration (for use in
!H absorption correction type integrals).
!P NL,NM,NN in /GAUSS/ should be the required number of Gauss points
!P        to scan the given crystal in the 3 directions x,y,z.
!P INPUTG should have read all the "G" cards.
!
!D Sets up a 3D mesh of Gauss points and weights covering the given
!D crystal whose faces are described in /CPLANE/.  In /GAUSS/
!D the arrays XX, YY, ZZ hold the x,y and z coordinates of the points
!D referred to the standard crystallographic axes, and the array WW
!D holds the weights.
!O Writes the crystal volume so found to unit LPT.
!
!N SETGAU may be called several times in one job, to enable comparison
!N between integrations using different numbers of points.
!
      LOGICAL TESTOV
      COMMON /CPLANE/ AA(15), BB(15), CC(15), DD(15), NP
      COMMON /GAUSS / XX(1000), YY(1000), ZZ(1000), WW(1000), NL, NM,   &
     &                NN, NQ
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /SCRAT / GPT(150), GWT(150)
!
!
      IF (INREAD(7).GT.0) CALL INPUTG
      NQ = NL*NM*NN
      CALL ERRCHK(1,NQ,1000,0,'Gauss points, product of all 3')
      U = 0.
      V = 0.
      DO IR = 1, NP
        DO IS = 1, NP
          D = BB(IR)*CC(IS) - CC(IR)*BB(IS)
          DO IT = 1, NP
            E = BB(IS)*CC(IT) - CC(IS)*BB(IT)
            F = BB(IT)*CC(IR) - CC(IT)*BB(IR)
            A = DD(IR)*E + DD(IS)*F + DD(IT)*D
            B = AA(IR)*E + AA(IS)*F + AA(IT)*D
            IF (TESTOV(A,B)) GOTO 11
            X = A/B
            A = (DD(IS)-AA(IS)*X)*CC(IT) - (DD(IT)-AA(IT)*X)*CC(IS)
            IF (TESTOV(A,E)) GOTO 11
            Y = A/E
            A = DD(IT) - AA(IT)*X - BB(IT)*Y
            IF (TESTOV(A,CC(IT))) GOTO 11
            Z = A/CC(IT)
            DO I = 1, NP
              IF (AA(I)*X+BB(I)*Y+CC(I)*Z-DD(I).GT.0.0001) GOTO 11
            ENDDO
            IF (U.LT.X) U = X
            IF (X.LT.V) V = X
   11     ENDDO
        ENDDO
      ENDDO
      U = U - V
      IO = 1
!
! SET UP ENTIRE RANGES OF GAUSS POINTS AND WEIGHTS IN /SCRAT/:
      ITEM1 = 1
      ITEM2 = NL
      CALL GAUSPT(NL,GPT(ITEM1),GWT(ITEM1))
      DO IR = ITEM1, ITEM2
        X = V + U*GPT(IR)
        E = 6000.
        D = -6000.
        DO IS = 1, NP
          DO IT = 1, NP
            A = (DD(IS)-AA(IS)*X)*CC(IT) - (DD(IT)-AA(IT)*X)*CC(IS)
            B = BB(IS)*CC(IT) - CC(IS)*BB(IT)
            IF (TESTOV(A,B)) GOTO 17
            Y = A/B
            A = DD(IT) - AA(IT)*X - BB(IT)*Y
            IF (TESTOV(A,CC(IT))) GOTO 17
            Z = A/CC(IT)
            DO IQ = 1, NP
              IF (AA(IQ)*X+BB(IQ)*Y+CC(IQ)*Z-DD(IQ).GT.0.0001) GOTO 17
            ENDDO
            IF (D.LT.Y) D = Y
            IF (Y.LT.E) E = Y
   17     ENDDO
        ENDDO
        D = D - E
!
! SET UP GAUSS POINTS AND WEIGHTS FOR SECOND INTEGRATION DIRECTION (UNLESS SAME
! AS FIRST):
        ITEM3 = ITEM1
        ITEM4 = ITEM2
        IF (NM.EQ.NL) GOTO 1
        ITEM3 = ITEM2 + 1
        ITEM4 = ITEM3 + NM - 1
        CALL GAUSPT(NM,GPT(ITEM3),GWT(ITEM3))
    1   DO IS = ITEM3, ITEM4
          Y = E + D*GPT(IS)
          G = 6000.
          F = -6000.
          DO IT = 1, NP
            A = DD(IT) - AA(IT)*X - BB(IT)*Y
            IF (TESTOV(A,CC(IT))) GOTO 23
            Z = A/CC(IT)
            DO IQ = 1, NP
              IF (AA(IQ)*X+BB(IQ)*Y+CC(IQ)*Z-DD(IQ).GE.0.0001) GOTO 23
            ENDDO
            IF (F.LT.Z) F = Z
            IF (Z.LT.G) G = Z
   23     ENDDO
          F = F - G
          ITEM5 = ITEM1
          ITEM6 = ITEM2
          IF (NN.EQ.NL) GOTO 2
          ITEM5 = ITEM3
          ITEM6 = ITEM4
          IF (NN.EQ.NM) GOTO 2
          ITEM5 = ITEM4 + 1
          ITEM6 = ITEM5 + NN - 1
          CALL GAUSPT(NN,GPT(ITEM5),GWT(ITEM5))
    2     DO IT = ITEM5, ITEM6
            Z = G + F*GPT(IT)
            XX(IO) = X
            YY(IO) = Y
            ZZ(IO) = Z
            WW(IO) = D*F*GWT(IR)*GWT(IS)*GWT(IT)
            IO = IO + 1
          ENDDO
        ENDDO
      ENDDO
      V = 0.
      DO IQ = 1, NQ
        V = V + WW(IQ)
      ENDDO
      IF (TESTOV(1.,V)) CALL ERRMES(1,0,'- is origin strictly inside crystal?')
!
      VSTAR = 1/V
      DO IQ = 1, NQ
        WW(IQ) = VSTAR*WW(IQ)
      ENDDO
      V = V*U
      WRITE (LPT,2000) V
 2000 FORMAT (/' Crystal volume ',F12.5)
      RETURN
      END SUBROUTINE SETGAU
!*==INPUTG.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE INPUTG
      SUBROUTINE INPUTG
!
! *** INPUTG updated by JCM 14 Oct 86 ***
!
!X
!C 2A
!H Reads and interprets all "G" cards, for Gaussian integration of various
!H integrals over a crystal defined by its plane faces.
!
!D Absorbs all the "G" cards given.  It will normally be called by a
!D setting up routine (e.g. SETABS) which then checks whether it has had
!D enough "G" cards to make sense, and gives default values for any missing.
!D
!D The syntax of "G" cards is thus like that of M, D, L cards; a word of up to
!D 4 symbols (usually letters, and the first must be a letter) follows the
!D "G space" which starts the card, and what follows after that depends on
!D the word.  Possible words recognised are:
!D
!D G FACE followed by an integer and other numbers: a specification of a plane
!D        face of the crystal, according to the integer.
!D        (1 means read A,B,C,D in the equation AX+BY+CZ>=D)
!D
!D G PNTS followed by 3 integers which are the number of Gauss points required
!D        for integration in the x, y, and z directions.  These may be any
!D        integer in the range 1-20,32,40 (the list is being extended.)
!D
!D        The MAIN program may wish to alter these during a run.  This would
!D        involve resetting NL,NM and NN in COMMON /GAUSS/, and obeying
!D        SETGAU again.
!D
!D        If no G PNTS card is given, 5 points will be taken in all 3 directions
!D
!D G MU followed by the coefficient of absorption.  Its units must tie up with
!D        A,B,C,D above. (This card is not essential; if the MAIN program
!D        calls for different values of mu, these are simply written to AMU
!D        in the COMMON /ABSDAT/)
!D
!D G MODE followed by an integer which gives mode of use of ABSOR or ABMULT,
!D        i.e. which integral(s) are to be calculated.
!
!I Reads in all "G" cards.
!O Writes its findings to unit LPT.
!
      CHARACTER*4 GWD, GTABLE(4)
      COMMON /ABSDAT/ AMU, MODEA
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /CPLANE/ AA(15), BB(15), CC(15), DD(15), NP
      COMMON /GAUSS/ WW(1000), NL, NM,   &
     &                NN, NQ
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /GREAD/ IGREAD(4)
      DATA GTABLE/'FACE', 'PNTS', 'MU', 'MODE'/
!
! SET "NO G CARDS READ":
      CALL JGMZER(IGREAD,1,4)
!
! INITIALISE COUNTS OF ITEMS WHICH MAY COME ON MORE THAN 1 CARD:
      NP = 0
!
! READ ALL "G" CARDS:
      INREAD(7) = -IABS(INREAD(7))
      ID = IABS(INREAD(7))
      NCARD = ICDNO(7)
      IF (NCARD.LE.0) CALL ERRMES(2,0,'"G" cards')
!
      DO ICD = 1, NCARD
!
        CALL CARDIN(ID)
        ID = ID + NYZ
        CALL RDWORD(GWD,LEN,3,IPT,80,0,IER)
   42   L = NCFIND(GWD,GTABLE,4)
        IF (L.LE.0) THEN
          CALL ERRCH2(GWD,2,'cannot recognise word','on "G" card')
          GOTO 3
        ENDIF
!
! SET "HAVE READ PARTICULAR WORD" (COUNTING NUMBER OF CARDS), THEN BRANCH:
        IGREAD(L) = IGREAD(L) + 1
        GOTO (31,32,33,34), L
!
! FACE:
   31   IER = IERR
        CALL ERRCHK(2,NP,15,0,'plane faces')
        IF (IER.NE.IERR) GOTO 3
!
        CALL RDREAL(AA(NP),IPT,IPT,80,IER)
        CALL RDREAL(BB(NP),IPT,IPT,80,IER)
        CALL RDREAL(CC(NP),IPT,IPT,80,IER)
        CALL RDREAL(DD(NP),IPT,IPT,80,IER)
        IF (DD(NP).GT.0.) GOTO 3
        AA(NP) = -AA(NP)
        BB(NP) = -BB(NP)
        CC(NP) = -CC(NP)
        DD(NP) = -DD(NP)
        GOTO 3
!
! PNTS:
   32   CALL RDINTG(NL,IPT,IPT,80,IER)
        CALL RDINTG(NM,IPT,IPT,80,IER)
        CALL RDINTG(NN,IPT,IPT,80,IER)
        WRITE (LPT,2000) NL, NM, NN
 2000   FORMAT (/' Gauss points for integration in x,y and ',           &
     &          'z directions are',3I5)
        GOTO 3
!
! MU:
   33   CALL RDREAL(AMU,IPT,IPT,80,IER)
        WRITE (LPT,2003) AMU
 2003   FORMAT (/' Coefficient of absorption is ',F10.5)
        GOTO 43
!
! MODE:
   34   CALL RDINTG(MODEA,IPT,IPT,80,IER)
        WRITE (LPT,2004) MODEA
 2004   FORMAT (/' Absorption integral mode',I3)
        IF (MODEA.GT.0 .AND. MODEA.LT.8) GOTO 29
        CALL ERRMES(1,1,'No integral of this number')
        GOTO 43
!
   29   GOTO (21,22,23,24,25,26,27), MODEA
!
   21   CALL MESS(LPT,0,'Conventional absorption correction')
        GOTO 43
   22   CALL MESS(LPT,0,'Depolarisation - integral using path in only')
        GOTO 43
   23   CALL MESS(LPT,0,'Extinction - derivative integral')
        GOTO 43
   24   CALL MESS(LPT,0,'Absorption+depolarisation')
        GOTO 43
   25   CALL MESS(LPT,0,'Absorption+extinction')
        GOTO 43
   26   CALL MESS(LPT,0,'Depolarisation+extinction')
        GOTO 43
   27   CALL MESS(LPT,0,'Absorption,depolarisation and extinction')
        GOTO 43
!
! HERE TO CONTINUE READING AFTER <WORD> <NUMBER> FORMAT:
   43   CALL RDWORD(GWD,LEN,IPT,IPT,80,0,IER)
        IF (IER.EQ.100) GOTO 3
        GOTO 42
    3 ENDDO
!
      WRITE (LPT,2001) NP
 2001 FORMAT (/' Equations of',I3,' faces (with no + signs):')
      DO I = 1, NP
        WRITE (LPT,2002) AA(I), BB(I), CC(I), DD(I)
 2002   FORMAT (1X,F10.5,'x',F10.5,'y',F10.5,'z >=',F10.5)
      ENDDO
      RETURN
      END SUBROUTINE INPUTG
!*==FETTLE.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE FETTLE(X,IFIELD,IFDIG)
      SUBROUTINE FETTLE(X,IFIELD,IFDIG)
!
! *** FETTLE by JCM 8 Jun 82 ***
!
!X
!C 13C
!H Decides field width and fractional part of real number in order to print it.
!A On entry X holds the real number.
!A On exit IFDIG is the minimum number of digits in which the
!A               fractional part of X may be printed (up to 4)
!A         IFIELD is the corresponding necessary total field width.
!
      DIMENSION ITEMP(5)
      A = ABS(X)
      CALL FRACT(A,B,N)
      CALL INTDIG(NINT(B),ITEMP,IFIELD)
      CALL INTDIG(NINT(A*10.**4),ITEMP,NDIG)
      IFDIG = 0
      IF ((NDIG.EQ.1) .AND. (ITEMP(1).EQ.0)) GOTO 1
      IFDIG = 4
    2 IF (NDIG.EQ.0) GOTO 1
      IF (ITEMP(NDIG).NE.0) GOTO 1
      IFDIG = IFDIG - 1
      NDIG = NDIG - 1
      GOTO 2
    1 IF (IFDIG.NE.0) IFIELD = IFIELD + 1 + IFDIG
      IF (X.LT.0.) IFIELD = IFIELD + 1
      RETURN
      END SUBROUTINE FETTLE
!*==FACGRP.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE FACGRP(ISTAB,IFTAB,NFAC)
      SUBROUTINE FACGRP(ISTAB,IFTAB,NFAC)
!
! *** FACGRP updated by PJB 13 Feb 90 ***
!
!X
!C 1A
!H Extracts factor groups from a space group.
!D To extract the factor groups F(i) of space group G given a subgroup S
!D such that sum of F(i)xS=G
!
!A On entry ISTAB(I) is non-zero if element I is in the sub-group.
!A          ISTAB(1) is zero if the sub-group is non-centrosymmetric.
!A On exit IFTAB(I) defines the factor groups.
!A          IFTAB(I) is zero if I is in S, 1 if I is in F(i), and for all
!A          other elements IFTAB(N)= J where MULTAB(I,J)=N and I is an element
!A          of F
!A abs(NFAC) is the number of elements in the factor groups; NFAC is negative
!A          if it is centro-symmetric.
!
      LOGICAL NEW
      DIMENSION ISTAB(24), IFTAB(24), ITRY(24)
      COMMON /NSYM  / NOP, NCENT, NOPC, NLAT, NGEN, CENTRC, KOM13
      LOGICAL CENTRC
      COMMON /SYMTAB/ MULTAB(24,24), INVERS(24), NORD(24), IGEN(3),     &
     &                KOM22
!
!  MAKE INITIAL IFTAB FROM ISTAB
      IFTAB(1) = 1
      DO I = 2, NOPC
        IF (ISTAB(I).NE.0) THEN
          IFTAB(I) = -999
        ELSE
          IFTAB(I) = 0
        ENDIF
      ENDDO
!
      DO I = 2, NOPC
! POTENTIAL NEW ELEMENT OF A FACTOR GROUP:
        IF (IFTAB(I).NE.0) GOTO 2
! CONSTRUCT ITS SUBGROUP IN ITRY:
        DO K = 2, NOPC
          ITRY(K) = 0
        ENDDO
        ITRY(1) = 1
        ITRY(I) = 1
    7   NEW = .FALSE.
        DO K = 2, NOPC
          DO J = 2, NOPC
            IF (ITRY(J).EQ.0) GOTO 8
            IF (ITRY(K).EQ.0) GOTO 8
            JK = MULTAB(J,K)
            IF (ITRY(JK).GT.0) GOTO 8
            NEW = .TRUE.
            ITRY(JK) = 1
    8     ENDDO
        ENDDO
        IF (NEW) GOTO 7
!
! NOW TRY NEW SUBGROUP AS A FACTOR GROUP:
        DO J = 2, NOPC
          IF (ITRY(J).EQ.0 .OR. IFTAB(J).EQ.0) GOTO 6
          GOTO 2
    6   ENDDO
!
! NEW GROUP OK: ADD IT:
        DO K = 2, NOPC
          IF (ITRY(K).EQ.0) GOTO 5
          IFTAB(K) = 1
          NFAC = NFAC + 1
          DO J = 2, NOPC
            IF (ISTAB(J).EQ.0) GOTO 3
            IJ = MULTAB(K,J)
            IF (IFTAB(IJ).EQ.0) IFTAB(IJ) = J
    3     ENDDO
    5   ENDDO
    2 ENDDO
      IF (ISTAB(1).EQ.0) NFAC = -NFAC
      DO I = 1, NOPC
        IF (IFTAB(I).EQ.-999) IFTAB(I) = 0
      ENDDO
!
      RETURN
      END SUBROUTINE FACGRP
!*==PARRUN.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE PARRUN(IFAM,IGEN,ISPC)
      SUBROUTINE PARRUN(IFAM,IGEN,ISPC)
!
! *** PARRUN updated by JCM 26 Oct 89 ***
!
!X
!C 6C
!H Controls the cycling over all parameters in LSQ (not for Profile Refinement).
!
!A On entry, if IFAM=0 the cycle is to be initialised
!A       and otherwise IFAM,IGEN,ISPC contain the "previous"  values
!A On exit  IFAM contains the family of the "next" parameter,
!A               or -1 if the end has been reached.
!A          IGEN contains the genus of the "next" parameter,
!A          ISPC contains the species of the "next" parameter.
!
!P LSETUP must have set up the structure of the problem in the arrays:
!P     NGENS(I)=number of genera in family I
!P     NSPC(I) =number of species in each genus of family I
!P     LF1SP(I)=number of species in family 1, genus I.
!N There is a similar routine in the Profile Refinement section, RUNPAR,
!N which deals also with the special family 4 parameters, and multi-phase
!N and multi-source data.
!
      COMMON /PRBLEM/ NFAM, NGENPS(6,9), NSPCPS(6,9), LF1SP(5),         &
     &                LF3SP(10,9,5), LVFST1(6,9,5), LBFST1(6,9,5),      &
     &                NVARF(6,9,5), NBARF(6,9,5), LF6SP(3,5)
      DIMENSION NGENS(6), NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1))
      EQUIVALENCE (NSPC(1),NSPCPS(1,1))
!
! INITIALISE ENTRY:
      IF (IFAM.EQ.0) GOTO 5
!
! ENTRY TO ADVANCE:
      ISPC = ISPC + 1
! CHECK NOT TOO MANY SPECIES FOR THIS FAMILY+GENUS:
    3 IF (ISPC.GT.NSPC(IFAM)) GOTO 2
! ALSO, FAMILY 1 HAS INDIVIDUAL GENERA OF DIFFERING LENGTHS:
      IF (IFAM.EQ.1 .AND. ISPC.GT.IABS(LF1SP(IGEN))) GOTO 2
!
      GOTO 100
!
! NEXT GENUS:
    2 IGEN = IGEN + 1
    1 ISPC = 1
      IF (IGEN.LE.NGENS(IFAM)) GOTO 3
! NEXT FAMILY:
    5 IFAM = IFAM + 1
      IGEN = 1
! IN CASE NGENS(IFAM) = 0
      IF (IFAM.LE.NFAM) GOTO 1
      IFAM = -1
  100 RETURN
      END SUBROUTINE PARRUN
!*==PARSDS.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 10      SUBROUTINE PARSDS
      SUBROUTINE PARSDS
!
! *** PARSDS updated by JCM 28 Jan 88 ***
!
!X
!C 7A
!H Collects together all parameter fixing and varying information for
!H LSQ refinement of cell parameters using d spacings.
!
!P The LSQ system must have been set up by LSETUP.  A "C" card with
!P cell parameters must have been read using RECIP.
!
!D Absorbs constraints due to symmetry for cell parameters, then reads
!D and interprets L FIX, LVARY and L RELA cards.
!
!I L FIX, LVARY and L RELA cards.
!
! ABSORB EXISTING CONSTRAINTS ON CELL PARAMETERS DUE TO SYMMETRY:
      CALL CELREL(1,1,1)
!
! READ ALL 'L RELA' CARDS:
      CALL RDRELA
! READ ALL 'L FIX' AND 'L VARY' CARDS:
      CALL RDFV
      RETURN
      END SUBROUTINE PARSDS
!*==PARSFW.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 7      SUBROUTINE PARSFW
      SUBROUTINE PARSFW
!
! *** PARSFW updated by JCM 12 Jan 88 ***
!
!X
!C 7A
!H An older routine to set up variables from parameters for FWLSQ.
!D All parameters are in fact both variables and basic variables, as there
!D      are no constraints on this problem
!
      CHARACTER*4 IPR1(8), IPR2(8)
      COMMON /CONSTR/ JCONST, JROWPT(301), JCMAT(200), AMOUNT(200),     &
     &                NEXTJ
      COMMON /DERBAS/ DERIVB(400), LVARB
      COMMON /DERVAR/ DERIVV(500), LVARV
      COMMON /FWVALS/ NVALS, COEFFS(9)
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /POINTS/ LVRBS(500), LVRPR(500), LBSVR(400), LRDVR(300)
!
!THIS AVOIDS USING VARMAK FOR NO REASON AT ALL OTHER THAN HISTORY.
! IT MAY NOT STILL WORK.
!
      JCONST = 0
      LVARV = NVALS
      LVARB = NVALS
      IFAM = 1
      IGEN = 2
      DO I = 1, NVALS
        LBSVR(I) = I
        LVRBS(I) = I
        LVRPR(I) = KPAK(1,2,I,0,0)
      ENDDO
!
      IF (LVARB.LE.0) THEN
        CALL MESS(LPT,1,'No variables')
        GOTO 100
      ENDIF
      WRITE (LPT,2001) LVARB
 2001 FORMAT (/'0',I5,' basic variables :'/)
      IC = 0
      DO IB = 1, LVARB
        IC = IC + 1
        CALL PARNAM(IPR1(IC),IPR2(IC),1,IB)
        IF (IC.LT.8) GOTO 4
        WRITE (LPT,2002) (IPR1(J),IPR2(J),J=1,IC)
        IC = 0
    4 ENDDO
      IF (IC.NE.0) WRITE (LPT,2002) (IPR1(J),IPR2(J),J=1,IC)
  100 RETURN
 2002 FORMAT (' ',8(A4,1X,A4,2X))
      END SUBROUTINE PARSFW
!*==PARSSF.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 10      SUBROUTINE PARSSF(MAGPAR)
      SUBROUTINE PARSSF(MAGPAR)
!
! *** PARSSF updated by PJB 31-May-1994 ***
!
!X
!C 7B
!H Collects all parameter fix and vary information for single crystal LSQ.
!
!D Calls other routines to:
!D Collect all symmetry implied constraints
!D Read & interpret all L FIX, L RELA and L VARY cards.
!
!I L FIX, L VARY and L RELA cards.
      EXTERNAL MAGPAR
      DIMENSION ISPVEC(10)
      COMMON /EXTN  / IEXTYP, DOMR, KDOMR, AMOSC, KMOSC, EXTCOR, CEXT(4)&
     &                , DEXDFQ, DEXDRQ, DEXDGQ, LOREN, GAUSS
      LOGICAL LOREN, GAUSS
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /OVER  / ITFAC, OTFAC(10), KOTFAC(10), NTFAC, JTFAC, KOM15
      EQUIVALENCE (TFAC,OTFAC(1))
      EQUIVALENCE (KTFAC,KOTFAC(1))
      COMMON /SLAKDA/ NSLAK(4), SLKSWD(4), SLAKWT(4), CHISQD(4), ISLKTP,&
     &                NSKTOT, KOM24
!
! IN FAM1 THERE MAY BE TFAC MADE EARLIER BECAUSE NO 'L TFAC' CARD, WHICH NOW
! WANTS FIXING:
      IFAM = 1
      IGEN = 1
      ISPC = 1
      IF (NTFAC.EQ.0) CALL LLTFAC(6)
!
! IF NO E CARD, FIX DOMR AND MOSC:
      IF (IEXTYP.EQ.0) THEN
        DO I = 8, 12
          CALL ADDFX5(1,1,I,1,1,4)
        ENDDO
      ENDIF
!
! SET UP ALL FAMILY 2 RELATIONS DUE TO SYMMETRY:
      ISPVEC(1) = 1
      ISPVEC(2) = 4
      ISPVEC(3) = 10
      CALL F2RELA(2,ISPVEC)
! AND IF MAGNETIC, DO RELATIONS BETWEEN MAGNETIC PARS ALSO:
      CALL MAGPAR(5)
!
! IF SLACK CONSTRAINTS, DO CELL RELATIONS:
      IF (NSLAK(1).GT.0) CALL CELREL(1,1,2)
!
! READ ALL 'L RELA' CARDS:
      CALL RDRELA
! READ ALL 'L FUDG' CARDS:
      CALL FUDGIN
! READ ALL 'L FIX AND 'L VARY' CARDS:
      CALL RDFV
      RETURN
      END SUBROUTINE PARSSF
!*==CALCDS.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE CALCDS(H)
      SUBROUTINE CALCDS(H)
!
! *** CALCDS by JCM 31 Jan 85 ***
!
!X
!C 7B
!H Calculates  d star squared, and its derivatives wrt reciprocal
!H cell quadratic products.
!A On entry H is a 1x3 vector holding h,k,l
!P In /CELPAR/ CPARS(1:6,2) should hold the 6 reciprocal quadratic products
!P             A* = a* squared
!P             D* =  b* c* cos alpha* etc
!P             KCPARS(1:6) should hold fix/vary information for each of the 6
!P             reciprocal cell quadratic products.
!D Sets GCALC in /OBSCAL/ to be d star squared, the d spacing squared,
!D and DERIVV in /DERVAR/ to be the derivative, where relevant
!
      DIMENSION H(3)
      COMMON /CELPAR/ CELL(3,3,2), V(2), ORTH(3,3,2), CPARS(6,2),       &
     &                KCPARS(6), CELESD(6,6,2), CELLSD(6,6), KOM4
      COMMON /DERVAR/ DERIVV(500), LVARV
      COMMON /OBSCAL/ OBS, DOBS, GCALC, YCALC, DIFF, ICODE, SUMWD, NOBS,&
     &                IWGH(5), WTC(4), WT, SQRTWT, WDIFF, YBACK, YPEAK, &
     &                YMAX, CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /POINTS/ LVRBS(500), LVRPR(500), LBSVR(400), LRDVR(300)
!
      GCALC = 0.
      J = 2
      K = 3
      DO I = 1, 3
        C1 = H(I)*H(I)
        C2 = 2.*H(J)*H(K)
        GCALC = GCALC + C1*CPARS(I,2) + C2*CPARS(I+3,2)
        L1 = KCPARS(I)
        L2 = KCPARS(I+3)
        IF (L1.GT.0) DERIVV(L1) = C1
        IF (L2.GT.0) DERIVV(L2) = C2
        J = K
        K = I
      ENDDO
!
      RETURN
      END SUBROUTINE CALCDS
!*==CALCFW.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE CALCFW(S)
      SUBROUTINE CALCFW(S)
!
! *** CALCFW by JCM 19 Nov 84 ***
!
!X
!C 7B
!H Calculates the Forsyth & Wells exponential function which approximates
!H to observed scattering factor curves.
!A On entry S is sin theta.
!
!P The relevant number of coeffivients (usually 5, 7 or 9) are held in
!P /FWVALS/ as COEFFS(1:NVALS)
!D Used in FWLSQ as a very simple LSQ application, with no constraints.
!D Sets GCALC = Forsyth & Wells sum of exponential terms,
!D and DERIVV in /DERVAR/ as NVALS derivatives.
!N PJB says it doesn't work;  this must be investigated.
!
      COMMON /DERVAR/ DERIVV(500), LVARV
      COMMON /FWVALS/ NVALS, COEFFS(9)
      COMMON /OBSCAL/ OBS, DOBS, GCALC, YCALC, DIFF, ICODE, SUMWD, NOBS,&
     &                IWGH(5), WTC(4), WT, SQRTWT, WDIFF, YBACK, YPEAK, &
     &                YMAX, CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
!
      SSQRD = S*S
      GCALC = COEFFS(NVALS)
      DERIVV(NVALS) = 1.0
!
      DO I = 3, NVALS, 2
        J = NVALS - I + 2
        TEX = EXP(-COEFFS(J)*SSQRD)
        TERM = COEFFS(J-1)*TEX
        GCALC = GCALC + TERM
        DERIVV(J) = -SSQRD*TERM
        DERIVV(J-1) = TEX
      ENDDO
      RETURN
      END SUBROUTINE CALCFW
!*==CALCGR.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 8      SUBROUTINE CALCGR(H,FAC)
      SUBROUTINE CALCGR(H,FAC)
!
! *** CALCGR by JCM 18 Feb 85 ***
!
!X
!C 7B
!H Gives the calculated function for grouped single crystal Least Squares.
!A On entry H is a 1x3 real array holding h,k,l
!A          FAC is the factor by which to multiply GCALC before summing
!P SETFC (or its constituent parts SYMOP, RECIP etc) must have set up the
!P    structure factor calculation.
!P EXTINC must have set up the extinction corrections
!P LSETUP, PARSSF and VARMAK must have set up the Least Squares
!P STLSSF must have read the L cards.
!D Forms GCALC and sums it in YCALC, multiplied by FAC. Also derivatives of
!D GCALC with respect to any parameters, and summs them likewise into DERIVV.
!D GCALC is the product of 3 functions, P1, P2, P3
!D P1 is the scale * overall itf * FAC (at present in GRLSQ FAC=multiplicity
!D    times d to the power 4)
!D P2 is the square of the structure factor.
!D P3 is an extinction correction, possibly absent.
!N Only IREF=1 makes sense here.
!
      DIMENSION H(3)
      COMMON /BRAGG / STHMXX(5), STHL, SINTH, COSTH, SSQRD, TWSNTH(5),  &
     &                DSTAR2, TWOTHD(5), DIFANG(6)
      EQUIVALENCE (STHLMX,STHMXX(1))
      COMMON /DERVAR/ DERIVV(500), LVARV
      COMMON /EXTN  / IEXTYP, DOMR, KDOMR, AMOSC, KMOSC, EXTCOR, CEXT(4)&
     &                , DEXDFQ, DEXDRQ, DEXDGQ, LOREN, GAUSS
      LOGICAL LOREN, GAUSS
      COMMON /FCAL  / FC, FCMOD, COSAL, SINAL, FCDERS(300), DERIVT(300)
      COMPLEX FC, DERIVT
      COMMON /OBSCAL/ OBS, DOBS, GCALC, YCALC, DIFF, ICODE, SUMWD, NOBS,&
     &                IWGH(5), WTC(4), WT, SQRTWT, WDIFF, YBACK, YPEAK, &
     &                YMAX, CSQTOT
      EQUIVALENCE (IWGHT,IWGH(1))
      COMMON /OVER  / ITFAC, OTFAC(10), KOTFAC(10), NTFAC, JTFAC, KOM15
      EQUIVALENCE (TFAC,OTFAC(1))
      EQUIVALENCE (KTFAC,KOTFAC(1))
      COMMON /POINTS/ LVRBS(500), LVRPR(500), LBSVR(400), LRDVR(300)
      COMMON /PRBLEM/ NFAM, NGENPS(6,9), NSPCPS(6,9), LF1SP(5),         &
     &                LF3SP(10,9,5), LVFST1(6,9,5), LBFST1(6,9,5),      &
     &                NVARF(6,9,5), NBARF(6,9,5), LF6SP(3,5)
      DIMENSION NGENS(6), NSPC(6)
      EQUIVALENCE (NGENS(1),NGENPS(1,1))
      EQUIVALENCE (NSPC(1),NSPCPS(1,1))
      COMMON /SCLDAT/ ISCALE, NSCALE, SCALE(20), KSCALE(20), NSCL,      &
     &                LSCD(10)
      DIMENSION DERIVA(500)
!
      STHL = VCTMOD(0.5,H,2)
! STHL=SIN THETA/LAMBDA;  SSQRD = IT SQUARED
      SSQRD = STHL*STHL
!
! CLEAR INTERNAL DERIVATIVES:
      IF (LVARV.GT.0) CALL GMZER(DERIVA,1,LVARV)
!
! FORM P1, THE PART OF GCALC INDEPENDENT OF MOD(FC)
      P1 = SCALE(ISCALE)*EXP(-TFAC*SSQRD)*FAC
      IF (KTFAC.GT.0) DERIVA(KTFAC) = -SSQRD
      L = KSCALE(ISCALE)
      IF (L.NE.0) DERIVA(L) = 1./SCALE(ISCALE)
! NEXT DO P2:
      CALL LFCALC(H)
      P2 = FCMOD*FCMOD
      DP2DFQ = 2./FCMOD
!
! P3:
      CALL EXTINC(3,FCMOD)
      P3 = EXTCOR*EXTCOR
      IF (KDOMR.NE.0) DERIVA(KDOMR) = 2.*DEXDRQ
      IF (KMOSC.NE.0) DERIVA(KMOSC) = 2.*DEXDGQ
!
! CONVERT DERIVATIVES FOR FAMILY 2 FROM BEING 'OF FCMOD' AS THEY ARE OUT OF
! LFCALC, USING:
! DP2/DV = DMODFC/DV * DP2/DMODFC - AND ALL ARE DIVIDED BY P2
! DP3/DV = DMODFC/DV * DP3/DMODFC - AND ALL ARE DIVIDED BY P3
! GIVING D(GCALC)/DV OVER GCALC=(DP2/DV OVER P2 + DP3/DV OVER P3)
      DO I = 1, NVARF(2,1,1)
        DERIVA(LVFST1(2,1,1)+I) = FCDERS(I)*(DP2DFQ+2.*DEXDFQ)
      ENDDO
!
      GCALC = P1*P2*P3
      YCALC = YCALC + GCALC
!
      DO I = 1, LVARV
        DERIVV(I) = DERIVV(I) + DERIVA(I)*GCALC
      ENDDO
      RETURN
      END SUBROUTINE CALCGR
!*==ATOMS.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE ATOMS(IR,N,ALIST,MAX)
      SUBROUTINE ATOMS(IR,N,ALIST,MAX)
!
! *** ATOMS by JCM 3 Apr 88 ***
!
!X
!C 4B
!H Makes a real space unit cell full of related atomic positions.
!
!A On entry IR=an atom number
!A          MAX is the maximum number of positions ALIST can hold
!A On exit  N is the number of distinct positions related to the original,
!A               still within the original unit cell.
!A          ALIST(3,) holds N distinct atomic positions, the first being
!A               the given position, translated into (0,1) if necessary
!
      DIMENSION ALIST(3,MAX)
      DIMENSION XX(3), CEL(3)
      COMMON /NSYM  / NOP, NCENT, NOPC, NLAT, NGEN, CENTRC, KOM13
      LOGICAL CENTRC
      COMMON /POSNS / NATOM, X(3,150), KX(3,150), AMULT(150), TF(150),  &
     &                KTF(150), SITE(150), KSITE(150), ISGEN(3,150),    &
     &                SDX(3,150), SDTF(150), SDSITE(150), KOM17
!
      N = 0
! INITIAL POSITION:
      CALL GMEQ(X(1,IR),XX,1,3)
!
! OVER CENTRE IF PRESENT:
      DO IC = 1, NCENT
! OVER OTHER OPERATORS:
        DO NS = 1, NOPC
          IS = NS*(3-2*IC)
! LATTICE TRANSLATIONS:
          DO IL = 1, NLAT
! NO NEIGHBOURING CELLS:
            CALL GMZER(CEL,1,3)
            CALL XTRANS(IR,XX,IS,IL,CEL)
            CALL FRAC3(XX)
            CALL EQPOS(ALIST,XX,N,M,MAX)
            IF (M.GT.N) N = M
          ENDDO
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE ATOMS
!*==APSHDS.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 7      SUBROUTINE APSHDS
      SUBROUTINE APSHDS
!
! *** APSHDS updated by PJB 29-Sept-93 ***
!
!X
!C 7B
!H Applies shifts for during d-spacing refinement.
!
!P Only of use from MAIN program DSLSQ,DSMLSQ, or similar;
!P only expects one family of parameters, containing the 6 reciprocal cell
!P quadratic products and the three components of the propagation vector.
!P Expects shifts (one for each basic variable) in array BLSQ, with
!P corresponding ESDs in array DERIVB.
!
!D Applies shifts, possibly fudged, dealing with
!D constraints if necessary.  Recalculates all cell quantities and
!D if the propagation vector has changed, calls REINDX to reindex
!D the reflection indices in /REFLNS/
!
!O Writes to LPT the old and new values, the shift and its esd.
!
      DIMENSION DPROP(3)
      LOGICAL NPROP
      CHARACTER*4 LNAM1, LNAM2
      COMMON /CELPAR/ CELL(3,3,2), V(2), ORTH(3,3,2), CPARS(6,2),       &
     &                KCPARS(6), CELESD(6,6,2), CELLSD(6,6), KOM4
      COMMON /DERBAS/ DERIVB(400), LVARB
      COMMON /DERVAR/ DERIVV(500), LVARV
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /MATDAT/ MATPNT(401), BLSQ(400)
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /POINTS/ LVRBS(500), LVRPR(500), LBSVR(400), LRDVR(300)
      COMMON /REFINE/ IREF, NCYC, NCYC1, LASTCY, ICYC, MODERR(5),       &
     &                MODEOB(5), IPRNT(20), MAXCOR, IONLY(9), SIMUL,    &
     &                MAG, MPL, FIXED, DONE, CONV
      LOGICAL SIMUL, MAG, MPL, FIXED, DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SATELL/ PROP(3), KPROP(3), KSTAB(24), NKSTAR, IPROP,      &
     &                FKSTAR, NKC, KCENT, INCOM, KOM21
      LOGICAL INCOM
!
      WRITE (LPT,2000) ICYC
 2000 FORMAT (/////'1Shifts in variables for cycle',I3/                 &
     &      '   Variable       New           Esd          Shift        '&
     &      ,'  Old    ')
!
!
! INITIALISE SHIFT COUNT AND SUMS
      CALL FETSHF(0,0.,0.)
! CLEAR PROPAGATION VECTOR SHIFT
      CALL GMZER(DPROP,3,1)
      NPROP = .FALSE.
!
! CYCLE OVER VARIABLES
      DO I = 1, LVARV
        J = LVRBS(I)
        KPACK = LVRPR(I)
! IF VARIABLE IS BASIC:
        IF (J.GT.0) THEN
          SHIFT = BLSQ(J)
          ESD = DERIVB(J)
! OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
        ELSE
          CALL SHFESD(-J)
        ENDIF
!
        CALL FETSHF(2,SHIFT,ESD)
        CALL PARNAM(LNAM1,LNAM2,3,KPACK)
        CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
        IF (ISPC.LT.6) THEN
          CALL ADJUST(CPARS(ISPC,2))
          WRITE (LPT,2001) LNAM1, LNAM2, CPARS(ISPC,2), ESD, SHIFT, XOLD
        ELSE
          CALL ADJUST(PROP(ISPC-6))
          WRITE (LPT,2001) LNAM1, LNAM2, PROP(ISPC-6), ESD, SHIFT, XOLD
          DPROP(ISPC-6) = SHIFT
          NPROP = .TRUE.
        ENDIF
      ENDDO
      CALL FETSHF(3,SHIFT,ESD)
! RECALCULATE OTHER CELL-RELATED QUANTITIES:
      CALL RECELL(1,1)
      IF (NPROP) CALL REINDX(DPROP)
      RETURN
 2001 FORMAT (' ',1X,A4,1X,A4,4G14.5)
      END SUBROUTINE APSHDS
!*==GENNAM.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 2      CHARACTER *4 FUNCTION GENNAM(NAME)
      CHARACTER*4 FUNCTION GENNAM(NAME)
!
! *** GENNAM by JCM 26 Mar 91 ***
!
!X
!C 13C
!H Finds all the starting letters of an atom name.
!A On entry NAME is an A4 CHARACTER variable
!A On exit  GENNAM is an A4 CHARACTER variable being all the leftmost letters
!A          of NAME
!
      CHARACTER*4 NAME
!
      GENNAM = ' '
      DO I = 1, 4
        IF (LETTER(NAME(I:I)).LE.0) GOTO 100
        GENNAM = NAME(1:I)
      ENDDO
  100 RETURN
      END FUNCTION GENNAM
!*==PFCALC.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 7      COMPLEX FUNCTION PFCALC(H)
      COMPLEX FUNCTION PFCALC(H)
!
!X
!C 18B
!H Calculates the COMPLEX nuclear structure factor for the reflection H, using
!H a multipole expansion of the form factor.
!
      COMPLEX TERM, CRS, SUM1, HR, PSUM, PFACS(50)
      LOGICAL LATABS
      DIMENSION H(3), RH(3)
      COMMON /BRAGG / STHMXX(5), STHL, SINTH, COSTH, SSQRD, TWSNTH(5),  &
     &                DSTAR2, TWOTHD(5), DIFANG(6)
      EQUIVALENCE (STHLMX,STHMXX(1))
      COMMON /CONSTA/ PI, RAD, DEG, TWOPI, FOURPI, PIBY2, ALOG2, SQL2X8,&
     &                VALMUB
      COMMON /FCAL  / FC, FCMOD, COSAL, SINAL, FCDERS(300), DERIVT(300)
      COMPLEX FC, DERIVT
      COMMON /FORMDA/ NFORMF(150), MODE(20), NT(20), F(40,20), S(40,20),&
     &                CMULT(20), KCMULT(150), NBAKF(20), NUMFNM, KOM7
      COMMON /MPODA / NMPAT, NMPOL, MPATAB(20), MPNMTB(150), NCLUMP,    &
     &                KCLUMP(100), MPTAB(21), POLAMP(200,6), KPOLMP(200)&
     &                , NCMAT, CONMAT(600,2)
      COMMON /MPODAC/ MPNAM(200)
      CHARACTER*4 MPNAM
      COMMON /NSYM  / NOP, NCENT, NOPC, NLAT, NGEN, CENTRC, KOM13
      LOGICAL CENTRC
      COMMON /POSNS / NATOM, X(3,150), KX(3,150), AMULT(150), TF(150),  &
     &                KTF(150), SITE(150), KSITE(150), ISGEN(3,150),    &
     &                SDX(3,150), SDTF(150), SDSITE(150), KOM17
      COMMON /SYMDA / SYM(3,3,24), TRANS(3,24), ALAT(3,4), ORIGIN(3),   &
     &                KOM26
!
! CLEAR ANSWERS IN CASE ABSENT:
!
!  FC COLLECTS THE CONVENTIONAL STRUCTURE FACTOR, COMPLEX:
      FC = CMPLX(0.,0.)
! CLEAR MODULUS AND ANGLES:
      FCMOD = 0.
      COSAL = 0.
      SINAL = 0.
! OUT IF ABSENT:
      IF (LATABS(H)) GOTO 100
!
! STHL = SIN THETA/LAMBDA
      STHL = VCTMOD(0.5,H,2)
!
! SET FIRST SCATTERING FACTOR:
      IFF = 0
!
! CYCLE OVER INDEPENDENT ATOMS:
      DO IR = 1, NATOM
!
!  SET MP TO THE MULTIPOLE ATOM
        MP = MPNMTB(IR)
!
        SUM1 = CMPLX(0.,0.)
!  CALCULATE RADIAL FORM-FACTORS
        CALL PFORMF(H,MP,PSUM,PFACS,0)
!
! INNER LOOP OVER SYMMETRY EQUIVALENTS:
        DO IS = 1, NOPC
          CALL ROTSYM(H,RH,IS,-1)
! CALCULATE NON-SPHERICAL FORM FACTORS
          CALL PFORMF(RH,MP,PSUM,PFACS,1)
          F1 = TWOPI*(SCALPR(X(1,IR),RH)+SCALPR(TRANS(1,IS),H))
          ERS = ANITF(RH,IR)
! ANISOTROPIC T F (=1. IF NOT THERE) NEEDED SEPARATELY FOR LSQ:
          CRS = CEXP(CMPLX(0.,F1))*ERS
          TERM = CRS*PSUM
          ARS = REAL(TERM)
          BRS = AIMAG(TERM)
          SUM1 = SUM1 + TERM
!
        ENDDO
! END OF INNERMOST CYCLE OVER SYMMETRY
!
! IF CENTROSYMMETRIC, COMPENSATE FOR USING ONLY HALF NUMBER OF OPERATORS:
        IF (CENTRC) SUM1 = SUM1 + CONJG(SUM1)
!
        FAC = AMULT(IR)*EXP(-TF(IR)*STHL*STHL)
        HR = FAC*SITE(IR)
! HR IS PRODUCT OF ATOM DEPENDENT BUT SYMMETRY INDEPENDENT FACTORS
        FC = FC + HR*SUM1
!
      ENDDO
! END OF CYCLE OVER ATOMIC POSITIONS
!
!  TIDY FCALC AND COLLECT TRUE D(MODFC)/D(VARIABLE)
!
      A = REAL(FC)
      B = AIMAG(FC)
      FCMOD = SQRT(A*A+B*B)
      PFCALC = FC
  100 RETURN
      END FUNCTION PFCALC
!*==PFSET.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 6      SUBROUTINE PFSET
      SUBROUTINE PFSET
!
! *** PFSET corrected by PJB C17 17 Sept 93 ***
!
!X
!C 18A
!H Directs the reading of J and W cards for multipole calculations.
!
      CHARACTER*4 WORD, WWORDS(2)
      COMMON /ATNAM / ATNAME(150), ATNA(150,9)
      CHARACTER*4 ATNA, ATNAME
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /CHOOSE/ MFORTB(50)
      COMMON /FORMDA/ NFORMF(150), MODE(20), NT(20), F(40,20), S(40,20),&
     &                CMULT(20), KCMULT(150), NBAKF(20), NUMFNM, KOM7
      COMMON /FONAM / FONA(20,9), FONAME(20)
      CHARACTER*4 FONAME, FONA
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /MPODA / NMPAT, NMPOL, MPATAB(20), MPNMTB(150), NCLUMP,    &
     &                KCLUMP(100), MPTAB(21), POLAMP(200,6), KPOLMP(200)&
     &                , NCMAT, CONMAT(600,2)
      COMMON /MPODAC/ MPNAM(200)
      CHARACTER*4 MPNAM
      COMMON /POLFOR/ MPLFOR(20,6), NUMGEN, PFORFA(7), LMAX
      COMMON /SCRAT1/ AMPS(200), MPTMP(200), LABEL(200), LTMP(3),       &
     &                LPK(10,3), NMPL
      DATA WWORDS/'RADF', 'ROTN'/
!
! SAVE CURRENT ERROR COUNT
      IERSAV = IERR
!
      IF (IOUT.GT.200) CALL OPSYM(1)
!
!  READ IN J DATA
      NMPAT = 0
      NMPL = 0
      NCLUMP = 0
      NJ = ICDNO(10)
      IF (NJ.EQ.0) GOTO 32
!
      LTMP(1) = 50
      LTMP(2) = 7
      LTMP(3) = 13
      CALL NPACK(NPK,LTMP,3,0,LPK)
!
!  READ DATA FROM  J MPOL CARDS
      IDT = IABS(INREAD(10))
      INREAD(10) = -IDT
      DO J = 1, NJ
        CALL INPUTJ(IDT,NTYP,IAT,IPT,IE)
        IF (NTYP.NE.1) GOTO 28
        IF (MPNMTB(IAT).EQ.0) THEN
          CALL ERRCHK(2,NMPAT,20,0,'atoms with multipoles')
          MPATAB(NMPAT) = IAT
          MPNMTB(IAT) = NMPAT
        ENDIF
        LTMP(1) = MPNMTB(IAT)
   11   CALL RDWORD(WORD,ILEN,IPT,IPT1,80,0,IE)
! IF NOTHING MORE ON CARD:
        IF (IE.EQ.100) GOTO 28
!
        IF (IE.NE.0) GOTO 29
        LTMP(2) = NCHINT(WORD(2:2))
        IF (LTMP(2).LT.0 .OR. LTMP(2).GT.6) GOTO 29
        LT = NCHINT(WORD(3:3))
        IF (LT.LT.0 .OR. LT.GT.LTMP(2)) GOTO 29
        IF (WORD(4:4).EQ.'-') LT = -LT
        LTMP(3) = LTMP(2) + 1 - LT
        CALL ERRCHK(2,NMPL,200,0,'multipoles')
        CALL RDREAL(AMPS(NMPL),IPT1,IPT,80,IE)
        IF (IE.NE.0) GOTO 29
        CALL NPACK(MPTMP(NMPL),LTMP,3,1,LPK)
        GOTO 11
!
   29   CALL ERRMES(1,1,'reading J MPOL card')
!  TO GET NEXT J CARD
   28   IDT = IDT + NYZ
      ENDDO
!
! END OF J CARDS TIDY UP
      CALL SORTN(MPTMP,LABEL,NMPL)
!
   32 IF (ICDNO(10).GT.0) THEN
! FIND OUT WHICH FORM FACTORS ARE WHICH:
        IDT = IABS(INREAD(10))
        CALL MPFORM(IDT,NJ)
!
      ENDIF
      NCARDW = ICDNO(23)
      IF (NCARDW.EQ.0) GOTO 100
!
!  READ IN W DATA
      CALL RADFUN(MMPAT,-1)
      CALL READRT(NMPAT,-1)
      IDT = IABS(INREAD(23))
      DO N = 1, NCARDW
        CALL INPUTW(IAT,WORD,IDT,IPT)
        GOTO (3,4,5), 1 + NCFIND(WORD,WWORDS,2)
    4   CALL RADFUN(IAT,IPT)
        GOTO 3
    5   MAT = MPNMTB(IAT)
        IF (MAT.EQ.0) GOTO 3
        CALL READRT(MAT,IPT)
    3 ENDDO
      GOTO 100
!
      ENTRY PFEND(NEWAT)
      NAT = NEWAT
      NEXT = 0
!
      MAT = 0
    9 NEXT = NEXT + 1
      IF (NEXT.GT.NMPL) THEN
        JAT = 0
      ELSE
        NTAB = LABEL(NEXT)
        NPK = MPTMP(NTAB)
        PAMP = AMPS(NTAB)
        CALL NPACK(NPK,LTMP,3,2,LPK)
        JAT = LTMP(1)
        LV = LTMP(2)
        MVAL = LTMP(3)
      ENDIF
      IF ((MAT.NE.0) .AND. (MAT.NE.JAT.OR.LVAL.NE.LV))                  &
     &    CALL ORTFUN(IFUN,KNUM,DUM,0)
      IF (JAT.EQ.MAT .AND. JAT.NE.0) GOTO 40
!  NEW ATOM
      MPTAB(MAT+1) = NMPOL + 1
      IF (MAT.NE.0) WRITE (LPT,2001) (MPNAM(J),POLAMP(J,1),J=MPTAB(MAT),&
     &                               MPTAB(MAT+1)-1)
 2001 FORMAT (/' Multipoles: ',5(A4,F8.4,2X)/12(13X,5(A4,F8.4,2X)/))
      IF (JAT.NE.0) THEN
        MAT = JAT
        IAT = MPATAB(MAT)
      ELSE
        IF (NAT.EQ.0) GOTO 1
        MAT = NMPAT - NAT + 1
        NAT = NAT - 1
        IAT = MPATAB(MAT)
        CALL READRT(MAT,-2)
        PAMP = 1.0
        LV = 0
        MVAL = 0
      ENDIF
      LVAL = -1
! FIND APPROPRIATE FORM FACTOR:
      IFORM = MFORTB(IAT)
      IF (MPLFOR(IFORM,1).EQ.-999) THEN
        WRITE (LPT,2002) FONAME(IFORM)
        MPLFOR(IFORM,1) = -IFORM
        CALL RADFUN(IFORM,0)
      ENDIF
      WRITE (LPT,2002) ATNAME(IAT)
      IERCNT = IERR
      CALL READRT(MAT,0)
      IF (IERR.GT.IERCNT) CALL ERRMES(0,0,'in PFSET')
   40 IF (LV.EQ.LVAL) GOTO 41
!  NEW VALUE OF L
      LVAL = LV
      IF (LV.NE.0 .AND. MPLFOR(IFORM,LV).EQ.0) THEN
        WRITE (LPT,3000) LV, FONAME(IFORM), ATNAME(JAT)
        WRITE (ITO,3000) LV, FONAME(IFORM), ATNAME(JAT)
        IERR = IERR + 1
      ENDIF
      KNUM = 2*LVAL + 1
      IF (KNUM.GT.1) CALL MPCON(MAT,KNUM)
      MO = 1
! TEST OF PAMP=0 & TO LABEL 9 OMITTED BY JBF Apr 89
   41 CALL ORTFUN(MVAL,KNUM,PAMP,MO)
      MO = MO + 1
      GOTO 9
    1 IF (IERR.NE.0) WRITE (ITO,10) IERR
   10 FORMAT (/I5,' Errors in input of wave-functions',                 &
     &        ' and/or multipoles')
      IERR = IERR + IERSAV
! SET LSQ PARAMETERS:
      CALL CONVMP(1)
  100 RETURN
 2002 FORMAT (//' *********'/' *  ',A4,' *'/' *********')
 3000 FORMAT (/' ERROR ** No <j',I1,'> form factor name for ',A4,       &
     &        ' needed by atom ',A4/)
      END SUBROUTINE PFSET
!*==APSHMP.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 8      SUBROUTINE APSHMP(MAGROU)
      SUBROUTINE APSHMP(MAGROU)
!
! *** APSHMP updated by JCM 20 Mar 90 **
!
!X
!C 7B
!H Applies shifts to all variables in multipole LSQ, and prints the results.
!P Shifts are in array BLSQ, and ESDs in DERIVB (to save space)
!
!D Identifies each variable as a type of parameter, and call individual
!D routines to apply shift (possibly fudged).
!
!D For redundant variables, calculates shift from constituent parts of
!D relevant constraint.
!
!O Prints old and new values, shift and esd, with parameter name
!O If family 2 (structure parameter), does printing in blocks
!
      EXTERNAL MAGROU
      CHARACTER*4 LNAM1, LNAM2
      LOGICAL HEAD, FAM5
      COMMON /ATBLOC/ NAME, IPNAME(12)
      CHARACTER*4 NAME, IPNAME
      COMMON /ATBLOK/ IBUFF, PNEW(12), PESD(12), PSHIFT(12), POLD(12),  &
     &                PSESD(12)
      COMMON /DERBAS/ DERIVB(400), LVARB
      COMMON /DERVAR/ DERIVV(500), LVARV
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /MATDAT/ MATPNT(401), BLSQ(400)
      COMMON /MPODA / NMPAT, NMPOL, MPATAB(20), MPNMTB(150), NCLUMP,    &
     &                KCLUMP(100), MPTAB(21), POLAMP(200,6), KPOLMP(200)&
     &                , NCMAT, CONMAT(600,2)
      COMMON /MPODAC/ MPNAM(200)
      CHARACTER*4 MPNAM
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /POINTS/ LVRBS(500), LVRPR(500), LBSVR(400), LRDVR(300)
      COMMON /REFINE/ IREF, NCYC, NCYC1, LASTCY, ICYC, MODERR(5),       &
     &                MODEOB(5), IPRNT(20), MAXCOR, IONLY(9), SIMUL,    &
     &                MAG, MPL, FIXED, DONE, CONV
      LOGICAL SIMUL, MAG, MPL, FIXED, DONE
      EQUIVALENCE (MODER,MODERR(1))
!
      WRITE (LPT,2000) ICYC
 2000 FORMAT (/////'1Shifts in variables for cycle',I3)
!
! SET UP QUANTITIES TO USE WITH DIFFERENT STYLES OF OUTPUT:
      IG = 0
      IBUFF = 0
      HEAD = .FALSE.
      FAM5 = .FALSE.
! CLEAR SHIFT AVERAGING:
      CALL FETSHF(1,0.,0.)
! CLEAR VECTOR OF SHIFTS IN PROGRAM VERSION OF MULTIPOLES:
      CALL GMZER(POLAMP(1,4),1,NMPOL)
      CALL GMZER(POLAMP(1,6),1,NMPOL)
      I = 0
!
! SCAN ALL VARIABLES:
    1 I = I + 1
      IF (I.GT.LVARV) GOTO 101
      J = LVRBS(I)
      KPACK = LVRPR(I)
! IF VARIABLE IS BASIC:
      IF (J.GT.0) THEN
        SHIFT = BLSQ(J)
        ESD = DERIVB(J)
! OTHERWISE IT IS REDUNDANT, BY CONSTRAINT NUMBER -J:
      ELSE
        CALL SHFESD(-J)
      ENDIF
!
      CALL PUNPAK(KPACK,IFAM,IGEN,ISPC)
      IF (J.LT.0 .AND. IFAM.EQ.2 .AND. ISPC.EQ.10) GOTO 1
!
! BRANCH ON FAMILY:
      GOTO (11,12,99,99,50), IFAM
   99 CALL ERRIN2(IFAM,0,'Family','not in multipoles')
!
   11 GOTO (21,22), IGEN
!
! FAMILY 1, GENUS 1 - MISCELLANEOUS SPECIES (TFAC,DOMR,MOSC):
   21 IF (ISPC.GT.7) GOTO 32
!
! TFAC:
      IF (ISPC.EQ.1) CALL LLTFAC(3)
      GOTO 40
!
! DOMR OR MOSC (EXTINCTION CORRECTION PARAMETERS)
   32 CALL EXTINC(ISPC-4,0.)
      GOTO 40
!
! FAMILY 1, GENUS 2 - IN SF THIS IS 'SCAL':
   22 CALL LLSCAL(3)
      GOTO 40
!
! FAMILY 2 - THESE ARE ALL TO DO WITH THE STRUCTURE FACTOR:
   12 IF (ISPC.LT.13) THEN
        CALL F2SHFT
      ELSE
! MAGNETIC PARAMETERS:
        CALL MAGROU(3)
      ENDIF
      GOTO 40
!
! FAMILY 5: MULTIPOLES
   50 IF (.NOT.FAM5) THEN
! PRINT ANY REMNANTS FROM BUFFER:
        CALL PRBLOK
        CALL MESS(LPT,1,'Multipole parameter shifts:')
        FAM5 = .TRUE.
      ENDIF
      POLAMP(ISPC,4) = SHIFT
      POLAMP(ISPC,6) = ESD
      GOTO 1
!
! COMMON EXIT TO PRINT SHIFTS:
   40 CALL FETSHF(2,SHIFT,ESD)
      CALL PARNAM(LNAM1,LNAM2,3,KPACK)
      IF (IFAM.NE.2) GOTO 6
! DETECT CHANGE OF GENUS (ATOM)
      IF (IG.EQ.IGEN) GOTO 7
      HEAD = .FALSE.
      CALL PRBLOK
! PUT FIRST ENTRY FOR NEW ATOM INTO BUFFERS:
      NAME = LNAM1
      IG = IGEN
    7 IF (IBUFF.GE.12) CALL PRBLOK
      IBUFF = IBUFF + 1
      IPNAME(IBUFF) = LNAM2
      PNEW(IBUFF) = XNEW
      PESD(IBUFF) = ESD
      PSHIFT(IBUFF) = SHIFT
      POLD(IBUFF) = XOLD
      PSESD(IBUFF) = SHESD
      GOTO 1
!
! HERE TO PRINT TYPE 1 SHIFT AS BEFORE:
    6 IF (.NOT.HEAD) CALL MESS(LPT,1,'  Variable       New'//           &
     &  '           Esd          Shift          Old           Shift/Esd'&
     &  )
      HEAD = .TRUE.
      WRITE (LPT,2006) LNAM1, LNAM2, XNEW, ESD, SHIFT, XOLD, SHESD
 2006 FORMAT (' ',1X,A4,1X,A4,5G14.5)
      GOTO 1
!
  101 CALL PRBLOK
! APPLY ALL SHIFTS, AND PRINT IN USER UNITS:
      CALL PRMBLK
      CALL FETSHF(3,0.,0.)
      RETURN
      END SUBROUTINE APSHMP
!*==APSHFW.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 7      SUBROUTINE APSHFW
      SUBROUTINE APSHFW
!
! *** APSHFW updated by JCM 10 Feb 87 ***
!
!X
!C 7B
!H Applies shifts for Forsyth & Wells scattering factor coefficient
!H refinement.
!P Only useful if called from FWLSQ or similar.
!D Scans variables, applies shifts with possible fudges.
!O Prints new value, shift, esd and old value.
!
      CHARACTER*4 LNAM1, LNAM2
      COMMON /DERBAS/ DERIVB(400), LVARB
      COMMON /DERVAR/ DERIVV(500), LVARV
      COMMON /FWVALS/ NVALS, COEFFS(9)
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /MATDAT/ MATPNT(401), BLSQ(400)
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /POINTS/ LVRBS(500), LVRPR(500), LBSVR(400), LRDVR(300)
      COMMON /REFINE/ IREF, NCYC, NCYC1, LASTCY, ICYC, MODERR(5),       &
     &                MODEOB(5), IPRNT(20), MAXCOR, IONLY(9), SIMUL,    &
     &                MAG, MPL, FIXED, DONE, CONV
      LOGICAL SIMUL, MAG, MPL, FIXED, DONE
      EQUIVALENCE (MODER,MODERR(1))
!
      WRITE (LPT,2000) ICYC
 2000 FORMAT (/////'1Shifts in variables for cycle',I3/                 &
     &      '   Variable       New           Esd          Shift        '&
     &      ,'  Old    ')
      DO I = 1, LVARV
        J = LVRBS(I)
        KPACK = LVRPR(I)
        CALL PARNAM(LNAM1,LNAM2,3,KPACK)
        SHIFT = BLSQ(J)
        ESD = DERIVB(J)
        CALL ADJUST(COEFFS(I))
        COEFFS(I) = XNEW
        WRITE (LPT,2001) LNAM1, LNAM2, XNEW, ESD, SHIFT, XOLD
 2001   FORMAT (' ',1X,A4,1X,A4,4G14.5)
      ENDDO
      RETURN
      END SUBROUTINE APSHFW
!*==BITSET.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 2      SUBROUTINE BITSET(I,NC,TEST,SET)
      SUBROUTINE BITSET(I,NC,TEST,SET)
!
! *** BITSET by JCM 25 Nov 82 ***
!
!X
!C 15C
!H Sets or tests a single bit in a word.
!A On entry I,NC pick out the required bit in array IBIT
!A          SET is a LOGICAL.
!A On exit, if SET is TRUE, sets relevant single bit into array IBIT.
!A          if FALSE, sets LOGICAL TEST to indicate whether relevant bit is
!A                    already present in IBIT, and removes it if it is.
!
      LOGICAL TEST, SET
      COMMON /BITMAP/ IBIT(108,4), NWORDS
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /LENINT/ NBITS
!
      J = (NC-1)/NBITS + 1
      IF (J.LE.NWORDS) GOTO 3
      WRITE (LPT,3000) J, NWORDS, NC, NBITS
      WRITE (ITO,3000) J, NWORDS, NC, NBITS
!>> JCC Handle the STOP through an extra function
! Was
!     STOP
! Now
      CALL BMBOUT
      RETURN
!
    3 IB = MOD(NC,NBITS)
      IF (IB.EQ.0) IB = NBITS
      M = ITPOS(IB)
      IF (SET) GOTO 1
      TEST = (LOGAND(IBIT(I,J),M).NE.0)
      IF (TEST) IBIT(I,J) = IBIT(I,J) - M
      GOTO 100
!
    1 IBIT(I,J) = LOGOR(IBIT(I,J),M)
  100 RETURN
 3000 FORMAT (/' ERROR ** in BITSET - integer',I4,' called, but ',      &
     &        'only',I4,' available.  NC, NBITS=',2I4)
      END SUBROUTINE BITSET
!*==ITPOS.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      FUNCTION ITPOS(IPOS)
      FUNCTION ITPOS(IPOS)
!
! *** ITPOS 24 Nov 82 by JCM ***
!
!X
!C 15C
!H Sets ITPOS=a single bit (a one), in position IPOS, counting from the right.
!A IPOS is assumed non-zero on entry, and is unchanged.
!N It is also assumed that IPOS is not so large that integer
!N overflow will occur.  If it does, try reducing the number of
!N bits used in an integer (e.g.avoid the last, sign, bit) by reducing
!N the value of NBITS in COMMON /CONTUR/
!
      ITPOS = 1
      IF (IPOS.EQ.1) GOTO 100
      DO I = 2, IPOS
        ITPOS = 2*ITPOS
      ENDDO
  100 RETURN
      END FUNCTION ITPOS
!*==LOGAND.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
!
!
! LEVEL 1      FUNCTION LOGAND(I,J)
      FUNCTION LOGAND(I,J)
!
! *** LOGAND IN FORTRAN by JCM 10 Oct 83 ***
!
!C 15C
!H Performs logical "and" on 2 whole integers.
!A On entry I and J are the integers whose "and" is wanted.
!A On exit LOGAND is I and J, taken bit by bit.
!D Takes the logical "and" of all of the bits in I and J, except the sign
!D digit, relying on the value of NBITS in /LENINT/ being set to one fewer
!D than the number of bits in an integer (at most).  NBITS is set in INITIL
!D as a machine specific quantity.
!N This is now part of standard FORTRAN
!
      LOGICAL DIFFI, DIFFJ
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /LENINT/ NBITS
!
      IF ((I.LT.0) .OR. (J.LT.0)) THEN
        WRITE (LPT,3000) I, J, NBITS
        WRITE (ITO,3000) I, J, NBITS
!>> JCC Handle the STOP through an extra function
! Was
!     STOP
! Now
        CALL BMBOUT
        RETURN
      ENDIF
!
! FORM ANSWER IN IANS.  PUT SAMPLE BIT INTO IBT:
      IANS = 0
      IBT = 1
      II = I
      JJ = J
!
! COUNT OVER POSSIBLE BITS:
      DO IB = 1, NBITS
        DIFFI = .FALSE.
        I1 = II/2
        I2 = 2*I1
! IF HALVING THEN DOUBLING HAS PRODUCED NO CHANGE, II WAS EVEN:
        IF (I2-II) 2, 3, 4
! JUST IN CASE SOME MACHINE ROUNDS IT UP:
    4   I1 = I1 - 1
    2   DIFFI = .TRUE.
!
! SAME FOR JJ:
    3   DIFFJ = .FALSE.
        J1 = JJ/2
        J2 = 2*J1
        IF (J2-JJ) 5, 6, 7
    7   J1 = J1 - 1
    5   DIFFJ = .TRUE.
!
! IF INDIVIDUAL BITS BEING EXAMINED ARE THE SAME, ADD IN BIT TO ANSWER
    6   IF (DIFFI .AND. DIFFJ) IANS = IANS + IBT
        IF (IB.NE.NBITS) IBT = IBT*2
! WE OMIT DOUBLING LAST TIME ROUND IN CASE OF OVERFLOW
        II = I1
        JJ = J1
      ENDDO
      LOGAND = IANS
      RETURN
 3000 FORMAT (' ERROR ** in FUNCTION LOGAND - attempt to use',          &
     &        ' sign bit - check value of NBITS in COMMON /LENINT/ - ', &
     &        'I,J,NBITS =',3I5)
      END FUNCTION LOGAND
!*==LOGOR.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      FUNCTION LOGOR(I,J)
      FUNCTION LOGOR(I,J)
!
! *** LOGOR IN FORTRAN by JCM 10 Oct 83 ***
!
!C 15C
!H Performs logical "or" on 2 whole integers.
!A On entry I and J are the integers whose "or" is wanted.
!A On exit LOGAND is I or J, taken bit by bit.
!D Takes the logical "or" of all of the bits in I and J, except the sign
!D digit, relying on the value of NBITS in /LENINT/ being set to one fewer
!D than the number of bits in an integer (at most).  NBITS is set in INITIL
!D as a machine specific quantity.
!N This is now part of standard FORTRAN
!
      LOGICAL DIFFI, DIFFJ
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /LENINT/ NBITS
!
      IF ((I.LT.0) .OR. (J.LT.0)) THEN
        WRITE (LPT,3000) I, J, NBITS
        WRITE (ITO,3000) I, J, NBITS
!>> JCC Handle the STOP through an extra function
! Was
!     STOP
! Now
        CALL BMBOUT
        RETURN
      ENDIF
!
! FORM ANSWER IN IANS.  PUT SAMPLE BIT INTO IBT:
      IANS = 0
      IBT = 1
      II = I
      JJ = J
!
! COUNT OVER POSSIBLE BITS:
      DO IB = 1, NBITS
        DIFFI = .FALSE.
        I1 = II/2
        I2 = 2*I1
! IF HALVING THEN DOUBLING HAS PRODUCED NO CHANGE, II WAS EVEN:
        IF (I2-II) 2, 3, 4
! JUST IN CASE SOME MACHINE ROUNDS IT UP:
    4   I1 = I1 - 1
    2   DIFFI = .TRUE.
!
! SAME FOR JJ:
    3   DIFFJ = .FALSE.
        J1 = JJ/2
        J2 = 2*J1
        IF (J2-JJ) 5, 6, 7
    7   J1 = J1 - 1
    5   DIFFJ = .TRUE.
!
! IF INDIVIDUAL BITS BEING EXAMINED HAVE A 1, ADD IN BIT TO ANSWER
    6   IF (DIFFI .OR. DIFFJ) IANS = IANS + IBT
        IF (IB.NE.NBITS) IBT = IBT*2
! WE OMIT DOUBLING LAST TIME ROUND IN CASE OF OVERFLOW
        II = I1
        JJ = J1
      ENDDO
      LOGOR = IANS
      RETURN
 3000 FORMAT (' ERROR ** in FUNCTION LOGOR - attempt to use',           &
     &        ' sign bit - check value of NBITS in COMMON /LENINT/ - ', &
     &        'I,J,NBITS =',3I5)
      END FUNCTION LOGOR
!*==NEWPAG.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE NEWPAG(LUNIT)
      SUBROUTINE NEWPAG(LUNIT)
!
! *** NEWPAG by JCM 14 Sep 92 ***
!
!X
!C 13C
!H Writes a newpage carriage control ('1') to the output unit LUNIT
!
      WRITE (LUNIT,2000)
 2000 FORMAT ('1')
      RETURN
      END SUBROUTINE NEWPAG
!*==SORTN.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
!
! LEVEL 1      SUBROUTINE SORTN(IVAL,IP,N)
      SUBROUTINE SORTN(IVAL,IP,N)
!
! *** SORTN updated by JHM/JCM 22 Aug 86 ***
!
!X
!C 16C
!H Sorts pointers to an integer array using Heapsort.
!
!A On entry IVAL is an array of N integers.
!A On exit IP is an array of N pointers to IVAL in ascending order
!
!N Copyright John Matthewman 18 July 1983
!N  HEAPSORT
!N  (See Knuth 'Art of Computer Programming' Vol 3, Section 5.2.3)
!
      DIMENSION IVAL(N), IP(N)
!
! EXTRA PART (WHICH MAY BE REMOVED AGAIN) - SET UP POINTERS:
      DO I = 1, N
        IP(I) = I
      ENDDO
      IF (N.LT.2) GOTO 100
!  INITIALISE
      L = N/2 + 1
      IR = N
    1 L = L - 1
      K = IP(L)
    3 J = L
      GOTO 4
!
!  SIFTING LOOP
    5 IF (IVAL(IP(J)).LT.IVAL(IP(J+1))) J = J + 1
    7 IP(I) = IP(J)
    4 I = J
      J = J + J
      IF (J-IR) 5, 7, 8
!
!  FLOYDS MODIFICATION
   10 IP(J) = IP(I)
    8 J = I
      I = I/2
      IF (I) 6, 6, 9
    9 IF (J.GT.L .AND. IVAL(K).GT.IVAL(IP(I))) GOTO 10
    6 IP(J) = K
!
!  END OF A SIFT
      IF (L.GT.1) GOTO 1
      K = IP(IR)
      IP(IR) = IP(1)
      IR = IR - 1
      IF (IR.GT.1) GOTO 3
      IP(1) = K
  100 RETURN
      END SUBROUTINE SORTN
!*==MPFORM.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 5      SUBROUTINE MPFORM(IDT,NJ)
      SUBROUTINE MPFORM(IDT,NJ)
!
! *** MPFORM updated by JCM Aug 92 ***
!
!X
!C 18A
!H Finds out which radial form factors to apply to which atom and L value.
!P ATOPOS etc.
!A IDT is the position in the CDF of the first J card
!A NJ the number of J cards
!D Called normally by PFSET
!D Sets MPLFOR(I,J) in COMMON /POLFOR/ to be the number of the form
!D factor to use for multipole atom I and L value J, if negative a radial
!D wave function is to be used to compute the form factors
!
      CHARACTER*4 WORD
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /FORMDA/ NFORMF(150), MODE(20), NT(20), F(40,20), S(40,20),&
     &                CMULT(20), KCMULT(150), NBAKF(20), NUMFNM, KOM7
      COMMON /FONAM / FONA(20,9), FONAME(20)
      CHARACTER*4 FONAME, FONA
      COMMON /POLFOR/ MPLFOR(20,6), NUMGEN, PFORFA(7), LMAX
!
      CALL JGMZER(MPLFOR,20,6)
      NAMFRE = NUMFNM + 1
      DO J = 1, NJ
        CALL INPUTJ(IDT,NTYP,IAT,IPT,IE)
        IF (NTYP.NE.2) GOTO 2
        IERR = IERR + IE
    3   CALL RDWORD(WORD,LEN,IPT,IPT1,80,0,IE)
        IF (IE.EQ.100) GOTO 2
        IF (IE.NE.0) CALL ERRMES(1,1,' in form-factor name')
        IF (WORD.EQ.'RADF') THEN
          DO I = 1, 6
            MPLFOR(IAT,I) = -999
          ENDDO
        ELSE
          IFORM = NCFIND(WORD,FONAME,NAMFRE-1)
          IF (IFORM.EQ.0) THEN
            FONAME(NAMFRE) = WORD
            IFORM = NAMFRE
            CALL ERRCHK(2,NAMFRE,20,0,'Too many form-factors')
          ENDIF
          CALL RDINTG(L,IPT1,IPT,80,IE)
          IF (IE.NE.0) CALL ERRMES(1,1,' in form-factor L value')
          IF (L.GT.0) MPLFOR(IAT,L) = IFORM
          GOTO 3
        ENDIF
    2   IDT = IDT + NYZ
      ENDDO
      NUMGEN = NUMFNM
      NUMFNM = NAMFRE - 1
!
      RETURN
      END SUBROUTINE MPFORM
!*==PFORMF.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 6      SUBROUTINE PFORMF(H,MAT,PSUM,PFACS,KODE)
      SUBROUTINE PFORMF(H,MAT,PSUM,PFACS,KODE)
!
! *** PFORMF updated by PJB/JBF 4 Sep 89 ***
!
!X
!C 18B
!H Calculates radial form factors for multipole refinement.
!A On entry KODE gives the required action:
!A     = 0. Calculate radial form factors for atom MAT and put in POLFOR
!A     = 1. Return sum over multipoles in PSUM
!
      CHARACTER*1 ASIG
      DIMENSION H(3), OH(3), RH(3)
      COMPLEX Y(28), AI, PFACS(50), PSUM, FORMFA
      COMMON /CHOOSE/ MFORTB(50)
      COMMON /CONSTA/ PI, RAD, DEG, TWOPI, FOURPI, PIBY2, ALOG2, SQL2X8,&
     &                VALMUB
      COMMON /MPODA / NMPAT, NMPOL, MPATAB(20), MPNMTB(150), NCLUMP,    &
     &                KCLUMP(100), MPTAB(21), POLAMP(200,6), KPOLMP(200)&
     &                , NCMAT, CONMAT(600,2)
      COMMON /MPODAC/ MPNAM(200)
      CHARACTER*4 MPNAM
      COMMON /POLFOR/ MPLFOR(20,6), NUMGEN, PFORFA(7), LMAX
      COMMON /QROT  / ROT(3,3,10)
!
      IF (KODE.NE.0) GOTO 6
!  HERE TO CALCULATE RADIAL FORM FACTORS
      IFORM = MFORTB(MPATAB(MAT))
      AK = VCTMOD(0.5,H,2)
      AKK = FOURPI*AK
      CALL GMZER(PFORFA,7,1)
      LMAX = 0
      DO I = MPTAB(MAT), MPTAB(MAT+1) - 1
        READ (MPNAM(I),10) L
   10   FORMAT (1X,I1)
        IF (L.GT.LMAX) LMAX = L
        IF (PFORFA(L+1).NE.0) GOTO 5
        IF (L.EQ.0) THEN
          JFORM = IFORM
          IF (MPLFOR(IFORM,1).LT.0) JFORM = -JFORM
        ELSE
          JFORM = MPLFOR(IFORM,L)
        ENDIF
        IF (JFORM.GT.0) THEN
          PFORFA(L+1) = FORMFA(AK,JFORM)
        ELSE
          PFORFA(L+1) = FORMFC(AKK,L,0,IFORM)
        ENDIF
    5 ENDDO
      GOTO 100
!
!  HERE TO CALCULATE SUM OVER RADIAL FORM FACTORS * YLM
    6 CONTINUE
!  SQUARE ROOT OF -1
      AI = CMPLX(0.,1.)
      TWORTP = SQRT(FOURPI)
      ROOT2 = SQRT(2.)
!
      CALL GMPRD(ROT(1,1,MAT),H,RH,3,3,1)
      CALL GMEQ(RH,OH,1,3)
      CALL UNIVEC(OH,D)
      T = ACOS(OH(3))
      P = 0.
      IF (1.-ABS(OH(3)).GT.10E-5) P = ATAN2(OH(2),OH(1))
!  CALCULATE ALL NECESSARY SPHERICAL HARMONICS
      N = LMAX + 1
      NUM = N*(N+1)/2
      CALL SPHARM(Y,T,P,N,NUM)
!
!  NOW ACCUMULATE THE NON-SPHERICAL FORM FACTOR
      II = 1
      PSUM = 0.
      DO I = MPTAB(MAT), MPTAB(MAT+1) - 1
        READ (MPNAM(I),11) L, M, ASIG
   11   FORMAT (1X,I1,I1,A1)
        NUM = M + 1 + (L*(L+1)/2)
        IF (ASIG.EQ.'-') THEN
          HARM = AIMAG(Y(NUM))
        ELSE
          HARM = REAL(Y(NUM))
        ENDIF
        IF (M.NE.0) HARM = HARM*ROOT2
        PFACS(II) = PFORFA(L+1)*HARM*TWORTP*(AI**L)
        PSUM = PSUM + PFACS(II)*POLAMP(I,2)
        II = II + 1
      ENDDO
!
  100 RETURN
      END SUBROUTINE PFORMF
!*==NWINFW.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 5      SUBROUTINE NWINFW
      SUBROUTINE NWINFW
!
! *** NWINFW updated by JCM 10 May 88 ***
!
!X
!C 7B
!H Writes out a new Crystal Data File for main program FWLSQ.
!P NWINFW should only be called in the context of FWLSQ, after one
!P cycle of refinement in which the refined parameters have been updated.
!P An old Crystal Data File should be held on the scratch unit number IO10.
!
!D Writes out new file, with new values on the L VALS card.
!
!O Outputs new file on unit NEWIN.
!
      CHARACTER*4 LTEMP
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /FWVALS/ NVALS, COEFFS(9)
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
!
!
      ID = 0
    1 ID = ID + 1
      IF (ID.GT.NTOTAL(1)) GOTO 100
      READ (IO10,REC=ID,FMT=1000) ICARD
 1000 FORMAT (A80)
      L = LETTER(ICARD(1:1))
      IF (L.EQ.12) GOTO 3
      IF (L.NE.9) GOTO 2
!
! OUTPUT NEW I CARD:
      CALL OTPUTI
      GOTO 1
!
! OUTPUT NEW "L" CARD
    3 CALL RDWORD(LTEMP,LEN,3,IPT,80,0,IER)
      IF (LTEMP.NE.'VALS') GOTO 2
! NEW "L VALS" CARD:
      IF (NVALS.LT.0) GOTO 1
      LVCARD = 1
      IF (NVALS.GE.7) LVCARD = 2
      IV = 0
      DO I = 1, LVCARD
        JEND = 6
        IF (IV+6.GT.NVALS) JEND = NVALS - IV
        WRITE (NEWIN,2000) (COEFFS(IV+J),J=1,6)
 2000   FORMAT ('L VALS',6F12.5)
        IV = IV + 6
      ENDDO
      NVALS = -NVALS
      GOTO 1
!
! COPY UNCHANGED CARD:
    2 WRITE (NEWIN,2001) (ICARD(I:I),I=1,LENGT(ICARD))
 2001 FORMAT (80A1)
      GOTO 1
!
  100 RETURN
      END SUBROUTINE NWINFW
!*==PUNPAK.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE PUNPAK(KK,IFAM,IGEN,ISPC)
      SUBROUTINE PUNPAK(KK,IFAM,IGEN,ISPC)
!
! *** PUNPAK by JCM 8 Nov 90 ***
!
!X
!C 6C
!H Unpacks a parameter specification from single integer.
!A On entry KK holds packed parameter specification
!A On exit IFAM holds family number
!A         IGEN holds genus number
!A         ISPC holds species number
!P KK  must have been made via a call of KPAK set up by LSETUP
!D Unpacks KK according to bases previously set
!N There is an inverse routine KPAK
!
      DIMENSION LPAK(5)
      COMMON /LSQPAK/ KKPACK(10,3)
!
      CALL NPACK(KK,LPAK,3,2,KKPACK)
      IFAM = LPAK(1)
      IGEN = LPAK(2)
      ISPC = LPAK(3)
      RETURN
      END SUBROUTINE PUNPAK
!*==NWINDS.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 5      SUBROUTINE NWINDS
      SUBROUTINE NWINDS
!
! *** NWINDS updated by PJB 29-Sept-93  ***
!
!X
!C 7B
!H Outputs to unit NEWIN a new input dataset at the end of a refinement of
!H cell parameters and propagation vector from d spacing values.
!P The Crystal Data File must have been read by PREFIN
!D Deals with changed C, I or Q PROP cards.
!O Writes a new Crystal Data File to unit NEWIN in /NEWOLD/
!
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
!
      ID = 0
    1 ID = ID + 1
      IF (ID.GT.NTOTAL(1)) GOTO 100
      READ (IO10,REC=ID,FMT=1000) ICARD
 1000 FORMAT (A80)
      L = LETTER(ICARD(1:1))
      IF (L.EQ.3) GOTO 3
      IF (L.EQ.17) GOTO 4
      IF (L.NE.9) GOTO 2
!
! OUTPUT NEW I CARD:
      CALL OTPUTI
      GOTO 1
!
! OUTPUT NEW C CARD WITH NEW VALUES:
    3 CALL CELNEW
      GOTO 1
!
! Q PROP CARD NEEDS TO BE REWRITTEN
    4 CALL PROPAG(4,NEWIN)
      GOTO 1
!
! COPY UNCHANGED CARD:
    2 WRITE (NEWIN,2000) (ICARD(I:I),I=1,LENGT(ICARD))
 2000 FORMAT (80A1)
      GOTO 1
!
  100 RETURN
      END SUBROUTINE NWINDS
!*==MPOVAR.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE MPOVAR(I,J)
      SUBROUTINE MPOVAR(I,J)
!
! *** MPOVAR by JCM 9 Feb 91 ***
!
!X
!C 7A
!H Records whether each multipole parameter is fixed or varied.
!A On entry I=which parameter (or 0 if it is the initial entry to fix all)
!A          J=which variable it will be (or 0 if it is the initial entry)
!D If this is the initial entry records all multipoles fixed by clearing the
!D array KPOLMP in /MPODA.  Otherwise, records there that parameter I is
!D variable J.
!
      COMMON /MPODA / NMPAT, NMPOL, MPATAB(20), MPNMTB(150), NCLUMP,    &
     &                KCLUMP(100), MPTAB(21), POLAMP(200,6), KPOLMP(200)&
     &                , NCMAT, CONMAT(600,2)
      IF (J.EQ.0) THEN
        DO K = 1, NMPOL
          KPOLMP(K) = 0
        ENDDO
      ELSE
        KPOLMP(I) = J
      ENDIF
      RETURN
      END SUBROUTINE MPOVAR
!*==MPCON.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 5      SUBROUTINE MPCON(MAT,KMAX)
      SUBROUTINE MPCON(MAT,KMAX)
!
! *** MPCON by PJB ***
!
!X
!C 18A
!H Finds the symmetry constraints on multipoles.
!A MAT the multipole atom number
!A KMAX =  2l+1
!
      EXTERNAL DUMMY
      DIMENSION ANG(3), ROTN(3,3)
!
      COMMON /ATNAM / ATNAME(150), ATNA(150,9)
      CHARACTER*4 ATNA, ATNAME
      COMMON /CELPAR/ CELL(3,3,2), V(2), ORTH(3,3,2), CPARS(6,2),       &
     &                KCPARS(6), CELESD(6,6,2), CELLSD(6,6), KOM4
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /MPODA / NMPAT, NMPOL, MPATAB(20), MPNMTB(150), NCLUMP,    &
     &                KCLUMP(100), MPTAB(21), POLAMP(200,6), KPOLMP(200)&
     &                , NCMAT, CONMAT(600,2)
      COMMON /NSYM  / NOP, NCENT, NOPC, NLAT, NGEN, CENTRC, KOM13
      LOGICAL CENTRC
      COMMON /POSNS / NATOM, X(3,150), KX(3,150), AMULT(150), TF(150),  &
     &                KTF(150), SITE(150), KSITE(150), ISGEN(3,150),    &
     &                SDX(3,150), SDTF(150), SDSITE(150), KOM17
      COMMON /QROT  / ROT(3,3,10)
      COMMON /SCRAT2/ OROT(3,3,2), ISUB(24), MATP, ORMAT(169), FUN(169),&
     &                ORT(169), ANOR(13), USED(13), INDX(13), JNDX(13), &
     &                DIJ(196)
      LOGICAL USED, LODD
      COMPLEX DIJ
      COMMON /SYMDA / SYM(3,3,24), TRANS(3,24), ALAT(3,4), ORIGIN(3),   &
     &                KOM26
      COMMON /SYMTAB/ MULTAB(24,24), INVERS(24), NORD(24), IGEN(3),     &
     &                KOM22
!
      IODD = 2 - MOD(KMAX/2,2)
      NPTS = KMAX*KMAX
      IAT = MPATAB(MAT)
      IF (MAT.EQ.MATP) GOTO 9
!  NEW ATOM
      MATP = MAT
      CALL GMEQ(ROT(1,1,MAT),OROT(1,1,1),3,3)
      CALL GMEQ(ROT(1,1,MAT),OROT(1,1,2),3,3)
      CALL TRINV3(OROT(1,1,2),D)
      CALL TRANSQ(OROT(1,1,2),3)
      CALL MAKGRP(ISGEN(1,IAT),ISUB,0,DUMMY)
      WRITE (LPT,110) (I*ISUB(I),I=1,NOPC)
  110 FORMAT (//' Elements of Sub-group: '/1X,24I5)
    9 CALL GMZER(FUN,NPTS,2)
      DO N = 1, NOPC
        IF (ISUB(N).EQ.0) GOTO 1
        ISIG = NORD(N)*ISUB(N)
!  REMEMBER THE QUANTUM ROTATIONS ARE SET FOR RECIPROCAL SPACE
        CALL GMEQ(SYM(1,1,INVERS(N)),ROTN,3,3)
        CALL TRANSQ(ROTN,3)
!  USE ONLY PROPER ROTATIONS
        IF (NORD(N).LT.0) CALL GMREV(ROTN,ROTN,3,3)
        CALL EULSYM(ANG,ROTN,OROT)
        CALL DIJROT(DIJ,ANG(1),ANG(2),ANG(3),KMAX)
        IF (IOUT.GT.150) WRITE (LPT,4016) KMAX/2, N,                    &
     &                          (DEGREE(ANG(I)),I=1,3)
 4016   FORMAT (/' L =',I2,' Operator No:',I3,' Euler Angles:',3F8.2)
        L = 0
        LODD = MOD(KMAX/2,2).EQ.1
        DO J = 1, KMAX
!  REMOVE L ODD  IF CENTROSYMMETRIC
          IF (LODD .AND. ISGEN(1,IAT).LT.0) THEN
            DO I = 1, KMAX
              DIJ(L+I) = CMPLX(0.,0.)
            ENDDO
          ELSE
! FOR IMPROPER ROTATIONS reverse signs IF L is odd
            IF (ISIG.LT.0 .AND. LODD) THEN
              DO I = 1, KMAX
                DIJ(L+I) = -DIJ(L+I)
              ENDDO
            ENDIF
          ENDIF
          IF (IOUT.GT.200) WRITE (LPT,4010) (DIJ(L+I),I=1,KMAX)
 4010     FORMAT (12(1X,7(2F8.4,2X)/))
          L = L + KMAX
        ENDDO
        CALL REAORB(DIJ,ORT,KMAX)
        IF (IOUT.GT.200) THEN
          CALL MESS(LPT,1,'Dij matrix for real functions:')
          L = 0
          DO I = 1, KMAX
            WRITE (LPT,4012) (ORT(J),J=L+1,L+KMAX)
            L = L + KMAX
          ENDDO
        ENDIF
        CALL GMADD(FUN,ORT,FUN,1,NPTS)
    1 ENDDO
      IF (IOUT.GT.100) CALL MESS(LPT,2,'Sum Matrix')
      FAC = 1./FLOAT(IABS(ISGEN(1,IAT)))
      CALL GMSCA(FUN,FUN,FAC,1,NPTS)
      L = 0
      IF (IOUT.GT.100) THEN
        DO I = 1, KMAX
          WRITE (LPT,4012) (FUN(J),J=L+1,L+KMAX)
          L = L + KMAX
        ENDDO
      ENDIF
      CALL GMNORM(FUN,ANOR,KMAX,KMAX)
      CALL GMEQ(FUN,ORT,KMAX,KMAX)
      CALL TRANSQ(ORT,KMAX)
      CALL GMPRD(ORT,FUN,ORMAT,KMAX,KMAX,KMAX)
      IF (IOUT.GT.180) THEN
        CALL MESS(LPT,1,'Normalised sum matrix:')
        L = 0
        DO I = 1, KMAX
          WRITE (LPT,4012) (FUN(J),J=L+1,L+KMAX)
          L = L + KMAX
        ENDDO
        CALL MESS(LPT,1,'Product Matrix:')
        L = 0
        DO I = 1, KMAX
          WRITE (LPT,4012) (ORMAT(L+J),J=1,KMAX)
          L = L + KMAX
        ENDDO
      ENDIF
      RETURN
 4012 FORMAT (1X,15F8.4)
      END SUBROUTINE MPCON
!*==RADFUN.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
!
!
!
! LEVEL 4      SUBROUTINE RADFUN(JAT,IEND)
      SUBROUTINE RADFUN(JAT,IEND)
!
! *** RADFUN updated by PJB/JBF 3 Sep 89 ***
!
!X
!C 4A
!H Reads coefficients for the expansion of an atomic wave function.
!
!A On entry JAT indicates which atom (but is irrelevant if IEND=0)
!A          IEND points to the first character position on the card to read,
!A               unless IEND is -ve, when it is a request for initialisation.
!A               or IEND=0, which requests checking and printing.
!
!D The card has already been read as far as "W atom-name RADF".
!D Entry IEND +ve reads the coefficients in atomic units of IMAX Slater
!D type functions, for the expansion of an atomic wave function as a sun
!D of tems of the form:    F(1,I)*R**N(I)*exp(-F(2,I)*R)
!D In mode 1 the F(1,I) are not normalised (Clementi) and in mode 2 they are
!D (Watson).
!D The numbers given are MODE, N(I,IAT), F(1,I,IAT) AND F(2,I,IAT)
!D
!D Entry IEND=0 converts the coefficients to Angstrom units, and checks for
!D normalisation, for atom JAT.
!
!O Entry IEND=0 writes its findings to unit LPT.
!
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /RADINT/ N(20,5), FF(2,20,5), NTERMS(5), IRADF(5), NRADF
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      COMMON /SCRAT / MODE(20), IROT(20), TEMP(3,3), MFUN(10,20),       &
     &                LENG(3)
      DATA S/1.8896/
!
      IF (IEND) 30, 20, 1
!
!  INITIALISE
   30 NRADF = 0
      CALL JGMZER(NTERMS,1,5)
      GOTO 100
!
!  READ REST OF CARD STARTING W <ATOM> RADF:
    1 IF (NRADF.EQ.0 .OR. IRADF(NRADF).NE.JAT) THEN
        CALL ERRCHK(2,NRADF,5,0,'radial functions')
        IRADF(NRADF) = JAT
      ENDIF
      IPT1 = IEND
      DO I = 1, 2
        IPT = IPT1
        MODE(NRADF) = NN
        CALL RDINTG(NN,IPT,IPT1,80,IER)
        IF (IER.NE.0) GOTO 99
      ENDDO
!
      IT = NTERMS(NRADF)
      IT = IT + 1
      NTERMS(NRADF) = IT
      N(IT,NRADF) = NN
!
      DO I = 1, 2
        IPT = IPT1
        CALL RDREAL(FF(I,IT,NRADF),IPT,IPT1,80,IER)
        IF (IER.NE.0) GOTO 99
      ENDDO
      GOTO 100
!
! ERRORS IN READING:
   99 CALL ERRCH2(ICARD(IPT:IPT1-1),2,'cannot interpret','on W card')
      GOTO 100
!
!  ENTRY TO CHECK ONE ATOM AND OUTPUT PARAMETERS
   20 IAT = NFIND(JAT,IRADF,NRADF)
      IF (IAT.GT.0) IMAX = NTERMS(IAT)
      IF (IAT.EQ.0 .OR. IMAX.EQ.0) THEN
        CALL ERRMES(1,1,'No radial wave-function given')
        GOTO 100
      ENDIF
      CALL MESS(LPT,1,'Radial wave function :  Exponent      '//        &
     &          'Amplitude     Screening')
      CALL MESS(LPT,0,'                           of r'//               &
     &          '                      Constant')
      DO I = 1, IMAX
        XI = FF(2,I,IAT)
        A = FF(1,I,IAT)
        FF(2,I,IAT) = S*XI
        XX = FLOAT(N(I,IAT)) + 1.5
        IF (MODE(IAT).EQ.1) GOTO 22
        FF(1,I,IAT) = A*(S**XX)
        GOTO 23
   22   XX = 2.0*XX
        Y = (2.*FF(2,I,IAT))**XX
        Y = 1./Y
        Y = Y*FACT(IFIX(XX)-1)
        Y = SQRT(1./Y)
        FF(1,I,IAT) = A*Y
   23   WRITE (LPT,2001) N(I,IAT), A, XI
 2001   FORMAT (25X,I5,7X,F10.5,4X,F10.5,3X,E12.5)
      ENDDO
!
!     CHECK NORMALISATION
      SUM = 0.
      DO I = 1, IMAX
        DO J = 1, IMAX
          IX = (N(I,IAT)+N(J,IAT)+3)
          Y = FF(1,I,IAT)*FF(1,J,IAT)*FACT(IX-1)
          Y = Y/((FF(2,I,IAT)+FF(2,J,IAT))**IX)
          SUM = SUM + Y
        ENDDO
      ENDDO
      Y = ABS(SUM-1.0)
      IF (Y.GT.0.0005) CALL ERRRE2(SUM,1,'Function is not normalised',  &
     &                             'needed as normalisation integral')
  100 RETURN
      END SUBROUTINE RADFUN
!*==PUTPAR.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE PUTPAR(A,I,NUM,PAR,BAD)
      SUBROUTINE PUTPAR(A,I,NUM,PAR,BAD)
!
! *** PUTPAR by PJB Aug 91 ***
!
!X
!C 13C
!H Distributes parameters read by RDNUMS amongst individually named
!H variables.
!A On entry A is a vector of length at least NUM
!A          NUM is the number of parameters read by RDNUMS
!A          I is the position of the required parameter in A
!A          BAD is the value to put into PAR if the parameter wasn't read
!A              ie if I > NUM.
!A On exit the value has been set into PAR.
!
      DIMENSION A(1)
      IF (I.LE.NUM) THEN
        PAR = A(I)
      ELSE
        PAR = BAD
      ENDIF
      RETURN
      END SUBROUTINE PUTPAR
!*==NWINMP.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 8      SUBROUTINE NWINMP(MAGROU)
      SUBROUTINE NWINMP(MAGROU)
!
! *** NWINMP updated by JCM 11 Feb 91 ***
!
!X
!C 7B
!H Writes to unit NEWIN a replacement Crystal Data File after multipole LSQ.
!D For J MPOL cards after refinement, writes out all multipoles, not just
!D the ones that went in.
!
!
      EXTERNAL MAGROU
      CHARACTER*4 WORD, CHANGE(2)
      COMMON /ATNAM / ATNAME(150), ATNA(150,9)
      CHARACTER*4 ATNA, ATNAME
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /MPODA / NMPAT, NMPOL, MPATAB(20), MPNMTB(150), NCLUMP,    &
     &                KCLUMP(100), MPTAB(21), POLAMP(200,6), KPOLMP(200)&
     &                , NCMAT, CONMAT(600,2)
      COMMON /MPODAC/ MPNAM(200)
      CHARACTER*4 MPNAM
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      DATA CHANGE/'TFAC', 'SCAL'/
!
! OPEN NEW CD FILE:
      CALL NEWCD
! SCAN CARDS ON FILE IO10, PRODUCING NEW ONES IF THEY MAY HAVE CHANGED:
      ID = 0
    1 ID = ID + 1
      IF (ID.GT.NTOTAL(1)) GOTO 101
      READ (IO10,FMT=1000,REC=ID) ICARD
 1000 FORMAT (A80)
      LOLD = L
      L = LETTER(ICARD(1:1))
      IF (LOLD.EQ.10 .AND. L.NE.10) CALL JMPOL
! CHECK FOR L CARD
      IF (L.EQ.12) GOTO 3
! TREAT A, F AND T ALIKE:
      IF (L.EQ.1 .OR. L.EQ.6 .OR. L.EQ.20) GOTO 4
! CHECK FOR E CARD
      IF (L.EQ.5) GOTO 5
! CHECK FOR J CARD
      IF (L.EQ.10) GOTO 6
! CHECK FOR Q CARDS:
      IF (L.EQ.17) GOTO 7
      IF (L.NE.9) GOTO 2
!
! I CARD:
      CALL OTPUTI
      GOTO 1
!
! ANY FAMILY 2 PARAMETERS:
    4 CALL F2NEW(L)
      GOTO 1
!
! J CARD
    6 CALL RDWORD(WORD,LEN,3,IPT,80,0,IER)
      CALL RDWORD(WORD,LEN,IPT,IPT,80,0,IER)
      IF (WORD.NE.'MPOL') GOTO 2
      GOTO 1
!
! Q CARD:
    7 CALL MAGROU(4)
      GOTO 1
!
! L CARD:
    3 CALL RDWORD(WORD,LEN,3,IPT,80,0,IER)
      M = NCFIND(WORD,CHANGE,2)
      IF (M.LE.0) GOTO 2
      GOTO (11,12), M
!
! L TFAC:
   11 CALL LLTFAC(4)
      GOTO 1
!
! L SCAL:
   12 CALL LLSCAL(4)
      GOTO 1
!
! E CARD:
    5 CALL EXTINC(6,0.)
      GOTO 1
!
! OTHERWISE COPY CARD AS INPUT:
    2 WRITE (NEWIN,2000) (ICARD(I:I),I=1,LENGT(ICARD))
 2000 FORMAT (80A1)
      GOTO 1
!
  101 IF (L.EQ.10) CALL JMPOL
      RETURN
      END SUBROUTINE NWINMP
!*==NWINSF.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 8      SUBROUTINE NWINSF(MAGNEW)
      SUBROUTINE NWINSF(MAGNEW)
!
! *** NWINSF updated by PJB 31-May-94 ***
!
!X
!C 7B
!H Outputs a replacement Crystal Data File after single crystal refinement.
!A On entry MAGNEW is the name of a routine which writes a new Q card,
!A if magnetic, or does nothing if not.  This is to avoid loading any of
!A the magnetic code in non-magnetic examples.
!P An old Crystal Data File should be held on the scratch unit number IO10.
!P A cycle of LSQ refinement involving structure parameters should have
!P been done.
!D In general, writes the same number of "cards" as were on the original
!D Crystal Data File.  If there was originally no L SCAL card, makes one.
!D The new cards have the latest values of the refined parameters.
!O Outputs on unit NEWIN the updated Crystal Data File.
!
      EXTERNAL MAGNEW
      CHARACTER*4 WORD, CHANGE(3)
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /DEPMAT/ LDEP
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /REFINE/ IREF, NCYC, NCYC1, LASTCY, ICYC, MODERR(5),       &
     &                MODEOB(5), IPRNT(20), MAXCOR, IONLY(9), SIMUL,    &
     &                MAG, MPL, FIXED, DONE, CONV
      LOGICAL SIMUL, MAG, MPL, FIXED, DONE
      EQUIVALENCE (MODER,MODERR(1))
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      DATA CHANGE/'TFAC', 'SCAL', 'ATOM'/
!
      IF (SIMUL) GOTO 100
      CALL NEWCD
! SCAN CARDS ON SCRATCH, PRODUCING NEW ONES IF THEY MAY HAVE CHANGED:
      ID = 0
    1 ID = ID + 1
      IF (ID.GT.NTOTAL(1)) GOTO 101
      READ (IO10,REC=ID,FMT=1000) ICARD
 1000 FORMAT (A80)
      L = LETTER(ICARD(1:1))
      IF (L.EQ.12) GOTO 3
! TREAT A, F AND T ALIKE:
      IF (L.EQ.1 .OR. L.EQ.6 .OR. L.EQ.20) GOTO 4
      IF (L.EQ.5) GOTO 5
      IF (L.EQ.17) GOTO 6
      IF (L.NE.9) GOTO 2
!
! I CARD:
      CALL OTPUTI
      GOTO 1
!
! ANY FAMILY 2 PARAMETERS:
    4 CALL F2NEW(L)
      GOTO 1
!
! L CARD - THE OUTPUT OF THESE IS PROBLEM DEPENDENT:
    3 CALL RDWORD(WORD,LEN,3,IPT,80,0,IER)
      L = NCFIND(WORD,CHANGE,3)
      IF (L.LE.0) GOTO 2
!
! CARD TO UPDATE:
      GOTO (11,12,13), L
!
! L TFAC:
   11 CALL LLTFAC(4)
      GOTO 1
!
! L SCAL:
   12 CALL LLSCAL(4)
      GOTO 1
!
! L ATOM:
   13 CALL GEOMCO(3)
      GOTO 1
!
! E CARD:
    5 CALL EXTINC(6,0.)
      GOTO 1
!
! "Q" CARD:
    6 CALL MAGNEW(4)
      GOTO 1
!
! OTHERWISE COPY CARD AS INPUT:
    2 WRITE (NEWIN,2000) (ICARD(I:I),I=1,LENGT(ICARD))
 2000 FORMAT (80A1)
      GOTO 1
!
  101 IF (IPRNT(7).EQ.0) GOTO 100
! DEPOSITED MATERIAL SOURCE FILE:H,K,L,FOBS SIGMA FOBS, FCALC:
      MESSAG = 'Deposited Material'
      NAMFIL = '.DEP'
      CALL OPNFIL(LDEP,112)
  100 RETURN
      END SUBROUTINE NWINSF
!*==PRMBLK.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 7      SUBROUTINE PRMBLK
      SUBROUTINE PRMBLK
!
! *** PRMBLK updated by JCM 20 Mar 90 ***
!
!X
!C 7B
!H Applies shifts to multipole parameters, in both program and user units.
!P APSHMP must have stored a vector of multipole shifts in POLAMP(,4)
!P        and ESDs in POLAMP(,6)
!P CONMAT holds the conversion matrices
!D Applies matrix transformation to set of shifts to convert them into
!D user's notation.
!O Prints the converted shifts in the usual format on unit LPT
!
      CHARACTER*4 LNAM1, LNAM2
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /MPODA / NMPAT, NMPOL, MPATAB(20), MPNMTB(150), NCLUMP,    &
     &                KCLUMP(100), MPTAB(21), POLAMP(200,6), KPOLMP(200)&
     &                , NCMAT, CONMAT(600,2)
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /POINTS/ LVRBS(500), LVRPR(500), LBSVR(400), LRDVR(300)
!
      CALL CONVMP(2)
!
! APPLY ALL USER SHIFTS TO USER VALUES:
      IFAM = 5
      IGEN = 1
      DO ISPC = 1, NMPOL
        IF (KPOLMP(ISPC).EQ.0) GOTO 51
        SHIFT = POLAMP(ISPC,3)
        ESD = POLAMP(ISPC,5)
        CALL ADJUST(POLAMP(ISPC,1))
        CALL FETSHF(2,SHIFT,ESD)
        CALL PARNAM(LNAM1,LNAM2,3,KPAK(5,1,ISPC,0,0))
        WRITE (LPT,2000) LNAM1, LNAM2, XNEW, ESD, SHIFT, XOLD, SHESD
 2000   FORMAT (' ',1X,A4,1X,A4,5G14.5)
   51 ENDDO
!
! CONVERT NEW USER VALUES TO NEW PROGRAM VALUES:
      CALL CONVMP(1)
      RETURN
      END SUBROUTINE PRMBLK
!*==NORDER.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 2      FUNCTION NORDER(J)
      FUNCTION NORDER(J)
!
! *** NORDER by PJB/JCM 28 Jun 83 ***
!
!X
!C 1C
!H Returns the order of the Jth symmetry operator.
!A On entry J is the number of a symmetry operator.
!D The the absolute value of the function is set to the order of the
!D Jth symmetry operator, NORDER is negative if the rotation is an
!D improper one.
!P The symmetry operators must have been read by SYMOP, so that MULTAB is
!P filled in in /SYMTAB/ and SYM in /SYMDA/ holds the rotation matrices.
!
      COMMON /SYMDA / SYM(3,3,24), TRANS(3,24), ALAT(3,4), ORIGIN(3),   &
     &                KOM26
      COMMON /SYMTAB/ MULTAB(24,24), INVERS(24), NORD(24), IGEN(3),     &
     &                KOM22
!
      N = 1
      I = J
    2 IF (I.EQ.1) GOTO 1
! KEEP LOOKING UP RESULT OF REPEATEDLY MULTIPLYING OPERATOR BY ITSELF
! IN THE MULTIPLICATION TABLE;  EVENTUALLY THIS WILL LEAD TO ELEMENT 1,
! THE IDENTITY OPERATOR, AND THE NUMBER OF REQUIRED MULTIPLICATIONS
! IS THE ORDER OF THE OPERATOR
      I = MULTAB(J,I)
      N = N + 1
      GOTO 2
!
! N NOW THE ORDER; NEGATE IF INVERSION OPERATOR ALSO:
    1 IF (DETER3(SYM(1,1,J)).LT.0.) N = -N
      NORDER = N
      RETURN
      END FUNCTION NORDER
!*==RANMOV.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
      SUBROUTINE RANMOV(NA,RANDEL)
!
! *** RANMOV by JCM 28 Nov 91 ***
!
!X
!C 4B
!H Makes a change in atomic coordinates, according to the constraints
!A On entry NA=which atom
!A          RANDEL is an array of required shifts, holding 0,1,2 or 3 numbers
!A                 as appropriate.
!P Routine XYZREL must have set up the constraints in /POSREL/.
!D If the atomic position is unconstrained, applies RANDEL(1) to x, RANDEL(2)
!D to y and RANDEL(3) to z.  If there are constraints in /POSREL/, uses these
!D to shift some or all of x,y and z according to these constraints.
!D
!D Takes its shifts in sequence from the array RANDEL.
!
      DIMENSION RANDEL(3)
      COMMON /POSNS / NATOM, X(3,150), KX(3,150), AMULT(150), TF(150),  &
     &                KTF(150), SITE(150), KSITE(150), ISGEN(3,150),    &
     &                SDX(3,150), SDTF(150), SDSITE(150), KOM17
      COMMON /POSREL/ NXYZ(3,150), XYZ(3,150)
!
      J = 0
      NFIR = 0
      DO I = 1, 3
        IF (NXYZ(I,NA).LE.0) GOTO 1
        IF (NXYZ(I,NA).EQ.9999 .OR. NFIR.EQ.0) THEN
          J = J + 1
          X(I,NA) = X(I,NA) + RANDEL(J)
! FIRST OF A RELATED SET IS MARKED SPECIALLY:
          IF (NXYZ(I,NA).NE.9999) THEN
            NFIR = I
            NRAN = J
          ENDIF
        ELSE
          X(I,NA) = X(I,NA) + (XYZ(NFIR,NA)/XYZ(I,NA))*RANDEL(NRAN)
        ENDIF
    1 ENDDO
      RETURN
      END SUBROUTINE RANMOV
!*==SETFC.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 12      SUBROUTINE SETFC
      SUBROUTINE SETFC
!
! *** SETFC updated by JCM 17 Feb 88 ***
!
!X
!C 1A
!H Calls all the setting up routines needed for nuclear structure
!H factor calculations.
!D Calls INPUTN, SYMOP, OPSYM(1), RECIP, ATOPOS, SETFOR and SETANI to set data
!D in the COMMON blocks /SYMDA/, /SYMTAB/, /NSYM/, /CELLDA/, /ATNAM/, /POSNS/,
!D /FORNAM/, /FORDA/, possibly /ANSCAT/ and /ANISO/.
!
!I Causes all the crystallographic and structure cards to be read from
!I the copy of the Crystal Data File on unit IO10.
!O If any of the constituent routines sets the error flag IERR in /CARDRC,
!O prints an error message and stops.
!
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
!
      CALL INPUTN(LPT)
      CALL SYMOP
      CALL OPSYM(1)
      CALL RECIP
      CALL ATOPOS
      CALL SETFOR
      CALL SETANI
      IF (IERR.NE.0) CALL ERRMES(1,0,'s in SETFC')
      RETURN
      END SUBROUTINE SETFC
!*==SETDC.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 11      SUBROUTINE SETDC
      SUBROUTINE SETDC
!
! *** SETDC by JCM 8 Oct 85 ***
!
!X
!C 2A
!H Reads D cards to set up crystal orientation and diffraction geometry.
!P RECIP must have read in the cell parameters.
!D Sets the normalised orientation matrix into UM, the wavelength into
!D WLGTH, and the type of geometry into IGEOM all in COMMON /DGEOM/.
!D Also sets other useful quantities in /DGEOM/ for subsequent calculation
!D of the direction cosines of the incident and diffracted rays.
!D If IGEOM indicates 4-circle bisecting geometry, checks the determinant
!D of the UB matrix.  If it is a little different from 1., adjusts the
!D matrix elements until it is < 0.0001 away from 1.
!
      DIMENSION H(9)
      COMMON /DGEOM / IGEOM, UM(9), NLR, ANGLIN(3), ALAMBD(5,5), NLAMB, &
     &                ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /DREAD / IDREAD(8)
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
!
      IF (INREAD(3).GT.0) CALL RECIP
      IF (INREAD(4).GT.0) CALL INPUTD
!
! CHECK D CARDS AND PREPARE FOR USE - AT THIS STAGE USE COULD BE ONE OF SEVERAL
! APPLICATIONS LIKE LP CORRECTIONS, ABSORTION INTEGRALS ETC:
!
      CALL ORTHO(UM(1),H(7),1)
      CALL UNIVEC(H(7),D)
      IF (IDREAD(1).LE.0) THEN
        CALL ERRMES(2,1,'D GEOM card for LP')
        GOTO 100
      ENDIF
!
      GOTO (1,2,1,40,1,6,6,6,40,40,6), IGEOM
!
   40 CALL ERRMES(1,0,                                                  &
     &   'SETDC only for normal beam, equi-inclination, 4 circle and D3'&
     &   )
!
! NORMAL BEAM EQUATORIAL:
    2 IF (IDREAD(7).LE.0) GOTO 16
      IF (IDREAD(8).LE.0) THEN
        CALL ERRMES(2,1,'D CHIA card for type 2 geometry')
        GOTO 100
      ENDIF
!
      IF (ABS(SCALPR(UM(1),UM(4))).LT.1.E-5) GOTO 15
      WRITE (LPT,3006) (UM(I),I=1,3), (UM(I),I=4,6)
      WRITE (ITO,3006) (UM(I),I=1,3), (UM(I),I=4,6)
      IERR = IERR + 1
      GOTO 100
!
   15 CALL ORTHO(UM(4),H(1),2)
      CALL UNIVEC(H(1),D)
      CALL VECPRD(H(7),H(1),H(4))
      UM(4) = COS(ANGLIN(1))
      UM(5) = SIN(ANGLIN(1))
      UM(6) = 0.
      CALL GMPRD(H(1),UM(4),UM(1),3,3,1)
      GOTO 100
!
!     NORMAL BEAM AND EQUI-INCLINATION GEOMETRIES:
    1 IF (IDREAD(7).GT.0) GOTO 18
   16 CALL ERRIN2(IGEOM,1,'Type','geometry needs D ROTA card')
      GOTO 100
!
   18 DO I = 1, 3
        UM(I) = H(6+I)
      ENDDO
      GOTO 100
!
! 4 CIRCLE BISECTING & D3 GEOMETRIES:
    6 CALL GMEQ(UM,H,9,1)
      CALL TRANSQ(H,3)
      DO I = 1, 7, 3
        CALL ORTHO(H(I),UM(I),1)
      ENDDO
      CALL TRANSQ(UM,3)
!
      CALL TRINV3(UM,D)
      WRITE (LPT,2000) D
 2000 FORMAT (/' Determinant of UB matrix is ',F12.6)
      IF (ABS(D-1.).GE.10.E-2) CALL ERRMES(1,0,                         &
     &    'cell dimensions and UB matrix not compatible')
   11 IF (ABS(D-1.).LT.1.E-4) GOTO 12
      CALL GMEQ(UM,H,1,9)
      CALL TRINV3(UM,D)
      DO I = 1, 9
        UM(I) = 0.5*(H(I)+UM(I))
      ENDDO
      GOTO 11
!
! UB MATRIX NOW OK:
   12 WRITE (LPT,2002) UM
 2002 FORMAT (/' Matrix between diffractometer axes and ',              &
     &        'orthogonal crystallographic axes is:'/3(12X,3F10.5/))
  100 RETURN
 3006 FORMAT (/' ERROR ** in SETDC - scalar product of',3F5.0,' and',   &
     &        3F5.0,' non-zero')
!
      END SUBROUTINE SETDC
!*==UPLOW.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE UPLOW(C)
      SUBROUTINE UPLOW(C)
!
! *** UPLOW by JCM 3 Aug 92 ***
!
!X
!C 13C
!H Makes first letter of C upper case, and any subsequent letters lower case.
!
      CHARACTER*(*) C
      LOGICAL FIRST
      COMMON /CHARS / LETUP(26), LETLOW(26), ISPCE, IDIGIT(10),         &
     &                ISMBOL(21)
      CHARACTER*1 LETUP, LETLOW, ISPCE, IDIGIT, ISMBOL
!
      FIRST = .TRUE.
      L = LENGT(C)
      DO I = 1, L
        M = LETTER(C(I:I))
        IF (M.GT.0) THEN
          IF (FIRST) C(I:I) = LETUP(M)
          IF (.NOT.FIRST) C(I:I) = LETLOW(M)
          FIRST = .FALSE.
        ENDIF
      ENDDO
      RETURN
      END SUBROUTINE UPLOW
!*==LLSCAL.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 7      SUBROUTINE LLSCAL(N)
      SUBROUTINE LLSCAL(N)
!
! *** LLSCAL updated by JCM 10 Feb 87 ***
!
!X
!C 6A
!H Multiple entry routine which deals with scale factors in Least Squares.
!
!A On entry, N indicates the required action:
!A N=0 deals with the introduction of a single scale factor with the value 1,
!A     to be refined, when no L SCAL cards are given.
!A N=1 reads in an L SCAL card and records the scale factors from it.
!A N=2 is not assigned.
!A N=3 applies a shift to a specific SCALE(ISPC), with ISPC in /NEWOLD/.
!A N=4 writes out a new L SCAL card to unit NEWIN.
!
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /LREAD / ILREA(22,5), KOM18
      DIMENSION ILREAD(22)
      EQUIVALENCE (ILREAD(1),ILREA(1,1))
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
      COMMON /SCLDAT/ ISCALE, NSCALE, SCALE(20), KSCALE(20), NSCL,      &
     &                LSCD(10)
!
      IF (N) 11, 10, 12
!
! N=0 - DEAL WITH NO SCAL CARDS:
   10 NSCALE = 1
      SCALE(1) = 1.0
      CALL MESS(LPT,1,                                                  &
     &          'No L SCAL cards given - one scale factor of 1. assumed'&
     &          )
      GOTO 100
!
! N=-4 - IF A SCALE FACTOR WAS INRODUCED, MAKE NEW SCAL CARD:
   11 IF (ILREAD(2).NE.0) GOTO 100
! THIS IS NEVER CALLED, I THINK, BUT POSSIBLY SHOULD BE
      WRITE (NEWIN,2001) SCALE(1)
 2001 FORMAT ('L SCAL',F10.5)
      GOTO 100
!
   12 GOTO (1,100,3,4), N
!
    1 IF (ILREAD(2).EQ.1) NSCALE = 0
      IF (ILREAD(2).EQ.1) NSCL = 0
      NSCL = NSCL + 1
      ISKEEP = NSCALE + 1
      LSCD(NSCL) = ISKEEP
      CALL RDNUMS(SCALE(ISKEEP),7,20,NUM,IER)
      IF (IER.NE.0) IERR = IERR + 1
      NSCALE = NSCALE + NUM
      IER = IERR
      CALL ERRCHK(1,NSCALE,20,1,'scale factors')
      IF (IER.NE.IERR) GOTO 100
!
      LSCD(NSCL+1) = NSCALE + 1
      CALL MESS(LPT,1,'Scale factor(s) :')
      CALL PRILIS(SCALE,ISKEEP,NSCALE)
      GOTO 100
!
    3 CALL ADJUST(SCALE(ISPC))
      GOTO 100
!
! NEW L SCAL CARD:
! WE NEED TO KNOW WHICH FACTORS WERE INVOLVED ON THIS CARD.  IT IS PROBABLY
! SENSIBLE TO HANG ON TO THIS INFORMATION AT THE POINT AT WHICH WE HAVE IT,
! THAT IS, WHEN THE CARD IS FIRST INPUT.  ARRAY LSCD(I) HOLDS SERIAL NUMBER
! OF FIRST FACTOR ON I'TH CARD;  LSCD(NSCL+1)=1 OFF END;  THERE ARE NSCL
! L SCAL CARDS.
!
! WHEN A CARD HAS BEEN OUTPUT, THIS IS INDICATED BY TURNING LSCD() NEGATIVE.
!
    4 DO I = 1, NSCL
        IF (LSCD(I).GT.0) GOTO 18
      ENDDO
      WRITE (LPT,3001) LSCD, NSCL
      WRITE (ITO,3001) LSCD, NSCL
!>> JCC Handle the STOP through an extra function
! Was
!     STOP
! Now
      CALL BMBOUT
      RETURN
   18 N1 = LSCD(I)
      N2 = LSCD(I+1) - 1
      LSCD(I) = -LSCD(I)
      WRITE (NEWIN,2005) (SCALE(J),J=N1,N2)
 2005 FORMAT ('L SCAL',8F10.5)
      GOTO 100
!
      ENTRY LSCAL8(NP,NV)
      KSCALE(NP) = NV
      GOTO 100
!
      ENTRY LSCAL9
      DO I = 1, NSCALE
        KSCALE(I) = 0
      ENDDO
  100 RETURN
 3001 FORMAT (/' *** PROGRAM ERROR IN LLSCAL - TRYING TO WRITE MORE',   &
     &        ' CARDS THAN THERE WERE - NSCL, LSCD=',I4,10I3)
      END SUBROUTINE LLSCAL
!*==JMPOL.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!     All calls to function JFIX now replaced by calls to NINT
!     because it performs the same function and is consistent
!     across compilers.  Note that NINT meant something different
!     to Digital Fortran V6.0 on Windows NT.  Hence why the calls
!     had to be removed
!
!
!
! LEVEL 1      SUBROUTINE JMPOL
      SUBROUTINE JMPOL
!
! *** JMPOL by JCM 11 Feb 91 ***
!
!X
!C 7B
!H Writes to unit NEWIN all J MPOL cards after a multipole refinement.
!
      DIMENSION N2(4)
      COMMON /ATNAM / ATNAME(150), ATNA(150,9)
      CHARACTER*4 ATNA, ATNAME
      COMMON /MPODA / NMPAT, NMPOL, MPATAB(20), MPNMTB(150), NCLUMP,    &
     &                KCLUMP(100), MPTAB(21), POLAMP(200,6), KPOLMP(200)&
     &                , NCMAT, CONMAT(600,2)
      COMMON /MPODAC/ MPNAM(200)
      CHARACTER*4 MPNAM
      COMMON /NEWOLD/ SHIFT, XOLD, XNEW, ESD, IFAM, IGEN, ISPC, NEWIN,  &
     &                KPACK, LKH, SHESD, ISHFT, AVSHFT, AMAXSH
!
!
      DO MP = 1, NMPAT
        N1 = MPATAB(MP)
        N3 = 0
        DO J = MPTAB(MP), MPTAB(MP+1) - 1
          N3 = N3 + 1
          IF (N3.GT.4) THEN
            WRITE (NEWIN,2000) ATNAME(N1),                              &
     &                         (MPNAM(N2(I)),POLAMP(N2(I),1),I=1,4)
            N3 = 1
          ENDIF
          N2(N3) = J
        ENDDO
        IF (N3.GT.0) WRITE (NEWIN,2000) ATNAME(N1),                     &
     &                                  (MPNAM(N2(I)),POLAMP(N2(I),1),  &
     &                                  I=1,N3)
      ENDDO
!
      RETURN
 2000 FORMAT ('J ',A4,' MPOL',4(1X,A4,F10.4))
      END SUBROUTINE JMPOL
!*==DIJROT.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
!
!
!
! LEVEL 4      SUBROUTINE DIJROT(D,ALPHA,BETA,GAMMA,KMAX)
      SUBROUTINE DIJROT(D,ALPHA,BETA,GAMMA,KMAX)
!
! *** DIJROT renamed by PJB C17 15-Sept-93 ***
!
!X
!C 9C
!H Calculates the matrix D(i,j) for the Euler rotations alpha,beta,gamma
!H of the eigenfunctions of angular momentum l.
!A On entry KMAX gives the multiplicity = 2l+1, and hence the dimension of D.
!A ALPHA, BETA GAMMA in radians are the rotations
!A On exit, D is a COMPLEX matrix
!O If IOUT in /IOUNIT/ is > 100, outputs D.
!N     i = l+m1+1,j = l+m2+1, so that
!N     when i=j=k,m1=m2=l and when i=j=1,m1=m2=-l
!
      DIMENSION C(21), S(21)
      COMPLEX D(KMAX,KMAX), EALPHA(21), EGAMMA(21), EAL, EGA
      EQUIVALENCE (C,EALPHA)
      EQUIVALENCE (S,EGAMMA)
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
!
      SINB = SIN(0.5*BETA)
      COSB = COS(0.5*BETA)
      S(1) = 1.
      C(1) = 1.
      DO K = 2, KMAX
        S(K) = S(K-1)*SINB
        C(K) = C(K-1)*COSB
      ENDDO
      D(1,1) = CMPLX(COS(0.5*BETA),0.)
      D(1,2) = -CMPLX(SIN(0.5*BETA),0.)
      D(2,2) = D(1,1)
      D(2,1) = -D(1,2)
      IF (KMAX.LT.3) GOTO 4
      K = 2
    3 DO M = 1, K
        I = K - M + 1
        DO J = 1, K
          X = SQRT((FLOAT(K-I+1))/FLOAT(K-J+1))
          D(I,J) = X*D(I,J)*COSB
          IF (I.EQ.1) GOTO 2
          X = SQRT((FLOAT(I-1))/FLOAT(K-J+1))
          D(I,J) = D(I,J) + X*D(I-1,J)*SINB
    2   ENDDO
      ENDDO
      K = K + 1
      DO I = 1, K
        X = SQRT((FACT(K-1))/(FACT(K-I)*FACT(I-1)))
        SIGN = FLOAT(1-2*MOD(K-I,2))
        D(I,K) = SIGN*X*C(I)*S(K-I+1)
        D(K,I) = SIGN*D(I,K)
      ENDDO
      IF (IOUT.EQ.100) THEN
        DO I = 1, K
          WRITE (LPT,2000) (D(I,J),J=1,K)
 2000     FORMAT (7(F9.4,F8.4))
        ENDDO
        WRITE (LPT,2001)
 2001   FORMAT (' ')
      ENDIF
      IF (K.LT.KMAX) GOTO 3
    4 M = (K-1)/2 + 1
      CALL TRIG(EALPHA,ALPHA,M)
      CALL TRIG(EGAMMA,GAMMA,M)
      DO I = 1, K
        DO J = 1, K
          EAL = EALPHA(IABS(I-M)+1)
          IF (I.LT.M) EAL = CONJG(EAL)
          EGA = EGAMMA(IABS(J-M)+1)
          IF (J.LT.M) EGA = CONJG(EGA)
          D(I,J) = D(I,J)*EGA*EAL
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE DIJROT
!*==REAORB.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 2      SUBROUTINE REAORB(CORB,ORB,KMAX)
      SUBROUTINE REAORB(CORB,ORB,KMAX)
!
! *** REAORB by PJB Oct 88 ***
!
!X
!C 18A
!H To change the orbital basis from Ylm and Yl-m to (Ylm +- Yl-m).
!
      COMPLEX CORB(KMAX,KMAX)
      DIMENSION ORB(KMAX,KMAX)
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMPLEX FAC1, FAC2, D(169), D2(169), D3(169)
!
      K = KMAX/2
      RTHF = SQRT(0.5)
      FAC2 = CMPLX(RTHF,0.)
      FAC1 = FAC2*(-1)**K
      CALL CGMZER(D,KMAX,KMAX)
!
      I = K + 1
      DO M = -K, K
        IM = IABS(M)
        IF (M.EQ.0) THEN
          FAC1 = CMPLX(0.,RTHF)
          FAC2 = FAC1
          D(I) = CMPLX(1.,0.)
        ELSE
          D(I-IM) = FAC1
          D(I+IM) = FAC2
          FAC1 = -FAC1
        ENDIF
        I = I + KMAX
      ENDDO
      IF (IOUT.GT.220) THEN
        L = 0
        CALL MESS(LPT,1,'Transformation Matrix:')
        DO I = 1, KMAX
          WRITE (LPT,2001) (D(J),J=L+1,L+KMAX)
 2001     FORMAT (12(1X,7(2F8.4,2X)/))
          L = L + KMAX
        ENDDO
      ENDIF
      CALL CGMPRD(CORB,D,D2,KMAX,KMAX,KMAX)
      CALL TRANSC(D2,KMAX)
      CALL CGMPRD(D2,D,D3,KMAX,KMAX,KMAX)
      L = 0
      II = 1
      DO I = 1, KMAX
        DO J = 1, KMAX
          ORB(I,J) = REAL(D3(II))
          IF (ABS(AIMAG(D3(II))).GT..0001) THEN
            WRITE (LPT,3000) I, J, AIMAG(D3(II))
            WRITE (ITO,3000) I, J, AIMAG(D3(II))
          ENDIF
          II = II + 1
        ENDDO
      ENDDO
      RETURN
 3000 FORMAT (/' ERROR ** in REAORB - imaginary part of element',2I3,   &
     &        ' is non-zero; value is ',F8.4)
      END SUBROUTINE REAORB
!*==EULSYM.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
!
! LEVEL 2      SUBROUTINE EULSYM(ANG,SYM,ROT)
      SUBROUTINE EULSYM(ANG,SYM,ROT)
!
! *** EULSYM by PJB ***
!
!X
!C 1B
!H Finds the Euler angles correponding to a symmetry rotation.
!A On entry SYM holds a 3x3 symmetry matrix
!A    ROT 3x3x2 contains the matrix relating the axes for the Euler rotations
!A        to the axes of the symmetry matrices and its inverse.
!A On exit ANG holds the corresponding Euler angles alpha,beta and gamma
!A        in radians.
!
      DIMENSION ANG(3), SYM(3,3), ORSYM(3,3), TEMP(3,3), ROT(3,3,2)
      COMMON /CONSTA/ PI, RAD, DEG, TWOPI, FOURPI, PIBY2, ALOG2, SQL2X8,&
     &                VALMUB
!
! TRANSFORM SYMMETRY ROTATIONS WITH MATRIX ROT
      CALL GMPRD(ROT(1,1,1),SYM,TEMP,3,3,3)
      CALL GMPRD(TEMP,ROT(1,1,2),ORSYM,3,3,3)
!
      IF (ABS(ABS(ORSYM(3,3))-1.).LT..0001) THEN
        IF (ORSYM(3,3).LT.0.) THEN
          ANG(2) = PI
          ANG(3) = PI
        ELSE
          ANG(2) = 0.
          ANG(3) = 0.
        ENDIF
        ANG(1) = ATAN2(ORSYM(1,2),ORSYM(1,1))
      ELSE
        ANG(1) = ATAN2(ORSYM(3,2),ORSYM(3,1))
        ANG(3) = ATAN2(ORSYM(2,3),-ORSYM(1,3))
        IF (ABS(ORSYM(3,2)).LT.0.0001) THEN
          S = ORSYM(3,1)/COS(ANG(1))
        ELSE
          S = ORSYM(3,2)/SIN(ANG(1))
        ENDIF
        ANG(2) = ATAN2(S,ORSYM(3,3))
      ENDIF
      RETURN
      END SUBROUTINE EULSYM
!*==INPUTW.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 4       SUBROUTINE INPUTW(IAT,WORD,ID,IPT)
      SUBROUTINE INPUTW(IAT,WORD,ID,IPT)
!
! *** INPUTW updated by JCM 11 Oct 89 ***
!
!X
!C 4A
!H To read the "W" card indicated by ID, as far as atom label and word.
!A IAT on exit is which atom label, or scattering factor label identified
!A WORD is A4, on exit holding which word read after atom label
!A ID on entry points to card to read
!A IPT on exit points to next position on card to read
!D If the WORD is 'RADF', expects the label to be a scattering factor
!D label.
!
      CHARACTER*4 WORD
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
!
      CALL CARDIN(ID)
!  IN CASE COMMENT CARDS MIXED IN
      ID = ID + NYZ
      CALL RDWORD(WORD,LWORD,2,IPT1,80,0,IER)
      IF (IER.NE.0) GOTO 101
      IAT = IATOM(WORD)
      JAT = ISCAT(WORD)
      IF (IAT.EQ.0 .AND. JAT.EQ.0) GOTO 101
      CALL RDWORD(WORD,LWORD,IPT1,IPT,80,0,IER)
      IF (IER.NE.0) GOTO 101
      IF (WORD.EQ.'RADF') IAT = JAT
      IF (IAT.NE.0) GOTO 100
  101 CALL ERRMES(1,2,'looking for word on W card')
  100 RETURN
      END SUBROUTINE INPUTW
!*==INPUTJ.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE INPUTJ(ID,NTYP,IAT,IPT,IER)
      SUBROUTINE INPUTJ(ID,NTYP,IAT,IPT,IER)
!
! *** INPUTJ corrected by PJB c17 17 Sept 1993 ***
!
!X
!C 18A
!H Reads individual J cards.
!A On entry ID is the position in the CDF of the J card, or 0 (= card present)
!A On exit NTYP = a number indicating what kind of J card was read:
!A      NTYP=1 for MPOL ( l,m and amplitudes of its + and - combinations)
!A      NTYP=2 for FORM names of <jL> form factors with L values
!A On exit IAT = number corresponding to the atom or form factor la bel,
!A               if one was read.
!A On exit IPT = the next column on the card to be interpreted.
!A On exit IER = the error indicator, = 0 for no error.
!
      CHARACTER*4 WORD, WORD1, JWORD(2)
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      DATA NWRD/2/
      DATA JWORD/'MPOL', 'FORM'/
!
!
! SET NO ERROR
      IER = 0
      ITYP = 0
!
! IF ID=0, EXPECT CARD ALREADY PRESENT:
      IF (ID.NE.0) CALL CARDIN(ID)
      IPT1 = 3
      CALL RDWORD(WORD,LWORD,IPT1,IPT,80,0,IE)
      IF (IE.EQ.0) THEN
        JAT = ISCAT(WORD)
        IAT = IATOM(WORD)
        CALL RDWORD(WORD1,LWORD,IPT,IPT,80,0,IE)
        NTYP = NCFIND(WORD1,JWORD,NWRD)
        IF (NTYP.EQ.0) THEN
          CALL ERRCH2(WORD1,2,'The word "',                             &
     &                '" on a J card is not an allowed J word ')
          GOTO 99
        ENDIF
        IF (IAT.EQ.0 .AND. NTYP.EQ.1) THEN
          CALL ERRCH2(WORD,2,'The first word "',                        &
     &                '" on a J MPOL card is not an atom name ')
          GOTO 99
        ENDIF
        IF (JAT.EQ.0 .AND. NTYP.EQ.2) THEN
          CALL ERRCH2(WORD,2,'The first word "',                        &
     &                '" on a J FORM card is not a form-factor name ')
          GOTO 99
        ENDIF
        IF (NTYP.EQ.2) IAT = JAT
        GOTO 100
      ELSE
        CALL ERRCH2(ICARD(IPT1:IPT-1),2,'Illegal word','on J card')
      ENDIF
!
   99 IER = IER + 1
!
  100 RETURN
      END SUBROUTINE INPUTJ
!*==RESHUF.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE RESHUF(A,IPT,N)
      SUBROUTINE RESHUF(A,IPT,N)
!
! *** RESHUF by JCM 22 Aug 86 ***
!
!X
!C 16C
!H Reorders a real array, given a parallel pointer array out of SORTX.
!
!A On entry A is a real array, of dimension at least N, of numbers
!A            whose pointers have been sorted using SORTX.
!A          IPT is an integer array, of dimension at least N, of pointers
!A            within A, probably just produced by sorting with SORTX.
!A          N is the number of entries in each of A and IPT.
!A On exit  A contains the same numbers reordered according to the
!A            pointers in IPT.
!
      DIMENSION A(N), IPT(N)
      COMMON /SCRAT / TEMP(3000)
!
      DO I = 1, N
        TEMP(I) = A(IPT(I))
      ENDDO
!
      DO I = 1, N
        A(I) = TEMP(I)
      ENDDO
      RETURN
      END SUBROUTINE RESHUF
!*==GAUSPT.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
!
! LEVEL 3      SUBROUTINE GAUSPT(NN,GPT,GWT)
      SUBROUTINE GAUSPT(NN,GPT,GWT)
!
! *** GAUSPT by JCM 26 Sep 85 ***
!
!X
!C 2A
!H Sets up Gauss points and weights for use in 3D integration.
!A On entry NN=number of Gauss points & weights required.
!A On exit the array GPT contains the necessary Gaus points
!A        and the array GWT contains the corresponding weights.
!
!D The array GTABLE contains n-1 numbers for each n allowed.  If n is even,
!D these are X1, W1, X2, W2, . . Xm (where 2m=n), and if n is odd they are
!D X1, W1, X2, W2, . . Xm, Wm (where 2m=n-1).
!D
!D This subroutine generates the two full arrays GPT(1:n) from the Xi and
!D GWT(1:n) from the Wi.  For all except the 'centre' points the algorithm
!D is simple:
!D
!D i<m     Xi, Wi as stored;
!D i>m+1:  Xi=1-Xj and Wi=Wj, where i+j=n+1
!D
!D For the 'centre' points:
!D For n odd:  i=m    Xi, Wi as stored;
!D             i=m+1  Xi=0.5, Wi=1-sum of previous weights*2
!D     n even: i=m    Xi as stored, Wi=0.5-sum of previous weights.
!D
!N The allowed values of n are 1-11 inclusive, 14, 17, 20, 24, 32, 40
!
      LOGICAL EVEN
      DIMENSION GPT(NN), GWT(NN)
      DIMENSION GTABLE(196), IST(17), NGPT(6)
!
! N=2:
      DATA GTABLE(1)/.2886751346/
! N=3:
      DATA GTABLE(2), GTABLE(3)/.1127016654, .2777777778/
! N=4:
      DATA GTABLE(4), GTABLE(5)/.0694318441, .1739274225/
      DATA GTABLE(6)/.3300094782/
! N=5:
      DATA GTABLE(7), GTABLE(8)/.0469100770, .1184634425/
      DATA GTABLE(9), GTABLE(10)/.2307653450, .2393143353/
! N=6:
      DATA GTABLE(11), GTABLE(12)/.0337652429, .0856622462/
      DATA GTABLE(13), GTABLE(14)/.1669395307, .1803807865/
      DATA GTABLE(15)/.3806904069/
! N=7:
      DATA GTABLE(16), GTABLE(17)/.0254460439, .0647424831/
      DATA GTABLE(18), GTABLE(19)/.1292344072, .1398526957/
      DATA GTABLE(20), GTABLE(21)/.2970774243, .1909150252/
! N=8:
      DATA GTABLE(22), GTABLE(23)/.0198550718, .0506142681/
      DATA GTABLE(24), GTABLE(25)/.1016667613, .1111905172/
      DATA GTABLE(26), GTABLE(27)/.2372337950, .1568533229/
      DATA GTABLE(28)/.4082826788/
! N=9:
      DATA GTABLE(29), GTABLE(30)/.0159198803, .0406371941/
      DATA GTABLE(31), GTABLE(32)/.0819844463, .0903240804/
      DATA GTABLE(33), GTABLE(34)/.1933142837, .1303053482/
      DATA GTABLE(35), GTABLE(36)/.3378732883, .1561735385/
! N=10:
      DATA GTABLE(37), GTABLE(38)/.0130467358, .0333356721/
      DATA GTABLE(39), GTABLE(40)/.0674683166, .0747256746/
      DATA GTABLE(41), GTABLE(42)/.1602952159, .1095431812/
      DATA GTABLE(43), GTABLE(44)/.2833023030, .1346333597/
      DATA GTABLE(45)/.4255628305/
! N=11:
! TO BE ENTERED TO (46)-(55)
! N=14:
! TO BE ENTERED TO (56)-(68)
! N=17:
! TO BE ENTERED TO (69)-(84)
! N=20:
! TO BE ENTERED TO (85)-(103)
! N=24:
! TO BE ENTERED TO (104)-(126)
! N=32:
! TO BE ENTERED TO (127)-(157)
! N=40:
! TO BE ENTERED TO (158)-(196)
!
      DATA IST/0, 1, 2, 4, 7, 11, 16, 22, 29, 37, 46, 56, 69, 85, 104,  &
     &     127, 158/
      DATA NGPT/14, 17, 20, 24, 32, 40/
!
      N = NN
! CHECK N IS IN ALLOWED VOCABULARY:
      L = N - 10
      IF (N.LE.11) GOTO 5
      L = NFIND(N,NGPT,6)
      IF (L.EQ.0) CALL ERRIN2(N,0,' ',                                  &
     &                        ' points not allowed in Gauss table')
!
! IPT POINTS TO FIRST GTABLE ENTRY FOR THIS N:
    5 IPT = IST(L+10)
      IF (N.GT.1) GOTO 9
      GPT(1) = 0.5
      GWT(1) = 1.0
      GOTO 100
!
! SET EVEN TO BE TRUE IF N IS EVEN. M=N/2 IF N EVEN, (N-1)/2 IF N ODD.
    9 CALL PARITY(N,M,EVEN)
      DO I = 1, N
        IF (I.GE.M) GOTO 2
!
! FIRST POINTS AND WEIGHTS ARE STORED READY TO USE:
    4   GWT(I) = GTABLE(IPT+2*I-1)
        GPT(I) = GTABLE(IPT+2*I-2)
        GOTO 1
!
! I HAS REACHED AT LEAST M:
    2   IF (I.GT.M) GOTO 3
! IF N ODD, ARE AT (N-1)/2 WHICH IS AS ABOVE:
        IF (.NOT.EVEN) GOTO 4
!
! IF N EVEN, CENTRE TWO POINTS ARE AS ABOVE, BUT WEIGHTS ARE CALCULATED FROM
! THE FACT THAT THEIR SUM IS 1:
        GPT(I) = GTABLE(IPT+2*I-2)
! CHECK ADDRESSING **
        CALL SUMVEC(GTABLE(IPT),2,N-2,2,WSUM)
        GWT(I) = 0.5 - WSUM
        GOTO 1
!
! I IS PAST M:
    3   IF (I.GT.M+1) GOTO 6
        IF (EVEN) GOTO 6
!
! MIDPOINT FOR N ODD:
! CHECK ADDRESSING **
        CALL SUMVEC(GTABLE(IPT),2,N-1,2,WSUM)
        GWT(I) = 1. - 2.*WSUM
        GPT(I) = 0.5
        GOTO 1
!
! PAST MIDDLE:
    6   J = N + 1 - I
        GWT(I) = GWT(J)
        GPT(I) = 1. - GPT(J)
    1 ENDDO
  100 RETURN
      END SUBROUTINE GAUSPT
!*==NCHINT.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      FUNCTION NCHINT(CH)
      FUNCTION NCHINT(CH)
!
! *** NCHINT by JCM 27 Apr 90 ***
!
!X
!C 13C
!H Converts an ASCII character into an integer
!A On entry CH is the A1 character
!A On exit NCHINT is its decimal equivalent
!
      CHARACTER*1 CH
!
      NCHINT = ICHAR(CH) - 48
      RETURN
      END FUNCTION NCHINT
!*==RDWRDS.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE RDWRDS(WD,IPT1,NBOUND,NUM,IER)
      SUBROUTINE RDWRDS(WD,IPT1,NBOUND,NUM,IER)
!
! *** RDWRDS by JCM 1 Oct 86 ***
!
!X
!C 13C
!H Reads all the words on a line from column 3 onwards.
!
!A On entry IPT1 points to the first character in ICARD to read
!A          NBOUND is the dimension of the array WD
!A On exit WD is an A4 array which holds all the words read.
!A         NUM is the number of words read (it stops at a non-word)
!A IER = 1 on exit if a non-word read (starting with a non-letter)
!A IER = 2 on exit if the array is overfilled
!
!P The card must have already been read into ICARD in /SCRACH/, usually
!P by CARDIN
!
      CHARACTER*4 WD(NBOUND)
!
      IPT = IPT1
      IER = 0
      NUM = 0
    1 CALL RDWORD(WD(NUM+1),LEN,IPT,IPT,80,-1,IE)
      IF (IE.EQ.100 .OR. IPT.GE.80) GOTO 100
      IF (IE.EQ.0) GOTO 2
      IER = 1
      GOTO 100
!
    2 NUM = NUM + 1
      IF (NUM.LE.NBOUND) GOTO 1
      CALL ERRIN2(NBOUND,2,'array full - ','items, in RDWRDS')
      IER = 2
  100 RETURN
      END SUBROUTINE RDWRDS
!*==ORTFUN.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE ORTFUN(I,KMAX,VAL,MODE)
      SUBROUTINE ORTFUN(I,KMAX,VAL,MODE)
!
! *** ORTFUN updated by PJB/JBF 4 Sep 89 ***
!
!X
!C 18A
!H Finds the best set of orthonormal functions compatible with symmetry
!H based on the users input, and hence defines the multipoles to refine.
!A On entry  KMAX = 2l+1, VAL the initial amplitude of function I
!A  MODE = 1 First function - set up
!A       > 1 Try function I
!A       = 0 No more functions - tidy up
!
      CHARACTER*4 NAME
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /MPODA / NMPAT, NMPOL, MPATAB(20), MPNMTB(150), NCLUMP,    &
     &                KCLUMP(100), MPTAB(21), POLAMP(200,6), KPOLMP(200)&
     &                , NCMAT, CONMAT(600,2)
      COMMON /MPODAC/ MPNAM(200)
      CHARACTER*4 MPNAM
      COMMON /SCRAT2/ OROT(3,3,2), ISUB(24), MATP, ORMAT(169), FUN(169),&
     &                ORT(169), ANOR(13), USED(13), INDX(13), JNDX(13), &
     &                DIJ(196)
      LOGICAL USED, FLAG
      COMPLEX DIJ
!
      IF (MODE.EQ.0) GOTO 30
      IF (KMAX.EQ.1) THEN
        NEW = 1
        JJ = 1
        INDX(1) = 1
        GOTO 99
      ENDIF
      II = KMAX*(I-1)
      IF (MODE.EQ.1) THEN
!  INITIALISE TABLES
        JJ = 0
        DO J = 1, KMAX
          INDX(J) = 0
          JNDX(J) = 0
          USED(J) = (ABS(FUN(KMAX*(J-1)+J)).LT.0.0001)
        ENDDO
      ENDIF
      IF (ABS(FUN(KMAX*(I-1)+I)).LT.0.0001) THEN
        CALL NAMPOL(NAME,KMAX,I)
        CALL MESS(LPT,0,'Amplitude of '//NAME//' is zero from symmetry')
      ENDIF
      IF (USED(I)) THEN
        NEW = 0
        GOTO 99
      ENDIF
      USED(I) = .TRUE.
      IF (MODE.EQ.1) THEN
        CALL GMEQ(FUN(II+1),ORT,KMAX,1)
        JJ = 1
        INDX(1) = I
        JNDX(I) = 1
        NEW = 1
        GOTO 99
      ENDIF
!
!  ATTEMPT TO INSERT A GIVEN VECTOR
      AMIN = 0.
      DO J = 1, JJ
        AMIN = AMIN + ORMAT(I+KMAX*(INDX(J)-1))**2
      ENDDO
      IMIN = I
      GOTO 1
!
!  COMPLETE THE ORTHONORMAL SET
   30 IF (KMAX.EQ.1) THEN
        NCMAT = NCMAT + 1
        CONMAT(NCMAT,1) = 1.
        CONMAT(NCMAT,2) = 1.
        NCLUMP = NCLUMP + 1
        KCLUMP(NCLUMP) = 1
        GOTO 100
      ENDIF
      JJIN = JJ
   31 IF (JJ.EQ.KMAX) GOTO 20
      FLAG = JJ.EQ.0
      AMIN = FLOAT(KMAX)
      DO I = 1, KMAX
        IF (USED(I)) GOTO 2
        FLAG = .TRUE.
        VAL = 0.
        DO J = 1, JJ
          VAL = VAL + ORMAT(I+KMAX*(INDX(J)-1))**2
        ENDDO
        IF (VAL.GT.AMIN) GOTO 2
        AMIN = VAL
        IMIN = I
    2 ENDDO
      IF (.NOT.FLAG) GOTO 20
!
    1 ANORM = (1.-AMIN)
!      IF (ANORM.LT.-.002) STOP 'Error in Normalisation'
!>> JCC Handle the STOP through an extra function
! Was
!     IF (ANORM.LT.-.002) STOP 'Error in Normalisation'
! Now
      IF (ANORM.LT.-.002) THEN
        WRITE (LPT,*) 'Error in Normalisation'
        WRITE (ITO,*) 'Error in Normalisation'
        CALL BMBOUT
        RETURN
      ENDIF
!
      IF (ANORM.LE..0002) THEN
        ANORM = 0.
        GOTO 20
      ENDIF
      INDX(JJ+1) = IMIN
      JNDX(IMIN) = (JJ+1)
      USED(IMIN) = .TRUE.
      ANORM = 1./SQRT(ANORM)
!
      JJ1 = KMAX*(JJ)
      IJJ1 = KMAX*(INDX(JJ+1)-1)
      II = 0
      DO I = 1, KMAX
        ORT(I+JJ1) = FUN(I+IJJ1)
        DO J = 1, JJ
          IJ = KMAX*(J-1)
          ORT(I+JJ1) = ORT(I+JJ1) - ORT(I+IJ)*ORMAT(INDX(J)+IJJ1)
        ENDDO
        ORT(I+JJ1) = ORT(I+JJ1)*ANORM
      ENDDO
      DO I = 1, KMAX
        CALL GMPRD(ORT(1+JJ1),FUN(1+II),ORMAT(I+IJJ1),1,KMAX,1)
        II = II + KMAX
      ENDDO
      IF (IOUT.GT.160) THEN
        L = 0
        WRITE (LPT,4001) (ORT(JJ1+I),I=1,KMAX)
 4001   FORMAT (/' New function: '/13F9.4//' New product matrix:')
        DO I = 1, KMAX
          WRITE (LPT,4002) JNDX(I), (ORMAT(L+J),J=1,KMAX)
 4002     FORMAT (I4,13F9.4)
          L = L + KMAX
        ENDDO
      ENDIF
!
      JJ = JJ + 1
      IF (MODE.EQ.0) GOTO 31
      NEW = 1
      GOTO 99
!
   20 IF (MODE.NE.0) THEN
        NEW = 0
        GOTO 99
      ENDIF
      NEW = JJ - JJIN
      IF (IOUT.GT.120) THEN
        CALL MESS(LPT,1,'Orthonormal representation:')
        L = 0
        DO J = 1, JJ
          WRITE (LPT,4004) INDX(J), (ORT(L+I),I=1,KMAX)
          L = L + KMAX
        ENDDO
      ENDIF
!  CHECK THAT CONMAT WILL NOT OVERFLOW
      IF (NCMAT+JJ*JJ.GT.600) THEN
        CALL ERRMES(1,1,                                                &
     &   'Multipole matrix will overflow - increase dimension of CONMAT'&
     &   )
        GOTO 100
      ENDIF
      JK = JJ
      DO I = 1, KMAX
        IF (JNDX(I).NE.0) GOTO 21
        JK = JK + 1
        INDX(JK) = I
   21 ENDDO
!
!  DERIVE MATRICES RELATING PARAMETERS TO ACTUAL MULTIPOLES
      DO I = 1, JJ
        L = I
        II = KMAX*(INDX(I)-1)
        DO J = 1, JJ
          CONMAT(NCMAT+L,1) = FUN(INDX(J)+II)*ANOR(INDX(I))
          L = L + JJ
        ENDDO
      ENDDO
      CALL GMINV(CONMAT(NCMAT+1,1),CONMAT(NCMAT+1,2),JJ)
      IF (IOUT.GT.50) THEN
        WRITE (LPT,4010) (INDX(I),I=1,JJ)
 4010   FORMAT (' Inverse of Amount matrix:'/6X,12(I5,3X))
        L = 0
        DO I = 1, JJ
          WRITE (LPT,4004) INDX(I), (CONMAT(NCMAT+L+J,1),J=1,JJ)
          L = L + JJ
        ENDDO
        WRITE (LPT,4011) (INDX(I),I=1,JJ)
 4011   FORMAT (' Amount matrix:'/6X,12(I5,3X))
        L = 0
        DO I = 1, JJ
          WRITE (LPT,4004) INDX(I), (CONMAT(NCMAT+L+J,2),J=1,JJ)
          L = L + JJ
        ENDDO
      ENDIF
      NCMAT = NCMAT + JJ*JJ
      VAL = 0.
!
   99 II = JJ - NEW
      DO J = 1, NEW
        CALL ERRCHK(2,NMPOL,200,0,'multipoles')
        POLAMP(NMPOL,1) = VAL
        CALL NAMPOL(MPNAM(NMPOL),KMAX,INDX(II+J))
      ENDDO
      IF (MODE.NE.0) GOTO 100
      LVAL = KMAX/2
      ISTART = NMPOL - JJ + 1
!
! RECORD NEW CHUNK:
      CALL ERRCHK(2,NCLUMP,100,0,'blocks of l values for multipoles')
      KCLUMP(NCLUMP) = JJ
      IF (JJ.NE.1) THEN
        WRITE (LPT,2001) JJ, LVAL, (MPNAM(J),J=ISTART,NMPOL)
 2001   FORMAT (' There are',I2,' independent functions for l =',       &
     &          I2/' They are obtained from:',13(2X,A4))
      ELSE
        WRITE (LPT,2002) LVAL, (MPNAM(J),J=ISTART,NMPOL)
 2002   FORMAT (' There is one independent function for l =',           &
     &          I2/' It is obtained from:',13(2X,A4))
      ENDIF
  100 RETURN
 4004 FORMAT (1X,I5,12F8.4)
      END SUBROUTINE ORTFUN
!*==INPUTD.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 5      SUBROUTINE INPUTD
      SUBROUTINE INPUTD
!
! *** INPUTD updated by JCM 14 Oct 86 ***
!
!X
!C 2A
!H Reads and interprets all D cards, for general diffraction information.
!
!D Absorbs all the D cards given.  It will normally be called by a
!D setting up routine (e.g. SETDC) which then checks whether it has had
!D enough D cards to make sense, and gives default values for those missing.
!D
!D The syntax of D cards is thus like that of M, G, L cards;  a word of up
!D to 4 symbols (usually letters, and the first must be a letter) follows the
!D "D space" which starts the card, and what follows after that depends on
!D the word.  Possible words recognised are:
!
!D D GEOM followed by an integer, IGEOM.
!D        Possible values for IGEOM are:
!D   1 = normal beam
!D   2 = normal beam equatorial
!D   3 = equi-inclination Weissenberg
!D   4 = precession (no further code for this)
!D   5 = anti equi-inclination Weissenberg
!D   6 = 4 circle diffractometer, bisecting geometry
!D   7 = 4 circle diffractometer, angles given
!D   8 = normal beam, general orientation
!D  10 = powder data, X-rays
!D  11 = 4 circle diffractometer, high chi geometry
!D  12 = SXD geometry
!D
!D D WVLN followed by the wavelength, in same units as the lattice constants
!D        (possibly several wavelength values)
!D
!D D L/R  followed by an integer, the 'left or right' indicator:
!D        +ve means incident beam diffracted to the right,
!D        -ve means to the left. Value 1 means  that angles are
!D        measured clockwise about positive diffractometer axes, and 2
!D        means anti-clockwise.
!D
!D D TH2M followed by the value of 2theta monochromator, in degrees.
!D
!D D UMAT followed by 9 numbers, giving the UB matrix (as defined in the
!D        Manual under D cards).  If all 9 do not fit one card,
!D        several cards may be given;  for example, on 3 cards each with
!D        3 numbers.
!D
!D D ANGP followed by the precession angle in degrees.
!D
!D D ROTA for types 1-5, followed by 3 indices, being the zone-axis symbols
!D        of the zone parallel to the rotation axis.
!D
!D D CHIA for type 2 only, followed by 3 integers and a real;  the integers
!D        give another axis, perpendicular to that on the "D ROTA" card, and
!D        the real is the angle between this and the normal to the chi circle,
!D        in degrees.
!
!I Reads all D cards
!
!O Writes its findings to unit LPT
!
      CHARACTER*27 X27
      CHARACTER*4 DTABLE(8), DWD
      DIMENSION ITEMP(9), UMAT(9)
      COMMON /CARDRC/ ICRYDA, NTOTAL(9), NYZ, NTOTL, INREA(26,9),       &
     &                ICDN(26,9), IERR, IO10, SDREAD
      LOGICAL SDREAD
      DIMENSION INREAD(26), ICDNO(26)
      EQUIVALENCE (INREAD(1),INREA(1,1))
      EQUIVALENCE (ICDNO(1),ICDN(1,1))
      COMMON /DGEOM / IGEOM, UM(9), NLR, ANGLIN(3), ALAMBD(5,5), NLAMB, &
     &                ILAMB
      EQUIVALENCE (WLGTH,ALAMBD(1,1))
      COMMON /DREAD / IDREAD(8)
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
      COMMON /SCRACH/ MESSAG, NAMFIL
      CHARACTER*80 ICARD, MESSAG*100, NAMFIL*100
      EQUIVALENCE (ICARD,MESSAG)
      DATA DTABLE/'GEOM', 'WVLN', 'L/R', 'TH2M', 'UMAT', 'ANGP', 'ROTA',&
     &     'CHIA'/
      DATA X27/'                           '/
!
! SET "NO D CARDS READ":
      CALL JGMZER(IDREAD,1,8)
!
! CLEAR COUNT OF UB MATRIX ELEMENTS READ:
      NMAT = 0
!
! READ ALL D CARDS:
      INREAD(4) = -IABS(INREAD(4))
      ID = IABS(INREAD(4))
      NCARD = ICDNO(4)
      IF (NCARD.LE.0) THEN
        CALL MESS(LPT,1,'No D cards given')
        GOTO 100
      ENDIF
!
      DO ICD = 1, NCARD
!
! UNLIKE MK2, MK3 READS ITS D CARDS IN SEQUENCE AND DECIDES WHAT TO DO THEN
! ON THE EVIDENCE OF WHICH 4 LETTER WORD FOLLOWS THE D.
!
        CALL CARDIN(ID)
        ID = ID + NYZ
        CALL RDWORD(DWD,LEN,3,IPT,80,0,IER)
   42   L = NCFIND(DWD,DTABLE,8)
        IF (L.LE.0) THEN
          CALL ERRCH2(DWD,2,'word','on D card not recognised')
          GOTO 3
        ENDIF
!
! SET "HAVE READ PARTICULAR WORD" (COUNTING NUMBER OF CARDS), THEN BRANCH:
        IDREAD(L) = IDREAD(L) + 1
        GOTO (31,32,33,34,35,36,37,38), L
!
! D GEOM:
   31   CALL RDINTG(IGEOM,IPT,IPT,80,IER)
        IF (IGEOM.GT.0 .AND. IGEOM.LT.12) GOTO 8
        CALL ERRIN2(IGEOM,2,'data type','not allowed')
        GOTO 3
!
    8   WRITE (LPT,2020) IGEOM
 2020   FORMAT (/' Data geometry type',I5,' -')
        GOTO (11,12,13,14,15,16,17,18,19,20,21), IGEOM
   11   CALL MESS(LPT,0,X27//'normal beam')
        GOTO 43
   12   CALL MESS(LPT,0,X27//'normal beam equatorial')
        GOTO 43
   13   CALL MESS(LPT,0,X27//'equi-inclination Weissenberg')
        GOTO 43
   14   CALL MESS(LPT,0,X27//'precession camera')
        GOTO 43
   15   CALL MESS(LPT,0,X27//'anti-equinclination Weissenberg')
        GOTO 43
   16   CALL MESS(LPT,0,                                                &
     &            X27//'4 circle diffractometer bisecting geometry')
        GOTO 43
   17   CALL MESS(LPT,0,                                                &
     &            X27//'4 circle diffractometer angles to be given')
        GOTO 43
   18   CALL MESS(LPT,0,X27//'D3 polarised neutron diffractometer')
        GOTO 43
   19   CALL MESS(LPT,0,X27//'powder data - neutrons')
        GOTO 43
   20   CALL MESS(LPT,0,X27//'powder data - X rays')
        GOTO 43
   21   CALL MESS(LPT,0,X27//'4-circle diffractometer: high chi setting'&
     &            )
        GOTO 43
!
! WVLN:
   32   CALL RDNUMS(ALAMBD,IPT,5,NLAMB,IER)
        IF (NLAMB.GT.0) GOTO 52
        CALL ERRMES(1,1,'no values on D WVLN card')
        GOTO 3
!
   52   IF (NLAMB.GT.1) WRITE (LPT,2011) (ALAMBD(I,1),I=1,NLAMB)
 2011   FORMAT (/' Wavelength values',5F12.5)
        IF (NLAMB.EQ.1) WRITE (LPT,2012) WLGTH
 2012   FORMAT (/' Wavelength =',F12.5)
        GOTO 3
!
! L/R:
   33   CALL RDINTG(NLR,IPT,IPT,80,IER)
        IF (IABS(NLR).LE.2) GOTO 51
        CALL ERRIN2(NLR,2,'left/right indicator is',                    &
     &              'and should be +/-1 or +/-2')
        GOTO 43
!
   51   IF (NLR.GT.0) CALL MESS(LPT,1,'Beam diffracted to right')
        IF (NLR.LT.0) CALL MESS(LPT,1,'Beam diffracted to left')
        IF (IABS(NLR).GT.1) THEN
          CALL MESS(LPT,0,X27//'positive angles correspond to'//        &
     &              ' anti-clockwise rotations')
        ELSE
          CALL MESS(LPT,0,X27//'positive angles correspond to'//        &
     &              ' clockwise rotations')
        ENDIF
        GOTO 43
!
! TH2M:
   34   CALL RDREAL(ANGLIN(2),IPT,IPT,80,IER)
        WRITE (LPT,2041) ANGLIN(2)
 2041   FORMAT (' Monochromator 2theta = ',F10.4,' degrees')
        ANGLIN(2) = COS(RADIAN(ANGLIN(2)))
        GOTO 43
!
! UMAT:
   35   CALL RDNUMS(UMAT(NMAT+1),IPT,9,NM,IER)
        NMAT = NMAT + NM
! CANNOT CHECK TILL ALL THERE
        GOTO 3
!
! ANGP:
   36   CALL RDREAL(ANGLIN(1),IPT,IPT,80,IER)
        WRITE (LPT,2061) ANGLIN(1)
 2061   FORMAT (' Precession angle = ',F10.4,' degrees')
! FOR NOW WE DO NO MORE WITH PRECESSSION
        GOTO 43
!
! ROTA:
   37   CALL RDNUMS(UM,IPT,3,N,IER)
        CALL INDFIX(UM,ITEMP)
        WRITE (LPT,2071) (ITEMP(I),I=1,3)
 2071   FORMAT (/' Zone axis parallel to rotation axis is',3I5)
        GOTO 3
!
! CHIA:
   38   CALL RDNUMS(UM(4),IPT,4,N,IER)
        CALL INDFIX(UM(4),ITEMP)
        WRITE (LPT,2081) (ITEMP(I),I=1,3), ANGLIN(1)
 2081   FORMAT (/' Axis',3I5,' makes angle',F10.4,' with chi circle')
!
! KEEP ANGLE IN RADIANS:
        ANGLIN(1) = RADIAN(UM(7))
        GOTO 3
!
! HERE WHEN ONE ITEM OF THE <WORD> <NUMBER> TYPE READ - LOOK FOR OTHERS:
   43   CALL RDWORD(DWD,LEN,IPT,IPT,80,0,IER)
        IF (IER.EQ.0) GOTO 42
        IF (IER.NE.100) CALL ERRIN2(IPT,2,'word expected at point',     &
     &                              'on D card')
    3 ENDDO
!
! ALL D CARDS READ:
!
      IF (NMAT.NE.0) THEN
! CHECK IF ANY UB MATRIX ELEMENTS AT ALL, HAVE HAD 9:
        IF (NMAT.NE.9) THEN
          CALL ERRIN2(NMAT,2,'only','elements of UB matrix read')
        ELSE
          CALL GMEQ(UMAT,UM,3,3)
          WRITE (LPT,2051) UM
 2051     FORMAT (/' UB Matrix: ',3F10.5/2(12X,3F10.5/))
        ENDIF
      ENDIF
!
  100 RETURN
      END SUBROUTINE INPUTD
!*==CONVMP.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 2      SUBROUTINE CONVMP(MODE)
      SUBROUTINE CONVMP(MODE)
!
! *** CONVMP updated by JCM 20 Apr 90 ***
!
!X
!C 7B
!H Converts between user values and LSQ parameters for multipoles.
!A On entry MODE = the action required:
!A MODE=1 convert user values in POLAMP(,1) to LSQ parameters in POLAMP(,2)
!A MODE=2 convert LSQ obtained ESD's to user EDS's, and
!A        convert LSQ shifts in POLAMP(,4) to user values in POLAMP(,3)
!P In /MPODA/ CONMAT must have been set up by ORTFUN
!P            POLAMP must contain the user values, read by ORTFUN
!P            KCLUMP must contain clump sizes set in ORTFUN
!P            NCLUMP must be number of clumps set in ORTFUN
!
      COMMON /MPODA / NMPAT, NMPOL, MPATAB(20), MPNMTB(150), NCLUMP,    &
     &                KCLUMP(100), MPTAB(21), POLAMP(200,6), KPOLMP(200)&
     &                , NCMAT, CONMAT(600,2)
      COMMON /MPODAC/ MPNAM(200)
      CHARACTER*4 MPNAM
!
      DIMENSION TMP(13)
!
      IA = 1
      ICMAT = 1
! SCAN NCLUMP CLUMPS:
      DO K = 1, NCLUMP
        JJ = KCLUMP(K)
        IF (MODE.EQ.1) THEN
          CALL GMPRD(CONMAT(ICMAT,2),POLAMP(IA,1),POLAMP(IA,2),JJ,JJ,1)
        ELSE
          CALL GMPRD(CONMAT(ICMAT,1),POLAMP(IA,4),POLAMP(IA,3),JJ,JJ,1)
!  PROCEDURE FOR ESD'S
          DO I = 1, JJ
            TMP(I) = 0
            IJ = I - 1
            DO J = 1, JJ
              TMP(I) = TMP(I) + (POLAMP(IA+J-1,6)*CONMAT(ICMAT+IJ,1))**2
              IJ = IJ + JJ
            ENDDO
            POLAMP(IA+I-1,5) = SQRT(TMP(I))
          ENDDO
        ENDIF
!
        IA = IA + KCLUMP(K)
        ICMAT = ICMAT + KCLUMP(K)*KCLUMP(K)
      ENDDO
      RETURN
      END SUBROUTINE CONVMP
!*==NAMPOL.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 1      SUBROUTINE NAMPOL(NAME,K,L)
      SUBROUTINE NAMPOL(NAME,K,L)
!
! *** NAMPOL by PJB ***
!
!X
!C 18C
!H Creates the label for a given multipole.
!A On entry K=2l+1 and L goes from 1 to K for m from m+ to m-
!A On exit  NAME is the A4 label
!
      CHARACTER*4 NAME, SIG(3)*1
      DATA SIG/'+', ' ', '-'/
!
      IL = K/2
      M = IABS(L-IL-1)
      I = 1
      IF (L.GT.IL+1) I = 3
      IF (L.EQ.IL+1) I = 2
      WRITE (NAME,10) IL, M, SIG(I)
   10 FORMAT ('Y',2I1,A1)
      RETURN
      END SUBROUTINE NAMPOL
!*==FORMFC.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 5      FUNCTION FORMFC(AK,L,MODE,JAT)
      FUNCTION FORMFC(AK,L,MODE,JAT)
!
! *** FORMFC updated by PJB/JBF 3 Sep 89 ***
!
!X
!C 4B
!H Calculates form factor integrals from radial wave functions.
!A On entry AK=4*pi* sin theta/lamda.
!A          MODE=0 requests FORMFC to be <Jl>
!A          MODE=1 requests <Gl>, the orbital integral
!A          MODE=2 requests the wavefunction factor.
!A On exit FORMFC contains the COMPLEX factor
!P RADFUN should have read the radial wave function
!
      COMMON /RADINT/ N(20,5), FF(2,20,5), NTERMS(5), IRADF(5), NRADF
!
      IAT = NFIND(JAT,IRADF,NRADF)
      FORMFC = 0.
      IMAX = NTERMS(IAT)
      DO I = 1, IMAX
        IF (MODE.EQ.2) THEN
          FORMFC = FORMFC + FF(1,I,IAT)                                 &
     &             *EXPINT(AK,FF(2,I,IAT),N(I,IAT),L)
          GOTO 1
        ENDIF
!
        DO J = 1, IMAX
          MAX = N(I,IAT) + N(J,IAT)
          NUM = MAX + 1
          P = FF(2,I,IAT) + FF(2,J,IAT)
          IF (MODE.EQ.0) GOTO 3
          FAC = 1/P
          G = 0
          DO M = 1, NUM
            G = G + FAC*EXPINT(AK,P,MAX-M,L)
            FAC = FAC*FLOAT(MAX-M+1)/P
          ENDDO
          FORMFC = FORMFC + FF(1,I,IAT)*FF(1,J,IAT)*G*2.
          IF (MODE.EQ.1) GOTO 2
    3     FORMFC = FORMFC + FF(1,I,IAT)*FF(1,J,IAT)*EXPINT(AK,P,MAX,L)
    2   ENDDO
    1 ENDDO
      RETURN
      END FUNCTION FORMFC
!*==NUMA1.f90  processed by SPAG 6.11Dc at 14:22 on 17 Sep 2001
!
!
!
!
! LEVEL 4      SUBROUTINE NUMA1(X,IFIELD,IFDIG,ITOT,IA)
      SUBROUTINE NUMA1(X,IFIELD,IFDIG,ITOT,IA)
!
! *** NUMA1 updated by JCM 12 Nov 89 ***
!
!X
!C 13C
!H Prepares a number for writing, probably on a plotter.
!A X is a floating point number to be decoded into characters
!A IA is a string variable of length at least IFIELD to receive the characters
!A IDIG is the number of digits to be given after the decimal point
!A      if IDIG is zero the decimal point is omitted.
!A The final number is right justified in a field of width ITOT
!A placed centrally in IFIELD.
!D If the number is too big to fit in IFIELD it is replaced by stars.
!
      CHARACTER*(*) IA
      DIMENSION ITEMP(5)
      COMMON /CHARS / LETUP(26), LETLOW(26), ISPCE, IDIGIT(10),         &
     &                ISMBOL(21)
      CHARACTER*1 LETUP, LETLOW, ISPCE, IDIGIT, ISMBOL
      COMMON /IOUNIT/ LPT, ITI, ITO, IPLO, LUNI, IOUT
!
      IF = IFIELD
      IF (ITOT.GE.IF) GOTO 6
      WRITE (LPT,3001) ITOT, IF, X
      WRITE (ITO,3001) ITOT, IF, X
      DO I = 1, ITOT
        IA(I:I) = '*'
      ENDDO
      GOTO 100
!
    6 IPT = IF + (ITOT-IF)/2
! IPT MOVES FROM RIGHT TO LEFT IN OUTPUT ARRAY IA
      IA = ' '
      Y = ABS(X)
      IF (IFDIG) 2, 2, 3
!
! HERE IF THERE IS A FRACTIONAL PART
    3 CALL FRACT(Y,A,N)
      CALL INTDIG(NINT(Y*10.**IFDIG),ITEMP,NDIG)
      L = NDIG
! COPY FRACTION BACKWARDS
      DO K = 1, IFDIG
        IF (ITEMP(L).EQ.0) ITEMP(L) = 10
        IF (L.GT.0) IA(IPT:IPT) = IDIGIT(ITEMP(L))
        IF (L.LE.0) IA(IPT:IPT) = IDIGIT(10)
        IPT = IPT - 1
        L = L - 1
      ENDDO
      IA(IPT:IPT) = '.'
      IPT = IPT - 1
      Y = A
!
! HERE TO DO INTEGER PART
    2 CALL INTDIG(NINT(Y),ITEMP,NDIG)
      L = NDIG
      DO K = 1, NDIG
        IF (ITEMP(L).EQ.0) ITEMP(L) = 10
        IA(IPT:IPT) = IDIGIT(ITEMP(L))
        IPT = IPT - 1
        L = L - 1
      ENDDO
!
! SIGN
      IF (IFDIG.EQ.0 .AND. NINT(Y).EQ.0) GOTO 100
      IF (X.LT.0.) IA(IPT:IPT) = '-'
  100 RETURN
 3001 FORMAT (/' ERROR ** IN USE OF NUMA1 - TOTAL FIELD OF',I5,         &
     &        ' AND NUMBER FIELD OF',I5,' REQUESTED - PRINTING',F12.4)
      END SUBROUTINE NUMA1
!
!
!
!
! JvdS The following routine was never called and used an uninitialised variable
! causing a compiler warning. Removing all exclamation marks restores the original routine.
!C LEVEL 2      FUNCTION RGAUSS(SIGMA)
!      FUNCTION RGAUSS(SIGMA)
!C
!C *** RGAUSS by PJB 27-Sept-93 ***
!C
!CX
!CC 9C
!CH Returns a value random number with a gaussian distribution.
!CA On entry SIGMA gives the width if the dsitribution such that
!CA          p(x)=exp-(x/SIGMA)**2
!CA          if SIGMA=0 sets the seed for random number generation
!CN  Uses the subprogram NB01A from the Harwell library.
!C
!      COMMON /LENINT/NBITS
!      COMMON /SEEDIT/LSEED
!C
!      IF (SIGMA.EQ.0) THEN
!c        SEED=SECNDS(0.)
!        ISEED=2**(NBITS-1) -INT(SEED)
!        ISEED=2*ISEED-1
!        GO TO 100
!      ENDIF
!c      AR=RAN(ISEED)
!      ar=.756
!      R=ABS(2*AR-1.)
!      K=0
!      NUM=0
!      A=0.
!      XLIM=100.
!      B=XLIM
!      ERR=.0001
!      MAXIT=100
!    5 CALL NB01A(K,A,B,ERR,X,Y,MAXIT)
!      GO TO (1,2,3,4) K
!C
!    1 IF (X.GT.XLIM) THEN
!        Y=1.-R
!      ELSE
!        Y=1.-ERFNC(X)-R
!      ENDIF
!      GO TO 5
!C
!    2 RGAUSS=X
!      IF (AR.LT.0.5) RGAUSS=-X
!      RGAUSS=RGAUSS*SIGMA
!      GO TO 100
!C
!    3 CALL ERRMES(1,0,'Too many iterations in RGAUSS')
!      GO TO 100
!    4 CALL ERRMES(1,0,'from RGAUSS')
!      GO TO 100
!C
!C
!  100 RETURN
!      END
!
!
!
!*****************************************************************************
!
! Originally in 
!
